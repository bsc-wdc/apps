typedef long int ptrdiff_t;
typedef unsigned long int size_t;
struct  max_align_t
{
    __attribute__((aligned(alignof(long long int)))) long long int __max_align_ll;
    __attribute__((aligned(alignof(long double)))) long double __max_align_ld;
};
typedef decltype(nullptr) nullptr_t;
typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;
typedef long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long int uint64_t;
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long int uint_least64_t;
typedef signed char int_fast8_t;
typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
typedef long int intptr_t;
typedef unsigned long int uintptr_t;
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
struct  nanos_region_dimension_internal_t
{
    ::size_t size;
    ::size_t lower_bound;
    ::size_t accessed_length;
};
struct  nanos_access_type_internal_t
{
    bool input:1;
    bool output:1;
    bool can_rename:1;
    bool concurrent:1;
    bool commutative:1;
};
struct  nanos_data_access_internal_t
{
    void *address;
    ::nanos_access_type_internal_t flags;
    short int dimension_count;
    const ::nanos_region_dimension_internal_t *dimensions;
    ::ptrdiff_t offset;
};
enum nanos_sharing_t
{
  NANOS_PRIVATE = 0,
  NANOS_SHARED = 1
};
struct  nanos_reduction_t
{
    void *original;
    void *privates;
    ::size_t element_size;
    ::size_t num_scalars;
    void *descriptor;
    void (*bop)(void *, void *, int);
    void (*vop)(int, void *, void *);
    void (*cleanup)(void *);
};
typedef unsigned int reg_t;
typedef unsigned int memory_space_id_t;
struct  nanos_copy_data_internal_t
{
    void *address;
    ::nanos_sharing_t sharing;
    struct  mcc_struct_anon_6
    {
        bool input:1;
        bool output:1;
    };
    ::nanos_copy_data_internal_t::mcc_struct_anon_6 flags;
    short int dimension_count;
    const ::nanos_region_dimension_internal_t *dimensions;
    ::ptrdiff_t offset;
    ::uint64_t host_base_address;
    ::reg_t host_region_id;
    bool remote_host;
    void *deducted_cd;
};
typedef ::nanos_access_type_internal_t nanos_access_type_t;
typedef ::nanos_region_dimension_internal_t nanos_region_dimension_t;
typedef ::nanos_data_access_internal_t nanos_data_access_t;
typedef ::nanos_copy_data_internal_t nanos_copy_data_t;
typedef void *nanos_thread_t;
typedef void *nanos_wd_t;
struct  nanos_compound_wd_data_t
{
    int nsect;
    ::nanos_wd_t lwd[];
};
struct  nanos_repeat_n_info_t
{
    int n;
};
struct  nanos_loop_info_t
{
    ::int64_t lower;
    ::int64_t upper;
    ::int64_t step;
    bool last;
    bool wait;
    ::int64_t chunk;
    ::int64_t stride;
    int thid;
    int threads;
    void *args;
};
typedef void *nanos_ws_t;
typedef void *nanos_ws_info_t;
typedef void *nanos_ws_data_t;
typedef void *nanos_ws_item_t;
struct  nanos_ws_info_loop_t
{
    ::int64_t lower_bound;
    ::int64_t upper_bound;
    ::int64_t loop_step;
    ::int64_t chunk_size;
};
struct  nanos_ws_item_loop_t
{
    ::int64_t lower;
    ::int64_t upper;
    bool execute:1;
    bool last:1;
};
struct nanos_ws_desc;
struct  nanos_ws_desc
{
    volatile ::nanos_ws_t ws;
    ::nanos_ws_data_t data;
    ::nanos_ws_desc *next;
    ::nanos_thread_t *threads;
    int nths;
};
typedef ::nanos_ws_desc nanos_ws_desc_t;
struct  nanos_wd_props_t
{
    bool mandatory_creation:1;
    bool tied:1;
    bool clear_chunk:1;
    bool reserved0:1;
    bool reserved1:1;
    bool reserved2:1;
    bool reserved3:1;
    bool reserved4:1;
};
struct  nanos_wd_dyn_flags_t
{
    bool is_final:1;
    bool is_recover:1;
    bool is_implicit:1;
    bool reserved3:1;
    bool reserved4:1;
    bool reserved5:1;
    bool reserved6:1;
    bool reserved7:1;
};
struct  nanos_wd_dyn_props_t
{
    ::nanos_wd_dyn_flags_t flags;
    ::nanos_thread_t tie_to;
    int priority;
    void *callback;
    void *arguments;
};
struct  nanos_device_t
{
    void *(*factory)(void *);
    void *arg;
};
struct  nanos_smp_args_t
{
    void (*outline)(void *);
};
extern "C"
{
  extern void *nanos_smp_factory_(void *args);
}
extern "C"
{
  extern void *nanos_smp_factory(void *args);
}
enum nanos_event_type_t
{
  NANOS_STATE_START = 0,
  NANOS_STATE_END = 1,
  NANOS_SUBSTATE_START = 2,
  NANOS_SUBSTATE_END = 3,
  NANOS_BURST_START = 4,
  NANOS_BURST_END = 5,
  NANOS_PTP_START = 6,
  NANOS_PTP_END = 7,
  NANOS_POINT = 8,
  EVENT_TYPES = 9
};
typedef unsigned int nanos_event_key_t;
typedef unsigned long long int nanos_event_value_t;
enum nanos_event_state_value_t
{
  NANOS_NOT_CREATED = 0,
  NANOS_NOT_RUNNING = 1,
  NANOS_STARTUP = 2,
  NANOS_SHUTDOWN = 3,
  NANOS_ERROR = 4,
  NANOS_IDLE = 5,
  NANOS_RUNTIME = 6,
  NANOS_RUNNING = 7,
  NANOS_SYNCHRONIZATION = 8,
  NANOS_SCHEDULING = 9,
  NANOS_CREATION = 10,
  NANOS_MEM_TRANSFER_ISSUE = 11,
  NANOS_CACHE = 12,
  NANOS_YIELD = 13,
  NANOS_ACQUIRING_LOCK = 14,
  NANOS_CONTEXT_SWITCH = 15,
  NANOS_FILL1 = 16,
  NANOS_WAKINGUP = 17,
  NANOS_STOPPED = 18,
  NANOS_SYNCED_RUNNING = 19,
  NANOS_DEBUG = 20,
  NANOS_EVENT_STATE_TYPES = 21
};
enum nanos_event_domain_t
{
  NANOS_WD_DOMAIN = 0,
  NANOS_WD_DEPENDENCY = 1,
  NANOS_WAIT = 2,
  NANOS_XFER_DATA = 3,
  NANOS_XFER_REQ = 4,
  NANOS_WD_REMOTE = 5,
  NANOS_AM_WORK = 6,
  NANOS_AM_WORK_DONE = 7,
  NANOS_XFER_WAIT_REQ_PUT = 8,
  NANOS_XFER_FREE_TMP_BUFF = 9
};
typedef long long int nanos_event_id_t;
struct  nanos_event_t
{
    ::nanos_event_type_t type;
    ::nanos_event_key_t key;
    ::nanos_event_value_t value;
    ::nanos_event_domain_t domain;
    ::nanos_event_id_t id;
};
enum nanos_lock_state_t
{
  NANOS_LOCK_FREE = 0,
  NANOS_LOCK_BUSY = 1
};
struct  nanos_lock_t
{
    volatile ::nanos_lock_state_t state_;
    inline nanos_lock_t(::nanos_lock_state_t init  = (::NANOS_LOCK_FREE))
      : state_(init)
    {
    }
};
typedef void (*nanos_translate_args_t)(void *, ::nanos_wd_t);
typedef void nanos_init_func_t(void *);
struct  nanos_init_desc_t
{
    ::nanos_init_func_t (*func);
    void *data;
};
enum nanos_err_t
{
  NANOS_OK = 0,
  NANOS_UNKNOWN_ERR = 1,
  NANOS_UNIMPLEMENTED = 2,
  NANOS_ENOMEM = 3,
  NANOS_INVALID_PARAM = 4,
  NANOS_INVALID_REQUEST = 5
};
typedef void *nanos_wg_t;
typedef void *nanos_team_t;
typedef void *nanos_sched_t;
typedef void *nanos_slicer_t;
typedef void *nanos_dd_t;
typedef void *nanos_sync_cond_t;
typedef unsigned int nanos_copy_id_t;
struct  nanos_const_wd_definition_tag
{
    ::nanos_wd_props_t props;
    ::size_t data_alignment;
    ::size_t num_copies;
    ::size_t num_devices;
    ::size_t num_dimensions;
    const char *description;
};
typedef ::nanos_const_wd_definition_tag nanos_const_wd_definition_t;
struct  nanos_constraint_t
{
    int nthreads;
    void *arch;
};
typedef void *nanos_cpu_set_t;
typedef const void *const_nanos_cpu_set_t;
struct  nanos_const_wd_definition_internal_t : ::nanos_const_wd_definition_tag
{
    ::nanos_device_t devices[1L];
};
extern "C"
{
  extern char *nanos_get_mode_();
}
extern "C"
{
  extern char *nanos_get_mode();
}
extern "C"
{
  extern ::nanos_wd_t nanos_current_wd_();
}
extern "C"
{
  extern ::nanos_wd_t nanos_current_wd();
}
extern "C"
{
  extern int nanos_get_wd_id_(::nanos_wd_t wd);
}
extern "C"
{
  extern int nanos_get_wd_id(::nanos_wd_t wd);
}
extern "C"
{
  extern int nanos_get_wd_priority_(::nanos_wd_t wd);
}
extern "C"
{
  extern int nanos_get_wd_priority(::nanos_wd_t wd);
}
extern "C"
{
  extern void nanos_set_wd_priority_(::nanos_wd_t wd, int p);
}
extern "C"
{
  extern void nanos_set_wd_priority(::nanos_wd_t wd, int p);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_wd_description_(const char **description, ::nanos_wd_t wd);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_wd_description(const char **description, ::nanos_wd_t wd);
}
extern "C"
{
  extern ::nanos_slicer_t nanos_find_slicer_(const char *slicer);
}
extern "C"
{
  extern ::nanos_slicer_t nanos_find_slicer(const char *slicer);
}
extern "C"
{
  extern ::nanos_ws_t nanos_find_worksharing_(const char *label);
}
extern "C"
{
  extern ::nanos_ws_t nanos_find_worksharing(const char *label);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_wd_compact_(::nanos_wd_t *wd, ::nanos_const_wd_definition_t *const_data, ::nanos_wd_dyn_props_t *dyn_props, ::size_t data_size, void **data, ::nanos_wg_t wg, ::nanos_copy_data_t **copies, ::nanos_region_dimension_internal_t **dimensions);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_wd_compact(::nanos_wd_t *wd, ::nanos_const_wd_definition_t *const_data, ::nanos_wd_dyn_props_t *dyn_props, ::size_t data_size, void **data, ::nanos_wg_t wg, ::nanos_copy_data_t **copies, ::nanos_region_dimension_internal_t **dimensions);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_translate_function_(::nanos_wd_t wd, ::nanos_translate_args_t translate_args);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_translate_function(::nanos_wd_t wd, ::nanos_translate_args_t translate_args);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_sliced_wd_(::nanos_wd_t *uwd, ::size_t num_devices, ::nanos_device_t *devices, ::size_t outline_data_size, int outline_data_align, void **outline_data, ::nanos_wg_t uwg, ::nanos_slicer_t slicer, ::nanos_wd_props_t *props, ::nanos_wd_dyn_props_t *dyn_props, ::size_t num_copies, ::nanos_copy_data_t **copies, ::size_t num_dimensions, ::nanos_region_dimension_internal_t **dimensions);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_sliced_wd(::nanos_wd_t *uwd, ::size_t num_devices, ::nanos_device_t *devices, ::size_t outline_data_size, int outline_data_align, void **outline_data, ::nanos_wg_t uwg, ::nanos_slicer_t slicer, ::nanos_wd_props_t *props, ::nanos_wd_dyn_props_t *dyn_props, ::size_t num_copies, ::nanos_copy_data_t **copies, ::size_t num_dimensions, ::nanos_region_dimension_internal_t **dimensions);
}
extern "C"
{
  extern ::nanos_err_t nanos_submit_(::nanos_wd_t wd, ::size_t num_data_accesses, ::nanos_data_access_t *data_accesses, ::nanos_team_t team);
}
extern "C"
{
  extern ::nanos_err_t nanos_submit(::nanos_wd_t wd, ::size_t num_data_accesses, ::nanos_data_access_t *data_accesses, ::nanos_team_t team);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_wd_and_run_compact_(::nanos_const_wd_definition_t *const_data, ::nanos_wd_dyn_props_t *dyn_props, ::size_t data_size, void *data, ::size_t num_data_accesses, ::nanos_data_access_t *data_accesses, ::nanos_copy_data_t *copies, ::nanos_region_dimension_internal_t *dimensions, ::nanos_translate_args_t translate_args);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_wd_and_run_compact(::nanos_const_wd_definition_t *const_data, ::nanos_wd_dyn_props_t *dyn_props, ::size_t data_size, void *data, ::size_t num_data_accesses, ::nanos_data_access_t *data_accesses, ::nanos_copy_data_t *copies, ::nanos_region_dimension_internal_t *dimensions, ::nanos_translate_args_t translate_args);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_for_();
}
extern "C"
{
  extern ::nanos_err_t nanos_create_for();
}
extern "C"
{
  extern ::nanos_err_t nanos_set_internal_wd_data_(::nanos_wd_t wd, void *data);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_internal_wd_data(::nanos_wd_t wd, void *data);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_internal_wd_data_(::nanos_wd_t wd, void **data);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_internal_wd_data(::nanos_wd_t wd, void **data);
}
extern "C"
{
  extern ::nanos_err_t nanos_yield_();
}
extern "C"
{
  extern ::nanos_err_t nanos_yield();
}
extern "C"
{
  extern ::nanos_err_t nanos_slicer_get_specific_data_(::nanos_slicer_t slicer, void **data);
}
extern "C"
{
  extern ::nanos_err_t nanos_slicer_get_specific_data(::nanos_slicer_t slicer, void **data);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_ready_tasks_(unsigned int *ready_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_ready_tasks(unsigned int *ready_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_total_tasks_(unsigned int *total_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_total_tasks(unsigned int *total_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_nonready_tasks_(unsigned int *nonready_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_nonready_tasks(unsigned int *nonready_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_running_tasks_(unsigned int *running_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_running_tasks(unsigned int *running_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_blocked_tasks_(unsigned int *blocked_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_blocked_tasks(unsigned int *blocked_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_in_final_(bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_in_final(bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_final_(bool value);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_final(bool value);
}
extern "C"
{
  extern ::nanos_err_t nanos_switch_to_thread_(unsigned int *thid);
}
extern "C"
{
  extern ::nanos_err_t nanos_switch_to_thread(unsigned int *thid);
}
extern "C"
{
  extern ::nanos_err_t nanos_is_tied_(bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_is_tied(bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_team_(::nanos_team_t *team, ::nanos_sched_t sg, unsigned int *nthreads, ::nanos_constraint_t *constraints, bool reuse, ::nanos_thread_t *info, ::nanos_const_wd_definition_t *const_data);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_team(::nanos_team_t *team, ::nanos_sched_t sg, unsigned int *nthreads, ::nanos_constraint_t *constraints, bool reuse, ::nanos_thread_t *info, ::nanos_const_wd_definition_t *const_data);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_team_mapped_(::nanos_team_t *team, ::nanos_sched_t sg, unsigned int *nthreads, unsigned int *mapping);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_team_mapped(::nanos_team_t *team, ::nanos_sched_t sg, unsigned int *nthreads, unsigned int *mapping);
}
extern "C"
{
  extern ::nanos_err_t nanos_enter_team_();
}
extern "C"
{
  extern ::nanos_err_t nanos_enter_team();
}
extern "C"
{
  extern ::nanos_err_t nanos_leave_team_();
}
extern "C"
{
  extern ::nanos_err_t nanos_leave_team();
}
extern "C"
{
  extern ::nanos_err_t nanos_end_team_(::nanos_team_t team);
}
extern "C"
{
  extern ::nanos_err_t nanos_end_team(::nanos_team_t team);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_barrier_();
}
extern "C"
{
  extern ::nanos_err_t nanos_team_barrier();
}
extern "C"
{
  extern ::nanos_err_t nanos_single_guard_(bool *);
}
extern "C"
{
  extern ::nanos_err_t nanos_single_guard(bool *);
}
extern "C"
{
  extern ::nanos_err_t nanos_enter_sync_init_(bool *b);
}
extern "C"
{
  extern ::nanos_err_t nanos_enter_sync_init(bool *b);
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_sync_init_();
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_sync_init();
}
extern "C"
{
  extern ::nanos_err_t nanos_release_sync_init_();
}
extern "C"
{
  extern ::nanos_err_t nanos_release_sync_init();
}
extern "C"
{
  extern ::nanos_err_t nanos_memory_fence_();
}
extern "C"
{
  extern ::nanos_err_t nanos_memory_fence();
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_num_supporting_threads_(int *n);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_num_supporting_threads(int *n);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_supporting_threads_(int *n, ::nanos_thread_t *list_of_threads);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_supporting_threads(int *n, ::nanos_thread_t *list_of_threads);
}
extern "C"
{
  extern ::nanos_err_t nanos_register_reduction_(::nanos_reduction_t *red);
}
extern "C"
{
  extern ::nanos_err_t nanos_register_reduction(::nanos_reduction_t *red);
}
extern "C"
{
  extern ::nanos_err_t nanos_reduction_get_private_data_(void **copy, void *original);
}
extern "C"
{
  extern ::nanos_err_t nanos_reduction_get_private_data(void **copy, void *original);
}
extern "C"
{
  extern ::nanos_err_t nanos_reduction_get_(::nanos_reduction_t **dest, void *original);
}
extern "C"
{
  extern ::nanos_err_t nanos_reduction_get(::nanos_reduction_t **dest, void *original);
}
extern "C"
{
  extern ::nanos_err_t nanos_task_reduction_register_(void *orig, ::size_t size_target, ::size_t size_elem, void (*init)(void *, void *), void (*reducer)(void *, void *));
}
extern "C"
{
  extern ::nanos_err_t nanos_task_reduction_register(void *orig, ::size_t size_target, ::size_t size_elem, void (*init)(void *, void *), void (*reducer)(void *, void *));
}
extern "C"
{
  extern ::nanos_err_t nanos_task_fortran_array_reduction_register_(void *orig, void *dep, ::size_t array_descriptor_size, void (*init)(void *, void *), void (*reducer)(void *, void *), void (*reducer_orig_var)(void *, void *));
}
extern "C"
{
  extern ::nanos_err_t nanos_task_fortran_array_reduction_register(void *orig, void *dep, ::size_t array_descriptor_size, void (*init)(void *, void *), void (*reducer)(void *, void *), void (*reducer_orig_var)(void *, void *));
}
extern "C"
{
  extern ::nanos_err_t nanos_task_reduction_get_thread_storage_(void *orig, void **tpd);
}
extern "C"
{
  extern ::nanos_err_t nanos_task_reduction_get_thread_storage(void *orig, void **tpd);
}
extern "C"
{
  extern ::nanos_err_t nanos_admit_current_thread_();
}
extern "C"
{
  extern ::nanos_err_t nanos_admit_current_thread();
}
extern "C"
{
  extern ::nanos_err_t nanos_expel_current_thread_();
}
extern "C"
{
  extern ::nanos_err_t nanos_expel_current_thread();
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_release_all_();
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_release_all();
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_pendant_writes_(bool *res, void *addr);
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_pendant_writes(bool *res, void *addr);
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_create_(::nanos_wd_t pred, ::nanos_wd_t succ);
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_create(::nanos_wd_t pred, ::nanos_wd_t succ);
}
extern "C"
{
  extern ::nanos_err_t nanos_worksharing_create_(::nanos_ws_desc_t **wsd, ::nanos_ws_t ws, ::nanos_ws_info_t *info, bool *b);
}
extern "C"
{
  extern ::nanos_err_t nanos_worksharing_create(::nanos_ws_desc_t **wsd, ::nanos_ws_t ws, ::nanos_ws_info_t *info, bool *b);
}
extern "C"
{
  extern ::nanos_err_t nanos_worksharing_next_item_(::nanos_ws_desc_t *wsd, ::nanos_ws_item_t *wsi);
}
extern "C"
{
  extern ::nanos_err_t nanos_worksharing_next_item(::nanos_ws_desc_t *wsd, ::nanos_ws_item_t *wsi);
}
extern "C"
{
  extern ::nanos_err_t nanos_wg_wait_completion_mandatory_(::nanos_wg_t wg, bool avoid_flush);
}
extern "C"
{
  extern ::nanos_err_t nanos_wg_wait_completion_mandatory(::nanos_wg_t wg, bool avoid_flush);
}
extern "C"
{
  extern ::nanos_err_t nanos_wg_wait_completion_(::nanos_wg_t wg, bool avoid_flush);
}
extern "C"
{
  extern ::nanos_err_t nanos_wg_wait_completion(::nanos_wg_t wg, bool avoid_flush);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_int_sync_cond_(::nanos_sync_cond_t *sync_cond, volatile int *p, int condition);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_int_sync_cond(::nanos_sync_cond_t *sync_cond, volatile int *p, int condition);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_bool_sync_cond_(::nanos_sync_cond_t *sync_cond, volatile bool *p, bool condition);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_bool_sync_cond(::nanos_sync_cond_t *sync_cond, volatile bool *p, bool condition);
}
extern "C"
{
  extern ::nanos_err_t nanos_sync_cond_wait_(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_sync_cond_wait(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_sync_cond_signal_(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_sync_cond_signal(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_destroy_sync_cond_(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_destroy_sync_cond(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_on_(::size_t num_data_accesses, ::nanos_data_access_t *data_accesses);
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_on(::size_t num_data_accesses, ::nanos_data_access_t *data_accesses);
}
extern "C"
{
  extern ::nanos_err_t nanos_init_lock_(::nanos_lock_t **lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_init_lock(::nanos_lock_t **lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_init_lock_at_(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_init_lock_at(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_lock_(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_lock(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_unset_lock_(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_unset_lock(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_try_lock_(::nanos_lock_t *lock, bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_try_lock(::nanos_lock_t *lock, bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_destroy_lock_(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_destroy_lock(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_lock_address_(void *addr, ::nanos_lock_t **lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_lock_address(void *addr, ::nanos_lock_t **lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_copies_(::nanos_wd_t wd, int num_copies, ::nanos_copy_data_t *copies);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_copies(::nanos_wd_t wd, int num_copies, ::nanos_copy_data_t *copies);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_addr_(::nanos_copy_id_t copy_id, void **addr, ::nanos_wd_t cwd);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_addr(::nanos_copy_id_t copy_id, void **addr, ::nanos_wd_t cwd);
}
extern "C"
{
  extern ::nanos_err_t nanos_copy_value_(void *dst, ::nanos_copy_id_t copy_id, ::nanos_wd_t cwd);
}
extern "C"
{
  extern ::nanos_err_t nanos_copy_value(void *dst, ::nanos_copy_id_t copy_id, ::nanos_wd_t cwd);
}
extern "C"
{
  extern const char *nanos_get_runtime_version_();
}
extern "C"
{
  extern const char *nanos_get_runtime_version();
}
extern "C"
{
  extern const char *nanos_get_default_architecture_();
}
extern "C"
{
  extern const char *nanos_get_default_architecture();
}
extern "C"
{
  extern const char *nanos_get_pm_();
}
extern "C"
{
  extern const char *nanos_get_pm();
}
extern "C"
{
  extern ::nanos_err_t nanos_get_default_binding_(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_default_binding(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_binding_(::nanos_cpu_set_t *);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_binding(::nanos_cpu_set_t *);
}
extern "C"
{
  extern ::nanos_err_t nanos_delay_start_();
}
extern "C"
{
  extern ::nanos_err_t nanos_delay_start();
}
extern "C"
{
  extern ::nanos_err_t nanos_start_();
}
extern "C"
{
  extern ::nanos_err_t nanos_start();
}
extern "C"
{
  extern ::nanos_err_t nanos_finish_();
}
extern "C"
{
  extern ::nanos_err_t nanos_finish();
}
extern "C"
{
  extern ::nanos_err_t nanos_current_socket_(int socket);
}
extern "C"
{
  extern ::nanos_err_t nanos_current_socket(int socket);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_sockets_(int *num_sockets);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_sockets(int *num_sockets);
}
extern "C"
{
  extern ::nanos_err_t nanos_malloc_(void **p, ::size_t size, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_malloc(void **p, ::size_t size, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_memalign_(void **p, ::size_t size, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_memalign(void **p, ::size_t size, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_cmalloc_(void **p, ::size_t size, unsigned int node, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_cmalloc(void **p, ::size_t size, unsigned int node, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_cmalloc_2dim_distributed_(void **p, ::size_t rows, ::size_t cols, ::size_t elem_size, unsigned int start_node, ::size_t num_nodes, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_cmalloc_2dim_distributed(void **p, ::size_t rows, ::size_t cols, ::size_t elem_size, unsigned int start_node, ::size_t num_nodes, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_stick_to_producer_(void *p, ::size_t size);
}
extern "C"
{
  extern ::nanos_err_t nanos_stick_to_producer(void *p, ::size_t size);
}
extern "C"
{
  extern ::nanos_err_t nanos_free_(void *p);
}
extern "C"
{
  extern ::nanos_err_t nanos_free(void *p);
}
extern "C"
{
  extern void nanos_free0_(void *p);
}
extern "C"
{
  extern void nanos_free0(void *p);
}
extern "C"
{
  extern void nanos_handle_error_(::nanos_err_t err);
}
extern "C"
{
  extern void nanos_handle_error(::nanos_err_t err);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_key_(::nanos_event_key_t *event_key, const char *key, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_key(::nanos_event_key_t *event_key, const char *key, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_value_(::nanos_event_value_t *event_value, const char *key, const char *value, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_value(::nanos_event_value_t *event_value, const char *key, const char *value, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_value_with_val_(::nanos_event_value_t val, const char *key, const char *value, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_value_with_val(::nanos_event_value_t val, const char *key, const char *value, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_get_key_(const char *key, ::nanos_event_key_t *event_key);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_get_key(const char *key, ::nanos_event_key_t *event_key);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_get_value_(const char *key, const char *value, ::nanos_event_value_t *event_value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_get_value(const char *key, const char *value, ::nanos_event_value_t *event_value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_events_(unsigned int num_events, ::nanos_event_t events[]);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_events(unsigned int num_events, ::nanos_event_t events[]);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_close_user_fun_event_();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_close_user_fun_event();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_raise_gpu_kernel_launch_event_();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_raise_gpu_kernel_launch_event();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_close_gpu_kernel_launch_event_();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_close_gpu_kernel_launch_event();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_enable_();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_enable();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_disable_();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_disable();
}
extern "C"
{
  extern ::nanos_err_t nanos_get_node_num_(unsigned int *num);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_node_num(unsigned int *num);
}
extern "C"
{
  extern int nanos_get_num_nodes_();
}
extern "C"
{
  extern int nanos_get_num_nodes();
}
extern "C"
{
  extern ::nanos_err_t nanos_set_create_local_tasks_(bool value);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_create_local_tasks(bool value);
}
typedef const char *nanos_string_t;
extern "C"
{
  extern ::nanos_err_t nanos_instrument_begin_burst_(::nanos_string_t key, ::nanos_string_t key_descr, ::nanos_string_t value, ::nanos_string_t value_descr);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_begin_burst(::nanos_string_t key, ::nanos_string_t key_descr, ::nanos_string_t value, ::nanos_string_t value_descr);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_end_burst_(::nanos_string_t key, ::nanos_string_t value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_end_burst(::nanos_string_t key, ::nanos_string_t value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_begin_burst_with_val_(::nanos_string_t key, ::nanos_string_t key_descr, ::nanos_event_value_t *val);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_begin_burst_with_val(::nanos_string_t key, ::nanos_string_t key_descr, ::nanos_event_value_t *val);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_end_burst_with_val_(::nanos_string_t key, ::nanos_event_value_t *val);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_end_burst_with_val(::nanos_string_t key, ::nanos_event_value_t *val);
}
extern "C"
{
  extern ::nanos_err_t nanos_memcpy_(void *dest, const void *src, ::size_t n);
}
extern "C"
{
  extern ::nanos_err_t nanos_memcpy(void *dest, const void *src, ::size_t n);
}
extern "C"
{
  extern ::nanos_err_t nanos_register_object_(int num_objects, ::nanos_copy_data_t *obj);
}
extern "C"
{
  extern ::nanos_err_t nanos_register_object(int num_objects, ::nanos_copy_data_t *obj);
}
extern "C"
{
  extern ::nanos_err_t nanos_unregister_object_(int num_objects, void *base_addresses);
}
extern "C"
{
  extern ::nanos_err_t nanos_unregister_object(int num_objects, void *base_addresses);
}
extern "C"
{
  extern const char *nanos_get_default_scheduler_();
}
extern "C"
{
  extern const char *nanos_get_default_scheduler();
}
extern "C"
{
  extern ::nanos_err_t nanos_start_scheduler_();
}
extern "C"
{
  extern ::nanos_err_t nanos_start_scheduler();
}
extern "C"
{
  extern ::nanos_err_t nanos_stop_scheduler_();
}
extern "C"
{
  extern ::nanos_err_t nanos_stop_scheduler();
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_enabled_(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_enabled(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_until_threads_paused_();
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_until_threads_paused();
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_until_threads_unpaused_();
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_until_threads_unpaused();
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_get_stealing_(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_get_stealing(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_set_stealing_(bool value);
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_set_stealing(bool value);
}
extern "C"
{
  extern void ompss_nanox_main_begin_(void *addr, const char *filename, int line);
}
extern "C"
{
  extern void ompss_nanox_main_begin(void *addr, const char *filename, int line);
}
extern "C"
{
  extern void ompss_nanox_main_end_();
}
extern "C"
{
  extern void ompss_nanox_main_end();
}
extern "C"
{
  extern void ompss_nanox_main_();
}
extern "C"
{
  extern void ompss_nanox_main();
}
extern "C"
{
  extern void nanos_atexit_(void *);
}
extern "C"
{
  extern void nanos_atexit(void *);
}
extern "C"
{
  void nanos_reduction_int_vop(int, void *, void *);
}
extern "C"
{
  extern int nanos_cmpi_init_(int *argc, char **argv[]);
}
extern "C"
{
  extern int nanos_cmpi_init(int *argc, char **argv[]);
}
extern "C"
{
  extern void nanos_cmpi_finalize_();
}
extern "C"
{
  extern void nanos_cmpi_finalize();
}
extern "C"
{
  extern void nanos_into_blocking_mpi_call_();
}
extern "C"
{
  extern void nanos_into_blocking_mpi_call();
}
extern "C"
{
  extern void nanos_out_of_blocking_mpi_call_();
}
extern "C"
{
  extern void nanos_out_of_blocking_mpi_call();
}
extern "C"
{
  extern void nanos_thread_print_(char *str);
}
extern "C"
{
  extern void nanos_thread_print(char *str);
}
extern "C"
{
  extern void nanos_set_watch_addr_(void *addr);
}
extern "C"
{
  extern void nanos_set_watch_addr(void *addr);
}
extern "C"
{
  extern void nanos_print_bt_();
}
extern "C"
{
  extern void nanos_print_bt();
}
extern "C"
{
  extern void nanos_enable_verbose_copies_();
}
extern "C"
{
  extern void nanos_enable_verbose_copies();
}
extern "C"
{
  extern void nanos_disable_verbose_copies_();
}
extern "C"
{
  extern void nanos_disable_verbose_copies();
}
extern "C"
{
  extern void nanos_atomic_assig_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_assig_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_assig_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_assig_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_assig_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_assig_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_assig_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_assig_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_assig_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_assig_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_assig_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_assig_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_assig_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_assig_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_assig_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_assig_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_assig_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_assig_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_assig_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_assig_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_assig_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_assig_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_assig_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_assig_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_assig_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_assig_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_assig_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_assig_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_assig_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_assig_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_assig_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_assig_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_assig_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_add_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_add_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_add_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_add_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_add_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_add_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_add_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_add_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_add_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_add_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_add_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_add_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_add_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_add_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_add_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_add_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_add_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_add_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_add_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_add_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_add_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_add_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_add_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_add_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_add_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_add_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_add_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_add_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_add_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_add_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_add_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_add_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_add_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_add_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_add_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_add_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_add_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_add_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_add_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_add_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_add_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_add_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_sub_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_sub_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_sub_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_sub_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_sub_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_sub_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_sub_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_sub_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_sub_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_sub_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_sub_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_sub_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_sub_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_sub_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_sub_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_sub_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_sub_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_sub_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_sub_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_sub_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_sub_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_sub_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_sub_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_sub_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_sub_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_sub_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_sub_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_sub_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_sub_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_sub_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_sub_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_sub_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_sub_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_mul_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mul_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mul_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mul_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mul_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mul_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mul_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mul_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_mul_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_mul_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_mul_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_mul_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_mul_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_mul_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_mul_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_mul_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mul_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mul_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mul_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mul_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mul_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mul_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_mul_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_mul_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_mul_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_mul_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_mul_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_mul_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_mul_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_mul_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_mul_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_mul_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_mul_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_div_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_div_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_div_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_div_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_div_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_div_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_div_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_div_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_div_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_div_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_div_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_div_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_div_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_div_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_div_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_div_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_div_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_div_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_div_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_div_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_div_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_div_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_div_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_div_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_div_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_div_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_div_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_div_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_div_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_div_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_div_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_div_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_div_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_div_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_div_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_div_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_div_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_div_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_div_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_div_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_div_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_div_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_pow_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_pow_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_pow_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_pow_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_pow_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_pow_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_pow_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_pow_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_pow_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_pow_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_pow_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_pow_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_pow_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_pow_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_pow_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_pow_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_pow_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_pow_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_pow_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_pow_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_pow_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_pow_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_pow_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_pow_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_pow_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_pow_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_pow_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_pow_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_pow_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_pow_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_pow_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_pow_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_pow_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_max_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_max_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_max_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_max_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_max_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_max_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_max_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_max_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_max_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_max_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_max_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_max_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_max_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_max_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_max_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_max_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_max_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_max_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_max_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_max_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_max_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_max_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_max_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_max_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_max_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_max_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_max_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_max_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_max_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_max_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_min_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_min_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_min_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_min_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_min_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_min_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_min_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_min_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_min_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_min_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_min_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_min_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_min_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_min_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_min_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_min_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_min_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_min_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_min_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_min_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_min_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_min_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_min_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_min_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_min_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_min_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_min_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_min_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_min_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_min_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_max_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_max_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_max_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_max_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_max_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_max_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_min_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_min_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_min_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_min_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_min_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_min_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_eq_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_eq_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_eq_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_eq_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_eq_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_eq_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_eq_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_eq_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_eq_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_eq_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_eq_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_eq_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_eq_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_eq_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_eq_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_eq_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_eq_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_eq_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_eq_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_eq_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_eq_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_eq_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_eq_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_eq_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_eq_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_eq_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_eq_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_eq_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_eq_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_eq_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_eq_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_eq_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_eq_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_neq_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_neq_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_neq_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_neq_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_neq_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_neq_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_neq_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_neq_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_neq_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_neq_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_neq_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_neq_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_neq_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_neq_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_neq_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_neq_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_neq_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_neq_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_neq_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_neq_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_neq_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_neq_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_neq_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_neq_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_neq_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_neq_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_neq_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_neq_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_neq_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_neq_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_neq_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_neq_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_neq_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_mod_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mod_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mod_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mod_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mod_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mod_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mod_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mod_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_mod_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_mod_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_mod_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_mod_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_mod_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_mod_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_mod_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_mod_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mod_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mod_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mod_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mod_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mod_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mod_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shl_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shl_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shl_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shl_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shl_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shl_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shl_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_shl_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_shl_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_shl_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_shl_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_shl_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_shl_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_shl_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_shl_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shl_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shl_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shl_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shl_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shl_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shl_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shr_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shr_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shr_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shr_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shr_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shr_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shr_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_shr_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_shr_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_shr_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_shr_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_shr_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_shr_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_shr_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_shr_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shr_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shr_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shr_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shr_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shr_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shr_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_land_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_land_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_land_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_land_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_land_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_land_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_land_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_land_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_land_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_land_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_land_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_land_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_land_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_land_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_land_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_land_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_land_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_land_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_land_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_land_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_land_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_land_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_land_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_land_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_land_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_land_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_land_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_land_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_land_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_land_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_lor_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_lor_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_lor_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_lor_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_lor_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_lor_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_lor_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_lor_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_lor_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_lor_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_lor_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_lor_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_lor_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_lor_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_lor_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_lor_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_lor_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_lor_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_lor_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_lor_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_lor_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_band_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_band_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_band_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_band_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_band_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_band_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_band_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_band_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_band_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_band_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_band_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_band_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_band_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_band_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_band_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_band_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_band_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_band_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_band_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_band_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_band_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_band_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_band_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_band_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_band_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_band_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_band_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_band_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_band_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_band_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bor_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bor_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bor_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bor_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bor_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bor_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bor_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_bor_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_bor_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_bor_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_bor_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_bor_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_bor_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_bor_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_bor_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bor_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bor_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bor_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bor_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bor_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bor_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bxor_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bxor_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bxor_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bxor_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_bxor_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_bxor_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_bxor_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bxor_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bxor_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bxor_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longlongbool(volatile long long int *, long long int);
}
enum nanos_omp_sched_t
{
  nanos_omp_sched_static = 1,
  nanos_omp_sched_dynamic = 2,
  nanos_omp_sched_guided = 3,
  nanos_omp_sched_auto = 4
};
extern "C"
{
  extern ::nanos_err_t nanos_omp_single_(bool *);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_single(bool *);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_barrier_();
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_barrier();
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_set_implicit_(::nanos_wd_t uwd);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_set_implicit(::nanos_wd_t uwd);
}
extern "C"
{
  extern int nanos_omp_get_max_threads_();
}
extern "C"
{
  extern int nanos_omp_get_max_threads();
}
extern "C"
{
  extern int nanos_omp_get_num_threads_();
}
extern "C"
{
  extern int nanos_omp_get_num_threads();
}
extern "C"
{
  extern int nanos_omp_get_thread_num_();
}
extern "C"
{
  extern int nanos_omp_get_thread_num();
}
extern "C"
{
  extern int nanos_omp_set_num_threads_(int nthreads);
}
extern "C"
{
  extern int nanos_omp_set_num_threads(int nthreads);
}
extern "C"
{
  extern ::nanos_ws_t nanos_omp_find_worksharing_(::nanos_omp_sched_t kind);
}
extern "C"
{
  extern ::nanos_ws_t nanos_omp_find_worksharing(::nanos_omp_sched_t kind);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_get_schedule_(::nanos_omp_sched_t *kind, int *modifier);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_get_schedule(::nanos_omp_sched_t *kind, int *modifier);
}
extern "C"
{
  extern int nanos_omp_get_num_threads_next_parallel_(int threads_requested);
}
extern "C"
{
  extern int nanos_omp_get_num_threads_next_parallel(int threads_requested);
}
extern "C"
{
  extern void nanos_omp_get_process_mask_(::nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_get_process_mask(::nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern int nanos_omp_set_process_mask_(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern int nanos_omp_set_process_mask(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_add_process_mask_(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_add_process_mask(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_get_active_mask_(::nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_get_active_mask(::nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern int nanos_omp_set_active_mask_(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern int nanos_omp_set_active_mask(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_add_active_mask_(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_add_active_mask(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern int nanos_omp_enable_cpu_(int cpuid);
}
extern "C"
{
  extern int nanos_omp_enable_cpu(int cpuid);
}
extern "C"
{
  extern int nanos_omp_disable_cpu_(int cpuid);
}
extern "C"
{
  extern int nanos_omp_disable_cpu(int cpuid);
}
extern "C"
{
  extern int nanos_omp_get_max_processors_();
}
extern "C"
{
  extern int nanos_omp_get_max_processors();
}
struct  nanos_opencl_args_t
{
    void (*outline)(void *);
};
extern "C"
{
  extern void *nanos_opencl_factory_(void *args);
}
extern "C"
{
  extern void *nanos_opencl_factory(void *args);
}
extern "C"
{
  extern void *nanos_create_current_kernel_(const char *kernel_name, const char *opencl_code, const char *compiler_opts);
}
extern "C"
{
  extern void *nanos_create_current_kernel(const char *kernel_name, const char *opencl_code, const char *compiler_opts);
}
extern "C"
{
  extern ::nanos_err_t nanos_opencl_set_bufferarg_(void *opencl_kernel, int arg_num, const void *pointer);
}
extern "C"
{
  extern ::nanos_err_t nanos_opencl_set_bufferarg(void *opencl_kernel, int arg_num, const void *pointer);
}
extern "C"
{
  extern ::nanos_err_t nanos_opencl_set_arg_(void *opencl_kernel, int arg_num, ::size_t size, const void *pointer);
}
extern "C"
{
  extern ::nanos_err_t nanos_opencl_set_arg(void *opencl_kernel, int arg_num, ::size_t size, const void *pointer);
}
extern "C"
{
  extern ::nanos_err_t nanos_exec_kernel_(void *opencl_kernel, int work_dim, ::size_t *ndr_local_size, ::size_t *ndr_global_size);
}
extern "C"
{
  extern ::nanos_err_t nanos_exec_kernel(void *opencl_kernel, int work_dim, ::size_t *ndr_local_size, ::size_t *ndr_global_size);
}
extern "C"
{
  extern ::nanos_err_t nanos_profile_exec_kernel_(void *opencl_kernel, int work_dim, ::size_t *ndr_global_size);
}
extern "C"
{
  extern ::nanos_err_t nanos_profile_exec_kernel(void *opencl_kernel, int work_dim, ::size_t *ndr_global_size);
}
extern "C"
{
  unsigned int nanos_get_opencl_num_devices();
}
extern "C"
{
  void *ompss_opencl_malloc(::size_t size);
}
extern "C"
{
  void ompss_opencl_free(void *address);
}
extern "C"
{
  void nanos_get_opencl_num_devices_(int *numret);
}
extern "C"
{
  void *nanos_malloc_opencl(::size_t size) __attribute__((deprecated));
}
extern "C"
{
  void nanos_free_opencl(void *address) __attribute__((deprecated));
}
extern "C"
{
  extern void nanos_opencl_allocate_fortran_(::ptrdiff_t size, void *ptr);
}
extern "C"
{
  extern void nanos_opencl_allocate_fortran(::ptrdiff_t size, void *ptr);
}
extern "C"
{
  extern void nanos_opencl_deallocate_fortran_(void *address);
}
extern "C"
{
  extern void nanos_opencl_deallocate_fortran(void *address);
}
namespace std __attribute__((__visibility__("default"))) {
  typedef unsigned long int size_t;
  typedef long int ptrdiff_t;
  typedef decltype(nullptr) nullptr_t;
}
#pragma GCC visibility push(default)
namespace std __attribute__((__visibility__("default"))) {
  class  exception
  {
    public:
      inline exception() noexcept(true)
      {
      }
      virtual ~exception() noexcept(true);
      virtual const char *what() const  noexcept(true);
  };
  class  bad_exception : public ::std::exception
  {
    public:
      inline bad_exception() noexcept(true)
      {
      }
      virtual ~bad_exception() noexcept(true);
      virtual const char *what() const  noexcept(true);
  };
  typedef void (*terminate_handler)();
  typedef void (*unexpected_handler)();
  ::std::terminate_handler set_terminate(::std::terminate_handler) noexcept(true);
  void terminate() noexcept(true) __attribute__((__noreturn__));
  ::std::unexpected_handler set_unexpected(::std::unexpected_handler) noexcept(true);
  void unexpected() __attribute__((__noreturn__));
  bool uncaught_exception() noexcept(true) __attribute__((__pure__));
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  void __verbose_terminate_handler();
}
#pragma GCC visibility pop
#pragma GCC visibility push(default)
namespace std __attribute__((__visibility__("default"))) {
  class type_info;
  namespace __exception_ptr {
    class exception_ptr;
  }
  using ::std::__exception_ptr::exception_ptr;
  ::std::__exception_ptr::exception_ptr current_exception() noexcept(true);
  void rethrow_exception(::std::__exception_ptr::exception_ptr) __attribute__((__noreturn__));
  namespace __exception_ptr {
    class  exception_ptr
    {
        void *_M_exception_object;
        explicit exception_ptr(void *__e) noexcept(true);
        void _M_addref() noexcept(true);
        void _M_release() noexcept(true);
        void *_M_get() const  noexcept(true) __attribute__((__pure__));
      public:
        exception_ptr() noexcept(true);
        exception_ptr(const ::std::__exception_ptr::exception_ptr &) noexcept(true);
        inline exception_ptr(::std::nullptr_t) noexcept(true)
          : _M_exception_object(0)
        {
        }
        inline exception_ptr(::std::__exception_ptr::exception_ptr &&__o) noexcept(true)
          : _M_exception_object(__o._M_exception_object)
        {
          __o._M_exception_object = 0;
        }
        ::std::__exception_ptr::exception_ptr &operator =(const ::std::__exception_ptr::exception_ptr &) noexcept(true);
        inline ::std::__exception_ptr::exception_ptr &operator =(::std::__exception_ptr::exception_ptr &&__o) noexcept(true)
        {
          ::std::__exception_ptr::exception_ptr(static_cast< ::std::__exception_ptr::exception_ptr &&>(__o)).::std::__exception_ptr::exception_ptr::swap(*this);
          return *this;
        }
        ~exception_ptr() noexcept(true);
        void swap(::std::__exception_ptr::exception_ptr &) noexcept(true);
        inline explicit operator bool() const 
        {
          return (*this)._M_exception_object;
        }
        const ::std::type_info *__cxa_exception_type() const  noexcept(true) __attribute__((__pure__));
      friend ::std::__exception_ptr::exception_ptr (::std::current_exception)() noexcept(true);
      friend void (::std::rethrow_exception)(::std::__exception_ptr::exception_ptr);
      friend bool operator ==(const ::std::__exception_ptr::exception_ptr &, const ::std::__exception_ptr::exception_ptr &) noexcept(true);
    };
    bool operator ==(const ::std::__exception_ptr::exception_ptr &, const ::std::__exception_ptr::exception_ptr &) noexcept(true) __attribute__((__pure__));
    bool operator !=(const ::std::__exception_ptr::exception_ptr &, const ::std::__exception_ptr::exception_ptr &) noexcept(true) __attribute__((__pure__));
    inline void swap(::std::__exception_ptr::exception_ptr &__lhs, ::std::__exception_ptr::exception_ptr &__rhs)
    {
      __lhs.::std::__exception_ptr::exception_ptr::swap(__rhs);
    }
  }
  template < typename _Ex >
  ::std::__exception_ptr::exception_ptr copy_exception(_Ex __ex) noexcept(true);
  template < typename _Ex >
  ::std::__exception_ptr::exception_ptr copy_exception(_Ex __ex) noexcept(true)
  {
    try
    {
      throw __ex;
    }
    catch (...)
    {
      return ::std::current_exception();
    }
  }
  template < typename _Ex >
  ::std::__exception_ptr::exception_ptr make_exception_ptr(_Ex __ex) noexcept(true);
  template < typename _Ex >
  ::std::__exception_ptr::exception_ptr make_exception_ptr(_Ex __ex) noexcept(true)
  {
    return std::copy_exception<_Ex>(__ex);
  }
}
#pragma GCC visibility pop
#pragma GCC visibility push(default)
namespace std __attribute__((__visibility__("default"))) {
  class  nested_exception
  {
      ::std::__exception_ptr::exception_ptr _M_ptr;
    public:
      inline nested_exception() noexcept(true)
        : _M_ptr(::std::current_exception())
      {
      }
      nested_exception(const ::std::nested_exception &) = default ;
      ::std::nested_exception &operator =(const ::std::nested_exception &) = default ;
      virtual ~nested_exception() noexcept(true);
      inline __attribute__((__noreturn__)) void rethrow_nested() const 
      {
        ::std::rethrow_exception((*this)._M_ptr);
      }
      inline ::std::__exception_ptr::exception_ptr nested_ptr() const 
      {
        return (*this)._M_ptr;
      }
  };
  template < typename _Except >
  struct  _Nested_exception : _Except, ::std::nested_exception
  {
      inline explicit _Nested_exception(_Except &&__ex)
        : _Except(static_cast<_Except &&>(__ex))
      {
      }
  };
  template < typename _Ex >
  struct  __get_nested_helper
  {
      static inline const ::std::nested_exception *_S_get(const _Ex &__ex)
      {
        return dynamic_cast<const ::std::nested_exception *>(&__ex);
      }
  };
  template < typename _Ex >
  struct  __get_nested_helper<_Ex *>
  {
      static inline const ::std::nested_exception *_S_get(const _Ex *__ex)
      {
        return dynamic_cast<const ::std::nested_exception *>(__ex);
      }
  };
  template < typename _Ex >
  inline const ::std::nested_exception *__get_nested_exception(const _Ex &__ex);
  template < typename _Ex >
  inline const ::std::nested_exception *__get_nested_exception(const _Ex &__ex)
  {
    return __get_nested_helper<_Ex>::_S_get(__ex);
  }
  template < typename _Ex >
  inline void __throw_with_nested(_Ex &&__ex, const ::std::nested_exception *  = (0));
  template < typename _Ex >
  inline void __throw_with_nested(_Ex &&__ex, ...);
  template < typename _Ex >
  inline void __throw_with_nested(_Ex &&__ex, const ::std::nested_exception *)
  {
    throw __ex;
  }
  template < typename _Ex >
  inline void __throw_with_nested(_Ex &&__ex, ...)
  {
    throw ::std::_Nested_exception<_Ex>(static_cast<_Ex &&>(__ex));
  }
  template < typename _Ex >
  inline void throw_with_nested(_Ex __ex);
  template < typename _Ex >
  inline void throw_with_nested(_Ex __ex)
  {
    if (__get_nested_exception(__ex))
      {
        throw __ex;
      }
    __throw_with_nested(static_cast<_Ex &&>(__ex), &__ex);
  }
  template < typename _Ex >
  inline void rethrow_if_nested(const _Ex &__ex);
  template < typename _Ex >
  inline void rethrow_if_nested(const _Ex &__ex)
  {
    if (const ::std::nested_exception *__nested = __get_nested_exception(__ex))
      {
        (*__nested).::std::nested_exception::rethrow_nested();
      }
  }
  inline void rethrow_if_nested(const ::std::nested_exception &__ex)
  {
    __ex.::std::nested_exception::rethrow_nested();
  }
}
#pragma GCC visibility pop
#pragma GCC visibility push(default)
namespace std __attribute__((__visibility__("default"))) {
  class  bad_alloc : public ::std::exception
  {
    public:
      inline bad_alloc() throw()
      {
      }
      virtual ~bad_alloc() throw();
      virtual const char *what() const  throw();
  };
  struct  nothrow_t
  {
  };
  extern const ::std::nothrow_t nothrow;
  typedef void (*new_handler)();
  ::std::new_handler set_new_handler(::std::new_handler) throw();
}
void *operator new(::std::size_t, const ::std::nothrow_t &) noexcept(true) __attribute__((__externally_visible__));
void *operator new[](::std::size_t, const ::std::nothrow_t &) noexcept(true) __attribute__((__externally_visible__));
void operator delete(void *, const ::std::nothrow_t &) noexcept(true) __attribute__((__externally_visible__));
void operator delete[](void *, const ::std::nothrow_t &) noexcept(true) __attribute__((__externally_visible__));
inline void *operator new(::std::size_t, void *__p) noexcept(true)
{
  return __p;
}
inline void *operator new[](::std::size_t, void *__p) noexcept(true)
{
  return __p;
}
inline void operator delete(void *, void *) noexcept(true)
{
}
inline void operator delete[](void *, void *) noexcept(true)
{
}
#pragma GCC visibility pop
namespace std __attribute__((__visibility__("default"))) {
  template < typename __type_tpl__param_1_0__ >
  class allocator;
  template <>
  class allocator<void>;
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct uses_allocator;
  template < typename _CharT >
  struct char_traits;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
  class basic_string;
  template <>
  struct char_traits<char>;
  typedef ::std::basic_string<char> string;
  template <>
  struct char_traits<wchar_t>;
  typedef ::std::basic_string<wchar_t> wstring;
  template <>
  struct char_traits<char16_t>;
  template <>
  struct char_traits<char32_t>;
  typedef ::std::basic_string<char16_t> u16string;
  typedef ::std::basic_string<char32_t> u32string;
}
struct _IO_FILE;
typedef ::_IO_FILE FILE;
typedef ::_IO_FILE __FILE;
typedef ::__builtin_va_list __gnuc_va_list;
typedef unsigned int wint_t;
struct  __mbstate_t
{
    int __count;
    union  mcc_union_anon_22
    {
        unsigned int __wch;
        char __wchb[4L];
    };
    ::__mbstate_t::mcc_union_anon_22 __value;
};
typedef ::__mbstate_t mbstate_t;
struct tm;
extern "C"
{
  extern wchar_t *wcscpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw();
}
extern "C"
{
  extern wchar_t *wcsncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw();
}
extern "C"
{
  extern wchar_t *wcscat(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw();
}
extern "C"
{
  extern wchar_t *wcsncat(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw();
}
extern "C"
{
  extern int wcscmp(const wchar_t *__s1, const wchar_t *__s2) throw() __attribute__((__pure__));
}
extern "C"
{
  extern int wcsncmp(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw() __attribute__((__pure__));
}
extern "C"
{
  extern int wcscasecmp(const wchar_t *__s1, const wchar_t *__s2) throw();
}
extern "C"
{
  extern int wcsncasecmp(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw();
}
struct __locale_data;
struct  __locale_struct
{
    ::__locale_data *__locales[13L];
    const unsigned short int *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13L];
};
typedef ::__locale_struct *__locale_t;
typedef ::__locale_t locale_t;
extern "C"
{
  extern int wcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2, ::__locale_t __loc) throw();
}
extern "C"
{
  extern int wcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n, ::__locale_t __loc) throw();
}
extern "C"
{
  extern int wcscoll(const wchar_t *__s1, const wchar_t *__s2) throw();
}
extern "C"
{
  extern ::size_t wcsxfrm(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw();
}
extern "C"
{
  extern int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2, ::__locale_t __loc) throw();
}
extern "C"
{
  extern ::size_t wcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, ::size_t __n, ::__locale_t __loc) throw();
}
extern "C"
{
  extern wchar_t *wcsdup(const wchar_t *__s) throw() __attribute__((__malloc__));
}
wchar_t *wcschr(wchar_t *__wcs, wchar_t __wc) throw() __asm("wcschr") __attribute__((__pure__));
const wchar_t *wcschr(const wchar_t *__wcs, wchar_t __wc) throw() __asm("wcschr") __attribute__((__pure__));
wchar_t *wcsrchr(wchar_t *__wcs, wchar_t __wc) throw() __asm("wcsrchr") __attribute__((__pure__));
const wchar_t *wcsrchr(const wchar_t *__wcs, wchar_t __wc) throw() __asm("wcsrchr") __attribute__((__pure__));
extern "C"
{
  extern wchar_t *wcschrnul(const wchar_t *__s, wchar_t __wc) throw() __attribute__((__pure__));
}
extern "C"
{
  extern ::size_t wcscspn(const wchar_t *__wcs, const wchar_t *__reject) throw() __attribute__((__pure__));
}
extern "C"
{
  extern ::size_t wcsspn(const wchar_t *__wcs, const wchar_t *__accept) throw() __attribute__((__pure__));
}
wchar_t *wcspbrk(wchar_t *__wcs, const wchar_t *__accept) throw() __asm("wcspbrk") __attribute__((__pure__));
const wchar_t *wcspbrk(const wchar_t *__wcs, const wchar_t *__accept) throw() __asm("wcspbrk") __attribute__((__pure__));
wchar_t *wcsstr(wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcsstr") __attribute__((__pure__));
const wchar_t *wcsstr(const wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcsstr") __attribute__((__pure__));
extern "C"
{
  extern wchar_t *wcstok(wchar_t *__restrict __s, const wchar_t *__restrict __delim, wchar_t **__restrict __ptr) throw();
}
extern "C"
{
  extern ::size_t wcslen(const wchar_t *__s) throw() __attribute__((__pure__));
}
wchar_t *wcswcs(wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcswcs") __attribute__((__pure__));
const wchar_t *wcswcs(const wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcswcs") __attribute__((__pure__));
extern "C"
{
  extern ::size_t wcsnlen(const wchar_t *__s, ::size_t __maxlen) throw() __attribute__((__pure__));
}
wchar_t *wmemchr(wchar_t *__s, wchar_t __c, ::size_t __n) throw() __asm("wmemchr") __attribute__((__pure__));
const wchar_t *wmemchr(const wchar_t *__s, wchar_t __c, ::size_t __n) throw() __asm("wmemchr") __attribute__((__pure__));
extern "C"
{
  extern int wmemcmp(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw() __attribute__((__pure__));
}
extern "C"
{
  extern wchar_t *wmemcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw();
}
extern "C"
{
  extern wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw();
}
extern "C"
{
  extern wchar_t *wmemset(wchar_t *__s, wchar_t __c, ::size_t __n) throw();
}
extern "C"
{
  extern wchar_t *wmempcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw();
}
extern "C"
{
  extern inline ::wint_t btowc(int __c) throw() __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int wctob(::wint_t __wc) throw() __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int mbsinit(const ::mbstate_t *__ps) throw() __attribute__((__pure__));
}
extern "C"
{
  extern ::size_t mbrtowc(wchar_t *__restrict __pwc, const char *__restrict __s, ::size_t __n, ::mbstate_t *__restrict __p) throw();
}
extern "C"
{
  extern ::size_t wcrtomb(char *__restrict __s, wchar_t __wc, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern ::size_t __mbrlen(const char *__restrict __s, ::size_t __n, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern inline ::size_t mbrlen(const char *__restrict __s, ::size_t __n, ::mbstate_t *__restrict __ps) throw() __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern ::wint_t __btowc_alias(int __c) __asm("btowc");
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__gnu_inline__)) ::wint_t btowc(int __c) throw()
  {
    return (__builtin_constant_p(__c) && __c >= '\000') && __c <= '\177' ? (::wint_t)__c : ::__btowc_alias(__c);
  }
}
extern "C"
{
  extern int __wctob_alias(::wint_t __c) __asm("wctob");
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int wctob(::wint_t __wc) throw()
  {
    return (__builtin_constant_p(__wc) && __wc >= L'\x0000') && __wc <= L'\x007f' ? (int)__wc : ::__wctob_alias(__wc);
  }
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__gnu_inline__)) ::size_t mbrlen(const char *__restrict __s, ::size_t __n, ::mbstate_t *__restrict __ps) throw()
  {
    return __ps != 0L ? ::mbrtowc(0L, __s, __n, __ps) : ::__mbrlen(__s, __n, 0L);
  }
}
extern "C"
{
  extern ::size_t mbsrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern ::size_t wcsrtombs(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern ::size_t mbsnrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __nmc, ::size_t __len, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern ::size_t wcsnrtombs(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __nwc, ::size_t __len, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern int wcwidth(wchar_t __c) throw();
}
extern "C"
{
  extern int wcswidth(const wchar_t *__s, ::size_t __n) throw();
}
extern "C"
{
  extern double wcstod(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern float wcstof(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern long double wcstold(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern long int wcstol(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern unsigned long int wcstoul(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern long long int wcstoll(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern unsigned long long int wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern long long int wcstoq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern unsigned long long int wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern long int wcstol_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::__locale_t __loc) throw();
}
extern "C"
{
  extern unsigned long int wcstoul_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::__locale_t __loc) throw();
}
extern "C"
{
  extern long long int wcstoll_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::__locale_t __loc) throw();
}
extern "C"
{
  extern unsigned long long int wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::__locale_t __loc) throw();
}
extern "C"
{
  extern double wcstod_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::__locale_t __loc) throw();
}
extern "C"
{
  extern float wcstof_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::__locale_t __loc) throw();
}
extern "C"
{
  extern long double wcstold_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::__locale_t __loc) throw();
}
extern "C"
{
  extern wchar_t *wcpcpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw();
}
extern "C"
{
  extern wchar_t *wcpncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw();
}
extern "C"
{
  extern ::__FILE *open_wmemstream(wchar_t **__bufloc, ::size_t *__sizeloc) throw();
}
extern "C"
{
  extern int fwide(::__FILE *__fp, int __mode) throw();
}
extern "C"
{
  extern int fwprintf(::__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int wprintf(const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int swprintf(wchar_t *__restrict __s, ::size_t __n, const wchar_t *__restrict __format, ...) throw();
}
extern "C"
{
  extern int vfwprintf(::__FILE *__restrict __s, const wchar_t *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vwprintf(const wchar_t *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vswprintf(wchar_t *__restrict __s, ::size_t __n, const wchar_t *__restrict __format, ::__gnuc_va_list __arg) throw();
}
extern "C"
{
  extern int fwscanf(::__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int wscanf(const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) throw();
}
extern "C"
{
  extern int vfwscanf(::__FILE *__restrict __s, const wchar_t *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vwscanf(const wchar_t *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ::__gnuc_va_list __arg) throw();
}
extern "C"
{
  extern ::wint_t fgetwc(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwc(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwchar();
}
extern "C"
{
  extern ::wint_t fputwc(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwc(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwchar(wchar_t __wc);
}
extern "C"
{
  extern wchar_t *fgetws(wchar_t *__restrict __ws, int __n, ::__FILE *__restrict __stream);
}
extern "C"
{
  extern int fputws(const wchar_t *__restrict __ws, ::__FILE *__restrict __stream);
}
extern "C"
{
  extern ::wint_t ungetwc(::wint_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwc_unlocked(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwchar_unlocked();
}
extern "C"
{
  extern ::wint_t fgetwc_unlocked(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t fputwc_unlocked(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwc_unlocked(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwchar_unlocked(wchar_t __wc);
}
extern "C"
{
  extern wchar_t *fgetws_unlocked(wchar_t *__restrict __ws, int __n, ::__FILE *__restrict __stream);
}
extern "C"
{
  extern int fputws_unlocked(const wchar_t *__restrict __ws, ::__FILE *__restrict __stream);
}
extern "C"
{
  extern ::size_t wcsftime(wchar_t *__restrict __s, ::size_t __maxsize, const wchar_t *__restrict __format, const ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern ::size_t wcsftime_l(wchar_t *__restrict __s, ::size_t __maxsize, const wchar_t *__restrict __format, const ::tm *__restrict __tp, ::__locale_t __loc) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::mbstate_t;
  using ::wint_t;
  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;
  using ::vfwscanf;
  using ::vswprintf;
  using ::vswscanf;
  using ::vwprintf;
  using ::vwscanf;
  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;
  using ::wcstof;
  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::wcstold;
  using ::wcstoll;
  using ::wcstoull;
}
namespace std __attribute__((__visibility__("default"))) {
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
  using ::std::wcstof;
  using ::std::vfwscanf;
  using ::std::vswscanf;
  using ::std::vwscanf;
  using ::std::wcstold;
  using ::std::wcstoll;
  using ::std::wcstoull;
  typedef long int streamoff;
  typedef ::std::ptrdiff_t streamsize;
  template < typename _StateT >
  class  fpos
  {
      ::std::streamoff _M_off;
      _StateT _M_state;
    public:
      inline fpos()
        : _M_off(0), _M_state()
      {
      }
      inline fpos(::std::streamoff __off)
        : _M_off(__off), _M_state()
      {
      }
      inline operator ::std::streamoff() const 
      {
        return ::std::fpos<_StateT>::_M_off;
      }
      inline void state(_StateT __st)
      {
        ::std::fpos<_StateT>::_M_state = __st;
      }
      inline _StateT state() const 
      {
        return ::std::fpos<_StateT>::_M_state;
      }
      inline ::std::fpos<_StateT> &operator +=(::std::streamoff __off)
      {
        ::std::fpos<_StateT>::_M_off += __off;
        return *this;
      }
      inline ::std::fpos<_StateT> &operator -=(::std::streamoff __off)
      {
        ::std::fpos<_StateT>::_M_off -= __off;
        return *this;
      }
      inline ::std::fpos<_StateT> operator +(::std::streamoff __off) const 
      {
        ::std::fpos<_StateT> __pos(*this);
        __pos += __off;
        return __pos;
      }
      inline ::std::fpos<_StateT> operator -(::std::streamoff __off) const 
      {
        ::std::fpos<_StateT> __pos(*this);
        __pos -= __off;
        return __pos;
      }
      inline ::std::streamoff operator -(const ::std::fpos<_StateT> &__other) const 
      {
        return ::std::fpos<_StateT>::_M_off - __other._M_off;
      }
  };
  template < typename _StateT >
  inline bool operator ==(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs);
  template < typename _StateT >
  inline bool operator ==(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs)
  {
    return long(__lhs) == long(__rhs);
  }
  template < typename _StateT >
  inline bool operator !=(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs);
  template < typename _StateT >
  inline bool operator !=(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs)
  {
    return long(__lhs) != long(__rhs);
  }
  typedef ::std::fpos< ::__mbstate_t> streampos;
  typedef ::std::fpos< ::__mbstate_t> wstreampos;
  typedef ::std::fpos< ::__mbstate_t> u16streampos;
  typedef ::std::fpos< ::__mbstate_t> u32streampos;
  class ios_base;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ios;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_streambuf;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_istream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ostream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_iostream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
  class basic_stringbuf;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
  class basic_istringstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
  class basic_ostringstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
  class basic_stringstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_filebuf;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ifstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ofstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_fstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class istreambuf_iterator;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class ostreambuf_iterator;
  typedef ::std::basic_ios<char> ios;
  typedef ::std::basic_streambuf<char> streambuf;
  typedef ::std::basic_istream<char> istream;
  typedef ::std::basic_ostream<char> ostream;
  typedef ::std::basic_iostream<char> iostream;
  typedef ::std::basic_stringbuf<char> stringbuf;
  typedef ::std::basic_istringstream<char> istringstream;
  typedef ::std::basic_ostringstream<char> ostringstream;
  typedef ::std::basic_stringstream<char> stringstream;
  typedef ::std::basic_filebuf<char> filebuf;
  typedef ::std::basic_ifstream<char> ifstream;
  typedef ::std::basic_ofstream<char> ofstream;
  typedef ::std::basic_fstream<char> fstream;
  typedef ::std::basic_ios<wchar_t> wios;
  typedef ::std::basic_streambuf<wchar_t> wstreambuf;
  typedef ::std::basic_istream<wchar_t> wistream;
  typedef ::std::basic_ostream<wchar_t> wostream;
  typedef ::std::basic_iostream<wchar_t> wiostream;
  typedef ::std::basic_stringbuf<wchar_t> wstringbuf;
  typedef ::std::basic_istringstream<wchar_t> wistringstream;
  typedef ::std::basic_ostringstream<wchar_t> wostringstream;
  typedef ::std::basic_stringstream<wchar_t> wstringstream;
  typedef ::std::basic_filebuf<wchar_t> wfilebuf;
  typedef ::std::basic_ifstream<wchar_t> wifstream;
  typedef ::std::basic_ofstream<wchar_t> wofstream;
  typedef ::std::basic_fstream<wchar_t> wfstream;
  void __throw_bad_exception() __attribute__((__noreturn__));
  void __throw_bad_alloc() __attribute__((__noreturn__));
  void __throw_bad_cast() __attribute__((__noreturn__));
  void __throw_bad_typeid() __attribute__((__noreturn__));
  void __throw_logic_error(const char *) __attribute__((__noreturn__));
  void __throw_domain_error(const char *) __attribute__((__noreturn__));
  void __throw_invalid_argument(const char *) __attribute__((__noreturn__));
  void __throw_length_error(const char *) __attribute__((__noreturn__));
  void __throw_out_of_range(const char *) __attribute__((__noreturn__));
  void __throw_runtime_error(const char *) __attribute__((__noreturn__));
  void __throw_range_error(const char *) __attribute__((__noreturn__));
  void __throw_overflow_error(const char *) __attribute__((__noreturn__));
  void __throw_underflow_error(const char *) __attribute__((__noreturn__));
  void __throw_ios_failure(const char *) __attribute__((__noreturn__));
  void __throw_system_error(int) __attribute__((__noreturn__));
  void __throw_future_error(int) __attribute__((__noreturn__));
  void __throw_bad_function_call() __attribute__((__noreturn__));
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < typename _Iterator, typename _Container >
  class __normal_iterator;
}
namespace std __attribute__((__visibility__("default"))) {
  struct  __true_type
  {
  };
  struct  __false_type
  {
  };
  template < bool __nontype_tpl_param_1_0__ >
  struct  __truth_type
  {
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __truth_type<true>
  {
      typedef ::std::__true_type __type;
  };
  template < typename _Sp, typename _Tp >
  struct  __traitor
  {
      enum mcc_enum_anon_6
      {
        __value = bool(_Sp::__value) || bool(_Tp::__value)
      };
      typedef typename ::std::__truth_type< ::std::__traitor<_Sp, _Tp>::__value>::__type __type;
  };
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct  __are_same
  {
      enum mcc_enum_anon_7
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template < typename _Tp >
  struct  __are_same<_Tp, _Tp>
  {
      enum mcc_enum_anon_8
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_void
  {
      enum mcc_enum_anon_9
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_void<void>
  {
      enum mcc_enum_anon_10
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_integer
  {
      enum mcc_enum_anon_11
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_integer<bool>
  {
      enum mcc_enum_anon_12
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<char>
  {
      enum mcc_enum_anon_13
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<signed char>
  {
      enum mcc_enum_anon_14
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned char>
  {
      enum mcc_enum_anon_15
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<wchar_t>
  {
      enum mcc_enum_anon_16
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<char16_t>
  {
      enum mcc_enum_anon_17
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<char32_t>
  {
      enum mcc_enum_anon_18
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<short int>
  {
      enum mcc_enum_anon_19
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned short int>
  {
      enum mcc_enum_anon_20
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<int>
  {
      enum mcc_enum_anon_21
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned int>
  {
      enum mcc_enum_anon_22
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<long int>
  {
      enum mcc_enum_anon_23
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned long int>
  {
      enum mcc_enum_anon_24
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<long long int>
  {
      enum mcc_enum_anon_25
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned long long int>
  {
      enum mcc_enum_anon_26
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_floating
  {
      enum mcc_enum_anon_27
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_floating<float>
  {
      enum mcc_enum_anon_28
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_floating<double>
  {
      enum mcc_enum_anon_29
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_floating<long double>
  {
      enum mcc_enum_anon_30
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_pointer
  {
      enum mcc_enum_anon_31
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template < typename _Tp >
  struct  __is_pointer<_Tp *>
  {
      enum mcc_enum_anon_32
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_normal_iterator
  {
      enum mcc_enum_anon_33
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template < typename _Iterator, typename _Container >
  struct  __is_normal_iterator< ::__gnu_cxx::__normal_iterator<_Iterator, _Container> >
  {
      enum mcc_enum_anon_34
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_arithmetic : ::std::__traitor< ::std::__is_integer<_Tp>, ::std::__is_floating<_Tp> >
  {
  };
  template < typename _Tp >
  struct  __is_fundamental : ::std::__traitor< ::std::__is_void<_Tp>, ::std::__is_arithmetic<_Tp> >
  {
  };
  template < typename _Tp >
  struct  __is_scalar : ::std::__traitor< ::std::__is_arithmetic<_Tp>, ::std::__is_pointer<_Tp> >
  {
  };
  template < typename _Tp >
  struct  __is_char
  {
      enum mcc_enum_anon_35
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_char<char>
  {
      enum mcc_enum_anon_36
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_char<wchar_t>
  {
      enum mcc_enum_anon_37
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_byte
  {
      enum mcc_enum_anon_38
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_byte<char>
  {
      enum mcc_enum_anon_39
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_byte<signed char>
  {
      enum mcc_enum_anon_40
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_byte<unsigned char>
  {
      enum mcc_enum_anon_41
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_move_iterator
  {
      enum mcc_enum_anon_42
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template < typename _Iterator >
  class move_iterator;
  template < typename _Iterator >
  struct  __is_move_iterator< ::std::move_iterator<_Iterator> >
  {
      enum mcc_enum_anon_43
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < bool __nontype_tpl_param_1_0__, typename __type_tpl__param_1_1__ >
  struct  __enable_if
  {
  };
  template < typename _Tp >
  struct  __enable_if<true, _Tp>
  {
      typedef _Tp __type;
  };
  template < bool _Cond, typename _Iftrue, typename _Iffalse >
  struct  __conditional_type
  {
      typedef _Iftrue __type;
  };
  template < typename _Iftrue, typename _Iffalse >
  struct  __conditional_type<false, _Iftrue, _Iffalse>
  {
      typedef _Iffalse __type;
  };
  template < typename _Tp >
  struct  __add_unsigned
  {
    private:
      typedef ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
    public:
      typedef typename ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp>::__type __type;
  };
  template <>
  struct  __add_unsigned<char>
  {
      typedef unsigned char __type;
  };
  template <>
  struct  __add_unsigned<signed char>
  {
      typedef unsigned char __type;
  };
  template <>
  struct  __add_unsigned<short int>
  {
      typedef unsigned short int __type;
  };
  template <>
  struct  __add_unsigned<int>
  {
      typedef unsigned int __type;
  };
  template <>
  struct  __add_unsigned<long int>
  {
      typedef unsigned long int __type;
  };
  template <>
  struct  __add_unsigned<long long int>
  {
      typedef unsigned long long int __type;
  };
  template <>
  struct __add_unsigned<bool>;
  template <>
  struct __add_unsigned<wchar_t>;
  template < typename _Tp >
  struct  __remove_unsigned
  {
    private:
      typedef ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
    public:
      typedef typename ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp>::__type __type;
  };
  template <>
  struct  __remove_unsigned<char>
  {
      typedef signed char __type;
  };
  template <>
  struct  __remove_unsigned<unsigned char>
  {
      typedef signed char __type;
  };
  template <>
  struct  __remove_unsigned<unsigned short int>
  {
      typedef short int __type;
  };
  template <>
  struct  __remove_unsigned<unsigned int>
  {
      typedef int __type;
  };
  template <>
  struct  __remove_unsigned<unsigned long int>
  {
      typedef long int __type;
  };
  template <>
  struct  __remove_unsigned<unsigned long long int>
  {
      typedef long long int __type;
  };
  template <>
  struct __remove_unsigned<bool>;
  template <>
  struct __remove_unsigned<wchar_t>;
  template < typename _Type >
  inline bool __is_null_pointer(_Type *__ptr);
  template < typename _Type >
  inline bool __is_null_pointer(_Type *__ptr)
  {
    return __ptr == 0;
  }
  template < typename _Type >
  inline bool __is_null_pointer(_Type);
  template < typename _Type >
  inline bool __is_null_pointer(_Type)
  {
    return false;
  }
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = std::__is_integer<_Tp>::__value >
  struct  __promote
  {
      typedef double __type;
  };
  template < typename _Tp >
  struct  __promote<_Tp, false>
  {
  };
 /* Instantiation of class template '::std::__is_integer<long double>' */ 
  template <>
  struct  __promote<long double>
  {
      typedef long double __type;
  };
 /* Instantiation of class template '::std::__is_integer<double>' */ 
  template <>
  struct  __promote<double>
  {
      typedef double __type;
  };
 /* Instantiation of class template '::std::__is_integer<float>' */ 
  template <>
  struct  __promote<float>
  {
      typedef float __type;
  };
  template < typename _Tp, typename _Up, typename _Tp2 = typename ::__gnu_cxx::__promote<_Tp>::__type, typename _Up2 = typename ::__gnu_cxx::__promote<_Up>::__type >
  struct  __promote_2
  {
      typedef __typeof__(_Tp2() + _Up2()) __type;
  };
  template < typename _Tp, typename _Up, typename _Vp, typename _Tp2 = typename ::__gnu_cxx::__promote<_Tp>::__type, typename _Up2 = typename ::__gnu_cxx::__promote<_Up>::__type, typename _Vp2 = typename ::__gnu_cxx::__promote<_Vp>::__type >
  struct  __promote_3
  {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
  };
  template < typename _Tp, typename _Up, typename _Vp, typename _Wp, typename _Tp2 = typename ::__gnu_cxx::__promote<_Tp>::__type, typename _Up2 = typename ::__gnu_cxx::__promote<_Up>::__type, typename _Vp2 = typename ::__gnu_cxx::__promote<_Vp>::__type, typename _Wp2 = typename ::__gnu_cxx::__promote<_Wp>::__type >
  struct  __promote_4
  {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
  };
  template < typename _Value >
  struct  __numeric_traits_integer
  {
      static const _Value __min = (_Value) -1 < 0 ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value) -1 < 0)) : (_Value)0;
      static const _Value __max = (_Value) -1 < 0 ? ((((_Value)1 << (sizeof(_Value) * 8 - ((_Value) -1 < 0) - 1)) - 1) << 1) + 1 : ~((_Value)0);
      static const bool __is_signed = (_Value) -1 < 0;
      static const int __digits = sizeof(_Value) * 8 - ((_Value) -1 < 0);
  };
  template < typename _Value >
  struct  __numeric_traits_floating
  {
      static const int __max_digits10 = 2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136;
      static const bool __is_signed = true;
      static const int __digits10 = std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18;
      static const int __max_exponent10 = std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932;
  };
  template < typename _Value >
  struct  __numeric_traits : ::__gnu_cxx::__conditional_type<std::__is_integer<_Value>::__value, ::__gnu_cxx::__numeric_traits_integer<_Value>, ::__gnu_cxx::__numeric_traits_floating<_Value> >::__type
  {
  };
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Tp >
  inline _Tp *__addressof(_Tp &__r) noexcept(true);
  template < typename _Tp >
  inline _Tp *__addressof(_Tp &__r) noexcept(true)
  {
    return reinterpret_cast<_Tp *>(&const_cast<char &>(reinterpret_cast<const volatile char &>(__r)));
  }
  template < typename _Tp, _Tp __v >
  struct  integral_constant
  {
      static constexpr const _Tp value = __v;
      typedef _Tp value_type;
      typedef ::std::integral_constant<_Tp, __v> type;
      inline constexpr operator typename ::std::integral_constant<_Tp, __v>::value_type() const 
      {
        return ::std::integral_constant<_Tp, __v>::value;
      }
  };
  typedef ::std::integral_constant<bool, true> true_type;
  typedef ::std::integral_constant<bool, false> false_type;
  template < bool __nontype_tpl_param_1_0__, typename __type_tpl__param_1_1__, typename __type_tpl__param_1_2__ >
  struct conditional;
  template < typename ...__type_tpl__param_1_0__ >
  struct __or_;
 /* Instantiation of class template '::std::integral_constant<bool, false>' */ 
  template <>
  struct  __or_<> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _B1 >
  struct  __or_<_B1> : _B1
  {
  };
  template < typename _B1, typename _B2 >
  struct  __or_<_B1, _B2> : ::std::conditional<_B1::value, _B1, _B2>::type
  {
  };
  template < typename _B1, typename _B2, typename _B3, typename ..._Bn >
  struct  __or_<_B1, _B2, _B3, _Bn ...> : ::std::conditional<_B1::value, _B1, ::std::__or_<_B2, _B3, _Bn ...> >::type
  {
  };
  template < typename ...__type_tpl__param_1_0__ >
  struct __and_;
 /* Instantiation of class template '::std::integral_constant<bool, true>' */ 
  template <>
  struct  __and_<> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _B1 >
  struct  __and_<_B1> : _B1
  {
  };
  template < typename _B1, typename _B2 >
  struct  __and_<_B1, _B2> : ::std::conditional<_B1::value, _B2, _B1>::type
  {
  };
  template < typename _B1, typename _B2, typename _B3, typename ..._Bn >
  struct  __and_<_B1, _B2, _B3, _Bn ...> : ::std::conditional<_B1::value, ::std::__and_<_B2, _B3, _Bn ...>, _B1>::type
  {
  };
  template < typename _Pp >
  struct  __not_ : ::std::integral_constant<bool, !_Pp::value>
  {
  };
  struct  __sfinae_types
  {
      typedef char __one;
      struct  __two
      {
          char __arr[2L];
      };
  };
  template < typename _Tp >
  struct  __success_type
  {
      typedef _Tp type;
  };
  struct  __failure_type
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct remove_cv;
  template < typename __type_tpl__param_1_0__ >
  struct  __is_void_helper : ::std::integral_constant<bool, false>
  {
  };
  template <>
  struct  __is_void_helper<void> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_void : ::std::integral_constant<bool, __is_void_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  __is_integral_helper : ::std::integral_constant<bool, false>
  {
  };
  template <>
  struct  __is_integral_helper<bool> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<char> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<signed char> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<unsigned char> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<wchar_t> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<char16_t> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<char32_t> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<short int> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<unsigned short int> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<int> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<unsigned int> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<long int> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<unsigned long int> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<long long int> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<unsigned long long int> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_integral : ::std::integral_constant<bool, __is_integral_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  __is_floating_point_helper : ::std::integral_constant<bool, false>
  {
  };
  template <>
  struct  __is_floating_point_helper<float> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_floating_point_helper<double> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_floating_point_helper<long double> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_floating_point : ::std::integral_constant<bool, __is_floating_point_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  is_array : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp, ::std::size_t _Size >
  struct  is_array<_Tp [_Size]> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_array<_Tp []> : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  __is_pointer_helper : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_pointer_helper<_Tp *> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_pointer : ::std::integral_constant<bool, __is_pointer_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  is_lvalue_reference : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  is_lvalue_reference<_Tp &> : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  is_rvalue_reference : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  is_rvalue_reference<_Tp &&> : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct is_function;
  template < typename __type_tpl__param_1_0__ >
  struct  __is_member_object_pointer_helper : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp, typename _Cp >
  struct  __is_member_object_pointer_helper<_Tp _Cp::*> : ::std::integral_constant<bool, !is_function<_Tp>::value>
  {
  };
  template < typename _Tp >
  struct  is_member_object_pointer : ::std::integral_constant<bool, __is_member_object_pointer_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  __is_member_function_pointer_helper : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp, typename _Cp >
  struct  __is_member_function_pointer_helper<_Tp _Cp::*> : ::std::integral_constant<bool, is_function<_Tp>::value>
  {
  };
  template < typename _Tp >
  struct  is_member_function_pointer : ::std::integral_constant<bool, __is_member_function_pointer_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename _Tp >
  struct  is_enum : ::std::integral_constant<bool, __is_enum(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_union : ::std::integral_constant<bool, __is_union(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_class : ::std::integral_constant<bool, __is_class(_Tp)>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  is_function : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...)> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...)> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...) const > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...) const > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...) volatile > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...) volatile > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...) const volatile > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...) const volatile > : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  __is_nullptr_t_helper : ::std::integral_constant<bool, false>
  {
  };
  template <>
  struct  __is_nullptr_t_helper<decltype(nullptr)> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  __is_nullptr_t : ::std::integral_constant<bool, __is_nullptr_t_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename _Tp >
  struct  is_reference : ::std::__or_< ::std::is_lvalue_reference<_Tp>, ::std::is_rvalue_reference<_Tp> >::type
  {
  };
  template < typename _Tp >
  struct  is_arithmetic : ::std::__or_< ::std::is_integral<_Tp>, ::std::is_floating_point<_Tp> >::type
  {
  };
  template < typename _Tp >
  struct  is_fundamental : ::std::__or_< ::std::is_arithmetic<_Tp>, ::std::is_void<_Tp>, ::std::__is_nullptr_t<_Tp> >::type
  {
  };
  template < typename _Tp >
  struct  is_object : ::std::__not_< ::std::__or_< ::std::is_function<_Tp>, ::std::is_reference<_Tp>, ::std::is_void<_Tp> > >::type
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct is_member_pointer;
  template < typename _Tp >
  struct  is_scalar : ::std::__or_< ::std::is_arithmetic<_Tp>, ::std::is_enum<_Tp>, ::std::is_pointer<_Tp>, ::std::is_member_pointer<_Tp>, ::std::__is_nullptr_t<_Tp> >::type
  {
  };
  template < typename _Tp >
  struct  is_compound : ::std::integral_constant<bool, !is_fundamental<_Tp>::value>
  {
  };
  template < typename _Tp >
  struct  __is_member_pointer_helper : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp, typename _Cp >
  struct  __is_member_pointer_helper<_Tp _Cp::*> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_member_pointer : ::std::integral_constant<bool, __is_member_pointer_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  is_const : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  is_const<const _Tp> : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  is_volatile : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  is_volatile<volatile _Tp> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_trivial : ::std::integral_constant<bool, __is_trivial(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_standard_layout : ::std::integral_constant<bool, __is_standard_layout(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_pod : ::std::integral_constant<bool, __is_pod(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_literal_type : ::std::integral_constant<bool, __is_literal_type(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_empty : ::std::integral_constant<bool, __is_empty(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_polymorphic : ::std::integral_constant<bool, __is_polymorphic(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_abstract : ::std::integral_constant<bool, __is_abstract(_Tp)>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = is_integral<_Tp>::value, bool __nontype_tpl_param_1_2__ = is_floating_point<_Tp>::value >
  struct  __is_signed_helper : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_signed_helper<_Tp, false, true> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  __is_signed_helper<_Tp, true, false> : ::std::integral_constant<bool, static_cast<bool>(_Tp( -1) < _Tp(0))>
  {
  };
  template < typename _Tp >
  struct  is_signed : ::std::integral_constant<bool, __is_signed_helper<_Tp>::value>
  {
  };
  template < typename _Tp >
  struct  is_unsigned : ::std::__and_< ::std::is_arithmetic<_Tp>, ::std::__not_< ::std::is_signed<_Tp> > >::type
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct add_rvalue_reference;
  template < typename _Tp >
  inline typename ::std::add_rvalue_reference<_Tp>::type declval() noexcept(true);
  template < typename __type_tpl__param_1_0__, unsigned int __nontype_tpl_param_1_1__ = 0 >
  struct extent;
  template < typename __type_tpl__param_1_0__ >
  struct remove_all_extents;
  template < typename _Tp >
  struct  __is_array_known_bounds : ::std::integral_constant<bool, (extent<_Tp>::value > 0)>
  {
  };
  template < typename _Tp >
  struct  __is_array_unknown_bounds : ::std::__and_< ::std::is_array<_Tp>, ::std::__not_< ::std::extent<_Tp> > >::type
  {
  };
  struct  __do_is_destructible_impl
  {
      template < typename _Tp, typename __type_tpl__param_1_1__ = decltype(declval<_Tp &>().~_Tp()) >
      static ::std::true_type __test(int);
      template < typename __type_tpl__param_1_0__ >
      static ::std::false_type __test(...);
  };
  template < typename _Tp >
  struct  __is_destructible_impl : ::std::__do_is_destructible_impl
  {
      typedef decltype(__test<_Tp>(0)) type;
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __or_< ::std::is_void<_Tp>, ::std::__is_array_unknown_bounds<_Tp>, ::std::is_function<_Tp> >::value, bool __nontype_tpl_param_1_2__ = __or_< ::std::is_reference<_Tp>, ::std::is_scalar<_Tp> >::value >
  struct __is_destructible_safe;
  template < typename _Tp >
  struct  __is_destructible_safe<_Tp, false, false> : ::std::__is_destructible_impl<typename ::std::remove_all_extents<_Tp>::type>::type
  {
  };
  template < typename _Tp >
  struct  __is_destructible_safe<_Tp, true, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_destructible_safe<_Tp, false, true> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_destructible : ::std::integral_constant<bool, __is_destructible_safe<_Tp>::value>
  {
  };
  struct  __do_is_nt_destructible_impl
  {
      template < typename _Tp >
      static ::std::integral_constant<bool, noexcept(declval<_Tp &>().~_Tp())> __test(int);
      template < typename __type_tpl__param_1_0__ >
      static ::std::false_type __test(...);
  };
  template < typename _Tp >
  struct  __is_nt_destructible_impl : ::std::__do_is_nt_destructible_impl
  {
      typedef decltype(__test<_Tp>(0)) type;
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __or_< ::std::is_void<_Tp>, ::std::__is_array_unknown_bounds<_Tp>, ::std::is_function<_Tp> >::value, bool __nontype_tpl_param_1_2__ = __or_< ::std::is_reference<_Tp>, ::std::is_scalar<_Tp> >::value >
  struct __is_nt_destructible_safe;
  template < typename _Tp >
  struct  __is_nt_destructible_safe<_Tp, false, false> : ::std::__is_nt_destructible_impl<typename ::std::remove_all_extents<_Tp>::type>::type
  {
  };
  template < typename _Tp >
  struct  __is_nt_destructible_safe<_Tp, true, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_nt_destructible_safe<_Tp, false, true> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_nothrow_destructible : ::std::integral_constant<bool, __is_nt_destructible_safe<_Tp>::value>
  {
  };
  struct  __do_is_default_constructible_impl
  {
      template < typename _Tp, typename __type_tpl__param_1_1__ = decltype(_Tp()) >
      static ::std::true_type __test(int);
      template < typename __type_tpl__param_1_0__ >
      static ::std::false_type __test(...);
  };
  template < typename _Tp >
  struct  __is_default_constructible_impl : ::std::__do_is_default_constructible_impl
  {
      typedef decltype(__test<_Tp>(0)) type;
  };
  template < typename _Tp >
  struct  __is_default_constructible_atom : ::std::__and_< ::std::__not_< ::std::is_void<_Tp> >, ::std::__is_default_constructible_impl<_Tp> >::type
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = is_array<_Tp>::value >
  struct __is_default_constructible_safe;
  template < typename _Tp >
  struct  __is_default_constructible_safe<_Tp, true> : ::std::__and_< ::std::__is_array_known_bounds<_Tp>, ::std::__is_default_constructible_atom<typename ::std::remove_all_extents<_Tp>::type> >::type
  {
  };
  template < typename _Tp >
  struct  __is_default_constructible_safe<_Tp, false> : ::std::__is_default_constructible_atom<_Tp>::type
  {
  };
  template < typename _Tp >
  struct  is_default_constructible : ::std::integral_constant<bool, __is_default_constructible_safe<_Tp>::value>
  {
  };
  struct  __do_is_static_castable_impl
  {
      template < typename _From, typename _To, typename __type_tpl__param_1_2__ = decltype(static_cast<_To>(declval<_From>())) >
      static ::std::true_type __test(int);
      template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
      static ::std::false_type __test(...);
  };
  template < typename _From, typename _To >
  struct  __is_static_castable_impl : ::std::__do_is_static_castable_impl
  {
      typedef decltype(__test<_From, _To>(0)) type;
  };
  template < typename _From, typename _To >
  struct  __is_static_castable_safe : ::std::__is_static_castable_impl<_From, _To>::type
  {
  };
  template < typename _From, typename _To >
  struct  __is_static_castable : ::std::integral_constant<bool, __is_static_castable_safe<_From, _To>::value>
  {
  };
  struct  __do_is_direct_constructible_impl
  {
      template < typename _Tp, typename _Arg, typename __type_tpl__param_1_2__ = decltype(::new _Tp(declval<_Arg>())) >
      static ::std::true_type __test(int);
      template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
      static ::std::false_type __test(...);
  };
  template < typename _Tp, typename _Arg >
  struct  __is_direct_constructible_impl : ::std::__do_is_direct_constructible_impl
  {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
  };
  template < typename _Tp, typename _Arg >
  struct  __is_direct_constructible_new_safe : ::std::__and_< ::std::is_destructible<_Tp>, ::std::__is_direct_constructible_impl<_Tp, _Arg> >::type
  {
  };
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct is_same;
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct is_base_of;
  template < typename __type_tpl__param_1_0__ >
  struct remove_reference;
  template < typename _From, typename _To, bool __nontype_tpl_param_1_2__ = __not_< ::std::__or_< ::std::is_void<_From>, ::std::is_function<_From> > >::value >
  struct __is_base_to_derived_ref;
  template < typename _From, typename _To >
  struct  __is_base_to_derived_ref<_From, _To, true>
  {
      typedef typename ::std::remove_cv<typename ::std::remove_reference<_From>::type>::type __src_t;
      typedef typename ::std::remove_cv<typename ::std::remove_reference<_To>::type>::type __dst_t;
      typedef ::std::__and_< ::std::__not_< ::std::is_same<typename ::std::__is_base_to_derived_ref<_From, _To, true>::__src_t, typename ::std::__is_base_to_derived_ref<_From, _To, true>::__dst_t> >, ::std::is_base_of<typename ::std::__is_base_to_derived_ref<_From, _To, true>::__src_t, typename ::std::__is_base_to_derived_ref<_From, _To, true>::__dst_t> > type;
      static constexpr const bool value = type::value;
  };
  template < typename _From, typename _To >
  struct  __is_base_to_derived_ref<_From, _To, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _From, typename _To, bool __nontype_tpl_param_1_2__ = __and_< ::std::is_lvalue_reference<_From>, ::std::is_rvalue_reference<_To> >::value >
  struct __is_lvalue_to_rvalue_ref;
  template < typename _From, typename _To >
  struct  __is_lvalue_to_rvalue_ref<_From, _To, true>
  {
      typedef typename ::std::remove_cv<typename ::std::remove_reference<_From>::type>::type __src_t;
      typedef typename ::std::remove_cv<typename ::std::remove_reference<_To>::type>::type __dst_t;
      typedef ::std::__and_< ::std::__not_< ::std::is_function<typename ::std::__is_lvalue_to_rvalue_ref<_From, _To, true>::__src_t> >, ::std::__or_< ::std::is_same<typename ::std::__is_lvalue_to_rvalue_ref<_From, _To, true>::__src_t, typename ::std::__is_lvalue_to_rvalue_ref<_From, _To, true>::__dst_t>, ::std::is_base_of<typename ::std::__is_lvalue_to_rvalue_ref<_From, _To, true>::__dst_t, typename ::std::__is_lvalue_to_rvalue_ref<_From, _To, true>::__src_t> > > type;
      static constexpr const bool value = type::value;
  };
  template < typename _From, typename _To >
  struct  __is_lvalue_to_rvalue_ref<_From, _To, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp, typename _Arg >
  struct  __is_direct_constructible_ref_cast : ::std::__and_< ::std::__is_static_castable<_Arg, _Tp>, ::std::__not_< ::std::__or_< ::std::__is_base_to_derived_ref<_Arg, _Tp>, ::std::__is_lvalue_to_rvalue_ref<_Arg, _Tp> > > >::type
  {
  };
  template < typename _Tp, typename _Arg >
  struct  __is_direct_constructible_new : ::std::conditional<is_reference<_Tp>::value, ::std::__is_direct_constructible_ref_cast<_Tp, _Arg>, ::std::__is_direct_constructible_new_safe<_Tp, _Arg> >::type
  {
  };
  template < typename _Tp, typename _Arg >
  struct  __is_direct_constructible : ::std::integral_constant<bool, __is_direct_constructible_new<_Tp, _Arg>::value>
  {
  };
  struct  __do_is_nary_constructible_impl
  {
      template < typename _Tp, typename ..._Args, typename __type_tpl__param_1_2__ = decltype(_Tp(declval<_Args>() ...)) >
      static ::std::true_type __test(int);
      template < typename __type_tpl__param_1_0__, typename ...__type_tpl__param_1_1__ >
      static ::std::false_type __test(...);
  };
  template < typename _Tp, typename ..._Args >
  struct  __is_nary_constructible_impl : ::std::__do_is_nary_constructible_impl
  {
      typedef decltype(__test<_Tp, _Args ...>(0)) type;
  };
  template < typename _Tp, typename ..._Args >
  struct  __is_nary_constructible : ::std::__is_nary_constructible_impl<_Tp, _Args ...>::type
  {
      static_assert((sizeof...(_Args)) > 1, "Only useful for > 1 arguments");
  };
  template < typename _Tp, typename ..._Args >
  struct  __is_constructible_impl : ::std::__is_nary_constructible<_Tp, _Args ...>
  {
  };
  template < typename _Tp, typename _Arg >
  struct  __is_constructible_impl<_Tp, _Arg> : ::std::__is_direct_constructible<_Tp, _Arg>
  {
  };
  template < typename _Tp >
  struct  __is_constructible_impl<_Tp> : ::std::is_default_constructible<_Tp>
  {
  };
  template < typename _Tp, typename ..._Args >
  struct  is_constructible : ::std::integral_constant<bool, __is_constructible_impl<_Tp, _Args ...>::value>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = is_void<_Tp>::value >
  struct __is_copy_constructible_impl;
  template < typename _Tp >
  struct  __is_copy_constructible_impl<_Tp, true> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_copy_constructible_impl<_Tp, false> : ::std::is_constructible<_Tp, const _Tp &>
  {
  };
  template < typename _Tp >
  struct  is_copy_constructible : ::std::__is_copy_constructible_impl<_Tp>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = is_void<_Tp>::value >
  struct __is_move_constructible_impl;
  template < typename _Tp >
  struct  __is_move_constructible_impl<_Tp, true> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_move_constructible_impl<_Tp, false> : ::std::is_constructible<_Tp, _Tp &&>
  {
  };
  template < typename _Tp >
  struct  is_move_constructible : ::std::__is_move_constructible_impl<_Tp>
  {
  };
  template < typename _Tp >
  struct  __is_nt_default_constructible_atom : ::std::integral_constant<bool, noexcept(_Tp())>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = is_array<_Tp>::value >
  struct __is_nt_default_constructible_impl;
  template < typename _Tp >
  struct  __is_nt_default_constructible_impl<_Tp, true> : ::std::__and_< ::std::__is_array_known_bounds<_Tp>, ::std::__is_nt_default_constructible_atom<typename ::std::remove_all_extents<_Tp>::type> >::type
  {
  };
  template < typename _Tp >
  struct  __is_nt_default_constructible_impl<_Tp, false> : ::std::__is_nt_default_constructible_atom<_Tp>
  {
  };
  template < typename _Tp >
  struct  is_nothrow_default_constructible : ::std::__and_< ::std::is_default_constructible<_Tp>, ::std::__is_nt_default_constructible_impl<_Tp> >::type
  {
  };
  template < typename _Tp, typename ..._Args >
  struct  __is_nt_constructible_impl : ::std::integral_constant<bool, noexcept(_Tp(declval<_Args>() ...))>
  {
  };
  template < typename _Tp, typename _Arg >
  struct  __is_nt_constructible_impl<_Tp, _Arg> : ::std::integral_constant<bool, noexcept(static_cast<_Tp>(declval<_Arg>()))>
  {
  };
  template < typename _Tp >
  struct  __is_nt_constructible_impl<_Tp> : ::std::is_nothrow_default_constructible<_Tp>
  {
  };
  template < typename _Tp, typename ..._Args >
  struct  is_nothrow_constructible : ::std::__and_< ::std::is_constructible<_Tp, _Args ...>, ::std::__is_nt_constructible_impl<_Tp, _Args ...> >::type
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = is_void<_Tp>::value >
  struct __is_nothrow_copy_constructible_impl;
  template < typename _Tp >
  struct  __is_nothrow_copy_constructible_impl<_Tp, true> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_nothrow_copy_constructible_impl<_Tp, false> : ::std::is_nothrow_constructible<_Tp, const _Tp &>
  {
  };
  template < typename _Tp >
  struct  is_nothrow_copy_constructible : ::std::__is_nothrow_copy_constructible_impl<_Tp>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = is_void<_Tp>::value >
  struct __is_nothrow_move_constructible_impl;
  template < typename _Tp >
  struct  __is_nothrow_move_constructible_impl<_Tp, true> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_nothrow_move_constructible_impl<_Tp, false> : ::std::is_nothrow_constructible<_Tp, _Tp &&>
  {
  };
  template < typename _Tp >
  struct  is_nothrow_move_constructible : ::std::__is_nothrow_move_constructible_impl<_Tp>
  {
  };
  template < typename _Tp, typename _Up >
  class  __is_assignable_helper : public ::std::__sfinae_types
  {
      template < typename _Tp1, typename _Up1 >
      static decltype((declval<_Tp1>() = declval<_Up1>(), ::std::__sfinae_types::__one())) __test(int);
      template < typename __type_tpl__param_2_0__, typename __type_tpl__param_2_1__ >
      static ::std::__sfinae_types::__two __test(...);
    public:
      static constexpr const bool value = sizeof(__test<_Tp, _Up>(0)) == 1;
  };
  template < typename _Tp, typename _Up >
  struct  is_assignable : ::std::integral_constant<bool, __is_assignable_helper<_Tp, _Up>::value>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = is_void<_Tp>::value >
  struct __is_copy_assignable_impl;
  template < typename _Tp >
  struct  __is_copy_assignable_impl<_Tp, true> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_copy_assignable_impl<_Tp, false> : ::std::is_assignable<_Tp &, const _Tp &>
  {
  };
  template < typename _Tp >
  struct  is_copy_assignable : ::std::__is_copy_assignable_impl<_Tp>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = is_void<_Tp>::value >
  struct __is_move_assignable_impl;
  template < typename _Tp >
  struct  __is_move_assignable_impl<_Tp, true> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_move_assignable_impl<_Tp, false> : ::std::is_assignable<_Tp &, _Tp &&>
  {
  };
  template < typename _Tp >
  struct  is_move_assignable : ::std::__is_move_assignable_impl<_Tp>
  {
  };
  template < typename _Tp, typename _Up >
  struct  __is_nt_assignable_impl : ::std::integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
  {
  };
  template < typename _Tp, typename _Up >
  struct  is_nothrow_assignable : ::std::__and_< ::std::is_assignable<_Tp, _Up>, ::std::__is_nt_assignable_impl<_Tp, _Up> >::type
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = is_void<_Tp>::value >
  struct __is_nt_copy_assignable_impl;
  template < typename _Tp >
  struct  __is_nt_copy_assignable_impl<_Tp, true> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_nt_copy_assignable_impl<_Tp, false> : ::std::is_nothrow_assignable<_Tp &, const _Tp &>
  {
  };
  template < typename _Tp >
  struct  is_nothrow_copy_assignable : ::std::__is_nt_copy_assignable_impl<_Tp>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = is_void<_Tp>::value >
  struct __is_nt_move_assignable_impl;
  template < typename _Tp >
  struct  __is_nt_move_assignable_impl<_Tp, true> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_nt_move_assignable_impl<_Tp, false> : ::std::is_nothrow_assignable<_Tp &, _Tp &&>
  {
  };
  template < typename _Tp >
  struct  is_nothrow_move_assignable : ::std::__is_nt_move_assignable_impl<_Tp>
  {
  };
  template < typename _Tp >
  struct  is_trivially_destructible : ::std::__and_< ::std::is_destructible<_Tp>, ::std::integral_constant<bool, __has_trivial_destructor(_Tp)> >::type
  {
  };
  template < typename _Tp >
  struct  has_trivial_default_constructor : ::std::integral_constant<bool, __has_trivial_constructor(_Tp)>
  {
  };
  template < typename _Tp >
  struct  has_trivial_copy_constructor : ::std::integral_constant<bool, __has_trivial_copy(_Tp)>
  {
  };
  template < typename _Tp >
  struct  has_trivial_copy_assign : ::std::integral_constant<bool, __has_trivial_assign(_Tp)>
  {
  };
  template < typename _Tp >
  struct  has_virtual_destructor : ::std::integral_constant<bool, __has_virtual_destructor(_Tp)>
  {
  };
  template < typename _Tp >
  struct  alignment_of : ::std::integral_constant<unsigned long int, alignof(_Tp)>
  {
  };
 /* Instantiation of class template '::std::integral_constant<unsigned long int, 0>' */ 
  template < typename __type_tpl__param_1_0__ >
  struct  rank : ::std::integral_constant<unsigned long int, 0>
  {
  };
  template < typename _Tp, ::std::size_t _Size >
  struct  rank<_Tp [_Size]> : ::std::integral_constant<unsigned long int, 1 + rank<_Tp>::value>
  {
  };
  template < typename _Tp >
  struct  rank<_Tp []> : ::std::integral_constant<unsigned long int, 1 + rank<_Tp>::value>
  {
  };
  template < typename __type_tpl__param_1_0__, unsigned int _Uint >
  struct  extent : ::std::integral_constant<unsigned long int, 0>
  {
  };
  template < typename _Tp, unsigned int _Uint, ::std::size_t _Size >
  struct  extent<_Tp [_Size], _Uint> : ::std::integral_constant<unsigned long int, _Uint == 0 ? _Size : extent<_Tp, _Uint - 1>::value>
  {
  };
  template < typename _Tp, unsigned int _Uint >
  struct  extent<_Tp [], _Uint> : ::std::integral_constant<unsigned long int, _Uint == 0 ? 0 : extent<_Tp, _Uint - 1>::value>
  {
  };
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct  is_same : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  is_same<_Tp, _Tp> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Base, typename _Derived >
  struct  is_base_of : ::std::integral_constant<bool, __is_base_of(_Base, _Derived)>
  {
  };
  template < typename _From, typename _To, bool __nontype_tpl_param_1_2__ = __or_< ::std::is_void<_From>, ::std::is_function<_To>, ::std::is_array<_To> >::value >
  struct  __is_convertible_helper
  {
      static constexpr const bool value = is_void<_To>::value;
  };
  template < typename _From, typename _To >
  class  __is_convertible_helper<_From, _To, false> : public ::std::__sfinae_types
  {
      template < typename _To1 >
      static void __test_aux(_To1);
      template < typename _From1, typename _To1 >
      static decltype((__test_aux<_To1>(std::declval<_From1>()), ::std::__sfinae_types::__one())) __test(int);
      template < typename __type_tpl__param_2_0__, typename __type_tpl__param_2_1__ >
      static ::std::__sfinae_types::__two __test(...);
    public:
      static constexpr const bool value = sizeof(__test<_From, _To>(0)) == 1;
  };
  template < typename _From, typename _To >
  struct  is_convertible : ::std::integral_constant<bool, __is_convertible_helper<_From, _To>::value>
  {
  };
  template < typename _Tp >
  struct  remove_const
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_const<const _Tp>
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_volatile
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_volatile<volatile _Tp>
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_cv
  {
      typedef typename ::std::remove_const<typename ::std::remove_volatile<_Tp>::type>::type type;
  };
  template < typename _Tp >
  struct  add_const
  {
      typedef const _Tp type;
  };
  template < typename _Tp >
  struct  add_volatile
  {
      typedef volatile _Tp type;
  };
  template < typename _Tp >
  struct  add_cv
  {
      typedef typename ::std::add_const<typename ::std::add_volatile<_Tp>::type>::type type;
  };
  template < typename _Tp >
  struct  remove_reference
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_reference<_Tp &>
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_reference<_Tp &&>
  {
      typedef _Tp type;
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __and_< ::std::__not_< ::std::is_reference<_Tp> >, ::std::__not_< ::std::is_void<_Tp> > >::value, bool __nontype_tpl_param_1_2__ = is_rvalue_reference<_Tp>::value >
  struct  __add_lvalue_reference_helper
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  __add_lvalue_reference_helper<_Tp, true, false>
  {
      typedef _Tp &type;
  };
  template < typename _Tp >
  struct  __add_lvalue_reference_helper<_Tp, false, true>
  {
      typedef typename ::std::remove_reference<_Tp>::type &type;
  };
  template < typename _Tp >
  struct  add_lvalue_reference : ::std::__add_lvalue_reference_helper<_Tp>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __and_< ::std::__not_< ::std::is_reference<_Tp> >, ::std::__not_< ::std::is_void<_Tp> > >::value >
  struct  __add_rvalue_reference_helper
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  __add_rvalue_reference_helper<_Tp, true>
  {
      typedef _Tp &&type;
  };
  template < typename _Tp >
  struct  add_rvalue_reference : ::std::__add_rvalue_reference_helper<_Tp>
  {
  };
  template < typename _Unqualified, bool _IsConst, bool _IsVol >
  struct __cv_selector;
  template < typename _Unqualified >
  struct  __cv_selector<_Unqualified, false, false>
  {
      typedef _Unqualified __type;
  };
  template < typename _Unqualified >
  struct  __cv_selector<_Unqualified, false, true>
  {
      typedef volatile _Unqualified __type;
  };
  template < typename _Unqualified >
  struct  __cv_selector<_Unqualified, true, false>
  {
      typedef const _Unqualified __type;
  };
  template < typename _Unqualified >
  struct  __cv_selector<_Unqualified, true, true>
  {
      typedef const volatile _Unqualified __type;
  };
  template < typename _Qualified, typename _Unqualified, bool _IsConst = is_const<_Qualified>::value, bool _IsVol = is_volatile<_Qualified>::value >
  class  __match_cv_qualifiers
  {
      typedef ::std::__cv_selector<_Unqualified, _IsConst, _IsVol> __match;
    public:
      typedef typename ::std::__cv_selector<_Unqualified, _IsConst, _IsVol>::__type __type;
  };
  template < typename _Tp >
  struct  __make_unsigned
  {
      typedef _Tp __type;
  };
  template <>
  struct  __make_unsigned<char>
  {
      typedef unsigned char __type;
  };
  template <>
  struct  __make_unsigned<signed char>
  {
      typedef unsigned char __type;
  };
  template <>
  struct  __make_unsigned<short int>
  {
      typedef unsigned short int __type;
  };
  template <>
  struct  __make_unsigned<int>
  {
      typedef unsigned int __type;
  };
  template <>
  struct  __make_unsigned<long int>
  {
      typedef unsigned long int __type;
  };
  template <>
  struct  __make_unsigned<long long int>
  {
      typedef unsigned long long int __type;
  };
  template < typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value >
  class __make_unsigned_selector;
  template < typename _Tp >
  class  __make_unsigned_selector<_Tp, true, false>
  {
      typedef ::std::__make_unsigned<typename ::std::remove_cv<_Tp>::type> __unsignedt;
      typedef typename ::std::__make_unsigned<typename ::std::remove_cv<_Tp>::type>::__type __unsigned_type;
      typedef ::std::__match_cv_qualifiers<_Tp, typename ::std::__make_unsigned_selector<_Tp, true, false>::__unsigned_type> __cv_unsigned;
    public:
      typedef typename ::std::__match_cv_qualifiers<_Tp, typename ::std::__make_unsigned_selector<_Tp, true, false>::__unsigned_type>::__type __type;
  };
  template < typename _Tp >
  class  __make_unsigned_selector<_Tp, false, true>
  {
      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(typename ::std::__make_unsigned_selector<_Tp, false, true>::__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short int);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      typedef ::std::conditional< ::std::__make_unsigned_selector<_Tp, false, true>::__b2, unsigned int, unsigned long int> __cond2;
      typedef typename ::std::conditional< ::std::__make_unsigned_selector<_Tp, false, true>::__b2, unsigned int, unsigned long int>::type __cond2_type;
      typedef ::std::conditional< ::std::__make_unsigned_selector<_Tp, false, true>::__b1, unsigned short int, typename ::std::__make_unsigned_selector<_Tp, false, true>::__cond2_type> __cond1;
      typedef typename ::std::conditional< ::std::__make_unsigned_selector<_Tp, false, true>::__b1, unsigned short int, typename ::std::__make_unsigned_selector<_Tp, false, true>::__cond2_type>::type __cond1_type;
    public:
      typedef typename ::std::conditional< ::std::__make_unsigned_selector<_Tp, false, true>::__b0, unsigned char, typename ::std::__make_unsigned_selector<_Tp, false, true>::__cond1_type>::type __type;
  };
  template < typename _Tp >
  struct  make_unsigned
  {
      typedef typename ::std::__make_unsigned_selector<_Tp>::__type type;
  };
  template <>
  struct make_unsigned<bool>;
  template < typename _Tp >
  struct  __make_signed
  {
      typedef _Tp __type;
  };
  template <>
  struct  __make_signed<char>
  {
      typedef signed char __type;
  };
  template <>
  struct  __make_signed<unsigned char>
  {
      typedef signed char __type;
  };
  template <>
  struct  __make_signed<unsigned short int>
  {
      typedef short int __type;
  };
  template <>
  struct  __make_signed<unsigned int>
  {
      typedef int __type;
  };
  template <>
  struct  __make_signed<unsigned long int>
  {
      typedef long int __type;
  };
  template <>
  struct  __make_signed<unsigned long long int>
  {
      typedef long long int __type;
  };
  template < typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value >
  class __make_signed_selector;
  template < typename _Tp >
  class  __make_signed_selector<_Tp, true, false>
  {
      typedef ::std::__make_signed<typename ::std::remove_cv<_Tp>::type> __signedt;
      typedef typename ::std::__make_signed<typename ::std::remove_cv<_Tp>::type>::__type __signed_type;
      typedef ::std::__match_cv_qualifiers<_Tp, typename ::std::__make_signed_selector<_Tp, true, false>::__signed_type> __cv_signed;
    public:
      typedef typename ::std::__match_cv_qualifiers<_Tp, typename ::std::__make_signed_selector<_Tp, true, false>::__signed_type>::__type __type;
  };
  template < typename _Tp >
  class  __make_signed_selector<_Tp, false, true>
  {
      typedef signed char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(typename ::std::__make_signed_selector<_Tp, false, true>::__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(short int);
      static const bool __b2 = sizeof(_Tp) <= sizeof(int);
      typedef ::std::conditional< ::std::__make_signed_selector<_Tp, false, true>::__b2, int, long int> __cond2;
      typedef typename ::std::conditional< ::std::__make_signed_selector<_Tp, false, true>::__b2, int, long int>::type __cond2_type;
      typedef ::std::conditional< ::std::__make_signed_selector<_Tp, false, true>::__b1, short int, typename ::std::__make_signed_selector<_Tp, false, true>::__cond2_type> __cond1;
      typedef typename ::std::conditional< ::std::__make_signed_selector<_Tp, false, true>::__b1, short int, typename ::std::__make_signed_selector<_Tp, false, true>::__cond2_type>::type __cond1_type;
    public:
      typedef typename ::std::conditional< ::std::__make_signed_selector<_Tp, false, true>::__b0, signed char, typename ::std::__make_signed_selector<_Tp, false, true>::__cond1_type>::type __type;
  };
  template < typename _Tp >
  struct  make_signed
  {
      typedef typename ::std::__make_signed_selector<_Tp>::__type type;
  };
  template <>
  struct make_signed<bool>;
  template < typename _Tp >
  struct  remove_extent
  {
      typedef _Tp type;
  };
  template < typename _Tp, ::std::size_t _Size >
  struct  remove_extent<_Tp [_Size]>
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_extent<_Tp []>
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_all_extents
  {
      typedef _Tp type;
  };
  template < typename _Tp, ::std::size_t _Size >
  struct  remove_all_extents<_Tp [_Size]>
  {
      typedef typename ::std::remove_all_extents<_Tp>::type type;
  };
  template < typename _Tp >
  struct  remove_all_extents<_Tp []>
  {
      typedef typename ::std::remove_all_extents<_Tp>::type type;
  };
  template < typename _Tp, typename __type_tpl__param_1_1__ >
  struct  __remove_pointer_helper
  {
      typedef _Tp type;
  };
  template < typename _Tp, typename _Up >
  struct  __remove_pointer_helper<_Tp, _Up *>
  {
      typedef _Up type;
  };
  template < typename _Tp >
  struct  remove_pointer : ::std::__remove_pointer_helper<_Tp, typename ::std::remove_cv<_Tp>::type>
  {
  };
  template < typename _Tp >
  struct  add_pointer
  {
      typedef typename ::std::remove_reference<_Tp>::type *type;
  };
  template < ::std::size_t _Len >
  struct  __aligned_storage_msa
  {
      union  __type
      {
          unsigned char __data[_Len];
          struct __attribute__((__aligned__))  mcc_struct_anon_24
          {
          };
          typename ::std::__aligned_storage_msa<_Len>::__type::mcc_struct_anon_24 __align;
      };
  };
  template < ::std::size_t _Len, ::std::size_t _Align = alignof(typename ::std::__aligned_storage_msa<_Len>::__type) >
  struct  aligned_storage
  {
      union  type
      {
          unsigned char __data[_Len];
          struct __attribute__((aligned(/* ??? */_Align)))  mcc_struct_anon_25
          {
          };
          typename ::std::aligned_storage<_Len, _Align>::type::mcc_struct_anon_25 __align;
      };
  };
  template < typename _Up, bool _IsArray = is_array<_Up>::value, bool _IsFunction = is_function<_Up>::value >
  struct __decay_selector;
  template < typename _Up >
  struct  __decay_selector<_Up, false, false>
  {
      typedef typename ::std::remove_cv<_Up>::type __type;
  };
  template < typename _Up >
  struct  __decay_selector<_Up, true, false>
  {
      typedef typename ::std::remove_extent<_Up>::type *__type;
  };
  template < typename _Up >
  struct  __decay_selector<_Up, false, true>
  {
      typedef typename ::std::add_pointer<_Up>::type __type;
  };
  template < typename _Tp >
  class  decay
  {
      typedef typename ::std::remove_reference<_Tp>::type __remove_type;
    public:
      typedef typename ::std::__decay_selector<typename ::std::decay<_Tp>::__remove_type>::__type type;
  };
  template < typename _Tp >
  class reference_wrapper;
  template < typename _Tp >
  struct  __strip_reference_wrapper
  {
      typedef _Tp __type;
  };
  template < typename _Tp >
  struct  __strip_reference_wrapper< ::std::reference_wrapper<_Tp> >
  {
      typedef _Tp &__type;
  };
  template < typename _Tp >
  struct  __strip_reference_wrapper<const ::std::reference_wrapper<_Tp> >
  {
      typedef _Tp &__type;
  };
  template < typename _Tp >
  struct  __decay_and_strip
  {
      typedef typename ::std::__strip_reference_wrapper<typename ::std::decay<_Tp>::type>::__type __type;
  };
  template < bool __nontype_tpl_param_1_0__, typename _Tp = void >
  struct  enable_if
  {
  };
  template < typename _Tp >
  struct  enable_if<true, _Tp>
  {
      typedef _Tp type;
  };
  template < typename ..._Cond >
  using _Require = typename ::std::enable_if<__and_<_Cond ...>::value>::type;
  template < bool _Cond, typename _Iftrue, typename _Iffalse >
  struct  conditional
  {
      typedef _Iftrue type;
  };
  template < typename _Iftrue, typename _Iffalse >
  struct  conditional<false, _Iftrue, _Iffalse>
  {
      typedef _Iffalse type;
  };
  template < typename ..._Tp >
  struct common_type;
  struct  __do_common_type_impl
  {
      template < typename _Tp, typename _Up >
      static ::std::__success_type<typename ::std::decay<decltype(true ? std::declval<_Tp>() : std::declval<_Up>())>::type> _S_test(int);
      template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
      static ::std::__failure_type _S_test(...);
  };
  template < typename _Tp, typename _Up >
  struct  __common_type_impl : private ::std::__do_common_type_impl
  {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
  };
  struct  __do_member_type_wrapper
  {
      template < typename _Tp >
      static ::std::__success_type<typename _Tp::type> _S_test(int);
      template < typename __type_tpl__param_1_0__ >
      static ::std::__failure_type _S_test(...);
  };
  template < typename _Tp >
  struct  __member_type_wrapper : private ::std::__do_member_type_wrapper
  {
      typedef decltype(_S_test<_Tp>(0)) type;
  };
  template < typename _CTp, typename ..._Args >
  struct  __expanded_common_type_wrapper
  {
      typedef ::std::common_type<typename _CTp::type, _Args ...> type;
  };
  template < typename ..._Args >
  struct  __expanded_common_type_wrapper< ::std::__failure_type, _Args ...>
  {
      typedef ::std::__failure_type type;
  };
  template < typename _Tp >
  struct  common_type<_Tp>
  {
      typedef typename ::std::decay<_Tp>::type type;
  };
  template < typename _Tp, typename _Up >
  struct  common_type<_Tp, _Up> : ::std::__common_type_impl<_Tp, _Up>::type
  {
  };
  template < typename _Tp, typename _Up, typename ..._Vp >
  struct  common_type<_Tp, _Up, _Vp ...> : ::std::__expanded_common_type_wrapper<typename ::std::__member_type_wrapper< ::std::common_type<_Tp, _Up> >::type, _Vp ...>::type
  {
  };
  template < typename _Tp >
  struct  underlying_type
  {
      typedef __underlying_type(_Tp) type;
  };
  template < typename _Tp >
  struct  __declval_protector
  {
      static const bool __stop = false;
      static typename ::std::add_rvalue_reference<_Tp>::type __delegate();
  };
  template < typename _Tp >
  inline typename ::std::add_rvalue_reference<_Tp>::type declval() noexcept(true)
  {
    static_assert(__declval_protector<_Tp>::__stop, "declval() must not be used!");
    return __declval_protector<_Tp>::__delegate();
  }
  template < typename _Signature >
  class result_of;
  struct  __result_of_memfun_ref_impl
  {
      template < typename _Fp, typename _Tp1, typename ..._Args >
      static ::std::__success_type<decltype((std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>() ...))> _S_test(int);
      template < typename ...__type_tpl__param_1_0__ >
      static ::std::__failure_type _S_test(...);
  };
  template < typename _MemPtr, typename _Arg, typename ..._Args >
  struct  __result_of_memfun_ref : private ::std::__result_of_memfun_ref_impl
  {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args ...>(0)) type;
  };
  struct  __result_of_memfun_deref_impl
  {
      template < typename _Fp, typename _Tp1, typename ..._Args >
      static ::std::__success_type<decltype((*std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>() ...))> _S_test(int);
      template < typename ...__type_tpl__param_1_0__ >
      static ::std::__failure_type _S_test(...);
  };
  template < typename _MemPtr, typename _Arg, typename ..._Args >
  struct  __result_of_memfun_deref : private ::std::__result_of_memfun_deref_impl
  {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args ...>(0)) type;
  };
  struct  __result_of_memobj_ref_impl
  {
      template < typename _Fp, typename _Tp1 >
      static ::std::__success_type<decltype(std::declval<_Tp1>().*std::declval<_Fp>())> _S_test(int);
      template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
      static ::std::__failure_type _S_test(...);
  };
  template < typename _MemPtr, typename _Arg >
  struct  __result_of_memobj_ref : private ::std::__result_of_memobj_ref_impl
  {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
  };
  struct  __result_of_memobj_deref_impl
  {
      template < typename _Fp, typename _Tp1 >
      static ::std::__success_type<decltype(*std::declval<_Tp1>().*std::declval<_Fp>())> _S_test(int);
      template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
      static ::std::__failure_type _S_test(...);
  };
  template < typename _MemPtr, typename _Arg >
  struct  __result_of_memobj_deref : private ::std::__result_of_memobj_deref_impl
  {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
  };
  template < typename _MemPtr, typename _Arg >
  struct __result_of_memobj;
  template < typename _Res, typename _Class, typename _Arg >
  struct  __result_of_memobj<_Res _Class::*, _Arg>
  {
      typedef typename ::std::remove_cv<typename ::std::remove_reference<_Arg>::type>::type _Argval;
      typedef _Res _Class::*_MemPtr;
      typedef typename ::std::conditional<__or_< ::std::is_same<typename ::std::__result_of_memobj<_Res _Class::*, _Arg>::_Argval, _Class>, ::std::is_base_of<_Class, typename ::std::__result_of_memobj<_Res _Class::*, _Arg>::_Argval> >::value, ::std::__result_of_memobj_ref<typename ::std::__result_of_memobj<_Res _Class::*, _Arg>::_MemPtr, _Arg>, ::std::__result_of_memobj_deref<typename ::std::__result_of_memobj<_Res _Class::*, _Arg>::_MemPtr, _Arg> >::type::type type;
  };
  template < typename _MemPtr, typename _Arg, typename ..._Args >
  struct __result_of_memfun;
  template < typename _Res, typename _Class, typename _Arg, typename ..._Args >
  struct  __result_of_memfun<_Res _Class::*, _Arg, _Args ...>
  {
      typedef typename ::std::remove_cv<typename ::std::remove_reference<_Arg>::type>::type _Argval;
      typedef _Res _Class::*_MemPtr;
      typedef typename ::std::conditional<__or_< ::std::is_same<typename ::std::__result_of_memfun<_Res _Class::*, _Arg, _Args ...>::_Argval, _Class>, ::std::is_base_of<_Class, typename ::std::__result_of_memfun<_Res _Class::*, _Arg, _Args ...>::_Argval> >::value, ::std::__result_of_memfun_ref<typename ::std::__result_of_memfun<_Res _Class::*, _Arg, _Args ...>::_MemPtr, _Arg, _Args ...>, ::std::__result_of_memfun_deref<typename ::std::__result_of_memfun<_Res _Class::*, _Arg, _Args ...>::_MemPtr, _Arg, _Args ...> >::type::type type;
  };
  template < bool __nontype_tpl_param_1_0__, bool __nontype_tpl_param_1_1__, typename _Functor, typename ..._ArgTypes >
  struct  __result_of_impl
  {
      typedef ::std::__failure_type type;
  };
  template < typename _MemPtr, typename _Arg >
  struct  __result_of_impl<true, false, _MemPtr, _Arg> : ::std::__result_of_memobj<typename ::std::decay<_MemPtr>::type, _Arg>
  {
  };
  template < typename _MemPtr, typename _Arg, typename ..._Args >
  struct  __result_of_impl<false, true, _MemPtr, _Arg, _Args ...> : ::std::__result_of_memfun<typename ::std::decay<_MemPtr>::type, _Arg, _Args ...>
  {
  };
  struct  __result_of_other_impl
  {
      template < typename _Fn, typename ..._Args >
      static ::std::__success_type<decltype(std::declval<_Fn>()(std::declval<_Args>() ...))> _S_test(int);
      template < typename ...__type_tpl__param_1_0__ >
      static ::std::__failure_type _S_test(...);
  };
  template < typename _Functor, typename ..._ArgTypes >
  struct  __result_of_impl<false, false, _Functor, _ArgTypes ...> : private ::std::__result_of_other_impl
  {
      typedef decltype(_S_test<_Functor, _ArgTypes ...>(0)) type;
  };
  template < typename _Functor, typename ..._ArgTypes >
  struct  result_of<_Functor (_ArgTypes ...)> : ::std::__result_of_impl<is_member_object_pointer<typename ::std::remove_reference<_Functor>::type>::value, is_member_function_pointer<typename ::std::remove_reference<_Functor>::type>::value, _Functor, _ArgTypes ...>::type
  {
  };
  template < typename _Tp >
  inline constexpr _Tp &&forward(typename ::std::remove_reference<_Tp>::type &__t) noexcept(true);
  template < typename _Tp >
  inline constexpr _Tp &&forward(typename ::std::remove_reference<_Tp>::type &__t) noexcept(true)
  {
    return static_cast<_Tp &&>(__t);
  }
  template < typename _Tp >
  inline constexpr _Tp &&forward(typename ::std::remove_reference<_Tp>::type &&__t) noexcept(true);
  template < typename _Tp >
  inline constexpr _Tp &&forward(typename ::std::remove_reference<_Tp>::type &&__t) noexcept(true)
  {
    static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument substituting _Tp is an lvalue reference type");
    return static_cast<_Tp &&>(__t);
  }
  template < typename _Tp >
  inline constexpr typename ::std::remove_reference<_Tp>::type &&move(_Tp &&__t) noexcept(true);
  template < typename _Tp >
  inline constexpr typename ::std::remove_reference<_Tp>::type &&move(_Tp &&__t) noexcept(true)
  {
    return static_cast<typename ::std::remove_reference<_Tp>::type &&>(__t);
  }
  template < typename _Tp >
  struct  __move_if_noexcept_cond : ::std::__and_< ::std::__not_< ::std::is_nothrow_move_constructible<_Tp> >, ::std::is_copy_constructible<_Tp> >::type
  {
  };
  template < typename _Tp >
  inline constexpr typename ::std::conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp &, _Tp &&>::type move_if_noexcept(_Tp &__x) noexcept(true);
  template < typename _Tp >
  inline constexpr typename ::std::conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp &, _Tp &&>::type move_if_noexcept(_Tp &__x) noexcept(true)
  {
    return std::move(__x);
  }
  template < typename _Tp >
  inline _Tp *addressof(_Tp &__r) noexcept(true);
  template < typename _Tp >
  inline _Tp *addressof(_Tp &__r) noexcept(true)
  {
    return std::__addressof(__r);
  }
  template < typename _Tp >
  inline void swap(_Tp &__a, _Tp &__b) noexcept(__and_< ::std::is_nothrow_move_constructible<_Tp>, ::std::is_nothrow_move_assignable<_Tp> >::value);
  template < typename _Tp >
  inline void swap(_Tp &__a, _Tp &__b) noexcept(__and_< ::std::is_nothrow_move_constructible<_Tp>, ::std::is_nothrow_move_assignable<_Tp> >::value)
  {
    _Tp __tmp = std::move(__a);
    __a = std::move(__b);
    __b = std::move(__tmp);
  }
  template < typename _Tp, ::std::size_t _Nm >
  inline void swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(noexcept(swap(*__a, *__b)));
  template < typename _Tp, ::std::size_t _Nm >
  inline void swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(noexcept(swap(*__a, *__b)))
  {
    for (::std::size_t __n(0); __n < _Nm;  ++__n)
      {
        swap(__a[__n], __b[__n]);
      }
  }
  struct  piecewise_construct_t
  {
  };
  constexpr const ::std::piecewise_construct_t piecewise_construct((::std::piecewise_construct_t()));
  template < typename ...__type_tpl__param_1_0__ >
  class tuple;
  template < ::std::size_t ... __nontype_tpl_param_1_0__ >
  struct _Index_tuple;
  template < typename _T1, typename _T2 >
  struct  pair
  {
      typedef _T1 first_type;
      typedef _T2 second_type;
      _T1 first;
      _T2 second;
      inline constexpr pair()
        : first(), second()
      {
      }
      inline constexpr pair(const _T1 &__a, const _T2 &__b)
        : first(__a), second(__b)
      {
      }
      template < typename _U1, typename _U2, typename __type_tpl__param_2_2__ = typename ::std::enable_if<__and_< ::std::is_convertible<const _U1 &, _T1>, ::std::is_convertible<const _U2 &, _T2> >::value>::type >
      inline constexpr pair(const ::std::pair<_U1, _U2> &__p)
        : first(__p.first), second(__p.second)
      {
      }
      inline constexpr pair(const ::std::pair<_T1, _T2> &) = default ;
      inline constexpr pair(::std::pair<_T1, _T2> &&) = default ;
      template < typename _U1, typename __type_tpl__param_2_1__ = typename ::std::enable_if<is_convertible<_U1, _T1>::value>::type >
      inline constexpr pair(_U1 &&__x, const _T2 &__y)
        : first(std::forward<_U1>(__x)), second(__y)
      {
      }
      template < typename _U2, typename __type_tpl__param_2_1__ = typename ::std::enable_if<is_convertible<_U2, _T2>::value>::type >
      inline constexpr pair(const _T1 &__x, _U2 &&__y)
        : first(__x), second(std::forward<_U2>(__y))
      {
      }
      template < typename _U1, typename _U2, typename __type_tpl__param_2_2__ = typename ::std::enable_if<__and_< ::std::is_convertible<_U1, _T1>, ::std::is_convertible<_U2, _T2> >::value>::type >
      inline constexpr pair(_U1 &&__x, _U2 &&__y)
        : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))
      {
      }
      template < typename _U1, typename _U2, typename __type_tpl__param_2_2__ = typename ::std::enable_if<__and_< ::std::is_convertible<_U1, _T1>, ::std::is_convertible<_U2, _T2> >::value>::type >
      inline constexpr pair(::std::pair<_U1, _U2> &&__p)
        : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second))
      {
      }
      template < typename ..._Args1, typename ..._Args2 >
      inline pair(::std::piecewise_construct_t, ::std::tuple<_Args1 ...> __first, ::std::tuple<_Args2 ...> __second);
      inline ::std::pair<_T1, _T2> &operator =(const ::std::pair<_T1, _T2> &__p)
      {
        ::std::pair<_T1, _T2>::first = __p.first;
        ::std::pair<_T1, _T2>::second = __p.second;
        return *this;
      }
      inline ::std::pair<_T1, _T2> &operator =(::std::pair<_T1, _T2> &&__p) noexcept(__and_< ::std::is_nothrow_move_assignable<_T1>, ::std::is_nothrow_move_assignable<_T2> >::value)
      {
        ::std::pair<_T1, _T2>::first = std::forward<typename ::std::pair<_T1, _T2>::first_type>(__p.first);
        ::std::pair<_T1, _T2>::second = std::forward<typename ::std::pair<_T1, _T2>::second_type>(__p.second);
        return *this;
      }
      template < typename _U1, typename _U2 >
      inline ::std::pair<_T1, _T2> &operator =(const ::std::pair<_U1, _U2> &__p)
      {
        ::std::pair<_T1, _T2>::first = __p.first;
        ::std::pair<_T1, _T2>::second = __p.second;
        return *this;
      }
      template < typename _U1, typename _U2 >
      inline ::std::pair<_T1, _T2> &operator =(::std::pair<_U1, _U2> &&__p)
      {
        ::std::pair<_T1, _T2>::first = std::forward<_U1>(__p.first);
        ::std::pair<_T1, _T2>::second = std::forward<_U2>(__p.second);
        return *this;
      }
      inline void swap(::std::pair<_T1, _T2> &__p) noexcept((noexcept(swap(::std::pair<_T1, _T2>::first, __p.first))) && (noexcept(swap(::std::pair<_T1, _T2>::second, __p.second))))
      {
        using ::std::swap;
        swap(::std::pair<_T1, _T2>::first, __p.first);
        swap(::std::pair<_T1, _T2>::second, __p.second);
      }
    private:
      template < typename ..._Args1, ::std::size_t ... _Indexes1, typename ..._Args2, ::std::size_t ... _Indexes2 >
      inline pair(::std::tuple<_Args1 ...> &__tuple1, ::std::tuple<_Args2 ...> &__tuple2, ::std::_Index_tuple<_Indexes1 ...>, ::std::_Index_tuple<_Indexes2 ...>);
  };
  template < typename _T1, typename _T2 >
  inline constexpr bool operator ==(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline constexpr bool operator ==(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return __x.first == __y.first && __x.second == __y.second;
  }
  template < typename _T1, typename _T2 >
  inline constexpr bool operator <(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline constexpr bool operator <(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
  }
  template < typename _T1, typename _T2 >
  inline constexpr bool operator !=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline constexpr bool operator !=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return !(__x == __y);
  }
  template < typename _T1, typename _T2 >
  inline constexpr bool operator >(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline constexpr bool operator >(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return __y < __x;
  }
  template < typename _T1, typename _T2 >
  inline constexpr bool operator <=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline constexpr bool operator <=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return !(__y < __x);
  }
  template < typename _T1, typename _T2 >
  inline constexpr bool operator >=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline constexpr bool operator >=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return !(__x < __y);
  }
  template < typename _T1, typename _T2 >
  inline void swap(::std::pair<_T1, _T2> &__x, ::std::pair<_T1, _T2> &__y) noexcept(noexcept(__x.swap(__y)));
  template < typename _T1, typename _T2 >
  inline void swap(::std::pair<_T1, _T2> &__x, ::std::pair<_T1, _T2> &__y) noexcept(noexcept(__x.swap(__y)))
  {
    __x.swap(__y);
  }
  template < typename _T1, typename _T2 >
  inline constexpr ::std::pair<typename ::std::__decay_and_strip<_T1>::__type, typename ::std::__decay_and_strip<_T2>::__type> make_pair(_T1 &&__x, _T2 &&__y);
  template < typename _T1, typename _T2 >
  inline constexpr ::std::pair<typename ::std::__decay_and_strip<_T1>::__type, typename ::std::__decay_and_strip<_T2>::__type> make_pair(_T1 &&__x, _T2 &&__y)
  {
    typedef typename ::std::__decay_and_strip<_T1>::__type __ds_type1;
    typedef typename ::std::__decay_and_strip<_T2>::__type __ds_type2;
    typedef ::std::pair<__ds_type1, __ds_type2> __pair_type;
    return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
  }
  struct  input_iterator_tag
  {
  };
  struct  output_iterator_tag
  {
  };
  struct  forward_iterator_tag : ::std::input_iterator_tag
  {
  };
  struct  bidirectional_iterator_tag : ::std::forward_iterator_tag
  {
  };
  struct  random_access_iterator_tag : ::std::bidirectional_iterator_tag
  {
  };
  template < typename _Category, typename _Tp, typename _Distance = ::std::ptrdiff_t, typename _Pointer = _Tp *, typename _Reference = _Tp & >
  struct  iterator
  {
      typedef _Category iterator_category;
      typedef _Tp value_type;
      typedef _Distance difference_type;
      typedef _Pointer pointer;
      typedef _Reference reference;
  };
  template < typename _Tp >
  class  __has_iterator_category_helper : ::std::__sfinae_types
  {
      template < typename _Up >
      struct  _Wrap_type
      {
      };
      template < typename _Up >
      static ::std::__sfinae_types::__one __test(typename ::std::__has_iterator_category_helper<_Tp>::template _Wrap_type<typename _Up::iterator_category> *);
      template < typename _Up >
      static ::std::__sfinae_types::__two __test(...);
    public:
      static constexpr const bool value = sizeof(__test<_Tp>(0)) == 1;
  };
  template < typename _Tp >
  struct  __has_iterator_category : ::std::integral_constant<bool, __has_iterator_category_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename _Iterator, bool __nontype_tpl_param_1_1__ = __has_iterator_category<_Iterator>::value >
  struct  __iterator_traits
  {
  };
  template < typename _Iterator >
  struct  __iterator_traits<_Iterator, true>
  {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
  };
  template < typename _Iterator >
  struct  iterator_traits : ::std::__iterator_traits<_Iterator>
  {
  };
  template < typename _Tp >
  struct  iterator_traits<_Tp *>
  {
      typedef ::std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Tp *pointer;
      typedef _Tp &reference;
  };
  template < typename _Tp >
  struct  iterator_traits<const _Tp *>
  {
      typedef ::std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef const _Tp *pointer;
      typedef const _Tp &reference;
  };
  template < typename _Iter >
  inline typename ::std::iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &);
  template < typename _Iter >
  inline typename ::std::iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &)
  {
    return typename ::std::iterator_traits<_Iter>::iterator_category();
  }
  template < typename _Iterator, bool _HasBase >
  struct  _Iter_base
  {
      typedef _Iterator iterator_type;
      static inline typename ::std::_Iter_base<_Iterator, _HasBase>::iterator_type _S_base(_Iterator __it)
      {
        return __it;
      }
  };
  template < typename _Iterator >
  struct  _Iter_base<_Iterator, true>
  {
      typedef typename _Iterator::iterator_type iterator_type;
      static inline typename ::std::_Iter_base<_Iterator, true>::iterator_type _S_base(_Iterator __it)
      {
        return __it.base();
      }
  };
  template < typename _InIter >
  using _RequireInputIter = typename ::std::enable_if<is_convertible<typename ::std::iterator_traits<_InIter>::iterator_category, ::std::input_iterator_tag>::value>::type;
  namespace __debug { }
}
namespace __gnu_debug {
  using namespace ::std::__debug;
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag);
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
  {
    typename ::std::iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last)
      {
         ++__first;
         ++__n;
      }
    return __n;
  }
  template < typename _RandomAccessIterator >
  inline typename ::std::iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator >
  inline typename ::std::iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, ::std::random_access_iterator_tag)
  {
    return __last - __first;
  }
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last);
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last)
  {
    return std::__distance(__first, __last, std::__iterator_category(__first));
  }
  template < typename _InputIterator, typename _Distance >
  inline void __advance(_InputIterator &__i, _Distance __n, ::std::input_iterator_tag);
  template < typename _InputIterator, typename _Distance >
  inline void __advance(_InputIterator &__i, _Distance __n, ::std::input_iterator_tag)
  {
    ;
    while (__n--)
      {
         ++__i;
      }
  }
  template < typename _BidirectionalIterator, typename _Distance >
  inline void __advance(_BidirectionalIterator &__i, _Distance __n, ::std::bidirectional_iterator_tag);
  template < typename _BidirectionalIterator, typename _Distance >
  inline void __advance(_BidirectionalIterator &__i, _Distance __n, ::std::bidirectional_iterator_tag)
  {
    if (__n > 0)
      {
        while (__n--)
          {
             ++__i;
          }
      }
    else
      {
        while (__n++)
          {
             --__i;
          }
      }
  }
  template < typename _RandomAccessIterator, typename _Distance >
  inline void __advance(_RandomAccessIterator &__i, _Distance __n, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator, typename _Distance >
  inline void __advance(_RandomAccessIterator &__i, _Distance __n, ::std::random_access_iterator_tag)
  {
    __i += __n;
  }
  template < typename _InputIterator, typename _Distance >
  inline void advance(_InputIterator &__i, _Distance __n);
  template < typename _InputIterator, typename _Distance >
  inline void advance(_InputIterator &__i, _Distance __n)
  {
    typename ::std::iterator_traits<_InputIterator>::difference_type __d = __n;
    std::__advance(__i, __d, std::__iterator_category(__i));
  }
  template < typename _ForwardIterator >
  inline _ForwardIterator next(_ForwardIterator __x, typename ::std::iterator_traits<_ForwardIterator>::difference_type __n  = (1));
  template < typename _ForwardIterator >
  inline _ForwardIterator next(_ForwardIterator __x, typename ::std::iterator_traits<_ForwardIterator>::difference_type __n)
  {
    std::advance(__x, __n);
    return __x;
  }
  template < typename _BidirectionalIterator >
  inline _BidirectionalIterator prev(_BidirectionalIterator __x, typename ::std::iterator_traits<_BidirectionalIterator>::difference_type __n  = (1));
  template < typename _BidirectionalIterator >
  inline _BidirectionalIterator prev(_BidirectionalIterator __x, typename ::std::iterator_traits<_BidirectionalIterator>::difference_type __n)
  {
    std::advance(__x,  -__n);
    return __x;
  }
  template < typename _Iterator >
  class  reverse_iterator : public ::std::iterator<typename ::std::iterator_traits<_Iterator>::iterator_category, typename ::std::iterator_traits<_Iterator>::value_type, typename ::std::iterator_traits<_Iterator>::difference_type, typename ::std::iterator_traits<_Iterator>::pointer, typename ::std::iterator_traits<_Iterator>::reference>
  {
    protected:
      _Iterator current;
      typedef ::std::iterator_traits<_Iterator> __traits_type;
    public:
      typedef _Iterator iterator_type;
      typedef typename ::std::iterator_traits<_Iterator>::difference_type difference_type;
      typedef typename ::std::iterator_traits<_Iterator>::pointer pointer;
      typedef typename ::std::iterator_traits<_Iterator>::reference reference;
      inline reverse_iterator()
        : current()
      {
      }
      inline explicit reverse_iterator(typename ::std::reverse_iterator<_Iterator>::iterator_type __x)
        : current(__x)
      {
      }
      inline reverse_iterator(const ::std::reverse_iterator<_Iterator> &__x)
        : current(__x.current)
      {
      }
      template < typename _Iter >
      inline reverse_iterator(const ::std::reverse_iterator<_Iter> &__x)
        : current(__x.base())
      {
      }
      inline typename ::std::reverse_iterator<_Iterator>::iterator_type base() const 
      {
        return ::std::reverse_iterator<_Iterator>::current;
      }
      inline typename ::std::reverse_iterator<_Iterator>::reference operator *() const 
      {
        _Iterator __tmp = ::std::reverse_iterator<_Iterator>::current;
        return * --__tmp;
      }
      inline typename ::std::reverse_iterator<_Iterator>::pointer operator ->() const 
      {
        return &(*this).operator *();
      }
      inline ::std::reverse_iterator<_Iterator> &operator ++()
      {
         --::std::reverse_iterator<_Iterator>::current;
        return *this;
      }
      inline ::std::reverse_iterator<_Iterator> operator ++(int)
      {
        ::std::reverse_iterator<_Iterator> __tmp = *this;
         --::std::reverse_iterator<_Iterator>::current;
        return __tmp;
      }
      inline ::std::reverse_iterator<_Iterator> &operator --()
      {
         ++::std::reverse_iterator<_Iterator>::current;
        return *this;
      }
      inline ::std::reverse_iterator<_Iterator> operator --(int)
      {
        ::std::reverse_iterator<_Iterator> __tmp = *this;
         ++::std::reverse_iterator<_Iterator>::current;
        return __tmp;
      }
      inline ::std::reverse_iterator<_Iterator> operator +(typename ::std::reverse_iterator<_Iterator>::difference_type __n) const 
      {
        return ::std::reverse_iterator<_Iterator>(::std::reverse_iterator<_Iterator>::current - __n);
      }
      inline ::std::reverse_iterator<_Iterator> &operator +=(typename ::std::reverse_iterator<_Iterator>::difference_type __n)
      {
        ::std::reverse_iterator<_Iterator>::current -= __n;
        return *this;
      }
      inline ::std::reverse_iterator<_Iterator> operator -(typename ::std::reverse_iterator<_Iterator>::difference_type __n) const 
      {
        return ::std::reverse_iterator<_Iterator>(::std::reverse_iterator<_Iterator>::current + __n);
      }
      inline ::std::reverse_iterator<_Iterator> &operator -=(typename ::std::reverse_iterator<_Iterator>::difference_type __n)
      {
        ::std::reverse_iterator<_Iterator>::current += __n;
        return *this;
      }
      inline typename ::std::reverse_iterator<_Iterator>::reference operator [](typename ::std::reverse_iterator<_Iterator>::difference_type __n) const 
      {
        return *(*this + __n);
      }
  };
  template < typename _Iterator >
  inline bool operator ==(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator ==(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __x.base() == __y.base();
  }
  template < typename _Iterator >
  inline bool operator <(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator <(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __y.base() < __x.base();
  }
  template < typename _Iterator >
  inline bool operator !=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator !=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Iterator >
  inline bool operator >(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator >(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __y < __x;
  }
  template < typename _Iterator >
  inline bool operator <=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator <=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Iterator >
  inline bool operator >=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator >=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Iterator >
  inline typename ::std::reverse_iterator<_Iterator>::difference_type operator -(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline typename ::std::reverse_iterator<_Iterator>::difference_type operator -(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __y.base() - __x.base();
  }
  template < typename _Iterator >
  inline ::std::reverse_iterator<_Iterator> operator +(typename ::std::reverse_iterator<_Iterator>::difference_type __n, const ::std::reverse_iterator<_Iterator> &__x);
  template < typename _Iterator >
  inline ::std::reverse_iterator<_Iterator> operator +(typename ::std::reverse_iterator<_Iterator>::difference_type __n, const ::std::reverse_iterator<_Iterator> &__x)
  {
    return ::std::reverse_iterator<_Iterator>(__x.base() - __n);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator ==(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator ==(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return __x.base() == __y.base();
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return __y.base() < __x.base();
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator !=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator !=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return !(__x == __y);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return __y < __x;
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return !(__y < __x);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return !(__x < __y);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline auto operator -(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y) -> decltype(__y.base() - __x.base());
  template < typename _IteratorL, typename _IteratorR >
  inline auto operator -(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y) -> decltype(__y.base() - __x.base())
  {
    return __y.base() - __x.base();
  }
 /* Instantiation of class template '::std::iterator< ::std::output_iterator_tag, void, void, void, void>' */ 
  template < typename _Container >
  class  back_insert_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    protected:
      _Container *container;
    public:
      typedef _Container container_type;
      inline explicit back_insert_iterator(_Container &__x)
        : container(&__x)
      {
      }
      inline ::std::back_insert_iterator<_Container> &operator =(const typename _Container::value_type &__value)
      {
        ::std::back_insert_iterator<_Container>::container->push_back(__value);
        return *this;
      }
      inline ::std::back_insert_iterator<_Container> &operator =(typename _Container::value_type &&__value)
      {
        ::std::back_insert_iterator<_Container>::container->push_back(std::move(__value));
        return *this;
      }
      inline ::std::back_insert_iterator<_Container> &operator *()
      {
        return *this;
      }
      inline ::std::back_insert_iterator<_Container> &operator ++()
      {
        return *this;
      }
      inline ::std::back_insert_iterator<_Container> operator ++(int)
      {
        return *this;
      }
  };
  template < typename _Container >
  inline ::std::back_insert_iterator<_Container> back_inserter(_Container &__x);
  template < typename _Container >
  inline ::std::back_insert_iterator<_Container> back_inserter(_Container &__x)
  {
    return ::std::back_insert_iterator<_Container>(__x);
  }
  template < typename _Container >
  class  front_insert_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    protected:
      _Container *container;
    public:
      typedef _Container container_type;
      inline explicit front_insert_iterator(_Container &__x)
        : container(&__x)
      {
      }
      inline ::std::front_insert_iterator<_Container> &operator =(const typename _Container::value_type &__value)
      {
        ::std::front_insert_iterator<_Container>::container->push_front(__value);
        return *this;
      }
      inline ::std::front_insert_iterator<_Container> &operator =(typename _Container::value_type &&__value)
      {
        ::std::front_insert_iterator<_Container>::container->push_front(std::move(__value));
        return *this;
      }
      inline ::std::front_insert_iterator<_Container> &operator *()
      {
        return *this;
      }
      inline ::std::front_insert_iterator<_Container> &operator ++()
      {
        return *this;
      }
      inline ::std::front_insert_iterator<_Container> operator ++(int)
      {
        return *this;
      }
  };
  template < typename _Container >
  inline ::std::front_insert_iterator<_Container> front_inserter(_Container &__x);
  template < typename _Container >
  inline ::std::front_insert_iterator<_Container> front_inserter(_Container &__x)
  {
    return ::std::front_insert_iterator<_Container>(__x);
  }
  template < typename _Container >
  class  insert_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    protected:
      _Container *container;
      typename _Container::iterator iter;
    public:
      typedef _Container container_type;
      inline insert_iterator(_Container &__x, typename _Container::iterator __i)
        : container(&__x), iter(__i)
      {
      }
      inline ::std::insert_iterator<_Container> &operator =(const typename _Container::value_type &__value)
      {
        ::std::insert_iterator<_Container>::iter = ::std::insert_iterator<_Container>::container->insert(::std::insert_iterator<_Container>::iter, __value);
         ++::std::insert_iterator<_Container>::iter;
        return *this;
      }
      inline ::std::insert_iterator<_Container> &operator =(typename _Container::value_type &&__value)
      {
        ::std::insert_iterator<_Container>::iter = ::std::insert_iterator<_Container>::container->insert(::std::insert_iterator<_Container>::iter, std::move(__value));
         ++::std::insert_iterator<_Container>::iter;
        return *this;
      }
      inline ::std::insert_iterator<_Container> &operator *()
      {
        return *this;
      }
      inline ::std::insert_iterator<_Container> &operator ++()
      {
        return *this;
      }
      inline ::std::insert_iterator<_Container> &operator ++(int)
      {
        return *this;
      }
  };
  template < typename _Container, typename _Iterator >
  inline ::std::insert_iterator<_Container> inserter(_Container &__x, _Iterator __i);
  template < typename _Container, typename _Iterator >
  inline ::std::insert_iterator<_Container> inserter(_Container &__x, _Iterator __i)
  {
    return ::std::insert_iterator<_Container>(__x, typename _Container::iterator(__i));
  }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::std::iterator_traits;
  using ::std::iterator;
  template < typename _Iterator, typename _Container >
  class  __normal_iterator
  {
    protected:
      _Iterator _M_current;
      typedef ::std::iterator_traits<_Iterator> __traits_type;
    public:
      typedef _Iterator iterator_type;
      typedef typename ::std::iterator_traits<_Iterator>::iterator_category iterator_category;
      typedef typename ::std::iterator_traits<_Iterator>::value_type value_type;
      typedef typename ::std::iterator_traits<_Iterator>::difference_type difference_type;
      typedef typename ::std::iterator_traits<_Iterator>::reference reference;
      typedef typename ::std::iterator_traits<_Iterator>::pointer pointer;
      inline constexpr __normal_iterator()
        : _M_current(_Iterator())
      {
      }
      inline explicit __normal_iterator(const _Iterator &__i)
        : _M_current(__i)
      {
      }
      template < typename _Iter >
      inline __normal_iterator(const ::__gnu_cxx::__normal_iterator<_Iter, typename ::__gnu_cxx::__enable_if<std::__are_same<_Iter, typename _Container::pointer>::__value, _Container>::__type> &__i)
        : _M_current(__i.base())
      {
      }
      inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::reference operator *() const 
      {
        return *::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
      }
      inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::pointer operator ->() const 
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator ++()
      {
         ++::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator ++(int)
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current++);
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator --()
      {
         --::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator --(int)
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current--);
      }
      inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::reference operator [](const typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type &__n) const 
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current[__n];
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator +=(const typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type &__n)
      {
        ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current += __n;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator +(const typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type &__n) const 
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current + __n);
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator -=(const typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type &__n)
      {
        ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current -= __n;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator -(const typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type &__n) const 
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current - __n);
      }
      inline const _Iterator &base() const 
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
      }
  };
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() == __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() == __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() != __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() != __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() < __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() < __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() > __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() > __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() <= __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() <= __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs)
  {
    return __lhs.base() >= __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() >= __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline auto operator -(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) -> decltype(__lhs.base() - __rhs.base());
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline auto operator -(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) -> decltype(__lhs.base() - __rhs.base())
  {
    return __lhs.base() - __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type operator -(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs);
  template < typename _Iterator, typename _Container >
  inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type operator -(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base() - __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator +(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__i);
  template < typename _Iterator, typename _Container >
  inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator +(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__i)
  {
    return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(__i.base() + __n);
  }
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Iterator >
  class  move_iterator
  {
    protected:
      _Iterator _M_current;
      typedef ::std::iterator_traits<_Iterator> __traits_type;
    public:
      typedef _Iterator iterator_type;
      typedef typename ::std::iterator_traits<_Iterator>::iterator_category iterator_category;
      typedef typename ::std::iterator_traits<_Iterator>::value_type value_type;
      typedef typename ::std::iterator_traits<_Iterator>::difference_type difference_type;
      typedef _Iterator pointer;
      typedef typename ::std::move_iterator<_Iterator>::value_type &&reference;
      inline move_iterator()
        : _M_current()
      {
      }
      inline explicit move_iterator(typename ::std::move_iterator<_Iterator>::iterator_type __i)
        : _M_current(__i)
      {
      }
      template < typename _Iter >
      inline move_iterator(const ::std::move_iterator<_Iter> &__i)
        : _M_current(__i.base())
      {
      }
      inline typename ::std::move_iterator<_Iterator>::iterator_type base() const 
      {
        return ::std::move_iterator<_Iterator>::_M_current;
      }
      inline typename ::std::move_iterator<_Iterator>::reference operator *() const 
      {
        return std::move(*::std::move_iterator<_Iterator>::_M_current);
      }
      inline typename ::std::move_iterator<_Iterator>::pointer operator ->() const 
      {
        return ::std::move_iterator<_Iterator>::_M_current;
      }
      inline ::std::move_iterator<_Iterator> &operator ++()
      {
         ++::std::move_iterator<_Iterator>::_M_current;
        return *this;
      }
      inline ::std::move_iterator<_Iterator> operator ++(int)
      {
        ::std::move_iterator<_Iterator> __tmp = *this;
         ++::std::move_iterator<_Iterator>::_M_current;
        return __tmp;
      }
      inline ::std::move_iterator<_Iterator> &operator --()
      {
         --::std::move_iterator<_Iterator>::_M_current;
        return *this;
      }
      inline ::std::move_iterator<_Iterator> operator --(int)
      {
        ::std::move_iterator<_Iterator> __tmp = *this;
         --::std::move_iterator<_Iterator>::_M_current;
        return __tmp;
      }
      inline ::std::move_iterator<_Iterator> operator +(typename ::std::move_iterator<_Iterator>::difference_type __n) const 
      {
        return ::std::move_iterator<_Iterator>(::std::move_iterator<_Iterator>::_M_current + __n);
      }
      inline ::std::move_iterator<_Iterator> &operator +=(typename ::std::move_iterator<_Iterator>::difference_type __n)
      {
        ::std::move_iterator<_Iterator>::_M_current += __n;
        return *this;
      }
      inline ::std::move_iterator<_Iterator> operator -(typename ::std::move_iterator<_Iterator>::difference_type __n) const 
      {
        return ::std::move_iterator<_Iterator>(::std::move_iterator<_Iterator>::_M_current - __n);
      }
      inline ::std::move_iterator<_Iterator> &operator -=(typename ::std::move_iterator<_Iterator>::difference_type __n)
      {
        ::std::move_iterator<_Iterator>::_M_current -= __n;
        return *this;
      }
      inline typename ::std::move_iterator<_Iterator>::reference operator [](typename ::std::move_iterator<_Iterator>::difference_type __n) const 
      {
        return std::move(::std::move_iterator<_Iterator>::_M_current[__n]);
      }
  };
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator ==(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator ==(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y)
  {
    return __x.base() == __y.base();
  }
  template < typename _Iterator >
  inline bool operator ==(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator ==(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y)
  {
    return __x.base() == __y.base();
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator !=(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator !=(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Iterator >
  inline bool operator !=(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator !=(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y)
  {
    return !(__x == __y);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y)
  {
    return __x.base() < __y.base();
  }
  template < typename _Iterator >
  inline bool operator <(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator <(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y)
  {
    return __x.base() < __y.base();
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <=(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <=(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Iterator >
  inline bool operator <=(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator <=(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y)
  {
    return !(__y < __x);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y)
  {
    return __y < __x;
  }
  template < typename _Iterator >
  inline bool operator >(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator >(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y)
  {
    return __y < __x;
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >=(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >=(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Iterator >
  inline bool operator >=(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator >=(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y)
  {
    return !(__x < __y);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline auto operator -(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y) -> decltype(__x.base() - __y.base());
  template < typename _IteratorL, typename _IteratorR >
  inline auto operator -(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y) -> decltype(__x.base() - __y.base())
  {
    return __x.base() - __y.base();
  }
  template < typename _Iterator >
  inline auto operator -(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y) -> decltype(__x.base() - __y.base());
  template < typename _Iterator >
  inline auto operator -(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y) -> decltype(__x.base() - __y.base())
  {
    return __x.base() - __y.base();
  }
  template < typename _Iterator >
  inline ::std::move_iterator<_Iterator> operator +(typename ::std::move_iterator<_Iterator>::difference_type __n, const ::std::move_iterator<_Iterator> &__x);
  template < typename _Iterator >
  inline ::std::move_iterator<_Iterator> operator +(typename ::std::move_iterator<_Iterator>::difference_type __n, const ::std::move_iterator<_Iterator> &__x)
  {
    return __x + __n;
  }
  template < typename _Iterator >
  inline ::std::move_iterator<_Iterator> make_move_iterator(_Iterator __i);
  template < typename _Iterator >
  inline ::std::move_iterator<_Iterator> make_move_iterator(_Iterator __i)
  {
    return ::std::move_iterator<_Iterator>(__i);
  }
  template < typename _Iterator, typename _ReturnType = typename ::std::conditional<__move_if_noexcept_cond<typename ::std::iterator_traits<_Iterator>::value_type>::value, _Iterator, ::std::move_iterator<_Iterator> >::type >
  inline _ReturnType __make_move_if_noexcept_iterator(_Iterator __i);
  template < typename _Iterator, typename _ReturnType >
  inline _ReturnType __make_move_if_noexcept_iterator(_Iterator __i)
  {
    return _ReturnType(__i);
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b);
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
  {
    swap(*__a, *__b);
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2);
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
  {
    ;
    for (; __first1 != __last1; ( ++__first1,  ++__first2))
      {
        std::iter_swap(__first1, __first2);
      }
    return __first2;
  }
  template < typename _Tp >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b);
  template < typename _Tp >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b)
  {
    if (__b < __a)
      {
        return __b;
      }
    return __a;
  }
  template < typename _Tp >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b);
  template < typename _Tp >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b)
  {
    if (__a < __b)
      {
        return __b;
      }
    return __a;
  }
  template < typename _Tp, typename _Compare >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp);
  template < typename _Tp, typename _Compare >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp)
  {
    if (__comp(__b, __a))
      {
        return __b;
      }
    return __a;
  }
  template < typename _Tp, typename _Compare >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp);
  template < typename _Tp, typename _Compare >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp)
  {
    if (__comp(__a, __b))
      {
        return __b;
      }
    return __a;
  }
  template < typename _Iterator >
  struct  _Niter_base : ::std::_Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
  {
  };
  template < typename _Iterator >
  inline typename ::std::_Niter_base<_Iterator>::iterator_type __niter_base(_Iterator __it);
  template < typename _Iterator >
  inline typename ::std::_Niter_base<_Iterator>::iterator_type __niter_base(_Iterator __it)
  {
    return std::_Niter_base<_Iterator>::_S_base(__it);
  }
  template < typename _Iterator >
  struct  _Miter_base : ::std::_Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
  {
  };
  template < typename _Iterator >
  inline typename ::std::_Miter_base<_Iterator>::iterator_type __miter_base(_Iterator __it);
  template < typename _Iterator >
  inline typename ::std::_Miter_base<_Iterator>::iterator_type __miter_base(_Iterator __it)
  {
    return std::_Miter_base<_Iterator>::_S_base(__it);
  }
  template < bool __nontype_tpl_param_1_0__, bool __nontype_tpl_param_1_1__, typename __type_tpl__param_1_2__ >
  struct  __copy_move
  {
      template < typename _II, typename _OI >
      static inline _OI __copy_m(_II __first, _II __last, _OI __result)
      {
        for (; __first != __last; ( ++__result,  ++__first))
          {
            *__result = *__first;
          }
        return __result;
      }
  };
  template < typename _Category >
  struct  __copy_move<true, false, _Category>
  {
      template < typename _II, typename _OI >
      static inline _OI __copy_m(_II __first, _II __last, _OI __result)
      {
        for (; __first != __last; ( ++__result,  ++__first))
          {
            *__result = std::move(*__first);
          }
        return __result;
      }
  };
  template <>
  struct  __copy_move<false, false, ::std::random_access_iterator_tag>
  {
      template < typename _II, typename _OI >
      static inline _OI __copy_m(_II __first, _II __last, _OI __result)
      {
        typedef typename ::std::iterator_traits<_II>::difference_type _Distance;
        for (_Distance __n = __last - __first; __n > 0;  --__n)
          {
            *__result = *__first;
             ++__first;
             ++__result;
          }
        return __result;
      }
  };
  template <>
  struct  __copy_move<true, false, ::std::random_access_iterator_tag>
  {
      template < typename _II, typename _OI >
      static inline _OI __copy_m(_II __first, _II __last, _OI __result)
      {
        typedef typename ::std::iterator_traits<_II>::difference_type _Distance;
        for (_Distance __n = __last - __first; __n > 0;  --__n)
          {
            *__result = std::move(*__first);
             ++__first;
             ++__result;
          }
        return __result;
      }
  };
  template < bool _IsMove >
  struct  __copy_move<_IsMove, true, ::std::random_access_iterator_tag>
  {
      template < typename _Tp >
      static inline _Tp *__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result)
      {
        const ::std::ptrdiff_t _Num = __last - __first;
        if (_Num)
          {
            __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
          }
        return __result + _Num;
      }
  };
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a(_II __first, _II __last, _OI __result);
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a(_II __first, _II __last, _OI __result)
  {
    typedef typename ::std::iterator_traits<_II>::value_type _ValueTypeI;
    typedef typename ::std::iterator_traits<_OI>::value_type _ValueTypeO;
    typedef typename ::std::iterator_traits<_II>::iterator_category _Category;
    const bool __simple = (((__is_trivial(_ValueTypeI)) && __is_pointer<_II>::__value) && __is_pointer<_OI>::__value) && __are_same<_ValueTypeI, _ValueTypeO>::__value;
    return std::__copy_move<_IsMove, __simple, _Category>::__copy_m(__first, __last, __result);
  }
  template < typename _CharT >
  struct char_traits;
  template < typename _CharT, typename _Traits >
  class istreambuf_iterator;
  template < typename _CharT, typename _Traits >
  class ostreambuf_iterator;
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(_CharT *__first, _CharT *__last, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __result);
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(const _CharT *__first, const _CharT *__last, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __result);
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __first, ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __last, _CharT *__result);
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a2(_II __first, _II __last, _OI __result);
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a2(_II __first, _II __last, _OI __result)
  {
    return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
  }
  template < typename _II, typename _OI >
  inline _OI copy(_II __first, _II __last, _OI __result);
  template < typename _II, typename _OI >
  inline _OI copy(_II __first, _II __last, _OI __result)
  {
    ;
    return std::__copy_move_a2<__is_move_iterator<_II>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
  }
  template < typename _II, typename _OI >
  inline _OI move(_II __first, _II __last, _OI __result);
  template < typename _II, typename _OI >
  inline _OI move(_II __first, _II __last, _OI __result)
  {
    ;
    return std::__copy_move_a2<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
  }
  template < bool __nontype_tpl_param_1_0__, bool __nontype_tpl_param_1_1__, typename __type_tpl__param_1_2__ >
  struct  __copy_move_backward
  {
      template < typename _BI1, typename _BI2 >
      static inline _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
      {
        while (__first != __last)
          {
            * --__result = * --__last;
          }
        return __result;
      }
  };
  template < typename _Category >
  struct  __copy_move_backward<true, false, _Category>
  {
      template < typename _BI1, typename _BI2 >
      static inline _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
      {
        while (__first != __last)
          {
            * --__result = std::move(* --__last);
          }
        return __result;
      }
  };
  template <>
  struct  __copy_move_backward<false, false, ::std::random_access_iterator_tag>
  {
      template < typename _BI1, typename _BI2 >
      static inline _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
      {
        typename ::std::iterator_traits<_BI1>::difference_type __n;
        for (__n = __last - __first; __n > 0;  --__n)
          {
            * --__result = * --__last;
          }
        return __result;
      }
  };
  template <>
  struct  __copy_move_backward<true, false, ::std::random_access_iterator_tag>
  {
      template < typename _BI1, typename _BI2 >
      static inline _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
      {
        typename ::std::iterator_traits<_BI1>::difference_type __n;
        for (__n = __last - __first; __n > 0;  --__n)
          {
            * --__result = std::move(* --__last);
          }
        return __result;
      }
  };
  template < bool _IsMove >
  struct  __copy_move_backward<_IsMove, true, ::std::random_access_iterator_tag>
  {
      template < typename _Tp >
      static inline _Tp *__copy_move_b(const _Tp *__first, const _Tp *__last, _Tp *__result)
      {
        const ::std::ptrdiff_t _Num = __last - __first;
        if (_Num)
          {
            __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
          }
        return __result - _Num;
      }
  };
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result);
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
  {
    typedef typename ::std::iterator_traits<_BI1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_BI2>::value_type _ValueType2;
    typedef typename ::std::iterator_traits<_BI1>::iterator_category _Category;
    const bool __simple = (((__is_trivial(_ValueType1)) && __is_pointer<_BI1>::__value) && __is_pointer<_BI2>::__value) && __are_same<_ValueType1, _ValueType2>::__value;
    return std::__copy_move_backward<_IsMove, __simple, _Category>::__copy_move_b(__first, __last, __result);
  }
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result);
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
  {
    return _BI2(std::__copy_move_backward_a<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
  }
  template < typename _BI1, typename _BI2 >
  inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result);
  template < typename _BI1, typename _BI2 >
  inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
  {
    ;
    return std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
  }
  template < typename _BI1, typename _BI2 >
  inline _BI2 move_backward(_BI1 __first, _BI1 __last, _BI2 __result);
  template < typename _BI1, typename _BI2 >
  inline _BI2 move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
  {
    ;
    return std::__copy_move_backward_a2<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
  }
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value);
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
  {
    for (; __first != __last;  ++__first)
      {
        *__first = __value;
      }
  }
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value);
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
  {
    const _Tp __tmp = __value;
    for (; __first != __last;  ++__first)
      {
        *__first = __tmp;
      }
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a(_Tp *__first, _Tp *__last, const _Tp &__c);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a(_Tp *__first, _Tp *__last, const _Tp &__c)
  {
    const _Tp __tmp = __c;
    __builtin_memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }
  template < typename _ForwardIterator, typename _Tp >
  inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value);
  template < typename _ForwardIterator, typename _Tp >
  inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
  {
    ;
    std::__fill_a(std::__niter_base(__first), std::__niter_base(__last), __value);
  }
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value);
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value)
  {
    for (decltype(__n + 0) __niter = __n; __niter > 0; ( --__niter,  ++__first))
      {
        *__first = __value;
      }
    return __first;
  }
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value);
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value)
  {
    const _Tp __tmp = __value;
    for (decltype(__n + 0) __niter = __n; __niter > 0; ( --__niter,  ++__first))
      {
        *__first = __tmp;
      }
    return __first;
  }
  template < typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp *>::__type __fill_n_a(_Tp *__first, _Size __n, const _Tp &__c);
  template < typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp *>::__type __fill_n_a(_Tp *__first, _Size __n, const _Tp &__c)
  {
    std::__fill_a(__first, __first + __n, __c);
    return __first + __n;
  }
  template < typename _OI, typename _Size, typename _Tp >
  inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value);
  template < typename _OI, typename _Size, typename _Tp >
  inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value)
  {
    return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
  }
  template < bool _BoolType >
  struct  __equal
  {
      template < typename _II1, typename _II2 >
      static inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2)
      {
        for (; __first1 != __last1; ( ++__first1,  ++__first2))
          {
            if (!(*__first1 == *__first2))
              {
                return false;
              }
          }
        return true;
      }
  };
  template <>
  struct  __equal<true>
  {
      template < typename _Tp >
      static inline bool equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2)
      {
        return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * (__last1 - __first1));
      }
  };
  template < typename _II1, typename _II2 >
  inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2);
  template < typename _II1, typename _II2 >
  inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
  {
    typedef typename ::std::iterator_traits<_II1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_II2>::value_type _ValueType2;
    const bool __simple = (((__is_integer<_ValueType1>::__value || __is_pointer<_ValueType1>::__value) && __is_pointer<_II1>::__value) && __is_pointer<_II2>::__value) && __are_same<_ValueType1, _ValueType2>::__value;
    return std::__equal<__simple>::equal(__first1, __last1, __first2);
  }
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct  __lc_rai
  {
      template < typename _II1, typename _II2 >
      static inline _II1 __newlast1(_II1, _II1 __last1, _II2, _II2)
      {
        return __last1;
      }
      template < typename _II >
      static inline bool __cnd2(_II __first, _II __last)
      {
        return __first != __last;
      }
  };
  template <>
  struct  __lc_rai< ::std::random_access_iterator_tag, ::std::random_access_iterator_tag>
  {
      template < typename _RAI1, typename _RAI2 >
      static inline _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 __first2, _RAI2 __last2)
      {
        const typename ::std::iterator_traits<_RAI1>::difference_type __diff1 = __last1 - __first1;
        const typename ::std::iterator_traits<_RAI2>::difference_type __diff2 = __last2 - __first2;
        return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
      }
      template < typename _RAI >
      static inline bool __cnd2(_RAI, _RAI)
      {
        return true;
      }
  };
  template < bool _BoolType >
  struct  __lexicographical_compare
  {
      template < typename _II1, typename _II2 >
      static bool __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2);
  };
  template < bool _BoolType >
  template < typename _II1, typename _II2 >
  bool __lexicographical_compare<_BoolType>::__lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
  {
    typedef typename ::std::iterator_traits<_II1>::iterator_category _Category1;
    typedef typename ::std::iterator_traits<_II2>::iterator_category _Category2;
    typedef ::std::__lc_rai<_Category1, _Category2> __rai_type;
    __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
    for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2); ( ++__first1,  ++__first2))
      {
        if (*__first1 < *__first2)
          {
            return true;
          }
        if (*__first2 < *__first1)
          {
            return false;
          }
      }
    return __first1 == __last1 && __first2 != __last2;
  }
  template <>
  struct  __lexicographical_compare<true>
  {
      template < typename _Tp, typename _Up >
      static inline bool __lc(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2)
      {
        const ::std::size_t __len1 = __last1 - __first1;
        const ::std::size_t __len2 = __last2 - __first2;
        const int __result = __builtin_memcmp(__first1, __first2, std::min(__len1, __len2));
        return __result != 0 ? __result < 0 : __len1 < __len2;
      }
  };
  template < typename _II1, typename _II2 >
  inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2);
  template < typename _II1, typename _II2 >
  inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
  {
    typedef typename ::std::iterator_traits<_II1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_II2>::value_type _ValueType2;
    const bool __simple = ((((__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value) && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed) && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed) && __is_pointer<_II1>::__value) && __is_pointer<_II2>::__value;
    return std::__lexicographical_compare<__simple>::__lc(__first1, __last1, __first2, __last2);
  }
  template < typename _ForwardIterator, typename _Tp >
  _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val);
  template < typename _ForwardIterator, typename _Tp >
  _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    ;
    _DistanceType __len = std::distance(__first, __last);
    while (__len > 0)
      {
        _DistanceType __half = __len >> 1;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __half);
        if (*__middle < __val)
          {
            __first = __middle;
             ++__first;
            __len = __len - __half - 1;
          }
        else
          {
            __len = __half;
          }
      }
    return __first;
  }
  inline constexpr int __lg(int __n)
  {
    return sizeof(int) * 8 - 1 - __builtin_clz(__n);
  }
  inline constexpr unsigned int __lg(unsigned int __n)
  {
    return sizeof(int) * 8 - 1 - __builtin_clz(__n);
  }
  inline constexpr long int __lg(long int __n)
  {
    return sizeof(long int) * 8 - 1 - __builtin_clzl(__n);
  }
  inline constexpr unsigned long int __lg(unsigned long int __n)
  {
    return sizeof(long int) * 8 - 1 - __builtin_clzl(__n);
  }
  inline constexpr long long int __lg(long long int __n)
  {
    return sizeof(long long int) * 8 - 1 - __builtin_clzll(__n);
  }
  inline constexpr unsigned long long int __lg(unsigned long long int __n)
  {
    return sizeof(long long int) * 8 - 1 - __builtin_clzll(__n);
  }
  template < typename _II1, typename _II2 >
  inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2);
  template < typename _II1, typename _II2 >
  inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2)
  {
    ;
    return std::__equal_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2));
  }
  template < typename _IIter1, typename _IIter2, typename _BinaryPredicate >
  inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred);
  template < typename _IIter1, typename _IIter2, typename _BinaryPredicate >
  inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)
  {
    ;
    for (; __first1 != __last1; ( ++__first1,  ++__first2))
      {
        if (!bool(__binary_pred(*__first1, *__first2)))
          {
            return false;
          }
      }
    return true;
  }
  template < typename _II1, typename _II2 >
  inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2);
  template < typename _II1, typename _II2 >
  inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
  {
    ;
    ;
    return std::__lexicographical_compare_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2), std::__niter_base(__last2));
  }
  template < typename _II1, typename _II2, typename _Compare >
  bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp);
  template < typename _II1, typename _II2, typename _Compare >
  bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_II1>::iterator_category _Category1;
    typedef typename ::std::iterator_traits<_II2>::iterator_category _Category2;
    typedef ::std::__lc_rai<_Category1, _Category2> __rai_type;
    ;
    ;
    __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
    for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2); ( ++__first1,  ++__first2))
      {
        if (__comp(*__first1, *__first2))
          {
            return true;
          }
        if (__comp(*__first2, *__first1))
          {
            return false;
          }
      }
    return __first1 == __last1 && __first2 != __last2;
  }
  template < typename _InputIterator1, typename _InputIterator2 >
  ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2);
  template < typename _InputIterator1, typename _InputIterator2 >
  ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
  {
    ;
    while (__first1 != __last1 && *__first1 == *__first2)
      {
         ++__first1;
         ++__first2;
      }
    return ::std::pair<_InputIterator1, _InputIterator2>(__first1, __first2);
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate >
  ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred);
  template < typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate >
  ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)
  {
    ;
    while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
      {
         ++__first1;
         ++__first2;
      }
    return ::std::pair<_InputIterator1, _InputIterator2>(__first1, __first2);
  }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < typename _CharT >
  struct  _Char_types
  {
      typedef unsigned long int int_type;
      typedef ::std::streampos pos_type;
      typedef ::std::streamoff off_type;
      typedef ::mbstate_t state_type;
  };
  template < typename _CharT >
  struct  char_traits
  {
      typedef _CharT char_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::int_type int_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::pos_type pos_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::off_type off_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::state_type state_type;
      static inline void assign(typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c2)
      {
        __c1 = __c2;
      }
      static inline constexpr bool eq(const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline constexpr bool lt(const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c2)
      {
        return __c1 < __c2;
      }
      static int compare(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n);
      static ::std::size_t length(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__p);
      static const typename ::__gnu_cxx::char_traits<_CharT>::char_type *find(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__a);
      static typename ::__gnu_cxx::char_traits<_CharT>::char_type *move(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n);
      static typename ::__gnu_cxx::char_traits<_CharT>::char_type *copy(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n);
      static typename ::__gnu_cxx::char_traits<_CharT>::char_type *assign(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, typename ::__gnu_cxx::char_traits<_CharT>::char_type __a);
      static inline constexpr typename ::__gnu_cxx::char_traits<_CharT>::char_type to_char_type(const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c)
      {
        return static_cast<typename ::__gnu_cxx::char_traits<_CharT>::char_type>(__c);
      }
      static inline constexpr typename ::__gnu_cxx::char_traits<_CharT>::int_type to_int_type(const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c)
      {
        return static_cast<typename ::__gnu_cxx::char_traits<_CharT>::int_type>(__c);
      }
      static inline constexpr bool eq_int_type(const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline constexpr typename ::__gnu_cxx::char_traits<_CharT>::int_type eof()
      {
        return static_cast<typename ::__gnu_cxx::char_traits<_CharT>::int_type>( -1);
      }
      static inline constexpr typename ::__gnu_cxx::char_traits<_CharT>::int_type not_eof(const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c)
      {
        return !eq_int_type(__c, eof()) ? __c : to_int_type(((typename ::__gnu_cxx::char_traits<_CharT>::char_type())));
      }
  };
  template < typename _CharT >
  int char_traits<_CharT>::compare(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n)
  {
    for (::std::size_t __i(0); __i < __n;  ++__i)
      {
        if (lt(__s1[__i], __s2[__i]))
          {
            return  -1;
          }
        else
          {
            if (lt(__s2[__i], __s1[__i]))
              {
                return 1;
              }
          }
      }
    return 0;
  }
  template < typename _CharT >
  ::std::size_t char_traits<_CharT>::length(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__p)
  {
    ::std::size_t __i(0);
    while (!eq(__p[__i], ((typename ::__gnu_cxx::char_traits<_CharT>::char_type()))))
      {
         ++__i;
      }
    return __i;
  }
  template < typename _CharT >
  const typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::find(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__a)
  {
    for (::std::size_t __i(0); __i < __n;  ++__i)
      {
        if (eq(__s[__i], __a))
          {
            return __s + __i;
          }
      }
    return 0;
  }
  template < typename _CharT >
  typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::move(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n)
  {
    return static_cast<_CharT *>(__builtin_memmove(__s1, __s2, __n * sizeof(typename ::__gnu_cxx::char_traits<_CharT>::char_type)));
  }
  template < typename _CharT >
  typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::copy(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n)
  {
    std::copy(__s2, __s2 + __n, __s1);
    return __s1;
  }
  template < typename _CharT >
  typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::assign(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, typename ::__gnu_cxx::char_traits<_CharT>::char_type __a)
  {
    std::fill_n(__s, __n, __a);
    return __s;
  }
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _CharT >
  struct  char_traits : ::__gnu_cxx::char_traits<_CharT>
  {
  };
  template <>
  struct  char_traits<char>
  {
      typedef char char_type;
      typedef int int_type;
      typedef ::std::streampos pos_type;
      typedef ::std::streamoff off_type;
      typedef ::mbstate_t state_type;
      static inline void assign(::std::char_traits<char>::char_type &__c1, const ::std::char_traits<char>::char_type &__c2) noexcept(true)
      {
        __c1 = __c2;
      }
      static inline constexpr bool eq(const ::std::char_traits<char>::char_type &__c1, const ::std::char_traits<char>::char_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr bool lt(const ::std::char_traits<char>::char_type &__c1, const ::std::char_traits<char>::char_type &__c2) noexcept(true)
      {
        return __c1 < __c2;
      }
      static inline int compare(const ::std::char_traits<char>::char_type *__s1, const ::std::char_traits<char>::char_type *__s2, ::std::size_t __n)
      {
        return __builtin_memcmp(__s1, __s2, __n);
      }
      static inline ::std::size_t length(const ::std::char_traits<char>::char_type *__s)
      {
        return __builtin_strlen(__s);
      }
      static inline const ::std::char_traits<char>::char_type *find(const ::std::char_traits<char>::char_type *__s, ::std::size_t __n, const ::std::char_traits<char>::char_type &__a)
      {
        return static_cast<const ::std::char_traits<char>::char_type *>(__builtin_memchr(__s, __a, __n));
      }
      static inline ::std::char_traits<char>::char_type *move(::std::char_traits<char>::char_type *__s1, const ::std::char_traits<char>::char_type *__s2, ::std::size_t __n)
      {
        return static_cast< ::std::char_traits<char>::char_type *>(__builtin_memmove(__s1, __s2, __n));
      }
      static inline ::std::char_traits<char>::char_type *copy(::std::char_traits<char>::char_type *__s1, const ::std::char_traits<char>::char_type *__s2, ::std::size_t __n)
      {
        return static_cast< ::std::char_traits<char>::char_type *>(__builtin_memcpy(__s1, __s2, __n));
      }
      static inline ::std::char_traits<char>::char_type *assign(::std::char_traits<char>::char_type *__s, ::std::size_t __n, ::std::char_traits<char>::char_type __a)
      {
        return static_cast< ::std::char_traits<char>::char_type *>(__builtin_memset(__s, __a, __n));
      }
      static inline constexpr ::std::char_traits<char>::char_type to_char_type(const ::std::char_traits<char>::int_type &__c) noexcept(true)
      {
        return static_cast< ::std::char_traits<char>::char_type>(__c);
      }
      static inline constexpr ::std::char_traits<char>::int_type to_int_type(const ::std::char_traits<char>::char_type &__c) noexcept(true)
      {
        return static_cast< ::std::char_traits<char>::int_type>(static_cast<unsigned char>(__c));
      }
      static inline constexpr bool eq_int_type(const ::std::char_traits<char>::int_type &__c1, const ::std::char_traits<char>::int_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr ::std::char_traits<char>::int_type eof() noexcept(true)
      {
        return static_cast< ::std::char_traits<char>::int_type>( -1);
      }
      static inline constexpr ::std::char_traits<char>::int_type not_eof(const ::std::char_traits<char>::int_type &__c) noexcept(true)
      {
        return __c == ::std::char_traits<char>::eof() ? 0 : __c;
      }
  };
  template <>
  struct  char_traits<wchar_t>
  {
      typedef wchar_t char_type;
      typedef ::wint_t int_type;
      typedef ::std::streamoff off_type;
      typedef ::std::wstreampos pos_type;
      typedef ::mbstate_t state_type;
      static inline void assign(::std::char_traits<wchar_t>::char_type &__c1, const ::std::char_traits<wchar_t>::char_type &__c2) noexcept(true)
      {
        __c1 = __c2;
      }
      static inline constexpr bool eq(const ::std::char_traits<wchar_t>::char_type &__c1, const ::std::char_traits<wchar_t>::char_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr bool lt(const ::std::char_traits<wchar_t>::char_type &__c1, const ::std::char_traits<wchar_t>::char_type &__c2) noexcept(true)
      {
        return __c1 < __c2;
      }
      static inline int compare(const ::std::char_traits<wchar_t>::char_type *__s1, const ::std::char_traits<wchar_t>::char_type *__s2, ::std::size_t __n)
      {
        return ::std::wmemcmp(__s1, __s2, __n);
      }
      static inline ::std::size_t length(const ::std::char_traits<wchar_t>::char_type *__s)
      {
        return ::std::wcslen(__s);
      }
      static inline const ::std::char_traits<wchar_t>::char_type *find(const ::std::char_traits<wchar_t>::char_type *__s, ::std::size_t __n, const ::std::char_traits<wchar_t>::char_type &__a)
      {
        return ::std::wmemchr(__s, __a, __n);
      }
      static inline ::std::char_traits<wchar_t>::char_type *move(::std::char_traits<wchar_t>::char_type *__s1, const ::std::char_traits<wchar_t>::char_type *__s2, ::std::size_t __n)
      {
        return ::std::wmemmove(__s1, __s2, __n);
      }
      static inline ::std::char_traits<wchar_t>::char_type *copy(::std::char_traits<wchar_t>::char_type *__s1, const ::std::char_traits<wchar_t>::char_type *__s2, ::std::size_t __n)
      {
        return ::std::wmemcpy(__s1, __s2, __n);
      }
      static inline ::std::char_traits<wchar_t>::char_type *assign(::std::char_traits<wchar_t>::char_type *__s, ::std::size_t __n, ::std::char_traits<wchar_t>::char_type __a)
      {
        return ::std::wmemset(__s, __a, __n);
      }
      static inline constexpr ::std::char_traits<wchar_t>::char_type to_char_type(const ::std::char_traits<wchar_t>::int_type &__c) noexcept(true)
      {
        return (::std::char_traits<wchar_t>::char_type)__c;
      }
      static inline constexpr ::std::char_traits<wchar_t>::int_type to_int_type(const ::std::char_traits<wchar_t>::char_type &__c) noexcept(true)
      {
        return (::std::char_traits<wchar_t>::int_type)__c;
      }
      static inline constexpr bool eq_int_type(const ::std::char_traits<wchar_t>::int_type &__c1, const ::std::char_traits<wchar_t>::int_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr ::std::char_traits<wchar_t>::int_type eof() noexcept(true)
      {
        return static_cast< ::std::char_traits<wchar_t>::int_type>(4294967295U);
      }
      static inline constexpr ::std::char_traits<wchar_t>::int_type not_eof(const ::std::char_traits<wchar_t>::int_type &__c) noexcept(true)
      {
        return ::std::char_traits<wchar_t>::eq_int_type(__c, ::std::char_traits<wchar_t>::eof()) ? 0 : __c;
      }
  };
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;
  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;
  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;
  using ::intmax_t;
  using ::intptr_t;
  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;
  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;
  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;
  using ::uintmax_t;
  using ::uintptr_t;
  template <>
  struct  char_traits<char16_t>
  {
      typedef char16_t char_type;
      typedef ::uint_least16_t int_type;
      typedef ::std::streamoff off_type;
      typedef ::std::u16streampos pos_type;
      typedef ::mbstate_t state_type;
      static inline void assign(::std::char_traits<char16_t>::char_type &__c1, const ::std::char_traits<char16_t>::char_type &__c2) noexcept(true)
      {
        __c1 = __c2;
      }
      static inline constexpr bool eq(const ::std::char_traits<char16_t>::char_type &__c1, const ::std::char_traits<char16_t>::char_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr bool lt(const ::std::char_traits<char16_t>::char_type &__c1, const ::std::char_traits<char16_t>::char_type &__c2) noexcept(true)
      {
        return __c1 < __c2;
      }
      static inline int compare(const ::std::char_traits<char16_t>::char_type *__s1, const ::std::char_traits<char16_t>::char_type *__s2, ::std::size_t __n)
      {
        for (::std::size_t __i(0); __i < __n;  ++__i)
          {
            if (::std::char_traits<char16_t>::lt(__s1[__i], __s2[__i]))
              {
                return  -1;
              }
            else
              {
                if (::std::char_traits<char16_t>::lt(__s2[__i], __s1[__i]))
                  {
                    return 1;
                  }
              }
          }
        return 0;
      }
      static inline ::std::size_t length(const ::std::char_traits<char16_t>::char_type *__s)
      {
        ::std::size_t __i(0);
        while (!::std::char_traits<char16_t>::eq(__s[__i], ::std::char_traits<char16_t>::char_type()))
          {
             ++__i;
          }
        return __i;
      }
      static inline const ::std::char_traits<char16_t>::char_type *find(const ::std::char_traits<char16_t>::char_type *__s, ::std::size_t __n, const ::std::char_traits<char16_t>::char_type &__a)
      {
        for (::std::size_t __i(0); __i < __n;  ++__i)
          {
            if (::std::char_traits<char16_t>::eq(__s[__i], __a))
              {
                return __s + __i;
              }
          }
        return 0;
      }
      static inline ::std::char_traits<char16_t>::char_type *move(::std::char_traits<char16_t>::char_type *__s1, const ::std::char_traits<char16_t>::char_type *__s2, ::std::size_t __n)
      {
        return static_cast< ::std::char_traits<char16_t>::char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(::std::char_traits<char16_t>::char_type)));
      }
      static inline ::std::char_traits<char16_t>::char_type *copy(::std::char_traits<char16_t>::char_type *__s1, const ::std::char_traits<char16_t>::char_type *__s2, ::std::size_t __n)
      {
        return static_cast< ::std::char_traits<char16_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(::std::char_traits<char16_t>::char_type)));
      }
      static inline ::std::char_traits<char16_t>::char_type *assign(::std::char_traits<char16_t>::char_type *__s, ::std::size_t __n, ::std::char_traits<char16_t>::char_type __a)
      {
        for (::std::size_t __i(0); __i < __n;  ++__i)
          {
            ::std::char_traits<char16_t>::assign(__s[__i], __a);
          }
        return __s;
      }
      static inline constexpr ::std::char_traits<char16_t>::char_type to_char_type(const ::std::char_traits<char16_t>::int_type &__c) noexcept(true)
      {
        return (::std::char_traits<char16_t>::char_type)__c;
      }
      static inline constexpr ::std::char_traits<char16_t>::int_type to_int_type(const ::std::char_traits<char16_t>::char_type &__c) noexcept(true)
      {
        return (::std::char_traits<char16_t>::int_type)__c;
      }
      static inline constexpr bool eq_int_type(const ::std::char_traits<char16_t>::int_type &__c1, const ::std::char_traits<char16_t>::int_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr ::std::char_traits<char16_t>::int_type eof() noexcept(true)
      {
        return static_cast< ::std::char_traits<char16_t>::int_type>( -1);
      }
      static inline constexpr ::std::char_traits<char16_t>::int_type not_eof(const ::std::char_traits<char16_t>::int_type &__c) noexcept(true)
      {
        return ::std::char_traits<char16_t>::eq_int_type(__c, ::std::char_traits<char16_t>::eof()) ? 0 : __c;
      }
  };
  template <>
  struct  char_traits<char32_t>
  {
      typedef char32_t char_type;
      typedef ::uint_least32_t int_type;
      typedef ::std::streamoff off_type;
      typedef ::std::u32streampos pos_type;
      typedef ::mbstate_t state_type;
      static inline void assign(::std::char_traits<char32_t>::char_type &__c1, const ::std::char_traits<char32_t>::char_type &__c2) noexcept(true)
      {
        __c1 = __c2;
      }
      static inline constexpr bool eq(const ::std::char_traits<char32_t>::char_type &__c1, const ::std::char_traits<char32_t>::char_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr bool lt(const ::std::char_traits<char32_t>::char_type &__c1, const ::std::char_traits<char32_t>::char_type &__c2) noexcept(true)
      {
        return __c1 < __c2;
      }
      static inline int compare(const ::std::char_traits<char32_t>::char_type *__s1, const ::std::char_traits<char32_t>::char_type *__s2, ::std::size_t __n)
      {
        for (::std::size_t __i(0); __i < __n;  ++__i)
          {
            if (::std::char_traits<char32_t>::lt(__s1[__i], __s2[__i]))
              {
                return  -1;
              }
            else
              {
                if (::std::char_traits<char32_t>::lt(__s2[__i], __s1[__i]))
                  {
                    return 1;
                  }
              }
          }
        return 0;
      }
      static inline ::std::size_t length(const ::std::char_traits<char32_t>::char_type *__s)
      {
        ::std::size_t __i(0);
        while (!::std::char_traits<char32_t>::eq(__s[__i], ::std::char_traits<char32_t>::char_type()))
          {
             ++__i;
          }
        return __i;
      }
      static inline const ::std::char_traits<char32_t>::char_type *find(const ::std::char_traits<char32_t>::char_type *__s, ::std::size_t __n, const ::std::char_traits<char32_t>::char_type &__a)
      {
        for (::std::size_t __i(0); __i < __n;  ++__i)
          {
            if (::std::char_traits<char32_t>::eq(__s[__i], __a))
              {
                return __s + __i;
              }
          }
        return 0;
      }
      static inline ::std::char_traits<char32_t>::char_type *move(::std::char_traits<char32_t>::char_type *__s1, const ::std::char_traits<char32_t>::char_type *__s2, ::std::size_t __n)
      {
        return static_cast< ::std::char_traits<char32_t>::char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(::std::char_traits<char32_t>::char_type)));
      }
      static inline ::std::char_traits<char32_t>::char_type *copy(::std::char_traits<char32_t>::char_type *__s1, const ::std::char_traits<char32_t>::char_type *__s2, ::std::size_t __n)
      {
        return static_cast< ::std::char_traits<char32_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(::std::char_traits<char32_t>::char_type)));
      }
      static inline ::std::char_traits<char32_t>::char_type *assign(::std::char_traits<char32_t>::char_type *__s, ::std::size_t __n, ::std::char_traits<char32_t>::char_type __a)
      {
        for (::std::size_t __i(0); __i < __n;  ++__i)
          {
            ::std::char_traits<char32_t>::assign(__s[__i], __a);
          }
        return __s;
      }
      static inline constexpr ::std::char_traits<char32_t>::char_type to_char_type(const ::std::char_traits<char32_t>::int_type &__c) noexcept(true)
      {
        return (::std::char_traits<char32_t>::char_type)__c;
      }
      static inline constexpr ::std::char_traits<char32_t>::int_type to_int_type(const ::std::char_traits<char32_t>::char_type &__c) noexcept(true)
      {
        return (::std::char_traits<char32_t>::int_type)__c;
      }
      static inline constexpr bool eq_int_type(const ::std::char_traits<char32_t>::int_type &__c1, const ::std::char_traits<char32_t>::int_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr ::std::char_traits<char32_t>::int_type eof() noexcept(true)
      {
        return static_cast< ::std::char_traits<char32_t>::int_type>( -1);
      }
      static inline constexpr ::std::char_traits<char32_t>::int_type not_eof(const ::std::char_traits<char32_t>::int_type &__c) noexcept(true)
      {
        return ::std::char_traits<char32_t>::eq_int_type(__c, ::std::char_traits<char32_t>::eof()) ? 0 : __c;
      }
  };
}
struct  lconv
{
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    char int_p_cs_precedes;
    char int_p_sep_by_space;
    char int_n_cs_precedes;
    char int_n_sep_by_space;
    char int_p_sign_posn;
    char int_n_sign_posn;
};
extern "C"
{
  extern char *setlocale(int __category, const char *__locale) throw();
}
extern "C"
{
  extern ::lconv *localeconv() throw();
}
extern "C"
{
  extern ::__locale_t newlocale(int __category_mask, const char *__locale, ::__locale_t __base) throw();
}
extern "C"
{
  extern ::__locale_t duplocale(::__locale_t __dataset) throw();
}
extern "C"
{
  extern void freelocale(::__locale_t __dataset) throw();
}
extern "C"
{
  extern ::__locale_t uselocale(::__locale_t __dataset) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
extern "C"
  {
    ::__locale_t __uselocale(::__locale_t) throw();
  }
}
namespace std __attribute__((__visibility__("default"))) {
  typedef ::__locale_t __c_locale;
  inline int __convert_from_v(const ::std::__c_locale &__cloc __attribute__((__unused__)), char *__out, const int __size __attribute__((__unused__)), const char *__fmt, ...)
  {
    ::std::__c_locale __old(__gnu_cxx::__uselocale(__cloc));
    ::__builtin_va_list __args;
    __builtin_va_start(__args, __fmt);
    const int __ret(__builtin_vsnprintf(__out, __size, __fmt, __args));
    __builtin_va_end(__args);
    __gnu_cxx::__uselocale(__old);
    return __ret;
  }
}
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short int __int16_t;
typedef unsigned short int __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long int __int64_t;
typedef unsigned long int __uint64_t;
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
struct  __fsid_t
{
    int __val[2L];
};
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long int __blksize_t;
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;
typedef long int __fsword_t;
typedef long int __ssize_t;
typedef long int __syscall_slong_t;
typedef unsigned long int __syscall_ulong_t;
typedef ::__off64_t __loff_t;
typedef ::__quad_t *__qaddr_t;
typedef char *__caddr_t;
typedef long int __intptr_t;
typedef unsigned int __socklen_t;
extern "C"
{
  static inline unsigned int __bswap_32(unsigned int __bsx)
  {
    return __builtin_bswap32(__bsx);
  }
}
extern "C"
{
  static inline ::__uint64_t __bswap_64(::__uint64_t __bsx)
  {
    return __builtin_bswap64(__bsx);
  }
}
enum mcc_enum_anon_44
{
  _ISupper = 0 < 8 ? 1 << 0 << 8 : 1 << 0 >> 8,
  _ISlower = 1 < 8 ? 1 << 1 << 8 : 1 << 1 >> 8,
  _ISalpha = 2 < 8 ? 1 << 2 << 8 : 1 << 2 >> 8,
  _ISdigit = 3 < 8 ? 1 << 3 << 8 : 1 << 3 >> 8,
  _ISxdigit = 4 < 8 ? 1 << 4 << 8 : 1 << 4 >> 8,
  _ISspace = 5 < 8 ? 1 << 5 << 8 : 1 << 5 >> 8,
  _ISprint = 6 < 8 ? 1 << 6 << 8 : 1 << 6 >> 8,
  _ISgraph = 7 < 8 ? 1 << 7 << 8 : 1 << 7 >> 8,
  _ISblank = 8 < 8 ? 1 << 8 << 8 : 1 << 8 >> 8,
  _IScntrl = 9 < 8 ? 1 << 9 << 8 : 1 << 9 >> 8,
  _ISpunct = 10 < 8 ? 1 << 10 << 8 : 1 << 10 >> 8,
  _ISalnum = 11 < 8 ? 1 << 11 << 8 : 1 << 11 >> 8
};
extern "C"
{
  extern const unsigned short int **__ctype_b_loc() throw() __attribute__((__const__));
}
extern "C"
{
  extern const ::__int32_t **__ctype_tolower_loc() throw() __attribute__((__const__));
}
extern "C"
{
  extern const ::__int32_t **__ctype_toupper_loc() throw() __attribute__((__const__));
}
extern "C"
{
  extern int isalnum(int) throw();
}
extern "C"
{
  extern int isalpha(int) throw();
}
extern "C"
{
  extern int iscntrl(int) throw();
}
extern "C"
{
  extern int isdigit(int) throw();
}
extern "C"
{
  extern int islower(int) throw();
}
extern "C"
{
  extern int isgraph(int) throw();
}
extern "C"
{
  extern int isprint(int) throw();
}
extern "C"
{
  extern int ispunct(int) throw();
}
extern "C"
{
  extern int isspace(int) throw();
}
extern "C"
{
  extern int isupper(int) throw();
}
extern "C"
{
  extern int isxdigit(int) throw();
}
extern "C"
{
  extern int tolower(int __c) throw();
}
extern "C"
{
  extern int toupper(int __c) throw();
}
extern "C"
{
  extern int isblank(int) throw();
}
extern "C"
{
  extern int isctype(int __c, int __mask) throw();
}
extern "C"
{
  extern int isascii(int __c) throw();
}
extern "C"
{
  extern int toascii(int __c) throw();
}
extern "C"
{
  extern int _toupper(int) throw();
}
extern "C"
{
  extern int _tolower(int) throw();
}
extern "C"
{
  extern int isalnum_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isalpha_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int iscntrl_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isdigit_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int islower_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isgraph_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isprint_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int ispunct_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isspace_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isupper_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isxdigit_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isblank_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int __tolower_l(int __c, ::__locale_t __l) throw();
}
extern "C"
{
  extern int tolower_l(int __c, ::__locale_t __l) throw();
}
extern "C"
{
  extern int __toupper_l(int __c, ::__locale_t __l) throw();
}
extern "C"
{
  extern int toupper_l(int __c, ::__locale_t __l) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
  using ::isblank;
  class locale;
  template < typename _Facet >
  bool has_facet(const ::std::locale &__loc) throw();
  template < typename _Facet >
  const _Facet &use_facet(const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isspace(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isprint(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool iscntrl(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isupper(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool islower(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isalpha(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isdigit(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool ispunct(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isxdigit(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isalnum(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isgraph(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline _CharT toupper(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline _CharT tolower(_CharT __c, const ::std::locale &__loc);
  struct ctype_base;
  template < typename _CharT >
  class ctype;
  template <>
  class ctype<char>;
  template <>
  class ctype<wchar_t>;
  template < typename _CharT >
  class ctype_byname;
  class codecvt_base;
  template < typename _InternT, typename _ExternT, typename _StateT >
  class codecvt;
  template <>
  class codecvt<char, char, ::__mbstate_t>;
  template <>
  class codecvt<wchar_t, char, ::__mbstate_t>;
  template < typename _InternT, typename _ExternT, typename _StateT >
  class codecvt_byname;
  template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT> >
  class num_get;
  template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT> >
  class num_put;
  template < typename _CharT >
  class numpunct;
  template < typename _CharT >
  class numpunct_byname;
  template < typename _CharT >
  class collate;
  template < typename _CharT >
  class collate_byname;
  class time_base;
  template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT> >
  class time_get;
  template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT> >
  class time_get_byname;
  template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT> >
  class time_put;
  template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT> >
  class time_put_byname;
  class money_base;
  template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT> >
  class money_get;
  template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT> >
  class money_put;
  template < typename _CharT, bool _Intl = false >
  class moneypunct;
  template < typename _CharT, bool _Intl = false >
  class moneypunct_byname;
  struct messages_base;
  template < typename _CharT >
  class messages;
  template < typename _CharT >
  class messages_byname;
}
#pragma GCC visibility push(default)
typedef ::__time_t time_t;
struct  timespec
{
    ::__time_t tv_sec;
    ::__syscall_slong_t tv_nsec;
};
typedef ::__pid_t pid_t;
struct  sched_param
{
    int __sched_priority;
};
extern "C"
{
  extern int clone(int (*__fn)(void *), void *__child_stack, int __flags, void *__arg, ...) throw();
}
extern "C"
{
  extern int unshare(int __flags) throw();
}
extern "C"
{
  extern int sched_getcpu() throw();
}
extern "C"
{
  extern int setns(int __fd, int __nstype) throw();
}
struct  __sched_param
{
    int __sched_priority;
};
typedef unsigned long int __cpu_mask;
struct  cpu_set_t
{
    ::__cpu_mask __bits[64L];
};
extern "C"
{
  extern int __sched_cpucount(::size_t __setsize, const ::cpu_set_t *__setp) throw();
}
extern "C"
{
  extern ::cpu_set_t *__sched_cpualloc(::size_t __count) throw();
}
extern "C"
{
  extern void __sched_cpufree(::cpu_set_t *__set) throw();
}
extern "C"
{
  extern int sched_setparam(::__pid_t __pid, const ::sched_param *__param) throw();
}
extern "C"
{
  extern int sched_getparam(::__pid_t __pid, ::sched_param *__param) throw();
}
extern "C"
{
  extern int sched_setscheduler(::__pid_t __pid, int __policy, const ::sched_param *__param) throw();
}
extern "C"
{
  extern int sched_getscheduler(::__pid_t __pid) throw();
}
extern "C"
{
  extern int sched_yield() throw();
}
extern "C"
{
  extern int sched_get_priority_max(int __algorithm) throw();
}
extern "C"
{
  extern int sched_get_priority_min(int __algorithm) throw();
}
extern "C"
{
  extern int sched_rr_get_interval(::__pid_t __pid, ::timespec *__t) throw();
}
extern "C"
{
  extern int sched_setaffinity(::__pid_t __pid, ::size_t __cpusetsize, const ::cpu_set_t *__cpuset) throw();
}
extern "C"
{
  extern int sched_getaffinity(::__pid_t __pid, ::size_t __cpusetsize, ::cpu_set_t *__cpuset) throw();
}
struct  timeval
{
    ::__time_t tv_sec;
    ::__suseconds_t tv_usec;
};
struct  timex
{
    unsigned int modes;
    ::__syscall_slong_t offset;
    ::__syscall_slong_t freq;
    ::__syscall_slong_t maxerror;
    ::__syscall_slong_t esterror;
    int status;
    ::__syscall_slong_t constant;
    ::__syscall_slong_t precision;
    ::__syscall_slong_t tolerance;
    ::timeval time;
    ::__syscall_slong_t tick;
    ::__syscall_slong_t ppsfreq;
    ::__syscall_slong_t jitter;
    int shift;
    ::__syscall_slong_t stabil;
    ::__syscall_slong_t jitcnt;
    ::__syscall_slong_t calcnt;
    ::__syscall_slong_t errcnt;
    ::__syscall_slong_t stbcnt;
    int tai;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
};
extern "C"
{
  extern int clock_adjtime(::__clockid_t __clock_id, ::timex *__utx) throw();
}
typedef ::__clock_t clock_t;
typedef ::__clockid_t clockid_t;
typedef ::__timer_t timer_t;
struct  tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long int tm_gmtoff;
    const char *tm_zone;
};
struct  itimerspec
{
    ::timespec it_interval;
    ::timespec it_value;
};
struct sigevent;
extern "C"
{
  extern ::clock_t clock() throw();
}
extern "C"
{
  extern ::time_t time(::time_t *__timer) throw();
}
extern "C"
{
  extern double difftime(::time_t __time1, ::time_t __time0) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::time_t mktime(::tm *__tp) throw();
}
extern "C"
{
  extern ::size_t strftime(char *__restrict __s, ::size_t __maxsize, const char *__restrict __format, const ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern char *strptime(const char *__restrict __s, const char *__restrict __fmt, ::tm *__tp) throw();
}
extern "C"
{
  extern ::size_t strftime_l(char *__restrict __s, ::size_t __maxsize, const char *__restrict __format, const ::tm *__restrict __tp, ::__locale_t __loc) throw();
}
extern "C"
{
  extern char *strptime_l(const char *__restrict __s, const char *__restrict __fmt, ::tm *__tp, ::__locale_t __loc) throw();
}
extern "C"
{
  extern ::tm *gmtime(const ::time_t *__timer) throw();
}
extern "C"
{
  extern ::tm *localtime(const ::time_t *__timer) throw();
}
extern "C"
{
  extern ::tm *gmtime_r(const ::time_t *__restrict __timer, ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern ::tm *localtime_r(const ::time_t *__restrict __timer, ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern char *asctime(const ::tm *__tp) throw();
}
extern "C"
{
  extern char *ctime(const ::time_t *__timer) throw();
}
extern "C"
{
  extern char *asctime_r(const ::tm *__restrict __tp, char *__restrict __buf) throw();
}
extern "C"
{
  extern char *ctime_r(const ::time_t *__restrict __timer, char *__restrict __buf) throw();
}
extern "C"
{
  extern char *__tzname[2L];
}
extern "C"
{
  extern int __daylight;
}
extern "C"
{
  extern long int __timezone;
}
extern "C"
{
  extern char *tzname[2L];
}
extern "C"
{
  extern void tzset() throw();
}
extern "C"
{
  extern int daylight;
}
extern "C"
{
  extern long int timezone;
}
extern "C"
{
  extern int stime(const ::time_t *__when) throw();
}
extern "C"
{
  extern ::time_t timegm(::tm *__tp) throw();
}
extern "C"
{
  extern ::time_t timelocal(::tm *__tp) throw();
}
extern "C"
{
  extern int dysize(int __year) throw() __attribute__((__const__));
}
extern "C"
{
  extern int nanosleep(const ::timespec *__requested_time, ::timespec *__remaining);
}
extern "C"
{
  extern int clock_getres(::clockid_t __clock_id, ::timespec *__res) throw();
}
extern "C"
{
  extern int clock_gettime(::clockid_t __clock_id, ::timespec *__tp) throw();
}
extern "C"
{
  extern int clock_settime(::clockid_t __clock_id, const ::timespec *__tp) throw();
}
extern "C"
{
  extern int clock_nanosleep(::clockid_t __clock_id, int __flags, const ::timespec *__req, ::timespec *__rem);
}
extern "C"
{
  extern int clock_getcpuclockid(::pid_t __pid, ::clockid_t *__clock_id) throw();
}
extern "C"
{
  extern int timer_create(::clockid_t __clock_id, ::sigevent *__restrict __evp, ::timer_t *__restrict __timerid) throw();
}
extern "C"
{
  extern int timer_delete(::timer_t __timerid) throw();
}
extern "C"
{
  extern int timer_settime(::timer_t __timerid, int __flags, const ::itimerspec *__restrict __value, ::itimerspec *__restrict __ovalue) throw();
}
extern "C"
{
  extern int timer_gettime(::timer_t __timerid, ::itimerspec *__value) throw();
}
extern "C"
{
  extern int timer_getoverrun(::timer_t __timerid) throw();
}
extern "C"
{
  extern int timespec_get(::timespec *__ts, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int getdate_err;
}
extern "C"
{
  extern ::tm *getdate(const char *__string);
}
extern "C"
{
  extern int getdate_r(const char *__restrict __string, ::tm *__restrict __resbufp);
}
typedef unsigned long int pthread_t;
union  pthread_attr_t
{
    char __size[56L];
    long int __align;
};
struct __pthread_internal_list;
struct  __pthread_internal_list
{
    ::__pthread_internal_list *__prev;
    ::__pthread_internal_list *__next;
};
typedef ::__pthread_internal_list __pthread_list_t;
union  pthread_mutex_t
{
    struct  __pthread_mutex_s
    {
        int __lock;
        unsigned int __count;
        int __owner;
        unsigned int __nusers;
        int __kind;
        short int __spins;
        short int __elision;
        ::__pthread_list_t __list;
    };
    ::pthread_mutex_t::__pthread_mutex_s __data;
    char __size[40L];
    long int __align;
};
union  pthread_mutexattr_t
{
    char __size[4L];
    int __align;
};
union  pthread_cond_t
{
    struct  mcc_struct_anon_31
    {
        int __lock;
        unsigned int __futex;
        __extension__ unsigned long long int __total_seq;
        __extension__ unsigned long long int __wakeup_seq;
        __extension__ unsigned long long int __woken_seq;
        void *__mutex;
        unsigned int __nwaiters;
        unsigned int __broadcast_seq;
    };
    ::pthread_cond_t::mcc_struct_anon_31 __data;
    char __size[48L];
    __extension__ long long int __align;
};
union  pthread_condattr_t
{
    char __size[4L];
    int __align;
};
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
union  pthread_rwlock_t
{
    struct  mcc_struct_anon_34
    {
        int __lock;
        unsigned int __nr_readers;
        unsigned int __readers_wakeup;
        unsigned int __writer_wakeup;
        unsigned int __nr_readers_queued;
        unsigned int __nr_writers_queued;
        int __writer;
        int __shared;
        unsigned long int __pad1;
        unsigned long int __pad2;
        unsigned int __flags;
    };
    ::pthread_rwlock_t::mcc_struct_anon_34 __data;
    char __size[56L];
    long int __align;
};
union  pthread_rwlockattr_t
{
    char __size[8L];
    long int __align;
};
typedef volatile int pthread_spinlock_t;
union  pthread_barrier_t
{
    char __size[32L];
    long int __align;
};
union  pthread_barrierattr_t
{
    char __size[4L];
    int __align;
};
typedef long int __jmp_buf[8L];
enum mcc_enum_anon_45
{
  PTHREAD_CREATE_JOINABLE = 0,
  PTHREAD_CREATE_DETACHED = 1
};
enum mcc_enum_anon_46
{
  PTHREAD_MUTEX_TIMED_NP = 0,
  PTHREAD_MUTEX_RECURSIVE_NP = 1,
  PTHREAD_MUTEX_ERRORCHECK_NP = 2,
  PTHREAD_MUTEX_ADAPTIVE_NP = 3,
  PTHREAD_MUTEX_NORMAL = ::PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = ::PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = ::PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = ::PTHREAD_MUTEX_NORMAL,
  PTHREAD_MUTEX_FAST_NP = ::PTHREAD_MUTEX_TIMED_NP
};
enum mcc_enum_anon_47
{
  PTHREAD_MUTEX_STALLED = 0,
  PTHREAD_MUTEX_STALLED_NP = ::PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST = 1,
  PTHREAD_MUTEX_ROBUST_NP = ::PTHREAD_MUTEX_ROBUST
};
enum mcc_enum_anon_48
{
  PTHREAD_PRIO_NONE = 0,
  PTHREAD_PRIO_INHERIT = 1,
  PTHREAD_PRIO_PROTECT = 2
};
enum mcc_enum_anon_49
{
  PTHREAD_RWLOCK_PREFER_READER_NP = 0,
  PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
  PTHREAD_RWLOCK_DEFAULT_NP = ::PTHREAD_RWLOCK_PREFER_READER_NP
};
enum mcc_enum_anon_50
{
  PTHREAD_INHERIT_SCHED = 0,
  PTHREAD_EXPLICIT_SCHED = 1
};
enum mcc_enum_anon_51
{
  PTHREAD_SCOPE_SYSTEM = 0,
  PTHREAD_SCOPE_PROCESS = 1
};
enum mcc_enum_anon_52
{
  PTHREAD_PROCESS_PRIVATE = 0,
  PTHREAD_PROCESS_SHARED = 1
};
struct _pthread_cleanup_buffer;
struct  _pthread_cleanup_buffer
{
    void (*__routine)(void *);
    void *__arg;
    int __canceltype;
    ::_pthread_cleanup_buffer *__prev;
};
enum mcc_enum_anon_53
{
  PTHREAD_CANCEL_ENABLE = 0,
  PTHREAD_CANCEL_DISABLE = 1
};
enum mcc_enum_anon_54
{
  PTHREAD_CANCEL_DEFERRED = 0,
  PTHREAD_CANCEL_ASYNCHRONOUS = 1
};
extern "C"
{
  extern int pthread_create(::pthread_t *__restrict __newthread, const ::pthread_attr_t *__restrict __attr, void *(*__start_routine)(void *), void *__restrict __arg) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern void pthread_exit(void *__retval) __attribute__((__noreturn__));
}
extern "C"
{
  extern int pthread_join(::pthread_t __th, void **__thread_return);
}
extern "C"
{
  extern int pthread_tryjoin_np(::pthread_t __th, void **__thread_return) throw();
}
extern "C"
{
  extern int pthread_timedjoin_np(::pthread_t __th, void **__thread_return, const ::timespec *__abstime);
}
extern "C"
{
  extern int pthread_detach(::pthread_t __th) throw();
}
extern "C"
{
  extern ::pthread_t pthread_self() throw() __attribute__((__const__));
}
extern "C"
{
  extern inline int pthread_equal(::pthread_t __thread1, ::pthread_t __thread2) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int pthread_attr_init(::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_destroy(::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getdetachstate(const ::pthread_attr_t *__attr, int *__detachstate) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setdetachstate(::pthread_attr_t *__attr, int __detachstate) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getguardsize(const ::pthread_attr_t *__attr, ::size_t *__guardsize) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setguardsize(::pthread_attr_t *__attr, ::size_t __guardsize) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getschedparam(const ::pthread_attr_t *__restrict __attr, ::sched_param *__restrict __param) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setschedparam(::pthread_attr_t *__restrict __attr, const ::sched_param *__restrict __param) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_getschedpolicy(const ::pthread_attr_t *__restrict __attr, int *__restrict __policy) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setschedpolicy(::pthread_attr_t *__attr, int __policy) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getinheritsched(const ::pthread_attr_t *__restrict __attr, int *__restrict __inherit) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setinheritsched(::pthread_attr_t *__attr, int __inherit) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getscope(const ::pthread_attr_t *__restrict __attr, int *__restrict __scope) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setscope(::pthread_attr_t *__attr, int __scope) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getstackaddr(const ::pthread_attr_t *__restrict __attr, void **__restrict __stackaddr) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__deprecated__));
}
extern "C"
{
  extern int pthread_attr_setstackaddr(::pthread_attr_t *__attr, void *__stackaddr) throw() __attribute__((__nonnull__(1))) __attribute__((__deprecated__));
}
extern "C"
{
  extern int pthread_attr_getstacksize(const ::pthread_attr_t *__restrict __attr, ::size_t *__restrict __stacksize) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setstacksize(::pthread_attr_t *__attr, ::size_t __stacksize) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getstack(const ::pthread_attr_t *__restrict __attr, void **__restrict __stackaddr, ::size_t *__restrict __stacksize) throw() __attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern int pthread_attr_setstack(::pthread_attr_t *__attr, void *__stackaddr, ::size_t __stacksize) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_setaffinity_np(::pthread_attr_t *__attr, ::size_t __cpusetsize, const ::cpu_set_t *__cpuset) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern int pthread_attr_getaffinity_np(const ::pthread_attr_t *__attr, ::size_t __cpusetsize, ::cpu_set_t *__cpuset) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern int pthread_getattr_default_np(::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_setattr_default_np(const ::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_getattr_np(::pthread_t __th, ::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int pthread_setschedparam(::pthread_t __target_thread, int __policy, const ::sched_param *__param) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int pthread_getschedparam(::pthread_t __target_thread, int *__restrict __policy, ::sched_param *__restrict __param) throw() __attribute__((__nonnull__(2, 3)));
}
extern "C"
{
  extern int pthread_setschedprio(::pthread_t __target_thread, int __prio) throw();
}
extern "C"
{
  extern int pthread_getname_np(::pthread_t __target_thread, char *__buf, ::size_t __buflen) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int pthread_setname_np(::pthread_t __target_thread, const char *__name) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int pthread_getconcurrency() throw();
}
extern "C"
{
  extern int pthread_setconcurrency(int __level) throw();
}
extern "C"
{
  extern int pthread_yield() throw();
}
extern "C"
{
  extern int pthread_setaffinity_np(::pthread_t __th, ::size_t __cpusetsize, const ::cpu_set_t *__cpuset) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int pthread_getaffinity_np(::pthread_t __th, ::size_t __cpusetsize, ::cpu_set_t *__cpuset) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int pthread_once(::pthread_once_t *__once_control, void (*__init_routine)()) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_setcancelstate(int __state, int *__oldstate);
}
extern "C"
{
  extern int pthread_setcanceltype(int __type, int *__oldtype);
}
extern "C"
{
  extern int pthread_cancel(::pthread_t __th);
}
extern "C"
{
  extern void pthread_testcancel();
}
struct __attribute__((__aligned__))  __pthread_unwind_buf_t
{
    struct  mcc_struct_anon_39
    {
        ::__jmp_buf __cancel_jmp_buf;
        int __mask_was_saved;
    };
    ::__pthread_unwind_buf_t::mcc_struct_anon_39 __cancel_jmp_buf[1L];
    void *__pad[4L];
};
struct  __pthread_cleanup_frame
{
    void (*__cancel_routine)(void *);
    void *__cancel_arg;
    int __do_it;
    int __cancel_type;
};
class  __pthread_cleanup_class
{
    void (*__cancel_routine)(void *);
    void *__cancel_arg;
    int __do_it;
    int __cancel_type;
  public:
    inline __pthread_cleanup_class(void (*__fct)(void *), void *__arg)
      : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1)
    {
    }
    inline ~__pthread_cleanup_class()
    {
      if ((*this).__do_it)
        {
          (*this).__cancel_routine((*this).__cancel_arg);
        }
    }
    inline void __setdoit(int __newval)
    {
      (*this).__do_it = __newval;
    }
    inline void __defer()
    {
      ::pthread_setcanceltype(::PTHREAD_CANCEL_DEFERRED, &(*this).__cancel_type);
    }
    inline void __restore() const 
    {
      ::pthread_setcanceltype((*this).__cancel_type, 0);
    }
};
struct __jmp_buf_tag;
extern "C"
{
  extern int __sigsetjmp(::__jmp_buf_tag *__env, int __savemask) throw();
}
extern "C"
{
  extern int pthread_mutex_init(::pthread_mutex_t *__mutex, const ::pthread_mutexattr_t *__mutexattr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_destroy(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_trylock(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_lock(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_timedlock(::pthread_mutex_t *__restrict __mutex, const ::timespec *__restrict __abstime) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutex_unlock(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_getprioceiling(const ::pthread_mutex_t *__restrict __mutex, int *__restrict __prioceiling) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutex_setprioceiling(::pthread_mutex_t *__restrict __mutex, int __prioceiling, int *__restrict __old_ceiling) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern int pthread_mutex_consistent(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_consistent_np(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_init(::pthread_mutexattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_destroy(::pthread_mutexattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getpshared(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setpshared(::pthread_mutexattr_t *__attr, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_gettype(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __kind) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_settype(::pthread_mutexattr_t *__attr, int __kind) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getprotocol(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __protocol) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setprotocol(::pthread_mutexattr_t *__attr, int __protocol) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getprioceiling(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __prioceiling) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setprioceiling(::pthread_mutexattr_t *__attr, int __prioceiling) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getrobust(const ::pthread_mutexattr_t *__attr, int *__robustness) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_getrobust_np(const ::pthread_mutexattr_t *__attr, int *__robustness) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setrobust(::pthread_mutexattr_t *__attr, int __robustness) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_setrobust_np(::pthread_mutexattr_t *__attr, int __robustness) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_init(::pthread_rwlock_t *__restrict __rwlock, const ::pthread_rwlockattr_t *__restrict __attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_destroy(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_rdlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_tryrdlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_timedrdlock(::pthread_rwlock_t *__restrict __rwlock, const ::timespec *__restrict __abstime) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlock_wrlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_trywrlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_timedwrlock(::pthread_rwlock_t *__restrict __rwlock, const ::timespec *__restrict __abstime) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlock_unlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_init(::pthread_rwlockattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_destroy(::pthread_rwlockattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_getpshared(const ::pthread_rwlockattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlockattr_setpshared(::pthread_rwlockattr_t *__attr, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_getkind_np(const ::pthread_rwlockattr_t *__restrict __attr, int *__restrict __pref) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlockattr_setkind_np(::pthread_rwlockattr_t *__attr, int __pref) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_init(::pthread_cond_t *__restrict __cond, const ::pthread_condattr_t *__restrict __cond_attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_destroy(::pthread_cond_t *__cond) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_signal(::pthread_cond_t *__cond) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_broadcast(::pthread_cond_t *__cond) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_wait(::pthread_cond_t *__restrict __cond, ::pthread_mutex_t *__restrict __mutex) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_cond_timedwait(::pthread_cond_t *__restrict __cond, ::pthread_mutex_t *__restrict __mutex, const ::timespec *__restrict __abstime) __attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern int pthread_condattr_init(::pthread_condattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_condattr_destroy(::pthread_condattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_condattr_getpshared(const ::pthread_condattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_condattr_setpshared(::pthread_condattr_t *__attr, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_condattr_getclock(const ::pthread_condattr_t *__restrict __attr, ::__clockid_t *__restrict __clock_id) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_condattr_setclock(::pthread_condattr_t *__attr, ::__clockid_t __clock_id) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_init(::pthread_spinlock_t *__lock, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_destroy(::pthread_spinlock_t *__lock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_lock(::pthread_spinlock_t *__lock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_trylock(::pthread_spinlock_t *__lock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_unlock(::pthread_spinlock_t *__lock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrier_init(::pthread_barrier_t *__restrict __barrier, const ::pthread_barrierattr_t *__restrict __attr, unsigned int __count) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrier_destroy(::pthread_barrier_t *__barrier) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrier_wait(::pthread_barrier_t *__barrier) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrierattr_init(::pthread_barrierattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrierattr_destroy(::pthread_barrierattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrierattr_getpshared(const ::pthread_barrierattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_barrierattr_setpshared(::pthread_barrierattr_t *__attr, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_key_create(::pthread_key_t *__key, void (*__destr_function)(void *)) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_key_delete(::pthread_key_t __key) throw();
}
extern "C"
{
  extern void *pthread_getspecific(::pthread_key_t __key) throw();
}
extern "C"
{
  extern int pthread_setspecific(::pthread_key_t __key, const void *__pointer) throw();
}
extern "C"
{
  extern int pthread_getcpuclockid(::pthread_t __thread_id, ::__clockid_t *__clock_id) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int pthread_atfork(void (*__prepare)(), void (*__parent)(), void (*__child)()) throw();
}
extern "C"
{
  extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int pthread_equal(::pthread_t __thread1, ::pthread_t __thread2) throw()
  {
    return __thread1 == __thread2;
  }
}
typedef ::pthread_t __gthread_t;
typedef ::pthread_key_t __gthread_key_t;
typedef ::pthread_once_t __gthread_once_t;
typedef ::pthread_mutex_t __gthread_mutex_t;
typedef ::pthread_mutex_t __gthread_recursive_mutex_t;
typedef ::pthread_cond_t __gthread_cond_t;
typedef ::timespec __gthread_time_t;
static int __gthrw_pthread_once(::pthread_once_t *, void (*)()) throw() __attribute__((__weakref__("pthread_once")));
static void *__gthrw_pthread_getspecific(::pthread_key_t) throw() __attribute__((__weakref__("pthread_getspecific")));
static int __gthrw_pthread_setspecific(::pthread_key_t, const void *) throw() __attribute__((__weakref__("pthread_setspecific")));
static int __gthrw_pthread_create(::pthread_t *__restrict , const ::pthread_attr_t *__restrict , void *(*)(void *), void *__restrict ) throw() __attribute__((__weakref__("pthread_create")));
static int __gthrw_pthread_join(::pthread_t, void **) throw() __attribute__((__weakref__("pthread_join")));
static int __gthrw_pthread_equal(::pthread_t, ::pthread_t) throw() __attribute__((__weakref__("pthread_equal")));
static ::pthread_t __gthrw_pthread_self() throw() __attribute__((__weakref__("pthread_self")));
static int __gthrw_pthread_detach(::pthread_t) throw() __attribute__((__weakref__("pthread_detach")));
static int __gthrw_pthread_cancel(::pthread_t) throw() __attribute__((__weakref__("pthread_cancel")));
static int __gthrw_sched_yield() throw() __attribute__((__weakref__("sched_yield")));
static int __gthrw_pthread_mutex_lock(::pthread_mutex_t *) throw() __attribute__((__weakref__("pthread_mutex_lock")));
static int __gthrw_pthread_mutex_trylock(::pthread_mutex_t *) throw() __attribute__((__weakref__("pthread_mutex_trylock")));
static int __gthrw_pthread_mutex_timedlock(::pthread_mutex_t *__restrict , const ::timespec *__restrict ) throw() __attribute__((__weakref__("pthread_mutex_timedlock")));
static int __gthrw_pthread_mutex_unlock(::pthread_mutex_t *) throw() __attribute__((__weakref__("pthread_mutex_unlock")));
static int __gthrw_pthread_mutex_init(::pthread_mutex_t *, const ::pthread_mutexattr_t *) throw() __attribute__((__weakref__("pthread_mutex_init")));
static int __gthrw_pthread_mutex_destroy(::pthread_mutex_t *) throw() __attribute__((__weakref__("pthread_mutex_destroy")));
static int __gthrw_pthread_cond_init(::pthread_cond_t *__restrict , const ::pthread_condattr_t *__restrict ) throw() __attribute__((__weakref__("pthread_cond_init")));
static int __gthrw_pthread_cond_broadcast(::pthread_cond_t *) throw() __attribute__((__weakref__("pthread_cond_broadcast")));
static int __gthrw_pthread_cond_signal(::pthread_cond_t *) throw() __attribute__((__weakref__("pthread_cond_signal")));
static int __gthrw_pthread_cond_wait(::pthread_cond_t *__restrict , ::pthread_mutex_t *__restrict ) throw() __attribute__((__weakref__("pthread_cond_wait")));
static int __gthrw_pthread_cond_timedwait(::pthread_cond_t *__restrict , ::pthread_mutex_t *__restrict , const ::timespec *__restrict ) throw() __attribute__((__weakref__("pthread_cond_timedwait")));
static int __gthrw_pthread_cond_destroy(::pthread_cond_t *) throw() __attribute__((__weakref__("pthread_cond_destroy")));
static int __gthrw_pthread_key_create(::pthread_key_t *, void (*)(void *)) throw() __attribute__((__weakref__("pthread_key_create")));
static int __gthrw_pthread_key_delete(::pthread_key_t) throw() __attribute__((__weakref__("pthread_key_delete")));
static int __gthrw_pthread_mutexattr_init(::pthread_mutexattr_t *) throw() __attribute__((__weakref__("pthread_mutexattr_init")));
static int __gthrw_pthread_mutexattr_settype(::pthread_mutexattr_t *, int) throw() __attribute__((__weakref__("pthread_mutexattr_settype")));
static int __gthrw_pthread_mutexattr_destroy(::pthread_mutexattr_t *) throw() __attribute__((__weakref__("pthread_mutexattr_destroy")));
static int __gthrw___pthread_key_create(::pthread_key_t *, void (*)(void *)) throw() __attribute__((__weakref__("__pthread_key_create")));
static inline int __gthread_active_p()
{
  static void *const __gthread_active_ptr((void *)::__gthrw___pthread_key_create);
  return __gthread_active_ptr != 0;
}
static inline int __gthread_create(::__gthread_t *__threadid, void *(*__func)(void *), void *__args)
{
  return ::__gthrw_pthread_create(__threadid, 0L, __func, __args);
}
static inline int __gthread_join(::__gthread_t __threadid, void **__value_ptr)
{
  return ::__gthrw_pthread_join(__threadid, __value_ptr);
}
static inline int __gthread_detach(::__gthread_t __threadid)
{
  return ::__gthrw_pthread_detach(__threadid);
}
static inline int __gthread_equal(::__gthread_t __t1, ::__gthread_t __t2)
{
  return ::__gthrw_pthread_equal(__t1, __t2);
}
static inline ::__gthread_t __gthread_self()
{
  return ::__gthrw_pthread_self();
}
static inline int __gthread_yield()
{
  return ::__gthrw_sched_yield();
}
static inline int __gthread_once(::__gthread_once_t *__once, void (*__func)())
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_once(__once, __func);
    }
  else
    {
      return  -1;
    }
}
static inline int __gthread_key_create(::__gthread_key_t *__key, void (*__dtor)(void *))
{
  return ::__gthrw_pthread_key_create(__key, __dtor);
}
static inline int __gthread_key_delete(::__gthread_key_t __key)
{
  return ::__gthrw_pthread_key_delete(__key);
}
static inline void *__gthread_getspecific(::__gthread_key_t __key)
{
  return ::__gthrw_pthread_getspecific(__key);
}
static inline int __gthread_setspecific(::__gthread_key_t __key, const void *__ptr)
{
  return ::__gthrw_pthread_setspecific(__key, __ptr);
}
static inline void __gthread_mutex_init_function(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      ::__gthrw_pthread_mutex_init(__mutex, 0L);
    }
}
static inline int __gthread_mutex_destroy(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_destroy(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_lock(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_lock(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_trylock(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_trylock(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_timedlock(::__gthread_mutex_t *__mutex, const ::__gthread_time_t *__abs_timeout)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_timedlock(__mutex, __abs_timeout);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_unlock(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_unlock(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_recursive_mutex_lock(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_lock(__mutex);
}
static inline int __gthread_recursive_mutex_trylock(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_trylock(__mutex);
}
static inline int __gthread_recursive_mutex_timedlock(::__gthread_recursive_mutex_t *__mutex, const ::__gthread_time_t *__abs_timeout)
{
  return ::__gthread_mutex_timedlock(__mutex, __abs_timeout);
}
static inline int __gthread_recursive_mutex_unlock(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_unlock(__mutex);
}
static inline int __gthread_recursive_mutex_destroy(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_destroy(__mutex);
}
static inline int __gthread_cond_broadcast(::__gthread_cond_t *__cond)
{
  return ::__gthrw_pthread_cond_broadcast(__cond);
}
static inline int __gthread_cond_signal(::__gthread_cond_t *__cond)
{
  return ::__gthrw_pthread_cond_signal(__cond);
}
static inline int __gthread_cond_wait(::__gthread_cond_t *__cond, ::__gthread_mutex_t *__mutex)
{
  return ::__gthrw_pthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_timedwait(::__gthread_cond_t *__cond, ::__gthread_mutex_t *__mutex, const ::__gthread_time_t *__abs_timeout)
{
  return ::__gthrw_pthread_cond_timedwait(__cond, __mutex, __abs_timeout);
}
static inline int __gthread_cond_wait_recursive(::__gthread_cond_t *__cond, ::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_destroy(::__gthread_cond_t *__cond)
{
  return ::__gthrw_pthread_cond_destroy(__cond);
}
#pragma GCC visibility pop
typedef int _Atomic_word;
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  static inline ::_Atomic_word __exchange_and_add(volatile ::_Atomic_word *__mem, int __val)
  {
    return __atomic_fetch_add(__mem, __val, 4);
  }
  static inline void __atomic_add(volatile ::_Atomic_word *__mem, int __val)
  {
    __atomic_fetch_add(__mem, __val, 4);
  }
  static inline ::_Atomic_word __exchange_and_add_single(::_Atomic_word *__mem, int __val)
  {
    ::_Atomic_word __result(*__mem);
    *__mem += __val;
    return __result;
  }
  static inline void __atomic_add_single(::_Atomic_word *__mem, int __val)
  {
    *__mem += __val;
  }
  static inline __attribute__((__unused__)) ::_Atomic_word __exchange_and_add_dispatch(::_Atomic_word *__mem, int __val)
  {
    if (::__gthread_active_p())
      {
        return ::__gnu_cxx::__exchange_and_add(__mem, __val);
      }
    else
      {
        return ::__gnu_cxx::__exchange_and_add_single(__mem, __val);
      }
  }
  static inline __attribute__((__unused__)) void __atomic_add_dispatch(::_Atomic_word *__mem, int __val)
  {
    if (::__gthread_active_p())
      {
        ::__gnu_cxx::__atomic_add(__mem, __val);
      }
    else
      {
        ::__gnu_cxx::__atomic_add_single(__mem, __val);
      }
  }
  using ::std::size_t;
  using ::std::ptrdiff_t;
  template < typename _Tp >
  class  new_allocator
  {
    public:
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Tp *pointer;
      typedef const _Tp *const_pointer;
      typedef _Tp &reference;
      typedef const _Tp &const_reference;
      typedef _Tp value_type;
      template < typename _Tp1 >
      struct  rebind
      {
          typedef ::__gnu_cxx::new_allocator<_Tp1> other;
      };
      typedef ::std::true_type propagate_on_container_move_assignment;
      inline new_allocator() noexcept(true)
      {
      }
      inline new_allocator(const ::__gnu_cxx::new_allocator<_Tp> &) noexcept(true)
      {
      }
      template < typename _Tp1 >
      inline new_allocator(const ::__gnu_cxx::new_allocator<_Tp1> &) noexcept(true)
      {
      }
      inline ~new_allocator() noexcept(true)
      {
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::pointer address(typename ::__gnu_cxx::new_allocator<_Tp>::reference __x) const  noexcept(true)
      {
        return std::__addressof(__x);
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::const_pointer address(typename ::__gnu_cxx::new_allocator<_Tp>::const_reference __x) const  noexcept(true)
      {
        return std::__addressof(__x);
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::pointer allocate(typename ::__gnu_cxx::new_allocator<_Tp>::size_type __n, const void *  = (0))
      {
        if (__n > this->max_size())
          {
            std::__throw_bad_alloc();
          }
        return static_cast<_Tp *>(::operator new(__n * sizeof(_Tp)));
      }
      inline void deallocate(typename ::__gnu_cxx::new_allocator<_Tp>::pointer __p, typename ::__gnu_cxx::new_allocator<_Tp>::size_type)
      {
        ::operator delete(__p);
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::size_type max_size() const  noexcept(true)
      {
        return (::std::size_t) -1 / sizeof(_Tp);
      }
      template < typename _Up, typename ..._Args >
      inline void construct(_Up *__p, _Args &&...__args)
      {
        ::new ((void *)__p)_Up(std::forward<_Args>(__args) ...);
      }
      template < typename _Up >
      inline void destroy(_Up *__p)
      {
        __p->~_Up();
      }
  };
  template < typename _Tp >
  inline bool operator ==(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &);
  template < typename _Tp >
  inline bool operator ==(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &)
  {
    return true;
  }
  template < typename _Tp >
  inline bool operator !=(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &);
  template < typename _Tp >
  inline bool operator !=(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &)
  {
    return false;
  }
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Tp >
  using __allocator_base = ::__gnu_cxx::new_allocator<_Tp>;
  template <>
  class  allocator<void>
  {
    public:
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef void *pointer;
      typedef const void *const_pointer;
      typedef void value_type;
      template < typename _Tp1 >
      struct  rebind
      {
          typedef ::std::allocator<_Tp1> other;
      };
      typedef ::std::true_type propagate_on_container_move_assignment;
  };
  template < typename _Tp >
  class  allocator : public ::std::__allocator_base<_Tp>
  {
    public:
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Tp *pointer;
      typedef const _Tp *const_pointer;
      typedef _Tp &reference;
      typedef const _Tp &const_reference;
      typedef _Tp value_type;
      template < typename _Tp1 >
      struct  rebind
      {
          typedef ::std::allocator<_Tp1> other;
      };
      typedef ::std::true_type propagate_on_container_move_assignment;
      inline allocator() throw()
      {
      }
      inline allocator(const ::std::allocator<_Tp> &__a) throw()
        : __allocator_base<_Tp>(__a)
      {
      }
      template < typename _Tp1 >
      inline allocator(const ::std::allocator<_Tp1> &) throw()
      {
      }
      inline ~allocator() throw()
      {
      }
  };
  template < typename _T1, typename _T2 >
  inline bool operator ==(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &);
  template < typename _T1, typename _T2 >
  inline bool operator ==(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &)
  {
    return true;
  }
  template < typename _Tp >
  inline bool operator ==(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &);
  template < typename _Tp >
  inline bool operator ==(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &)
  {
    return true;
  }
  template < typename _T1, typename _T2 >
  inline bool operator !=(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &);
  template < typename _T1, typename _T2 >
  inline bool operator !=(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &)
  {
    return false;
  }
  template < typename _Tp >
  inline bool operator !=(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &);
  template < typename _Tp >
  inline bool operator !=(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &)
  {
    return false;
  }
  extern template class ::std::allocator<char>;
  extern template class ::std::allocator<wchar_t>;
  template < typename _Alloc, bool __nontype_tpl_param_1_1__ = __is_empty(_Alloc) >
  struct  __alloc_swap
  {
      static inline void _S_do_it(_Alloc &, _Alloc &)
      {
      }
  };
  template < typename _Alloc >
  struct  __alloc_swap<_Alloc, false>
  {
      static inline void _S_do_it(_Alloc &__one, _Alloc &__two)
      {
        if (__one != __two)
          {
            swap(__one, __two);
          }
      }
  };
  template < typename _Alloc, bool __nontype_tpl_param_1_1__ = __is_empty(_Alloc) >
  struct  __alloc_neq
  {
      static inline bool _S_do_it(const _Alloc &, const _Alloc &)
      {
        return false;
      }
  };
  template < typename _Alloc >
  struct  __alloc_neq<_Alloc, false>
  {
      static inline bool _S_do_it(const _Alloc &__one, const _Alloc &__two)
      {
        return __one != __two;
      }
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __or_< ::std::is_copy_constructible<typename _Tp::value_type>, ::std::is_nothrow_move_constructible<typename _Tp::value_type> >::value >
  struct  __shrink_to_fit_aux
  {
      static inline bool _S_do_it(_Tp &)
      {
        return false;
      }
  };
  template < typename _Tp >
  struct  __shrink_to_fit_aux<_Tp, true>
  {
      static inline bool _S_do_it(_Tp &__c)
      {
        try
        {
          _Tp(__make_move_if_noexcept_iterator(__c.begin()), __make_move_if_noexcept_iterator(__c.end()), __c.get_allocator()).swap(__c);
          return true;
        }
        catch (...)
        {
          return false;
        }
      }
  };
}
#pragma GCC visibility push(default)
namespace __cxxabiv1 {
  class  __forced_unwind
  {
      virtual ~__forced_unwind() throw();
      virtual void __pure_dummy() = 0 ;
    public:
  };
}
#pragma GCC visibility pop
namespace std __attribute__((__visibility__("default"))) {
  template < typename _CharT, typename _Traits >
  inline void __ostream_write(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n);
  template < typename _CharT, typename _Traits >
  inline void __ostream_write(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const ::std::streamsize __put = __out.rdbuf()->sputn(__s, __n);
    if (__put != __n)
      {
        __out.setstate(__ios_base::badbit);
      }
  }
  template < typename _CharT, typename _Traits >
  inline void __ostream_fill(::std::basic_ostream<_CharT, _Traits> &__out, ::std::streamsize __n);
  template < typename _CharT, typename _Traits >
  inline void __ostream_fill(::std::basic_ostream<_CharT, _Traits> &__out, ::std::streamsize __n)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const _CharT __c = __out.fill();
    for (; __n > 0;  --__n)
      {
        const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
        if (_Traits::eq_int_type(__put, _Traits::eof()))
          {
            __out.setstate(__ios_base::badbit);
            break;
          }
      }
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &__ostream_insert(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n);
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &__ostream_insert(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(__out);
    if (__cerb)
      {
        try
        {
          const ::std::streamsize __w = __out.width();
          if (__w > __n)
            {
              const bool __left = (__out.flags() & __ios_base::adjustfield) == __ios_base::left;
              if (!__left)
                {
                  __ostream_fill(__out, __w - __n);
                }
              if (__out.good())
                {
                  __ostream_write(__out, __s, __n);
                }
              if (__left && __out.good())
                {
                  __ostream_fill(__out, __w - __n);
                }
            }
          else
            {
              __ostream_write(__out, __s, __n);
            }
          __out.width(0);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __out._M_setstate(__ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __out._M_setstate(__ios_base::badbit);
        }
      }
    return __out;
  }
  extern template ::std::basic_ostream<char> &__ostream_insert(::std::basic_ostream<char> &, const char *, long int);
  extern template ::std::basic_ostream<wchar_t> &__ostream_insert(::std::basic_ostream<wchar_t> &, const wchar_t *, long int);
  template < typename _Arg, typename _Result >
  struct  unary_function
  {
      typedef _Arg argument_type;
      typedef _Result result_type;
  };
  template < typename _Arg1, typename _Arg2, typename _Result >
  struct  binary_function
  {
      typedef _Arg1 first_argument_type;
      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
  };
  template < typename _Tp >
  struct  plus : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x + __y;
      }
  };
  template < typename _Tp >
  struct  minus : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x - __y;
      }
  };
  template < typename _Tp >
  struct  multiplies : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x * __y;
      }
  };
  template < typename _Tp >
  struct  divides : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x / __y;
      }
  };
  template < typename _Tp >
  struct  modulus : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x % __y;
      }
  };
  template < typename _Tp >
  struct  negate : ::std::unary_function<_Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x) const 
      {
        return  -__x;
      }
  };
  template < typename _Tp >
  struct  equal_to : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x == __y;
      }
  };
  template < typename _Tp >
  struct  not_equal_to : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x != __y;
      }
  };
  template < typename _Tp >
  struct  greater : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x > __y;
      }
  };
  template < typename _Tp >
  struct  less : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x < __y;
      }
  };
  template < typename _Tp >
  struct  greater_equal : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x >= __y;
      }
  };
  template < typename _Tp >
  struct  less_equal : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x <= __y;
      }
  };
  template < typename _Tp >
  struct  logical_and : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x && __y;
      }
  };
  template < typename _Tp >
  struct  logical_or : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x || __y;
      }
  };
  template < typename _Tp >
  struct  logical_not : ::std::unary_function<_Tp, bool>
  {
      inline bool operator ()(const _Tp &__x) const 
      {
        return !__x;
      }
  };
  template < typename _Tp >
  struct  bit_and : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x & __y;
      }
  };
  template < typename _Tp >
  struct  bit_or : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x | __y;
      }
  };
  template < typename _Tp >
  struct  bit_xor : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x ^ __y;
      }
  };
  template < typename _Predicate >
  class  unary_negate : public ::std::unary_function<typename _Predicate::argument_type, bool>
  {
    protected:
      _Predicate _M_pred;
    public:
      inline explicit unary_negate(const _Predicate &__x)
        : _M_pred(__x)
      {
      }
      inline bool operator ()(const typename _Predicate::argument_type &__x) const 
      {
        return !::std::unary_negate<_Predicate>::_M_pred(__x);
      }
  };
  template < typename _Predicate >
  inline ::std::unary_negate<_Predicate> not1(const _Predicate &__pred);
  template < typename _Predicate >
  inline ::std::unary_negate<_Predicate> not1(const _Predicate &__pred)
  {
    return ::std::unary_negate<_Predicate>(__pred);
  }
  template < typename _Predicate >
  class  binary_negate : public ::std::binary_function<typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool>
  {
    protected:
      _Predicate _M_pred;
    public:
      inline explicit binary_negate(const _Predicate &__x)
        : _M_pred(__x)
      {
      }
      inline bool operator ()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &__y) const 
      {
        return !::std::binary_negate<_Predicate>::_M_pred(__x, __y);
      }
  };
  template < typename _Predicate >
  inline ::std::binary_negate<_Predicate> not2(const _Predicate &__pred);
  template < typename _Predicate >
  inline ::std::binary_negate<_Predicate> not2(const _Predicate &__pred)
  {
    return ::std::binary_negate<_Predicate>(__pred);
  }
  template < typename _Arg, typename _Result >
  class  pointer_to_unary_function : public ::std::unary_function<_Arg, _Result>
  {
    protected:
      _Result (*_M_ptr)(_Arg);
    public:
      inline pointer_to_unary_function()
      {
      }
      inline explicit pointer_to_unary_function(_Result (*__x)(_Arg))
        : _M_ptr(__x)
      {
      }
      inline _Result operator ()(_Arg __x) const 
      {
        return ::std::pointer_to_unary_function<_Arg, _Result>::_M_ptr(__x);
      }
  };
  template < typename _Arg, typename _Result >
  inline ::std::pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg));
  template < typename _Arg, typename _Result >
  inline ::std::pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg))
  {
    return ::std::pointer_to_unary_function<_Arg, _Result>(__x);
  }
  template < typename _Arg1, typename _Arg2, typename _Result >
  class  pointer_to_binary_function : public ::std::binary_function<_Arg1, _Arg2, _Result>
  {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
      inline pointer_to_binary_function()
      {
      }
      inline explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
        : _M_ptr(__x)
      {
      }
      inline _Result operator ()(_Arg1 __x, _Arg2 __y) const 
      {
        return ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result>::_M_ptr(__x, __y);
      }
  };
  template < typename _Arg1, typename _Arg2, typename _Result >
  inline ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__x)(_Arg1, _Arg2));
  template < typename _Arg1, typename _Arg2, typename _Result >
  inline ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__x)(_Arg1, _Arg2))
  {
    return ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x);
  }
  template < typename _Tp >
  struct  _Identity : ::std::unary_function<_Tp, _Tp>
  {
      inline _Tp &operator ()(_Tp &__x) const 
      {
        return __x;
      }
      inline const _Tp &operator ()(const _Tp &__x) const 
      {
        return __x;
      }
  };
  template < typename _Pair >
  struct  _Select1st : ::std::unary_function<_Pair, typename _Pair::first_type>
  {
      inline typename _Pair::first_type &operator ()(_Pair &__x) const 
      {
        return __x.first;
      }
      inline const typename _Pair::first_type &operator ()(const _Pair &__x) const 
      {
        return __x.first;
      }
      template < typename _Pair2 >
      inline typename _Pair2::first_type &operator ()(_Pair2 &__x) const 
      {
        return __x.first;
      }
      template < typename _Pair2 >
      inline const typename _Pair2::first_type &operator ()(const _Pair2 &__x) const 
      {
        return __x.first;
      }
  };
  template < typename _Pair >
  struct  _Select2nd : ::std::unary_function<_Pair, typename _Pair::second_type>
  {
      inline typename _Pair::second_type &operator ()(_Pair &__x) const 
      {
        return __x.second;
      }
      inline const typename _Pair::second_type &operator ()(const _Pair &__x) const 
      {
        return __x.second;
      }
  };
  template < typename _Ret, typename _Tp >
  class  mem_fun_t : public ::std::unary_function<_Tp *, _Ret>
  {
    public:
      inline explicit mem_fun_t(_Ret (_Tp::*__pf)())
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp *__p) const 
      {
        return (__p->*::std::mem_fun_t<_Ret, _Tp>::_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)();
  };
  template < typename _Ret, typename _Tp >
  class  const_mem_fun_t : public ::std::unary_function<const _Tp *, _Ret>
  {
    public:
      inline explicit const_mem_fun_t(_Ret (_Tp::*__pf)() const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp *__p) const 
      {
        return (__p->*::std::const_mem_fun_t<_Ret, _Tp>::_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)() const ;
  };
  template < typename _Ret, typename _Tp >
  class  mem_fun_ref_t : public ::std::unary_function<_Tp, _Ret>
  {
    public:
      inline explicit mem_fun_ref_t(_Ret (_Tp::*__pf)())
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp &__r) const 
      {
        return (__r.*::std::mem_fun_ref_t<_Ret, _Tp>::_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)();
  };
  template < typename _Ret, typename _Tp >
  class  const_mem_fun_ref_t : public ::std::unary_function<_Tp, _Ret>
  {
    public:
      inline explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp &__r) const 
      {
        return (__r.*::std::const_mem_fun_ref_t<_Ret, _Tp>::_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)() const ;
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  mem_fun1_t : public ::std::binary_function<_Tp *, _Arg, _Ret>
  {
    public:
      inline explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp *__p, _Arg __x) const 
      {
        return (__p->*::std::mem_fun1_t<_Ret, _Tp, _Arg>::_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  const_mem_fun1_t : public ::std::binary_function<const _Tp *, _Arg, _Ret>
  {
    public:
      inline explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp *__p, _Arg __x) const 
      {
        return (__p->*::std::const_mem_fun1_t<_Ret, _Tp, _Arg>::_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const ;
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  mem_fun1_ref_t : public ::std::binary_function<_Tp, _Arg, _Ret>
  {
    public:
      inline explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp &__r, _Arg __x) const 
      {
        return (__r.*::std::mem_fun1_ref_t<_Ret, _Tp, _Arg>::_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  const_mem_fun1_ref_t : public ::std::binary_function<_Tp, _Arg, _Ret>
  {
    public:
      inline explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp &__r, _Arg __x) const 
      {
        return (__r.*::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg>::_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const ;
  };
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)());
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)())
  {
    return ::std::mem_fun_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)() const );
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)() const )
  {
    return ::std::const_mem_fun_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)());
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)())
  {
    return ::std::mem_fun_ref_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)() const );
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)() const )
  {
    return ::std::const_mem_fun_ref_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg));
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg))
  {
    return ::std::mem_fun1_t<_Ret, _Tp, _Arg>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const );
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const )
  {
    return ::std::const_mem_fun1_t<_Ret, _Tp, _Arg>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg));
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
  {
    return ::std::mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const );
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const )
  {
    return ::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
  }
  template < typename _Operation >
  class __attribute__((__deprecated__))  binder1st : public ::std::unary_function<typename _Operation::second_argument_type, typename _Operation::result_type>
  {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;
    public:
      inline binder1st(const _Operation &__x, const typename _Operation::first_argument_type &__y)
        : op(__x), value(__y)
      {
      }
      inline typename _Operation::result_type operator ()(const typename _Operation::second_argument_type &__x) const 
      {
        return ::std::binder1st<_Operation>::op(::std::binder1st<_Operation>::value, __x);
      }
      inline typename _Operation::result_type operator ()(typename _Operation::second_argument_type &__x) const 
      {
        return ::std::binder1st<_Operation>::op(::std::binder1st<_Operation>::value, __x);
      }
  };
  template < typename _Operation, typename _Tp >
  inline ::std::binder1st<_Operation> bind1st(const _Operation &__fn, const _Tp &__x);
  template < typename _Operation, typename _Tp >
  inline ::std::binder1st<_Operation> bind1st(const _Operation &__fn, const _Tp &__x)
  {
    typedef typename _Operation::first_argument_type _Arg1_type;
    return ::std::binder1st<_Operation>(__fn, _Arg1_type(__x));
  }
  template < typename _Operation >
  class __attribute__((__deprecated__))  binder2nd : public ::std::unary_function<typename _Operation::first_argument_type, typename _Operation::result_type>
  {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;
    public:
      inline binder2nd(const _Operation &__x, const typename _Operation::second_argument_type &__y)
        : op(__x), value(__y)
      {
      }
      inline typename _Operation::result_type operator ()(const typename _Operation::first_argument_type &__x) const 
      {
        return ::std::binder2nd<_Operation>::op(__x, ::std::binder2nd<_Operation>::value);
      }
      inline typename _Operation::result_type operator ()(typename _Operation::first_argument_type &__x) const 
      {
        return ::std::binder2nd<_Operation>::op(__x, ::std::binder2nd<_Operation>::value);
      }
  };
  template < typename _Operation, typename _Tp >
  inline ::std::binder2nd<_Operation> bind2nd(const _Operation &__fn, const _Tp &__x);
  template < typename _Operation, typename _Tp >
  inline ::std::binder2nd<_Operation> bind2nd(const _Operation &__fn, const _Tp &__x)
  {
    typedef typename _Operation::second_argument_type _Arg2_type;
    return ::std::binder2nd<_Operation>(__fn, _Arg2_type(__x));
  }
  template < typename _Container >
  inline auto begin(_Container &__cont) -> decltype(__cont.begin());
  template < typename _Container >
  inline auto begin(_Container &__cont) -> decltype(__cont.begin())
  {
    return __cont.begin();
  }
  template < typename _Container >
  inline auto begin(const _Container &__cont) -> decltype(__cont.begin());
  template < typename _Container >
  inline auto begin(const _Container &__cont) -> decltype(__cont.begin())
  {
    return __cont.begin();
  }
  template < typename _Container >
  inline auto end(_Container &__cont) -> decltype(__cont.end());
  template < typename _Container >
  inline auto end(_Container &__cont) -> decltype(__cont.end())
  {
    return __cont.end();
  }
  template < typename _Container >
  inline auto end(const _Container &__cont) -> decltype(__cont.end());
  template < typename _Container >
  inline auto end(const _Container &__cont) -> decltype(__cont.end())
  {
    return __cont.end();
  }
  template < typename _Tp, ::std::size_t _Nm >
  inline _Tp *begin(_Tp (&__arr)[_Nm]);
  template < typename _Tp, ::std::size_t _Nm >
  inline _Tp *begin(_Tp (&__arr)[_Nm])
  {
    return __arr;
  }
  template < typename _Tp, ::std::size_t _Nm >
  inline _Tp *end(_Tp (&__arr)[_Nm]);
  template < typename _Tp, ::std::size_t _Nm >
  inline _Tp *end(_Tp (&__arr)[_Nm])
  {
    return __arr + _Nm;
  }
}
#pragma GCC visibility push(default)
namespace std __attribute__((__visibility__("default"))) {
  template < typename _E >
  class  initializer_list
  {
    public:
      typedef _E value_type;
      typedef const _E &reference;
      typedef const _E &const_reference;
      typedef ::std::size_t size_type;
      typedef const _E *iterator;
      typedef const _E *const_iterator;
    private:
      typename ::std::initializer_list<_E>::iterator _M_array;
      typename ::std::initializer_list<_E>::size_type _M_len;
      inline constexpr initializer_list(typename ::std::initializer_list<_E>::const_iterator __a, typename ::std::initializer_list<_E>::size_type __l)
        : _M_array(__a), _M_len(__l)
      {
      }
    public:
      inline constexpr initializer_list() noexcept(true)
        : _M_array(0), _M_len(0)
      {
      }
      inline constexpr typename ::std::initializer_list<_E>::size_type size() const  noexcept(true)
      {
        return ::std::initializer_list<_E>::_M_len;
      }
      inline constexpr typename ::std::initializer_list<_E>::const_iterator begin() const  noexcept(true)
      {
        return ::std::initializer_list<_E>::_M_array;
      }
      inline constexpr typename ::std::initializer_list<_E>::const_iterator end() const  noexcept(true)
      {
        return (*this).begin() + (*this).size();
      }
  };
  template < typename _Tp >
  inline constexpr const _Tp *begin(::std::initializer_list<_Tp> __ils) noexcept(true);
  template < typename _Tp >
  inline constexpr const _Tp *begin(::std::initializer_list<_Tp> __ils) noexcept(true)
  {
    return __ils.begin();
  }
  template < typename _Tp >
  inline constexpr const _Tp *end(::std::initializer_list<_Tp> __ils) noexcept(true);
  template < typename _Tp >
  inline constexpr const _Tp *end(::std::initializer_list<_Tp> __ils) noexcept(true)
  {
    return __ils.end();
  }
}
#pragma GCC visibility pop
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<int>, ::__gnu_cxx::__numeric_traits_floating<int> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<int>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<int>' */ 
namespace std __attribute__((__visibility__("default"))) {
  template < typename _CharT, typename _Traits, typename _Alloc >
  class  basic_string
  {
      typedef typename _Alloc::template rebind< _CharT>::other _CharT_alloc_type;
    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _Alloc::template rebind< _CharT>::other::size_type size_type;
      typedef typename _Alloc::template rebind< _CharT>::other::difference_type difference_type;
      typedef typename _Alloc::template rebind< _CharT>::other::reference reference;
      typedef typename _Alloc::template rebind< _CharT>::other::const_reference const_reference;
      typedef typename _Alloc::template rebind< _CharT>::other::pointer pointer;
      typedef typename _Alloc::template rebind< _CharT>::other::const_pointer const_pointer;
      typedef ::__gnu_cxx::__normal_iterator<typename ::std::basic_string<_CharT, _Traits, _Alloc>::pointer, ::std::basic_string<_CharT, _Traits, _Alloc> > iterator;
      typedef ::__gnu_cxx::__normal_iterator<typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_pointer, ::std::basic_string<_CharT, _Traits, _Alloc> > const_iterator;
      typedef ::std::reverse_iterator<typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator> const_reverse_iterator;
      typedef ::std::reverse_iterator<typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator> reverse_iterator;
    private:
      struct  _Rep_base
      {
          typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type _M_length;
          typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type _M_capacity;
          ::_Atomic_word _M_refcount;
      };
      struct  _Rep : ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep_base
      {
          typedef typename _Alloc::template rebind< char>::other _Raw_bytes_alloc;
          static const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type _S_max_size;
          static const _CharT _S_terminal;
          static typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type _S_empty_rep_storage[(sizeof(typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep_base) + sizeof(_CharT) + sizeof(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type) - 1) / sizeof(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type)];
          static inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep &_S_empty_rep()
          {
            void *__p(reinterpret_cast<void *>(&::std::basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage));
            return *reinterpret_cast<typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *>(__p);
          }
          inline bool _M_is_leaked() const 
          {
            return this->_M_refcount < 0;
          }
          inline bool _M_is_shared() const 
          {
            return this->_M_refcount > 0;
          }
          inline void _M_set_leaked()
          {
            this->_M_refcount =  -1;
          }
          inline void _M_set_sharable()
          {
            this->_M_refcount = 0;
          }
          inline void _M_set_length_and_sharable(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
          {
            if (__builtin_expect(this != &_S_empty_rep(), false))
              {
                this->_M_set_sharable();
                this->_M_length = __n;
                traits_type::assign(this->_M_refdata()[__n], ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_terminal);
              }
          }
          inline _CharT *_M_refdata() throw()
          {
            return reinterpret_cast<_CharT *>(this + 1);
          }
          inline _CharT *_M_grab(const _Alloc &__alloc1, const _Alloc &__alloc2)
          {
            return !(*this)._M_is_leaked() && __alloc1 == __alloc2 ? (*this)._M_refcopy() : (*this)._M_clone(__alloc1);
          }
          static typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *_S_create(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __capacity, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __old_capacity, const _Alloc &__alloc);
          inline void _M_dispose(const _Alloc &__a)
          {
            if (__builtin_expect(this != &_S_empty_rep(), false))
              {
                ;
                if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,  -1) <= 0)
                  {
                    ;
                    (*this)._M_destroy(__a);
                  }
              }
          }
          void _M_destroy(const _Alloc &__a) throw();
          inline _CharT *_M_refcopy() throw()
          {
            if (__builtin_expect(this != &_S_empty_rep(), false))
              {
                __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
              }
            return (*this)._M_refdata();
          }
          _CharT *_M_clone(const _Alloc &__alloc, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __res  = (0));
      };
      struct  _Alloc_hider : _Alloc
      {
          inline _Alloc_hider(_CharT *__dat, const _Alloc &__a)
            : _Alloc(__a), _M_p(__dat)
          {
          }
          _CharT *_M_p;
      };
    public:
      static const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type npos = static_cast<typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type>( -1);
    private:
      mutable typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider _M_dataplus;
      inline _CharT *_M_data() const 
      {
        return ::std::basic_string<_CharT, _Traits, _Alloc>::_M_dataplus._M_p;
      }
      inline _CharT *_M_data(_CharT *__p)
      {
        return ::std::basic_string<_CharT, _Traits, _Alloc>::_M_dataplus._M_p = __p;
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *_M_rep() const 
      {
        return &reinterpret_cast<typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *>((*this)._M_data())[ -1];
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator _M_ibegin() const 
      {
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data())));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator _M_iend() const 
      {
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data() + this->size())));
      }
      inline void _M_leak()
      {
        if (!(*this)._M_rep()->_M_is_leaked())
          {
            (*this)._M_leak_hard();
          }
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type _M_check(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const char *__s) const 
      {
        if (__pos > this->size())
          {
            ::std::__throw_out_of_range(__s);
          }
        return __pos;
      }
      inline void _M_check_length(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, const char *__s) const 
      {
        if (this->max_size() - (this->size() - __n1) < __n2)
          {
            ::std::__throw_length_error(__s);
          }
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type _M_limit(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __off) const 
      {
        const bool __testoff = __off < this->size() - __pos;
        return __testoff ? __off : this->size() - __pos;
      }
      inline bool _M_disjunct(const _CharT *__s) const 
      {
        return ::std::less<const _CharT *>()(__s, (*this)._M_data()) || ::std::less<const _CharT *>()((*this)._M_data() + this->size(), __s);
      }
      static inline void _M_copy(_CharT *__d, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
      {
        if (__n == 1)
          {
            traits_type::assign(*__d, *__s);
          }
        else
          {
            traits_type::copy(__d, __s, __n);
          }
      }
      static inline void _M_move(_CharT *__d, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
      {
        if (__n == 1)
          {
            traits_type::assign(*__d, *__s);
          }
        else
          {
            traits_type::move(__d, __s, __n);
          }
      }
      static inline void _M_assign(_CharT *__d, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
      {
        if (__n == 1)
          {
            traits_type::assign(*__d, __c);
          }
        else
          {
            traits_type::assign(__d, __n, __c);
          }
      }
      template < typename _Iterator >
      static inline void _S_copy_chars(_CharT *__p, _Iterator __k1, _Iterator __k2)
      {
        for (; __k1 != __k2; ( ++__k1,  ++__p))
          {
            traits_type::assign(*__p, *__k1);
          }
      }
      static inline void _S_copy_chars(_CharT *__p, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __k1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __k2)
      {
        _S_copy_chars(__p, __k1.base(), __k2.base());
      }
      static inline void _S_copy_chars(_CharT *__p, typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k2)
      {
        _S_copy_chars(__p, __k1.base(), __k2.base());
      }
      static inline void _S_copy_chars(_CharT *__p, _CharT *__k1, _CharT *__k2)
      {
        _M_copy(__p, __k1, __k2 - __k1);
      }
      static inline void _S_copy_chars(_CharT *__p, const _CharT *__k1, const _CharT *__k2)
      {
        _M_copy(__p, __k1, __k2 - __k1);
      }
      static inline int _S_compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2)
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::difference_type __d = ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::difference_type(__n1 - __n2)));
        if (__d > ::__gnu_cxx::__numeric_traits_integer<int>::__max)
          {
            return ::__gnu_cxx::__numeric_traits_integer<int>::__max;
          }
        else
          {
            if (__d < ::__gnu_cxx::__numeric_traits_integer<int>::__min)
              {
                return ::__gnu_cxx::__numeric_traits_integer<int>::__min;
              }
            else
              {
                return int(__d);
              }
          }
      }
      void _M_mutate(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len2);
      void _M_leak_hard();
      static inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep &_S_empty_rep()
      {
        return _Rep::_S_empty_rep();
      }
    public:
      inline basic_string()
        : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc())
      {
      }
      explicit basic_string(const _Alloc &__a);
      basic_string(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str);
      basic_string(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n  = (::std::basic_string<_CharT, _Traits, _Alloc>::npos));
      basic_string(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const _Alloc &__a);
      basic_string(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const _Alloc &__a  = (_Alloc()));
      basic_string(const _CharT *__s, const _Alloc &__a  = (_Alloc()));
      basic_string(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c, const _Alloc &__a  = (_Alloc()));
      inline basic_string(::std::basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(true)
        : _M_dataplus(__str._M_dataplus)
      {
        __str._M_data(_S_empty_rep()._M_refdata());
      }
      basic_string(::std::initializer_list<_CharT> __l, const _Alloc &__a  = (_Alloc()));
      template < typename _InputIterator >
      basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc &__a  = (_Alloc()));
      inline ~basic_string() noexcept(true)
      {
        (*this)._M_rep()->_M_dispose(this->get_allocator());
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator =(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
      {
        return this->assign(__str);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator =(const _CharT *__s)
      {
        return this->assign(__s);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator =(_CharT __c)
      {
        this->assign(1, __c);
        return *this;
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator =(::std::basic_string<_CharT, _Traits, _Alloc> &&__str)
      {
        this->swap(__str);
        return *this;
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator =(::std::initializer_list<_CharT> __l)
      {
        this->assign(__l.begin(), __l.size());
        return *this;
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator begin() noexcept(true)
      {
        (*this)._M_leak();
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data())));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator begin() const  noexcept(true)
      {
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator((*this)._M_data())));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator end() noexcept(true)
      {
        (*this)._M_leak();
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data() + this->size())));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator end() const  noexcept(true)
      {
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator((*this)._M_data() + this->size())));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator rbegin() noexcept(true)
      {
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator(this->end())));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator rbegin() const  noexcept(true)
      {
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator(this->end())));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator rend() noexcept(true)
      {
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator(this->begin())));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator rend() const  noexcept(true)
      {
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator(this->begin())));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator cbegin() const  noexcept(true)
      {
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator(this->_M_data())));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator cend() const  noexcept(true)
      {
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator(this->_M_data() + this->size())));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator crbegin() const  noexcept(true)
      {
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator(this->end())));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator crend() const  noexcept(true)
      {
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator(this->begin())));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type size() const  noexcept(true)
      {
        return (*this)._M_rep()->_M_length;
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type length() const  noexcept(true)
      {
        return (*this)._M_rep()->_M_length;
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type max_size() const  noexcept(true)
      {
        return _Rep::_S_max_size;
      }
      void resize(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c);
      inline void resize(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
      {
        this->resize(__n, _CharT());
      }
      inline void shrink_to_fit()
      {
        if ((*this).capacity() > (*this).size())
          {
            try
            {
              (*this).reserve(0);
            }
            catch (...)
            {
            }
          }
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type capacity() const  noexcept(true)
      {
        return (*this)._M_rep()->_M_capacity;
      }
      void reserve(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __res  = (0));
      inline void clear() noexcept(true)
      {
        (*this)._M_mutate(0, this->size(), 0);
      }
      inline bool empty() const  noexcept(true)
      {
        return this->size() == 0;
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reference operator [](typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
      {
        ;
        return (*this)._M_data()[__pos];
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::reference operator [](typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos)
      {
        ;
        ;
        (*this)._M_leak();
        return (*this)._M_data()[__pos];
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reference at(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
      {
        if (__n >= this->size())
          {
            ::std::__throw_out_of_range("basic_string::at");
          }
        return (*this)._M_data()[__n];
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::reference at(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
      {
        if (__n >= (*this).size())
          {
            ::std::__throw_out_of_range("basic_string::at");
          }
        (*this)._M_leak();
        return (*this)._M_data()[__n];
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::reference front()
      {
        return (*this).operator [](0);
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reference front() const 
      {
        return (*this).operator [](0);
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::reference back()
      {
        return (*this).operator [](this->size() - 1);
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_reference back() const 
      {
        return (*this).operator [](this->size() - 1);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator +=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
      {
        return this->append(__str);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator +=(const _CharT *__s)
      {
        return this->append(__s);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator +=(_CharT __c)
      {
        this->push_back(__c);
        return *this;
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &operator +=(::std::initializer_list<_CharT> __l)
      {
        return this->append(__l.begin(), __l.size());
      }
      ::std::basic_string<_CharT, _Traits, _Alloc> &append(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str);
      ::std::basic_string<_CharT, _Traits, _Alloc> &append(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n);
      ::std::basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n);
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s)
      {
        ;
        return this->append(__s, traits_type::length(__s));
      }
      ::std::basic_string<_CharT, _Traits, _Alloc> &append(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c);
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &append(::std::initializer_list<_CharT> __l)
      {
        return this->append(__l.begin(), __l.size());
      }
      template < typename _InputIterator >
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &append(_InputIterator __first, _InputIterator __last)
      {
        return this->replace((*this)._M_iend(), (*this)._M_iend(), __first, __last);
      }
      inline void push_back(_CharT __c)
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = 1 + this->size();
        if (__len > this->capacity() || (*this)._M_rep()->_M_is_shared())
          {
            this->reserve(__len);
          }
        traits_type::assign((*this)._M_data()[this->size()], __c);
        (*this)._M_rep()->_M_set_length_and_sharable(__len);
      }
      ::std::basic_string<_CharT, _Traits, _Alloc> &assign(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str);
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &assign(::std::basic_string<_CharT, _Traits, _Alloc> &&__str)
      {
        this->swap(__str);
        return *this;
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &assign(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
      {
        return this->assign(__str._M_data() + __str._M_check(__pos, "basic_string::assign"), __str._M_limit(__pos, __n));
      }
      ::std::basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n);
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s)
      {
        ;
        return this->assign(__s, traits_type::length(__s));
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &assign(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
      {
        return (*this)._M_replace_aux(((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), this->size(), __n, __c);
      }
      template < typename _InputIterator >
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &assign(_InputIterator __first, _InputIterator __last)
      {
        return this->replace((*this)._M_ibegin(), (*this)._M_iend(), __first, __last);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &assign(::std::initializer_list<_CharT> __l)
      {
        return this->assign(__l.begin(), __l.size());
      }
      inline void insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __p, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
      {
        this->replace(__p, __p, __n, __c);
      }
      template < typename _InputIterator >
      inline void insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __p, _InputIterator __beg, _InputIterator __end)
      {
        this->replace(__p, __p, __beg, __end);
      }
      inline void insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __p, ::std::initializer_list<_CharT> __l)
      {
        ;
        this->insert(__p - (*this)._M_ibegin(), __l.begin(), __l.size());
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
      {
        return this->insert(__pos1, __str, ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __str.size());
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
      {
        return this->insert(__pos1, __str._M_data() + __str._M_check(__pos2, "basic_string::insert"), __str._M_limit(__pos2, __n));
      }
      ::std::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n);
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const _CharT *__s)
      {
        ;
        return this->insert(__pos, __s, traits_type::length(__s));
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
      {
        return (*this)._M_replace_aux((*this)._M_check(__pos, "basic_string::insert"), ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __n, __c);
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __p, _CharT __c)
      {
        ;
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __p - (*this)._M_ibegin();
        (*this)._M_replace_aux(__pos, ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(1))), __c);
        (*this)._M_rep()->_M_set_leaked();
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data() + __pos)));
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &erase(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0), typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n  = (::std::basic_string<_CharT, _Traits, _Alloc>::npos))
      {
        (*this)._M_mutate((*this)._M_check(__pos, "basic_string::erase"), (*this)._M_limit(__pos, __n), ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))));
        return *this;
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator erase(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __position)
      {
        ;
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __position - (*this)._M_ibegin();
        (*this)._M_mutate(__pos, ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(1))), ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))));
        (*this)._M_rep()->_M_set_leaked();
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data() + __pos)));
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator erase(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __first, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __last);
      inline void pop_back()
      {
        (*this).erase((*this).size() - 1, 1);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
      {
        return this->replace(__pos, __n, __str._M_data(), __str.size());
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2)
      {
        return this->replace(__pos1, __n1, __str._M_data() + __str._M_check(__pos2, "basic_string::replace"), __str._M_limit(__pos2, __n2));
      }
      ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2);
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s)
      {
        ;
        return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, _CharT __c)
      {
        return (*this)._M_replace_aux((*this)._M_check(__pos, "basic_string::replace"), (*this)._M_limit(__pos, __n1), __n2, __c);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
      {
        return this->replace(__i1, __i2, __str._M_data(), __str.size());
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
      {
        ;
        return this->replace(__i1 - (*this)._M_ibegin(), __i2 - __i1, __s, __n);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, const _CharT *__s)
      {
        ;
        return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
      {
        ;
        return (*this)._M_replace_aux(__i1 - (*this)._M_ibegin(), __i2 - __i1, __n, __c);
      }
      template < typename _InputIterator >
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, _InputIterator __k1, _InputIterator __k2)
      {
        ;
        ;
        typedef typename ::std::__is_integer<_InputIterator>::__type _Integral;
        return (*this)._M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, _CharT *__k1, _CharT *__k2)
      {
        ;
        ;
        return this->replace(__i1 - (*this)._M_ibegin(), __i2 - __i1, __k1, __k2 - __k1);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, const _CharT *__k1, const _CharT *__k2)
      {
        ;
        ;
        return this->replace(__i1 - (*this)._M_ibegin(), __i2 - __i1, __k1, __k2 - __k1);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __k1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __k2)
      {
        ;
        ;
        return this->replace(__i1 - (*this)._M_ibegin(), __i2 - __i1, __k1.base(), __k2 - __k1);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k2)
      {
        ;
        ;
        return this->replace(__i1 - (*this)._M_ibegin(), __i2 - __i1, __k1.base(), __k2 - __k1);
      }
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, ::std::initializer_list<_CharT> __l)
      {
        return this->replace(__i1, __i2, __l.begin(), __l.end());
      }
    private:
      template < typename _Integer >
      inline ::std::basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, _Integer __n, _Integer __val, ::std::__true_type)
      {
        return (*this)._M_replace_aux(__i1 - (*this)._M_ibegin(), __i2 - __i1, __n, __val);
      }
      template < typename _InputIterator >
      ::std::basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, _InputIterator __k1, _InputIterator __k2, ::std::__false_type);
      ::std::basic_string<_CharT, _Traits, _Alloc> &_M_replace_aux(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, _CharT __c);
      ::std::basic_string<_CharT, _Traits, _Alloc> &_M_replace_safe(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2);
      template < typename _InIterator >
      static inline _CharT *_S_construct_aux(_InIterator __beg, _InIterator __end, const _Alloc &__a, ::std::__false_type)
      {
        typedef typename ::std::iterator_traits<_InIterator>::iterator_category _Tag;
        return _S_construct(__beg, __end, __a, _Tag());
      }
      template < typename _Integer >
      static inline _CharT *_S_construct_aux(_Integer __beg, _Integer __end, const _Alloc &__a, ::std::__true_type)
      {
        return _S_construct_aux_2(static_cast<typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type>(__beg), __end, __a);
      }
      static inline _CharT *_S_construct_aux_2(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __req, _CharT __c, const _Alloc &__a)
      {
        return _S_construct(__req, __c, __a);
      }
      template < typename _InIterator >
      static inline _CharT *_S_construct(_InIterator __beg, _InIterator __end, const _Alloc &__a)
      {
        typedef typename ::std::__is_integer<_InIterator>::__type _Integral;
        return _S_construct_aux(__beg, __end, __a, _Integral());
      }
      template < typename _InIterator >
      static _CharT *_S_construct(_InIterator __beg, _InIterator __end, const _Alloc &__a, ::std::input_iterator_tag);
      template < typename _FwdIterator >
      static _CharT *_S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc &__a, ::std::forward_iterator_tag);
      static _CharT *_S_construct(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c, const _Alloc &__a);
    public:
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type copy(_CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const ;
      void swap(::std::basic_string<_CharT, _Traits, _Alloc> &__s);
      inline const _CharT *c_str() const  noexcept(true)
      {
        return (*this)._M_data();
      }
      inline const _CharT *data() const  noexcept(true)
      {
        return (*this)._M_data();
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::allocator_type get_allocator() const  noexcept(true)
      {
        return ::std::basic_string<_CharT, _Traits, _Alloc>::_M_dataplus;
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const  noexcept(true)
      {
        return this->find(__str.data(), __pos, __str.size());
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const 
      {
        ;
        return this->find(__s, __pos, traits_type::length(__s));
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const  noexcept(true);
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::basic_string<_CharT, _Traits, _Alloc>::npos)) const  noexcept(true)
      {
        return this->rfind(__str.data(), __pos, __str.size());
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
      {
        ;
        return this->rfind(__s, __pos, traits_type::length(__s));
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::basic_string<_CharT, _Traits, _Alloc>::npos)) const  noexcept(true);
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const  noexcept(true)
      {
        return this->find_first_of(__str.data(), __pos, __str.size());
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const 
      {
        ;
        return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const  noexcept(true)
      {
        return this->find(__c, __pos);
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::basic_string<_CharT, _Traits, _Alloc>::npos)) const  noexcept(true)
      {
        return this->find_last_of(__str.data(), __pos, __str.size());
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
      {
        ;
        return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::basic_string<_CharT, _Traits, _Alloc>::npos)) const  noexcept(true)
      {
        return this->rfind(__c, __pos);
      }
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const  noexcept(true)
      {
        return this->find_first_not_of(__str.data(), __pos, __str.size());
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const 
      {
        ;
        return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const  noexcept(true);
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::basic_string<_CharT, _Traits, _Alloc>::npos)) const  noexcept(true)
      {
        return this->find_last_not_of(__str.data(), __pos, __str.size());
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
      inline typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
      {
        ;
        return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
      typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::basic_string<_CharT, _Traits, _Alloc>::npos)) const  noexcept(true);
      inline ::std::basic_string<_CharT, _Traits, _Alloc> substr(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0), typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n  = (::std::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
      {
        return ::std::basic_string<_CharT, _Traits, _Alloc>(*this, (*this)._M_check(__pos, "basic_string::substr"), __n);
      }
      inline int compare(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str) const 
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = __str.size();
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__size, __osize);
        int __r = traits_type::compare((*this)._M_data(), __str.data(), __len);
        if (!__r)
          {
            __r = _S_compare(__size, __osize);
          }
        return __r;
      }
      int compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str) const ;
      int compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const ;
      int compare(const _CharT *__s) const ;
      int compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s) const ;
      int compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const ;
  };
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    ::std::basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
    __str.append(__rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> operator +(_CharT __lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    ::std::basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
    __str.append(__rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs)
  {
    typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    __string_type __str(__lhs);
    __str.append(__size_type(1), __rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(::std::basic_string<_CharT, _Traits, _Alloc> &&__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(::std::basic_string<_CharT, _Traits, _Alloc> &&__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return std::move(__lhs.append(__rhs));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, ::std::basic_string<_CharT, _Traits, _Alloc> &&__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, ::std::basic_string<_CharT, _Traits, _Alloc> &&__rhs)
  {
    return std::move(__rhs.insert(0, __lhs));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(::std::basic_string<_CharT, _Traits, _Alloc> &&__lhs, ::std::basic_string<_CharT, _Traits, _Alloc> &&__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(::std::basic_string<_CharT, _Traits, _Alloc> &&__lhs, ::std::basic_string<_CharT, _Traits, _Alloc> &&__rhs)
  {
    auto __size = __lhs.size() + __rhs.size();
    const bool __cond = __size > __lhs.capacity() && __size <= __rhs.capacity();
    return __cond ? std::move(__rhs.insert(0, __lhs)) : std::move(__lhs.append(__rhs));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const _CharT *__lhs, ::std::basic_string<_CharT, _Traits, _Alloc> &&__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const _CharT *__lhs, ::std::basic_string<_CharT, _Traits, _Alloc> &&__rhs)
  {
    return std::move(__rhs.insert(0, __lhs));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(_CharT __lhs, ::std::basic_string<_CharT, _Traits, _Alloc> &&__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(_CharT __lhs, ::std::basic_string<_CharT, _Traits, _Alloc> &&__rhs)
  {
    return std::move(__rhs.insert(0, 1, __lhs));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(::std::basic_string<_CharT, _Traits, _Alloc> &&__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(::std::basic_string<_CharT, _Traits, _Alloc> &&__lhs, const _CharT *__rhs)
  {
    return std::move(__lhs.append(__rhs));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(::std::basic_string<_CharT, _Traits, _Alloc> &&__lhs, _CharT __rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_string<_CharT, _Traits, _Alloc> operator +(::std::basic_string<_CharT, _Traits, _Alloc> &&__lhs, _CharT __rhs)
  {
    return std::move(__lhs.append(1, __rhs));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) == 0;
  }
  template < typename _CharT >
  inline typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type operator ==(const ::std::basic_string<_CharT> &__lhs, const ::std::basic_string<_CharT> &__rhs);
  template < typename _CharT >
  inline typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type operator ==(const ::std::basic_string<_CharT> &__lhs, const ::std::basic_string<_CharT> &__rhs)
  {
    return __lhs.size() == __rhs.size() && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(), __lhs.size());
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) == 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) == 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) < 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) < 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) > 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) > 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) > 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) < 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) <= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) <= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) >= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) >= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) >= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) <= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline void swap(::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline void swap(::std::basic_string<_CharT, _Traits, _Alloc> &__lhs, ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    __lhs.swap(__rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, ::std::basic_string<_CharT, _Traits, _Alloc> &__str);
  template <>
  ::std::basic_istream<char> &operator >><char, ::std::char_traits<char>, ::std::allocator<char> >(::std::basic_istream<char> &__is, ::std::basic_string<char> &__str);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    return __ostream_insert(__os, __str.data(), __str.size());
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__in, ::std::basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__is, ::std::basic_string<_CharT, _Traits, _Alloc> &__str);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__is, ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    return getline(__is, __str, __is.widen('\n'));
  }
  template <>
  ::std::basic_istream<char> &getline<char, ::std::char_traits<char>, ::std::allocator<char> >(::std::basic_istream<char> &__in, ::std::basic_string<char> &__str, char __delim);
  template <>
  ::std::basic_istream<wchar_t> &getline<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> >(::std::basic_istream<wchar_t> &__in, ::std::basic_string<wchar_t> &__str, wchar_t __delim);
}
union  wait
{
    int w_status;
    struct  mcc_struct_anon_40
    {
        unsigned int __w_termsig:7;
        unsigned int __w_coredump:1;
        unsigned int __w_retcode:8;
        unsigned int:16;
    };
    ::wait::mcc_struct_anon_40 __wait_terminated;
    struct  mcc_struct_anon_41
    {
        unsigned int __w_stopval:8;
        unsigned int __w_stopsig:8;
        unsigned int:16;
    };
    ::wait::mcc_struct_anon_41 __wait_stopped;
};
struct  div_t
{
    int quot;
    int rem;
};
struct  ldiv_t
{
    long int quot;
    long int rem;
};
__extension__ struct  lldiv_t
{
    __extension__ long long int quot;
    __extension__ long long int rem;
};
extern "C"
{
  extern ::size_t __ctype_get_mb_cur_max() throw();
}
extern "C"
{
  extern inline double atof(const char *__nptr) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int atoi(const char *__nptr) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline long int atol(const char *__nptr) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline long long int atoll(const char *__nptr) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern double strtod(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern float strtof(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long double strtold(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int strtol(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern unsigned long int strtoul(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long long int strtoq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern unsigned long long int strtouq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long long int strtoll(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern unsigned long long int strtoull(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int strtol_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::__locale_t __loc) throw() __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern unsigned long int strtoul_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::__locale_t __loc) throw() __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern long long int strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::__locale_t __loc) throw() __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern unsigned long long int strtoull_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::__locale_t __loc) throw() __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern double strtod_l(const char *__restrict __nptr, char **__restrict __endptr, ::__locale_t __loc) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern float strtof_l(const char *__restrict __nptr, char **__restrict __endptr, ::__locale_t __loc) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern long double strtold_l(const char *__restrict __nptr, char **__restrict __endptr, ::__locale_t __loc) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int atoi(const char *__nptr) throw()
  {
    return (int)::strtol(__nptr, (char **)0L, 10);
  }
}
extern "C"
{
  extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) long int atol(const char *__nptr) throw()
  {
    return ::strtol(__nptr, (char **)0L, 10);
  }
}
extern "C"
{
  __extension__ extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) long long int atoll(const char *__nptr) throw()
  {
    return ::strtoll(__nptr, (char **)0L, 10);
  }
}
extern "C"
{
  extern char *l64a(long int __n) throw();
}
extern "C"
{
  extern long int a64l(const char *__s) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1)));
}
typedef ::__u_char u_char;
typedef ::__u_short u_short;
typedef ::__u_int u_int;
typedef ::__u_long u_long;
typedef ::__quad_t quad_t;
typedef ::__u_quad_t u_quad_t;
typedef ::__fsid_t fsid_t;
typedef ::__loff_t loff_t;
typedef ::__ino_t ino_t;
typedef ::__ino64_t ino64_t;
typedef ::__dev_t dev_t;
typedef ::__gid_t gid_t;
typedef ::__mode_t mode_t;
typedef ::__nlink_t nlink_t;
typedef ::__uid_t uid_t;
typedef ::__off_t off_t;
typedef ::__off64_t off64_t;
typedef ::__id_t id_t;
typedef ::__ssize_t ssize_t;
typedef ::__daddr_t daddr_t;
typedef ::__caddr_t caddr_t;
typedef ::__key_t key_t;
typedef ::__useconds_t useconds_t;
typedef ::__suseconds_t suseconds_t;
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
typedef unsigned char u_int8_t;
typedef unsigned short int u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long int u_int64_t;
typedef long int register_t;
typedef int __sig_atomic_t;
struct  __sigset_t
{
    unsigned long int __val[16L];
};
typedef ::__sigset_t sigset_t;
typedef long int __fd_mask;
struct  fd_set
{
    ::__fd_mask fds_bits[16L];
};
typedef ::__fd_mask fd_mask;
extern "C"
{
  extern int select(int __nfds, ::fd_set *__restrict __readfds, ::fd_set *__restrict __writefds, ::fd_set *__restrict __exceptfds, ::timeval *__restrict __timeout);
}
extern "C"
{
  extern int pselect(int __nfds, ::fd_set *__restrict __readfds, ::fd_set *__restrict __writefds, ::fd_set *__restrict __exceptfds, const ::timespec *__restrict __timeout, const ::__sigset_t *__restrict __sigmask);
}
extern "C"
{
  extern inline unsigned int gnu_dev_major(unsigned long long int __dev) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline unsigned int gnu_dev_minor(unsigned long long int __dev) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline unsigned long long int gnu_dev_makedev(unsigned int __major, unsigned int __minor) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  __extension__ extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) unsigned int gnu_dev_major(unsigned long long int __dev) throw()
  {
    return (__dev >> 8 & 4095) | ((unsigned int)(__dev >> 32) & ~4095);
  }
}
extern "C"
{
  __extension__ extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) unsigned int gnu_dev_minor(unsigned long long int __dev) throw()
  {
    return (__dev & 255) | ((unsigned int)(__dev >> 12) & ~255);
  }
}
extern "C"
{
  __extension__ extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) unsigned long long int gnu_dev_makedev(unsigned int __major, unsigned int __minor) throw()
  {
    return (((__minor & 255) | (__major & 4095) << 8) | (unsigned long long int)(__minor & ~255) << 12) | (unsigned long long int)(__major & ~4095) << 32;
  }
}
typedef ::__blksize_t blksize_t;
typedef ::__blkcnt_t blkcnt_t;
typedef ::__fsblkcnt_t fsblkcnt_t;
typedef ::__fsfilcnt_t fsfilcnt_t;
typedef ::__blkcnt64_t blkcnt64_t;
typedef ::__fsblkcnt64_t fsblkcnt64_t;
typedef ::__fsfilcnt64_t fsfilcnt64_t;
extern "C"
{
  extern long int random() throw();
}
extern "C"
{
  extern void srandom(unsigned int __seed) throw();
}
extern "C"
{
  extern char *initstate(unsigned int __seed, char *__statebuf, ::size_t __statelen) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern char *setstate(char *__statebuf) throw() __attribute__((__nonnull__(1)));
}
struct  random_data
{
    ::int32_t *fptr;
    ::int32_t *rptr;
    ::int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    ::int32_t *end_ptr;
};
extern "C"
{
  extern int random_r(::random_data *__restrict __buf, ::int32_t *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int srandom_r(unsigned int __seed, ::random_data *__buf) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int initstate_r(unsigned int __seed, char *__restrict __statebuf, ::size_t __statelen, ::random_data *__restrict __buf) throw() __attribute__((__nonnull__(2, 4)));
}
extern "C"
{
  extern int setstate_r(char *__restrict __statebuf, ::random_data *__restrict __buf) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int rand() throw();
}
extern "C"
{
  extern void srand(unsigned int __seed) throw();
}
extern "C"
{
  extern int rand_r(unsigned int *__seed) throw();
}
extern "C"
{
  extern double drand48() throw();
}
extern "C"
{
  extern double erand48(unsigned short int __xsubi[3L]) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int lrand48() throw();
}
extern "C"
{
  extern long int nrand48(unsigned short int __xsubi[3L]) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int mrand48() throw();
}
extern "C"
{
  extern long int jrand48(unsigned short int __xsubi[3L]) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void srand48(long int __seedval) throw();
}
extern "C"
{
  extern unsigned short int *seed48(unsigned short int __seed16v[3L]) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void lcong48(unsigned short int __param[7L]) throw() __attribute__((__nonnull__(1)));
}
struct  drand48_data
{
    unsigned short int __x[3L];
    unsigned short int __old_x[3L];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;
};
extern "C"
{
  extern int drand48_r(::drand48_data *__restrict __buffer, double *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int erand48_r(unsigned short int __xsubi[3L], ::drand48_data *__restrict __buffer, double *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int lrand48_r(::drand48_data *__restrict __buffer, long int *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int nrand48_r(unsigned short int __xsubi[3L], ::drand48_data *__restrict __buffer, long int *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int mrand48_r(::drand48_data *__restrict __buffer, long int *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int jrand48_r(unsigned short int __xsubi[3L], ::drand48_data *__restrict __buffer, long int *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int srand48_r(long int __seedval, ::drand48_data *__buffer) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int seed48_r(unsigned short int __seed16v[3L], ::drand48_data *__buffer) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int lcong48_r(unsigned short int __param[7L], ::drand48_data *__buffer) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern void *malloc(::size_t __size) throw() __attribute__((__malloc__));
}
extern "C"
{
  extern void *calloc(::size_t __nmemb, ::size_t __size) throw() __attribute__((__malloc__));
}
extern "C"
{
  extern void *realloc(void *__ptr, ::size_t __size) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void free(void *__ptr) throw();
}
extern "C"
{
  extern void cfree(void *__ptr) throw();
}
extern "C"
{
  extern void *alloca(::size_t __size) throw();
}
extern "C"
{
  extern void *valloc(::size_t __size) throw() __attribute__((__malloc__));
}
extern "C"
{
  extern int posix_memalign(void **__memptr, ::size_t __alignment, ::size_t __size) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void *aligned_alloc(::size_t __alignment, ::size_t __size) throw() __attribute__((__malloc__)) __attribute__((__alloc_size__(2)));
}
extern "C"
{
  extern void abort() throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern int atexit(void (*__func)()) throw() __attribute__((__nonnull__(1)));
}
int at_quick_exit(void (*__func)()) throw() __asm("at_quick_exit") __attribute__((__nonnull__(1)));
extern "C"
{
  extern int on_exit(void (*__func)(int, void *), void *__arg) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void exit(int __status) throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern void quick_exit(int __status) throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern void _Exit(int __status) throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern char *getenv(const char *__name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *secure_getenv(const char *__name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int putenv(char *__string) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int setenv(const char *__name, const char *__value, int __replace) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int unsetenv(const char *__name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int clearenv() throw();
}
extern "C"
{
  extern char *mktemp(char *__template) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkstemp(char *__template) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkstemp64(char *__template) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkstemps(char *__template, int __suffixlen) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkstemps64(char *__template, int __suffixlen) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *mkdtemp(char *__template) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkostemp(char *__template, int __flags) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkostemp64(char *__template, int __flags) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkostemps(char *__template, int __suffixlen, int __flags) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkostemps64(char *__template, int __suffixlen, int __flags) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int system(const char *__command);
}
extern "C"
{
  extern char *canonicalize_file_name(const char *__name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *realpath(const char *__restrict __name, char *__restrict __resolved) throw();
}
typedef int (*__compar_fn_t)(const void *, const void *);
typedef ::__compar_fn_t comparison_fn_t;
typedef int (*__compar_d_fn_t)(const void *, const void *, void *);
extern "C"
{
  extern inline void *bsearch(const void *__key, const void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_fn_t __compar) __attribute__((__nonnull__(1, 2, 5))) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2, 5))) __attribute__((__gnu_inline__)) void *bsearch(const void *__key, const void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_fn_t __compar)
  {
    ::size_t __l;
    ::size_t __u;
    ::size_t __idx;
    const void *__p;
    int __comparison;
    __l = 0;
    __u = __nmemb;
    while (__l < __u)
      {
        __idx = (__l + __u) / 2;
        __p = (void *)((const char *)__base + __idx * __size);
        __comparison = (*__compar)(__key, __p);
        if (__comparison < 0)
          {
            __u = __idx;
          }
        else
          {
            if (__comparison > 0)
              {
                __l = __idx + 1;
              }
            else
              {
                return (void *)__p;
              }
          }
      }
    return 0L;
  }
}
extern "C"
{
  extern void qsort(void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_fn_t __compar) __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern void qsort_r(void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_d_fn_t __compar, void *__arg) __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern int abs(int __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long int labs(long int __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long long int llabs(long long int __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::div_t div(int __numer, int __denom) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::ldiv_t ldiv(long int __numer, long int __denom) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::lldiv_t lldiv(long long int __numer, long long int __denom) throw() __attribute__((__const__));
}
extern "C"
{
  extern char *ecvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((__nonnull__(3, 4)));
}
extern "C"
{
  extern char *fcvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((__nonnull__(3, 4)));
}
extern "C"
{
  extern char *gcvt(double __value, int __ndigit, char *__buf) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern char *qecvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((__nonnull__(3, 4)));
}
extern "C"
{
  extern char *qfcvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((__nonnull__(3, 4)));
}
extern "C"
{
  extern char *qgcvt(long double __value, int __ndigit, char *__buf) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int mblen(const char *__s, ::size_t __n) throw();
}
extern "C"
{
  extern int mbtowc(wchar_t *__restrict __pwc, const char *__restrict __s, ::size_t __n) throw();
}
extern "C"
{
  extern int wctomb(char *__s, wchar_t __wchar) throw();
}
extern "C"
{
  extern ::size_t mbstowcs(wchar_t *__restrict __pwcs, const char *__restrict __s, ::size_t __n) throw();
}
extern "C"
{
  extern ::size_t wcstombs(char *__restrict __s, const wchar_t *__restrict __pwcs, ::size_t __n) throw();
}
extern "C"
{
  extern int rpmatch(const char *__response) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int getsubopt(char **__restrict __optionp, char *const *__restrict __tokens, char **__restrict __valuep) throw() __attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern void setkey(const char *__key) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int posix_openpt(int __oflag);
}
extern "C"
{
  extern int grantpt(int __fd) throw();
}
extern "C"
{
  extern int unlockpt(int __fd) throw();
}
extern "C"
{
  extern char *ptsname(int __fd) throw();
}
extern "C"
{
  extern int ptsname_r(int __fd, char *__buf, ::size_t __buflen) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int getpt();
}
extern "C"
{
  extern int getloadavg(double __loadavg[], int __nelem) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) double atof(const char *__nptr) throw()
  {
    return ::strtod(__nptr, (char **)0L);
  }
}
namespace std __attribute__((__visibility__("default"))) {
  using ::div_t;
  using ::ldiv_t;
  using ::abort;
  using ::abs;
  using ::atexit;
  using ::at_quick_exit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;
  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;
  using ::qsort;
  using ::quick_exit;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;
  using ::wcstombs;
  using ::wctomb;
  inline long int abs(long int __i)
  {
    return __builtin_labs(__i);
  }
  inline ::ldiv_t div(long int __i, long int __j)
  {
    return ::std::ldiv(__i, __j);
  }
  inline long long int abs(long long int __x)
  {
    return __builtin_llabs(__x);
  }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::lldiv_t;
  using ::_Exit;
  using ::llabs;
  inline ::lldiv_t div(long long int __n, long long int __d)
  {
    ::lldiv_t __q /* () */ ;
    __q.quot = __n / __d;
    __q.rem = __n % __d;
    return __q;
  }
  using ::lldiv;
  using ::atoll;
  using ::strtoll;
  using ::strtoull;
  using ::strtof;
  using ::strtold;
}
namespace std __attribute__((__visibility__("default"))) {
  using ::__gnu_cxx::lldiv_t;
  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;
  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
struct  _G_fpos_t
{
    ::__off_t __pos;
    ::__mbstate_t __state;
};
struct  _G_fpos64_t
{
    ::__off64_t __pos;
    ::__mbstate_t __state;
};
struct _IO_jump_t;
typedef void _IO_lock_t;
struct _IO_marker;
struct  _IO_marker
{
    ::_IO_marker *_next;
    ::_IO_FILE *_sbuf;
    int _pos;
};
enum __codecvt_result
{
  __codecvt_ok = 0,
  __codecvt_partial = 1,
  __codecvt_error = 2,
  __codecvt_noconv = 3
};
struct  _IO_FILE
{
    int _flags;
    char *_IO_read_ptr;
    char *_IO_read_end;
    char *_IO_read_base;
    char *_IO_write_base;
    char *_IO_write_ptr;
    char *_IO_write_end;
    char *_IO_buf_base;
    char *_IO_buf_end;
    char *_IO_save_base;
    char *_IO_backup_base;
    char *_IO_save_end;
    ::_IO_marker *_markers;
    ::_IO_FILE *_chain;
    int _fileno;
    int _flags2;
    ::__off_t _old_offset;
    unsigned short int _cur_column;
    signed char _vtable_offset;
    char _shortbuf[1L];
    ::_IO_lock_t *_lock;
    ::__off64_t _offset;
    void *__pad1;
    void *__pad2;
    void *__pad3;
    void *__pad4;
    ::size_t __pad5;
    int _mode;
    char _unused2[20L];
};
struct _IO_FILE_plus;
extern "C"
{
  extern ::_IO_FILE_plus _IO_2_1_stdin_;
}
extern "C"
{
  extern ::_IO_FILE_plus _IO_2_1_stdout_;
}
extern "C"
{
  extern ::_IO_FILE_plus _IO_2_1_stderr_;
}
typedef ::__ssize_t __io_read_fn(void *, char *, ::size_t);
typedef ::__ssize_t __io_write_fn(void *, const char *, ::size_t);
typedef int __io_seek_fn(void *, ::__off64_t *, int);
typedef int __io_close_fn(void *);
typedef ::__io_read_fn cookie_read_function_t;
typedef ::__io_write_fn cookie_write_function_t;
typedef ::__io_seek_fn cookie_seek_function_t;
typedef ::__io_close_fn cookie_close_function_t;
struct  _IO_cookie_io_functions_t
{
    ::__io_read_fn (*read);
    ::__io_write_fn (*write);
    ::__io_seek_fn (*seek);
    ::__io_close_fn (*close);
};
typedef ::_IO_cookie_io_functions_t cookie_io_functions_t;
struct _IO_cookie_file;
extern "C"
{
  extern void _IO_cookie_init(::_IO_cookie_file *__cfile, int __read_write, void *__cookie, ::_IO_cookie_io_functions_t __fns);
}
extern "C"
{
  extern int __underflow(::_IO_FILE *);
}
extern "C"
{
  extern int __uflow(::_IO_FILE *);
}
extern "C"
{
  extern int __overflow(::_IO_FILE *, int);
}
extern "C"
{
  extern int _IO_getc(::_IO_FILE *__fp);
}
extern "C"
{
  extern int _IO_putc(int __c, ::_IO_FILE *__fp);
}
extern "C"
{
  extern int _IO_feof(::_IO_FILE *__fp) throw();
}
extern "C"
{
  extern int _IO_ferror(::_IO_FILE *__fp) throw();
}
extern "C"
{
  extern int _IO_peekc_locked(::_IO_FILE *__fp);
}
extern "C"
{
  extern void _IO_flockfile(::_IO_FILE *) throw();
}
extern "C"
{
  extern void _IO_funlockfile(::_IO_FILE *) throw();
}
extern "C"
{
  extern int _IO_ftrylockfile(::_IO_FILE *) throw();
}
extern "C"
{
  extern int _IO_vfscanf(::_IO_FILE *__restrict , const char *__restrict , ::__gnuc_va_list, int *__restrict );
}
extern "C"
{
  extern int _IO_vfprintf(::_IO_FILE *__restrict , const char *__restrict , ::__gnuc_va_list);
}
extern "C"
{
  extern ::__ssize_t _IO_padn(::_IO_FILE *, int, ::__ssize_t);
}
extern "C"
{
  extern ::size_t _IO_sgetn(::_IO_FILE *, void *, ::size_t);
}
extern "C"
{
  extern ::__off64_t _IO_seekoff(::_IO_FILE *, ::__off64_t, int, int);
}
extern "C"
{
  extern ::__off64_t _IO_seekpos(::_IO_FILE *, ::__off64_t, int);
}
extern "C"
{
  extern void _IO_free_backup_area(::_IO_FILE *) throw();
}
typedef ::__gnuc_va_list va_list;
typedef ::_G_fpos_t fpos_t;
typedef ::_G_fpos64_t fpos64_t;
extern "C"
{
  extern ::_IO_FILE *stdin;
}
extern "C"
{
  extern ::_IO_FILE *stdout;
}
extern "C"
{
  extern ::_IO_FILE *stderr;
}
extern "C"
{
  extern int remove(const char *__filename) throw();
}
extern "C"
{
  extern int rename(const char *__old, const char *__new) throw();
}
extern "C"
{
  extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new) throw();
}
extern "C"
{
  extern ::FILE *tmpfile();
}
extern "C"
{
  extern ::FILE *tmpfile64();
}
extern "C"
{
  extern char *tmpnam(char *__s) throw();
}
extern "C"
{
  extern char *tmpnam_r(char *__s) throw();
}
extern "C"
{
  extern char *tempnam(const char *__dir, const char *__pfx) throw() __attribute__((__malloc__));
}
extern "C"
{
  extern int fclose(::FILE *__stream);
}
extern "C"
{
  extern int fflush(::FILE *__stream);
}
extern "C"
{
  extern int fflush_unlocked(::FILE *__stream);
}
extern "C"
{
  extern int fcloseall();
}
extern "C"
{
  extern ::FILE *fopen(const char *__restrict __filename, const char *__restrict __modes);
}
extern "C"
{
  extern ::FILE *freopen(const char *__restrict __filename, const char *__restrict __modes, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::FILE *fopen64(const char *__restrict __filename, const char *__restrict __modes);
}
extern "C"
{
  extern ::FILE *freopen64(const char *__restrict __filename, const char *__restrict __modes, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::FILE *fdopen(int __fd, const char *__modes) throw();
}
extern "C"
{
  extern ::FILE *fopencookie(void *__restrict __magic_cookie, const char *__restrict __modes, ::_IO_cookie_io_functions_t __io_funcs) throw();
}
extern "C"
{
  extern ::FILE *fmemopen(void *__s, ::size_t __len, const char *__modes) throw();
}
extern "C"
{
  extern ::FILE *open_memstream(char **__bufloc, ::size_t *__sizeloc) throw();
}
extern "C"
{
  extern void setbuf(::FILE *__restrict __stream, char *__restrict __buf) throw();
}
extern "C"
{
  extern int setvbuf(::FILE *__restrict __stream, char *__restrict __buf, int __modes, ::size_t __n) throw();
}
extern "C"
{
  extern void setbuffer(::FILE *__restrict __stream, char *__restrict __buf, ::size_t __size) throw();
}
extern "C"
{
  extern void setlinebuf(::FILE *__stream) throw();
}
extern "C"
{
  extern int fprintf(::FILE *__restrict __stream, const char *__restrict __format, ...);
}
extern "C"
{
  extern int printf(const char *__restrict __format, ...);
}
extern "C"
{
  extern int sprintf(char *__restrict __s, const char *__restrict __format, ...) throw();
}
extern "C"
{
  extern int vfprintf(::FILE *__restrict __s, const char *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern inline int vprintf(const char *__restrict __fmt, ::__gnuc_va_list __arg) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int vsprintf(char *__restrict __s, const char *__restrict __format, ::__gnuc_va_list __arg) throw();
}
extern "C"
{
  extern int snprintf(char *__restrict __s, ::size_t __maxlen, const char *__restrict __format, ...) throw() __attribute__((__format__(__printf__, 3, 4)));
}
extern "C"
{
  extern int vsnprintf(char *__restrict __s, ::size_t __maxlen, const char *__restrict __format, ::__gnuc_va_list __arg) throw() __attribute__((__format__(__printf__, 3, 0)));
}
extern "C"
{
  extern int vasprintf(char **__restrict __ptr, const char *__restrict __f, ::__gnuc_va_list __arg) throw() __attribute__((__format__(__printf__, 2, 0)));
}
extern "C"
{
  extern int __asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) throw() __attribute__((__format__(__printf__, 2, 3)));
}
extern "C"
{
  extern int asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) throw() __attribute__((__format__(__printf__, 2, 3)));
}
extern "C"
{
  extern int vdprintf(int __fd, const char *__restrict __fmt, ::__gnuc_va_list __arg) __attribute__((__format__(__printf__, 2, 0)));
}
extern "C"
{
  extern int dprintf(int __fd, const char *__restrict __fmt, ...) __attribute__((__format__(__printf__, 2, 3)));
}
extern "C"
{
  extern int fscanf(::FILE *__restrict __stream, const char *__restrict __format, ...);
}
extern "C"
{
  extern int scanf(const char *__restrict __format, ...);
}
extern "C"
{
  extern int sscanf(const char *__restrict __s, const char *__restrict __format, ...) throw();
}
extern "C"
{
  extern int vfscanf(::FILE *__restrict __s, const char *__restrict __format, ::__gnuc_va_list __arg) __attribute__((__format__(__scanf__, 2, 0)));
}
extern "C"
{
  extern int vscanf(const char *__restrict __format, ::__gnuc_va_list __arg) __attribute__((__format__(__scanf__, 1, 0)));
}
extern "C"
{
  extern int vsscanf(const char *__restrict __s, const char *__restrict __format, ::__gnuc_va_list __arg) throw() __attribute__((__format__(__scanf__, 2, 0)));
}
extern "C"
{
  extern int fgetc(::FILE *__stream);
}
extern "C"
{
  extern int getc(::FILE *__stream);
}
extern "C"
{
  extern inline int getchar() __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int getc_unlocked(::FILE *__fp) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int getchar_unlocked() __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int fgetc_unlocked(::FILE *__fp) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int fputc(int __c, ::FILE *__stream);
}
extern "C"
{
  extern int putc(int __c, ::FILE *__stream);
}
extern "C"
{
  extern inline int putchar(int __c) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int fputc_unlocked(int __c, ::FILE *__stream) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int putc_unlocked(int __c, ::FILE *__stream) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int putchar_unlocked(int __c) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int getw(::FILE *__stream);
}
extern "C"
{
  extern int putw(int __w, ::FILE *__stream);
}
extern "C"
{
  extern char *fgets(char *__restrict __s, int __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern char *gets(char *__s) __attribute__((__deprecated__));
}
extern "C"
{
  extern char *fgets_unlocked(char *__restrict __s, int __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::__ssize_t __getdelim(char **__restrict __lineptr, ::size_t *__restrict __n, int __delimiter, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::__ssize_t getdelim(char **__restrict __lineptr, ::size_t *__restrict __n, int __delimiter, ::FILE *__restrict __stream);
}
extern "C"
{
  extern inline ::__ssize_t getline(char **__restrict __lineptr, ::size_t *__restrict __n, ::FILE *__restrict __stream) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int fputs(const char *__restrict __s, ::FILE *__restrict __stream);
}
extern "C"
{
  extern int puts(const char *__s);
}
extern "C"
{
  extern int ungetc(int __c, ::FILE *__stream);
}
extern "C"
{
  extern ::size_t fread(void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::size_t fwrite(const void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __s);
}
extern "C"
{
  extern int fputs_unlocked(const char *__restrict __s, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::size_t fread_unlocked(void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::size_t fwrite_unlocked(const void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern int fseek(::FILE *__stream, long int __off, int __whence);
}
extern "C"
{
  extern long int ftell(::FILE *__stream);
}
extern "C"
{
  extern void rewind(::FILE *__stream);
}
extern "C"
{
  extern int fseeko(::FILE *__stream, ::__off_t __off, int __whence);
}
extern "C"
{
  extern ::__off_t ftello(::FILE *__stream);
}
extern "C"
{
  extern int fgetpos(::FILE *__restrict __stream, ::fpos_t *__restrict __pos);
}
extern "C"
{
  extern int fsetpos(::FILE *__stream, const ::fpos_t *__pos);
}
extern "C"
{
  extern int fseeko64(::FILE *__stream, ::__off64_t __off, int __whence);
}
extern "C"
{
  extern ::__off64_t ftello64(::FILE *__stream);
}
extern "C"
{
  extern int fgetpos64(::FILE *__restrict __stream, ::fpos64_t *__restrict __pos);
}
extern "C"
{
  extern int fsetpos64(::FILE *__stream, const ::fpos64_t *__pos);
}
extern "C"
{
  extern void clearerr(::FILE *__stream) throw();
}
extern "C"
{
  extern int feof(::FILE *__stream) throw();
}
extern "C"
{
  extern int ferror(::FILE *__stream) throw();
}
extern "C"
{
  extern void clearerr_unlocked(::FILE *__stream) throw();
}
extern "C"
{
  extern inline int feof_unlocked(::FILE *__stream) throw() __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int ferror_unlocked(::FILE *__stream) throw() __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern void perror(const char *__s);
}
extern "C"
{
  extern int sys_nerr;
}
extern "C"
{
  extern const char *const sys_errlist[];
}
extern "C"
{
  extern int _sys_nerr;
}
extern "C"
{
  extern const char *const _sys_errlist[];
}
extern "C"
{
  extern int fileno(::FILE *__stream) throw();
}
extern "C"
{
  extern int fileno_unlocked(::FILE *__stream) throw();
}
extern "C"
{
  extern ::FILE *popen(const char *__command, const char *__modes);
}
extern "C"
{
  extern int pclose(::FILE *__stream);
}
extern "C"
{
  extern char *ctermid(char *__s) throw();
}
extern "C"
{
  extern char *cuserid(char *__s);
}
struct obstack;
extern "C"
{
  extern int obstack_printf(::obstack *__restrict __obstack, const char *__restrict __format, ...) throw() __attribute__((__format__(__printf__, 2, 3)));
}
extern "C"
{
  extern int obstack_vprintf(::obstack *__restrict __obstack, const char *__restrict __format, ::__gnuc_va_list __args) throw() __attribute__((__format__(__printf__, 2, 0)));
}
extern "C"
{
  extern void flockfile(::FILE *__stream) throw();
}
extern "C"
{
  extern int ftrylockfile(::FILE *__stream) throw();
}
extern "C"
{
  extern void funlockfile(::FILE *__stream) throw();
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int vprintf(const char *__restrict __fmt, ::__gnuc_va_list __arg)
  {
    return ::vfprintf(::stdout, __fmt, __arg);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int getchar()
  {
    return ::_IO_getc(::stdin);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int fgetc_unlocked(::FILE *__fp)
  {
    return __builtin_expect((*__fp)._IO_read_ptr >= (*__fp)._IO_read_end, 0) ? ::__uflow(__fp) : *((unsigned char *)(*__fp)._IO_read_ptr++);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int getc_unlocked(::FILE *__fp)
  {
    return __builtin_expect((*__fp)._IO_read_ptr >= (*__fp)._IO_read_end, 0) ? ::__uflow(__fp) : *((unsigned char *)(*__fp)._IO_read_ptr++);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int getchar_unlocked()
  {
    return __builtin_expect((*::stdin)._IO_read_ptr >= (*::stdin)._IO_read_end, 0) ? ::__uflow(::stdin) : *((unsigned char *)(*::stdin)._IO_read_ptr++);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int putchar(int __c)
  {
    return ::_IO_putc(__c, ::stdout);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int fputc_unlocked(int __c, ::FILE *__stream)
  {
    return __builtin_expect((*__stream)._IO_write_ptr >= (*__stream)._IO_write_end, 0) ? ::__overflow(__stream, (unsigned char)__c) : (unsigned char)(*(*__stream)._IO_write_ptr++ = __c);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int putc_unlocked(int __c, ::FILE *__stream)
  {
    return __builtin_expect((*__stream)._IO_write_ptr >= (*__stream)._IO_write_end, 0) ? ::__overflow(__stream, (unsigned char)__c) : (unsigned char)(*(*__stream)._IO_write_ptr++ = __c);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int putchar_unlocked(int __c)
  {
    return __builtin_expect((*::stdout)._IO_write_ptr >= (*::stdout)._IO_write_end, 0) ? ::__overflow(::stdout, (unsigned char)__c) : (unsigned char)(*(*::stdout)._IO_write_ptr++ = __c);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) ::__ssize_t getline(char **__lineptr, ::size_t *__n, ::FILE *__stream)
  {
    return ::__getdelim(__lineptr, __n, '\n', __stream);
  }
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int feof_unlocked(::FILE *__stream) throw()
  {
    return ((*__stream)._flags & 16) != 0;
  }
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int ferror_unlocked(::FILE *__stream) throw()
  {
    return ((*__stream)._flags & 32) != 0;
  }
}
namespace std __attribute__((__visibility__("default"))) {
  using ::FILE;
  using ::fpos_t;
  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;
}
namespace std __attribute__((__visibility__("default"))) {
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
extern "C"
{
  extern int *__errno_location() throw() __attribute__((__const__));
}
extern "C"
{
  extern char *program_invocation_name;
}
extern "C"
{
  extern char *program_invocation_short_name;
}
typedef int error_t;
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < typename _TRet, typename _Ret = _TRet, typename _CharT, typename ..._Base >
  _Ret __stoa(_TRet (*__convf)(const _CharT *, _CharT **, _Base ...), const char *__name, const _CharT *__str, ::std::size_t *__idx, _Base ...__base);
  template < typename _TRet, typename _Ret, typename _CharT, typename ..._Base >
  _Ret __stoa(_TRet (*__convf)(const _CharT *, _CharT **, _Base ...), const char *__name, const _CharT *__str, ::std::size_t *__idx, _Base ...__base)
  {
    _Ret __ret;
    _CharT *__endptr;
    *::__errno_location() = 0;
    const _TRet __tmp = __convf(__str, &__endptr, __base ...);
    if (__endptr == __str)
      {
        std::__throw_invalid_argument(__name);
      }
    else
      {
        if (*::__errno_location() == 34 || (std::__are_same<_Ret, int>::__value && (__tmp < ::__gnu_cxx::__numeric_traits_integer<int>::__min || __tmp > ::__gnu_cxx::__numeric_traits_integer<int>::__max)))
          {
            std::__throw_out_of_range(__name);
          }
        else
          {
            __ret = __tmp;
          }
      }
    if (__idx)
      {
        *__idx = __endptr - __str;
      }
    return __ret;
  }
  template < typename _String, typename _CharT = typename _String::value_type >
  _String __to_xstring(int (*__convf)(_CharT *, ::std::size_t, const _CharT *, ::__builtin_va_list), ::std::size_t __n, const _CharT *__fmt, ...);
  template < typename _String, typename _CharT >
  _String __to_xstring(int (*__convf)(_CharT *, ::std::size_t, const _CharT *, ::__builtin_va_list), ::std::size_t __n, const _CharT *__fmt, ...)
  {
    _CharT *__s = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __n));
    ::__builtin_va_list __args;
    __builtin_va_start(__args, __fmt);
    const int __len = __convf(__s, __n, __fmt, __args);
    __builtin_va_end(__args);
    return _String(__s, __s + __len);
  }
 /* Instantiation of class template '::__gnu_cxx::new_allocator<char>' */ 
 /* Instantiation of class template '::std::allocator<char>' */ 
 /* Instantiation of class template '::std::allocator<char>::rebind<char>' */ 
 /* Instantiation of class template '::std::basic_string<char>::_Alloc_hider' */ 
 /* Instantiation of class template '::std::basic_string<char>' */ 
 /* Instantiation of template function 'const char *::std::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'int ::__gnu_cxx::__stoa<long int, int, char, int>(long int (*)(const char *, char **, int), const char *, const char *, unsigned long int *, int)' */ 
}
namespace std __attribute__((__visibility__("default"))) {
  inline int stoi(const ::std::string &__str, ::std::size_t *__idx  = (0), int __base  = (10))
  {
    return __gnu_cxx::__stoa<long int, int>(::strtol, "stoi", __str.::std::basic_string<char>::c_str(), __idx, __base);
  }
 /* Instantiation of template function 'const char *::std::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'long int ::__gnu_cxx::__stoa<long int, long int, char, int>(long int (*)(const char *, char **, int), const char *, const char *, unsigned long int *, int)' */ 
  inline long int stol(const ::std::string &__str, ::std::size_t *__idx  = (0), int __base  = (10))
  {
    return __gnu_cxx::__stoa(::strtol, "stol", __str.::std::basic_string<char>::c_str(), __idx, __base);
  }
 /* Instantiation of template function 'const char *::std::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'unsigned long int ::__gnu_cxx::__stoa<unsigned long int, unsigned long int, char, int>(unsigned long int (*)(const char *, char **, int), const char *, const char *, unsigned long int *, int)' */ 
  inline unsigned long int stoul(const ::std::string &__str, ::std::size_t *__idx  = (0), int __base  = (10))
  {
    return __gnu_cxx::__stoa(::strtoul, "stoul", __str.::std::basic_string<char>::c_str(), __idx, __base);
  }
 /* Instantiation of template function 'const char *::std::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'long long int ::__gnu_cxx::__stoa<long long int, long long int, char, int>(long long int (*)(const char *, char **, int), const char *, const char *, unsigned long int *, int)' */ 
  inline long long int stoll(const ::std::string &__str, ::std::size_t *__idx  = (0), int __base  = (10))
  {
    return __gnu_cxx::__stoa(::strtoll, "stoll", __str.::std::basic_string<char>::c_str(), __idx, __base);
  }
 /* Instantiation of template function 'const char *::std::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'unsigned long long int ::__gnu_cxx::__stoa<unsigned long long int, unsigned long long int, char, int>(unsigned long long int (*)(const char *, char **, int), const char *, const char *, unsigned long int *, int)' */ 
  inline unsigned long long int stoull(const ::std::string &__str, ::std::size_t *__idx  = (0), int __base  = (10))
  {
    return __gnu_cxx::__stoa(::strtoull, "stoull", __str.::std::basic_string<char>::c_str(), __idx, __base);
  }
 /* Instantiation of template function 'const char *::std::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'float ::__gnu_cxx::__stoa<float, float, char>(float (*)(const char *, char **), const char *, const char *, unsigned long int *)' */ 
  inline float stof(const ::std::string &__str, ::std::size_t *__idx  = (0))
  {
    return __gnu_cxx::__stoa(::strtof, "stof", __str.::std::basic_string<char>::c_str(), __idx);
  }
 /* Instantiation of template function 'const char *::std::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'double ::__gnu_cxx::__stoa<double, double, char>(double (*)(const char *, char **), const char *, const char *, unsigned long int *)' */ 
  inline double stod(const ::std::string &__str, ::std::size_t *__idx  = (0))
  {
    return __gnu_cxx::__stoa(::strtod, "stod", __str.::std::basic_string<char>::c_str(), __idx);
  }
 /* Instantiation of template function 'const char *::std::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'long double ::__gnu_cxx::__stoa<long double, long double, char>(long double (*)(const char *, char **), const char *, const char *, unsigned long int *)' */ 
  inline long double stold(const ::std::string &__str, ::std::size_t *__idx  = (0))
  {
    return __gnu_cxx::__stoa(::strtold, "stold", __str.::std::basic_string<char>::c_str(), __idx);
  }
 /* Instantiation of template function '::std::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of class template '::std::initializer_list<char>' */ 
 /* Instantiation of template function '::std::basic_string<char>::basic_string(::std::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<char>::~basic_string() const ' */ 
  inline ::std::string to_string(int __val)
  {
    return __gnu_cxx::__to_xstring< ::std::string>(::vsnprintf, 4 * sizeof(int), "%d", __val);
  }
 /* Instantiation of template function '::std::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<char>::basic_string(::std::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<char>::~basic_string() const ' */ 
  inline ::std::string to_string(unsigned int __val)
  {
    return __gnu_cxx::__to_xstring< ::std::string>(::vsnprintf, 4 * sizeof(unsigned int), "%u", __val);
  }
 /* Instantiation of template function '::std::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<char>::basic_string(::std::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<char>::~basic_string() const ' */ 
  inline ::std::string to_string(long int __val)
  {
    return __gnu_cxx::__to_xstring< ::std::string>(::vsnprintf, 4 * sizeof(long int), "%ld", __val);
  }
 /* Instantiation of template function '::std::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<char>::basic_string(::std::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<char>::~basic_string() const ' */ 
  inline ::std::string to_string(unsigned long int __val)
  {
    return __gnu_cxx::__to_xstring< ::std::string>(::vsnprintf, 4 * sizeof(unsigned long int), "%lu", __val);
  }
 /* Instantiation of template function '::std::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<char>::basic_string(::std::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<char>::~basic_string() const ' */ 
  inline ::std::string to_string(long long int __val)
  {
    return __gnu_cxx::__to_xstring< ::std::string>(::vsnprintf, 4 * sizeof(long long int), "%lld", __val);
  }
 /* Instantiation of template function '::std::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<char>::basic_string(::std::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<char>::~basic_string() const ' */ 
  inline ::std::string to_string(unsigned long long int __val)
  {
    return __gnu_cxx::__to_xstring< ::std::string>(::vsnprintf, 4 * sizeof(unsigned long long int), "%llu", __val);
  }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<false, ::__gnu_cxx::__numeric_traits_integer<float>, ::__gnu_cxx::__numeric_traits_floating<float> >' */ 
 /* Instantiation of class template '::std::__are_same<float, float>' */ 
 /* Instantiation of class template '::std::__are_same<float, double>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_floating<float>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<float>' */ 
 /* Instantiation of template function '::std::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<char>::basic_string(::std::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<char>::~basic_string() const ' */ 
  inline ::std::string to_string(float __val)
  {
    const int __n(::__gnu_cxx::__numeric_traits_floating<float>::__max_exponent10 + 20);
    return __gnu_cxx::__to_xstring< ::std::string>(::vsnprintf, __n, "%f", __val);
  }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<false, ::__gnu_cxx::__numeric_traits_integer<double>, ::__gnu_cxx::__numeric_traits_floating<double> >' */ 
 /* Instantiation of class template '::std::__are_same<double, float>' */ 
 /* Instantiation of class template '::std::__are_same<double, double>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_floating<double>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<double>' */ 
 /* Instantiation of template function '::std::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<char>::basic_string(::std::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<char>::~basic_string() const ' */ 
  inline ::std::string to_string(double __val)
  {
    const int __n(::__gnu_cxx::__numeric_traits_floating<double>::__max_exponent10 + 20);
    return __gnu_cxx::__to_xstring< ::std::string>(::vsnprintf, __n, "%f", __val);
  }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<false, ::__gnu_cxx::__numeric_traits_integer<long double>, ::__gnu_cxx::__numeric_traits_floating<long double> >' */ 
 /* Instantiation of class template '::std::__are_same<long double, float>' */ 
 /* Instantiation of class template '::std::__are_same<long double, double>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_floating<long double>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<long double>' */ 
 /* Instantiation of template function '::std::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<char>::basic_string(::std::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<char>::~basic_string() const ' */ 
  inline ::std::string to_string(long double __val)
  {
    const int __n(::__gnu_cxx::__numeric_traits_floating<long double>::__max_exponent10 + 20);
    return __gnu_cxx::__to_xstring< ::std::string>(::vsnprintf, __n, "%Lf", __val);
  }
 /* Instantiation of class template '::__gnu_cxx::new_allocator<wchar_t>' */ 
 /* Instantiation of class template '::std::allocator<wchar_t>' */ 
 /* Instantiation of class template '::std::allocator<wchar_t>::rebind<wchar_t>' */ 
 /* Instantiation of class template '::std::basic_string<wchar_t>::_Alloc_hider' */ 
 /* Instantiation of class template '::std::basic_string<wchar_t>' */ 
 /* Instantiation of template function 'const wchar_t *::std::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'int ::__gnu_cxx::__stoa<long int, int, wchar_t, int>(long int (*)(const wchar_t *, wchar_t **, int), const char *, const wchar_t *, unsigned long int *, int)' */ 
  inline int stoi(const ::std::wstring &__str, ::std::size_t *__idx  = (0), int __base  = (10))
  {
    return __gnu_cxx::__stoa<long int, int>(::wcstol, "stoi", __str.::std::basic_string<wchar_t>::c_str(), __idx, __base);
  }
 /* Instantiation of template function 'const wchar_t *::std::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'long int ::__gnu_cxx::__stoa<long int, long int, wchar_t, int>(long int (*)(const wchar_t *, wchar_t **, int), const char *, const wchar_t *, unsigned long int *, int)' */ 
  inline long int stol(const ::std::wstring &__str, ::std::size_t *__idx  = (0), int __base  = (10))
  {
    return __gnu_cxx::__stoa(::wcstol, "stol", __str.::std::basic_string<wchar_t>::c_str(), __idx, __base);
  }
 /* Instantiation of template function 'const wchar_t *::std::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'unsigned long int ::__gnu_cxx::__stoa<unsigned long int, unsigned long int, wchar_t, int>(unsigned long int (*)(const wchar_t *, wchar_t **, int), const char *, const wchar_t *, unsigned long int *, int)' */ 
  inline unsigned long int stoul(const ::std::wstring &__str, ::std::size_t *__idx  = (0), int __base  = (10))
  {
    return __gnu_cxx::__stoa(::wcstoul, "stoul", __str.::std::basic_string<wchar_t>::c_str(), __idx, __base);
  }
 /* Instantiation of template function 'const wchar_t *::std::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'long long int ::__gnu_cxx::__stoa<long long int, long long int, wchar_t, int>(long long int (*)(const wchar_t *, wchar_t **, int), const char *, const wchar_t *, unsigned long int *, int)' */ 
  inline long long int stoll(const ::std::wstring &__str, ::std::size_t *__idx  = (0), int __base  = (10))
  {
    return __gnu_cxx::__stoa(::wcstoll, "stoll", __str.::std::basic_string<wchar_t>::c_str(), __idx, __base);
  }
 /* Instantiation of template function 'const wchar_t *::std::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'unsigned long long int ::__gnu_cxx::__stoa<unsigned long long int, unsigned long long int, wchar_t, int>(unsigned long long int (*)(const wchar_t *, wchar_t **, int), const char *, const wchar_t *, unsigned long int *, int)' */ 
  inline unsigned long long int stoull(const ::std::wstring &__str, ::std::size_t *__idx  = (0), int __base  = (10))
  {
    return __gnu_cxx::__stoa(::wcstoull, "stoull", __str.::std::basic_string<wchar_t>::c_str(), __idx, __base);
  }
 /* Instantiation of template function 'const wchar_t *::std::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'float ::__gnu_cxx::__stoa<float, float, wchar_t>(float (*)(const wchar_t *, wchar_t **), const char *, const wchar_t *, unsigned long int *)' */ 
  inline float stof(const ::std::wstring &__str, ::std::size_t *__idx  = (0))
  {
    return __gnu_cxx::__stoa(::wcstof, "stof", __str.::std::basic_string<wchar_t>::c_str(), __idx);
  }
 /* Instantiation of template function 'const wchar_t *::std::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'double ::__gnu_cxx::__stoa<double, double, wchar_t>(double (*)(const wchar_t *, wchar_t **), const char *, const wchar_t *, unsigned long int *)' */ 
  inline double stod(const ::std::wstring &__str, ::std::size_t *__idx  = (0))
  {
    return __gnu_cxx::__stoa(::wcstod, "stod", __str.::std::basic_string<wchar_t>::c_str(), __idx);
  }
 /* Instantiation of template function 'const wchar_t *::std::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'long double ::__gnu_cxx::__stoa<long double, long double, wchar_t>(long double (*)(const wchar_t *, wchar_t **), const char *, const wchar_t *, unsigned long int *)' */ 
  inline long double stold(const ::std::wstring &__str, ::std::size_t *__idx  = (0))
  {
    return __gnu_cxx::__stoa(::wcstold, "stold", __str.::std::basic_string<wchar_t>::c_str(), __idx);
  }
 /* Instantiation of template function '::std::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of class template '::std::initializer_list<wchar_t>' */ 
 /* Instantiation of template function '::std::basic_string<wchar_t>::basic_string(::std::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<wchar_t>::~basic_string() const ' */ 
  inline ::std::wstring to_wstring(int __val)
  {
    return __gnu_cxx::__to_xstring< ::std::wstring>(::vswprintf, 4 * sizeof(int), L"%d", __val);
  }
 /* Instantiation of template function '::std::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<wchar_t>::basic_string(::std::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<wchar_t>::~basic_string() const ' */ 
  inline ::std::wstring to_wstring(unsigned int __val)
  {
    return __gnu_cxx::__to_xstring< ::std::wstring>(::vswprintf, 4 * sizeof(unsigned int), L"%u", __val);
  }
 /* Instantiation of template function '::std::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<wchar_t>::basic_string(::std::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<wchar_t>::~basic_string() const ' */ 
  inline ::std::wstring to_wstring(long int __val)
  {
    return __gnu_cxx::__to_xstring< ::std::wstring>(::vswprintf, 4 * sizeof(long int), L"%ld", __val);
  }
 /* Instantiation of template function '::std::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<wchar_t>::basic_string(::std::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<wchar_t>::~basic_string() const ' */ 
  inline ::std::wstring to_wstring(unsigned long int __val)
  {
    return __gnu_cxx::__to_xstring< ::std::wstring>(::vswprintf, 4 * sizeof(unsigned long int), L"%lu", __val);
  }
 /* Instantiation of template function '::std::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<wchar_t>::basic_string(::std::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<wchar_t>::~basic_string() const ' */ 
  inline ::std::wstring to_wstring(long long int __val)
  {
    return __gnu_cxx::__to_xstring< ::std::wstring>(::vswprintf, 4 * sizeof(long long int), L"%lld", __val);
  }
 /* Instantiation of template function '::std::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<wchar_t>::basic_string(::std::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<wchar_t>::~basic_string() const ' */ 
  inline ::std::wstring to_wstring(unsigned long long int __val)
  {
    return __gnu_cxx::__to_xstring< ::std::wstring>(::vswprintf, 4 * sizeof(unsigned long long int), L"%llu", __val);
  }
 /* Instantiation of template function '::std::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<wchar_t>::basic_string(::std::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<wchar_t>::~basic_string() const ' */ 
  inline ::std::wstring to_wstring(float __val)
  {
    const int __n(::__gnu_cxx::__numeric_traits_floating<float>::__max_exponent10 + 20);
    return __gnu_cxx::__to_xstring< ::std::wstring>(::vswprintf, __n, L"%f", __val);
  }
 /* Instantiation of template function '::std::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<wchar_t>::basic_string(::std::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<wchar_t>::~basic_string() const ' */ 
  inline ::std::wstring to_wstring(double __val)
  {
    const int __n(::__gnu_cxx::__numeric_traits_floating<double>::__max_exponent10 + 20);
    return __gnu_cxx::__to_xstring< ::std::wstring>(::vswprintf, __n, L"%f", __val);
  }
 /* Instantiation of template function '::std::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::basic_string<wchar_t>::basic_string(::std::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::basic_string<wchar_t>::~basic_string() const ' */ 
  inline ::std::wstring to_wstring(long double __val)
  {
    const int __n(::__gnu_cxx::__numeric_traits_floating<long double>::__max_exponent10 + 20);
    return __gnu_cxx::__to_xstring< ::std::wstring>(::vswprintf, __n, L"%Lf", __val);
  }
  ::std::size_t _Hash_bytes(const void *__ptr, ::std::size_t __len, ::std::size_t __seed);
  ::std::size_t _Fnv_hash_bytes(const void *__ptr, ::std::size_t __len, ::std::size_t __seed);
  template < typename _Result, typename _Arg >
  struct  __hash_base
  {
      typedef _Result result_type;
      typedef _Arg argument_type;
  };
  template < typename _Tp >
  struct hash;
  template < typename _Tp >
  struct  hash<_Tp *> : ::std::__hash_base<unsigned long int, _Tp *>
  {
      inline ::std::size_t operator ()(_Tp *__p) const  noexcept(true)
      {
        return reinterpret_cast< ::std::size_t>(__p);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, bool>' */ 
  template <>
  struct  hash<bool> : ::std::__hash_base<unsigned long int, bool>
  {
      inline ::std::size_t operator ()(bool __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, char>' */ 
  template <>
  struct  hash<char> : ::std::__hash_base<unsigned long int, char>
  {
      inline ::std::size_t operator ()(char __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, signed char>' */ 
  template <>
  struct  hash<signed char> : ::std::__hash_base<unsigned long int, signed char>
  {
      inline ::std::size_t operator ()(signed char __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, unsigned char>' */ 
  template <>
  struct  hash<unsigned char> : ::std::__hash_base<unsigned long int, unsigned char>
  {
      inline ::std::size_t operator ()(unsigned char __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, wchar_t>' */ 
  template <>
  struct  hash<wchar_t> : ::std::__hash_base<unsigned long int, wchar_t>
  {
      inline ::std::size_t operator ()(wchar_t __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, char16_t>' */ 
  template <>
  struct  hash<char16_t> : ::std::__hash_base<unsigned long int, char16_t>
  {
      inline ::std::size_t operator ()(char16_t __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, char32_t>' */ 
  template <>
  struct  hash<char32_t> : ::std::__hash_base<unsigned long int, char32_t>
  {
      inline ::std::size_t operator ()(char32_t __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, short int>' */ 
  template <>
  struct  hash<short int> : ::std::__hash_base<unsigned long int, short int>
  {
      inline ::std::size_t operator ()(short int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, int>' */ 
  template <>
  struct  hash<int> : ::std::__hash_base<unsigned long int, int>
  {
      inline ::std::size_t operator ()(int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, long int>' */ 
  template <>
  struct  hash<long int> : ::std::__hash_base<unsigned long int, long int>
  {
      inline ::std::size_t operator ()(long int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, long long int>' */ 
  template <>
  struct  hash<long long int> : ::std::__hash_base<unsigned long int, long long int>
  {
      inline ::std::size_t operator ()(long long int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, unsigned short int>' */ 
  template <>
  struct  hash<unsigned short int> : ::std::__hash_base<unsigned long int, unsigned short int>
  {
      inline ::std::size_t operator ()(unsigned short int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, unsigned int>' */ 
  template <>
  struct  hash<unsigned int> : ::std::__hash_base<unsigned long int, unsigned int>
  {
      inline ::std::size_t operator ()(unsigned int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, unsigned long int>' */ 
  template <>
  struct  hash<unsigned long int> : ::std::__hash_base<unsigned long int, unsigned long int>
  {
      inline ::std::size_t operator ()(unsigned long int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, unsigned long long int>' */ 
  template <>
  struct  hash<unsigned long long int> : ::std::__hash_base<unsigned long int, unsigned long long int>
  {
      inline ::std::size_t operator ()(unsigned long long int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
  struct  _Hash_impl
  {
      static inline ::std::size_t hash(const void *__ptr, ::std::size_t __clength, ::std::size_t __seed  = (static_cast< ::std::size_t>(3339675911LU)))
      {
        return ::std::_Hash_bytes(__ptr, __clength, __seed);
      }
      template < typename _Tp >
      static inline ::std::size_t hash(const _Tp &__val)
      {
        return hash(&__val, sizeof(__val));
      }
      template < typename _Tp >
      static inline ::std::size_t __hash_combine(const _Tp &__val, ::std::size_t __hash)
      {
        return hash(&__val, sizeof(__val), __hash);
      }
  };
  struct  _Fnv_hash_impl
  {
      static inline ::std::size_t hash(const void *__ptr, ::std::size_t __clength, ::std::size_t __seed  = (static_cast< ::std::size_t>(2166136261LU)))
      {
        return ::std::_Fnv_hash_bytes(__ptr, __clength, __seed);
      }
      template < typename _Tp >
      static inline ::std::size_t hash(const _Tp &__val)
      {
        return hash(&__val, sizeof(__val));
      }
      template < typename _Tp >
      static inline ::std::size_t __hash_combine(const _Tp &__val, ::std::size_t __hash)
      {
        return hash(&__val, sizeof(__val), __hash);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, float>' */ 
 /* Instantiation of template function 'unsigned long int ::std::_Hash_impl::hash<float>(const float &)' */ 
  template <>
  struct  hash<float> : ::std::__hash_base<unsigned long int, float>
  {
      inline ::std::size_t operator ()(float __val) const  noexcept(true)
      {
        return __val != 0.000000000000000000000000e+00f ? std::_Hash_impl::hash(__val) : 0;
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, double>' */ 
 /* Instantiation of template function 'unsigned long int ::std::_Hash_impl::hash<double>(const double &)' */ 
  template <>
  struct  hash<double> : ::std::__hash_base<unsigned long int, double>
  {
      inline ::std::size_t operator ()(double __val) const  noexcept(true)
      {
        return __val != 0.00000000000000000000000000000000000000000000000000000e+00 ? std::_Hash_impl::hash(__val) : 0;
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, long double>' */ 
  template <>
  struct  hash<long double> : ::std::__hash_base<unsigned long int, long double>
  {
      ::std::size_t operator ()(long double __val) const  noexcept(true) __attribute__((__pure__));
  };
  template < typename _Hash >
  struct  __is_fast_hash : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_fast_hash< ::std::hash<long double> > : ::std::integral_constant<bool, false>
  {
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, ::std::basic_string<char> >' */ 
 /* Instantiation of template function 'const char *::std::basic_string<char>::data() const ' */ 
 /* Instantiation of template function '::std::allocator<char>::size_type ::std::basic_string<char>::length() const ' */ 
  template <>
  struct  hash< ::std::basic_string<char> > : ::std::__hash_base<unsigned long int, ::std::basic_string<char> >
  {
      inline ::std::size_t operator ()(const ::std::string &__s) const  noexcept(true)
      {
        return std::_Hash_impl::hash(__s.::std::basic_string<char>::data(), __s.::std::basic_string<char>::length() /* , static_cast<unsigned long int>(3339675911LU) */ );
      }
  };
  template <>
  struct  __is_fast_hash< ::std::hash< ::std::basic_string<char> > > : ::std::integral_constant<bool, false>
  {
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, ::std::basic_string<wchar_t> >' */ 
 /* Instantiation of template function 'const wchar_t *::std::basic_string<wchar_t>::data() const ' */ 
 /* Instantiation of template function '::std::allocator<wchar_t>::size_type ::std::basic_string<wchar_t>::length() const ' */ 
  template <>
  struct  hash< ::std::basic_string<wchar_t> > : ::std::__hash_base<unsigned long int, ::std::basic_string<wchar_t> >
  {
      inline ::std::size_t operator ()(const ::std::wstring &__s) const  noexcept(true)
      {
        return std::_Hash_impl::hash(__s.::std::basic_string<wchar_t>::data(), __s.::std::basic_string<wchar_t>::length() * sizeof(wchar_t) /* , static_cast<unsigned long int>(3339675911LU) */ );
      }
  };
  template <>
  struct  __is_fast_hash< ::std::hash< ::std::basic_string<wchar_t> > > : ::std::integral_constant<bool, false>
  {
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, ::std::basic_string<char16_t> >' */ 
 /* Instantiation of class template '::__gnu_cxx::new_allocator<char16_t>' */ 
 /* Instantiation of class template '::std::allocator<char16_t>' */ 
 /* Instantiation of class template '::std::allocator<char16_t>::rebind<char16_t>' */ 
 /* Instantiation of class template '::std::basic_string<char16_t>::_Alloc_hider' */ 
 /* Instantiation of class template '::std::basic_string<char16_t>' */ 
 /* Instantiation of template function 'const char16_t *::std::basic_string<char16_t>::data() const ' */ 
 /* Instantiation of template function '::std::allocator<char16_t>::size_type ::std::basic_string<char16_t>::length() const ' */ 
  template <>
  struct  hash< ::std::basic_string<char16_t> > : ::std::__hash_base<unsigned long int, ::std::basic_string<char16_t> >
  {
      inline ::std::size_t operator ()(const ::std::u16string &__s) const  noexcept(true)
      {
        return std::_Hash_impl::hash(__s.::std::basic_string<char16_t>::data(), __s.::std::basic_string<char16_t>::length() * sizeof(char16_t) /* , static_cast<unsigned long int>(3339675911LU) */ );
      }
  };
  template <>
  struct  __is_fast_hash< ::std::hash< ::std::basic_string<char16_t> > > : ::std::integral_constant<bool, false>
  {
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, ::std::basic_string<char32_t> >' */ 
 /* Instantiation of class template '::__gnu_cxx::new_allocator<char32_t>' */ 
 /* Instantiation of class template '::std::allocator<char32_t>' */ 
 /* Instantiation of class template '::std::allocator<char32_t>::rebind<char32_t>' */ 
 /* Instantiation of class template '::std::basic_string<char32_t>::_Alloc_hider' */ 
 /* Instantiation of class template '::std::basic_string<char32_t>' */ 
 /* Instantiation of template function 'const char32_t *::std::basic_string<char32_t>::data() const ' */ 
 /* Instantiation of template function '::std::allocator<char32_t>::size_type ::std::basic_string<char32_t>::length() const ' */ 
  template <>
  struct  hash< ::std::basic_string<char32_t> > : ::std::__hash_base<unsigned long int, ::std::basic_string<char32_t> >
  {
      inline ::std::size_t operator ()(const ::std::u32string &__s) const  noexcept(true)
      {
        return std::_Hash_impl::hash(__s.::std::basic_string<char32_t>::data(), __s.::std::basic_string<char32_t>::length() * sizeof(char32_t) /* , static_cast<unsigned long int>(3339675911LU) */ );
      }
  };
  template <>
  struct  __is_fast_hash< ::std::hash< ::std::basic_string<char32_t> > > : ::std::integral_constant<bool, false>
  {
  };
  template < typename _CharT, typename _Traits, typename _Alloc >
  const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_max_size = ((::std::basic_string<_CharT, _Traits, _Alloc>::npos - sizeof(typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep_base)) / sizeof(_CharT) - 1) / 4;
  template < typename _CharT, typename _Traits, typename _Alloc >
  const _CharT basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_terminal = _CharT();
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[(sizeof(typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep_base) + sizeof(_CharT) + sizeof(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type) - 1) / sizeof(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type)];
  template < typename _CharT, typename _Traits, typename _Alloc >
  template < typename _InIterator >
  _CharT *basic_string<_CharT, _Traits, _Alloc>::_S_construct(_InIterator __beg, _InIterator __end, const _Alloc &__a, ::std::input_iterator_tag)
  {
    if (__beg == __end && __a == _Alloc())
      {
        return _S_empty_rep()._M_refdata();
      }
    _CharT __buf[128L];
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = 0;
    while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
      {
        __buf[__len++] = *__beg;
         ++__beg;
      }
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *__r = _Rep::_S_create(__len, ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __a);
    _M_copy(__r->_M_refdata(), __buf, __len);
    try
    {
      while (__beg != __end)
        {
          if (__len == __r->_M_capacity)
            {
              typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *__another = _Rep::_S_create(__len + 1, __len, __a);
              _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
              __r->_M_destroy(__a);
              __r = __another;
            }
          __r->_M_refdata()[__len++] = *__beg;
           ++__beg;
        }
    }
    catch (...)
    {
      __r->_M_destroy(__a);
      throw;
    }
    __r->_M_set_length_and_sharable(__len);
    return __r->_M_refdata();
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  template < typename _InIterator >
  _CharT *basic_string<_CharT, _Traits, _Alloc>::_S_construct(_InIterator __beg, _InIterator __end, const _Alloc &__a, ::std::forward_iterator_tag)
  {
    if (__beg == __end && __a == _Alloc())
      {
        return _S_empty_rep()._M_refdata();
      }
    if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
      {
        ::std::__throw_logic_error("basic_string::_S_construct null not valid");
      }
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __dnew = static_cast<typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type>(std::distance(__beg, __end));
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *__r = _Rep::_S_create(__dnew, ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __a);
    try
    {
      _S_copy_chars(__r->_M_refdata(), __beg, __end);
    }
    catch (...)
    {
      __r->_M_destroy(__a);
      throw;
    }
    __r->_M_set_length_and_sharable(__dnew);
    return __r->_M_refdata();
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  _CharT *basic_string<_CharT, _Traits, _Alloc>::_S_construct(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c, const _Alloc &__a)
  {
    if (__n == 0 && __a == _Alloc())
      {
        return _S_empty_rep()._M_refdata();
      }
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *__r = _Rep::_S_create(__n, ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __a);
    if (__n)
      {
        _M_assign(__r->_M_refdata(), __n, __c);
      }
    __r->_M_set_length_and_sharable(__n);
    return __r->_M_refdata();
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()), __str.get_allocator()), __str.get_allocator())
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Alloc &__a)
    : _M_dataplus(_S_construct(((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type())), _CharT(), __a), __a)
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
    : _M_dataplus(_S_construct(__str._M_data() + __str._M_check(__pos, "basic_string::basic_string"), __str._M_data() + __str._M_limit(__pos, __n) + __pos, _Alloc()), _Alloc())
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const _Alloc &__a)
    : _M_dataplus(_S_construct(__str._M_data() + __str._M_check(__pos, "basic_string::basic_string"), __str._M_data() + __str._M_limit(__pos, __n) + __pos, __a), __a)
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const _Alloc &__a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT *__s, const _Alloc &__a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) : __s + ::std::basic_string<_CharT, _Traits, _Alloc>::npos, __a), __a)
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c, const _Alloc &__a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  template < typename _InputIterator >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc &__a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  basic_string<_CharT, _Traits, _Alloc>::basic_string(::std::initializer_list<_CharT> __l, const _Alloc &__a)
    : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)
  {
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::assign(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    if ((*this)._M_rep() != __str._M_rep())
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::allocator_type __a = this->get_allocator();
        _CharT *__tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
        (*this)._M_rep()->_M_dispose(__a);
        (*this)._M_data(__tmp);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::assign(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
  {
    ;
    (*this)._M_check_length(this->size(), __n, "basic_string::assign");
    if ((*this)._M_disjunct(__s) || (*this)._M_rep()->_M_is_shared())
      {
        return (*this)._M_replace_safe(((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), this->size(), __s, __n);
      }
    else
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __s - (*this)._M_data();
        if (__pos >= __n)
          {
            _M_copy((*this)._M_data(), __s, __n);
          }
        else
          {
            if (__pos)
              {
                _M_move((*this)._M_data(), __s, __n);
              }
          }
        (*this)._M_rep()->_M_set_length_and_sharable(__n);
        return *this;
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::append(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
  {
    if (__n)
      {
        (*this)._M_check_length(((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __n, "basic_string::append");
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = __n + this->size();
        if (__len > this->capacity() || (*this)._M_rep()->_M_is_shared())
          {
            this->reserve(__len);
          }
        _M_assign((*this)._M_data() + this->size(), __n, __c);
        (*this)._M_rep()->_M_set_length_and_sharable(__len);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::append(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
  {
    ;
    if (__n)
      {
        (*this)._M_check_length(((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __n, "basic_string::append");
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = __n + this->size();
        if (__len > this->capacity() || (*this)._M_rep()->_M_is_shared())
          {
            if ((*this)._M_disjunct(__s))
              {
                this->reserve(__len);
              }
            else
              {
                const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __off = __s - (*this)._M_data();
                this->reserve(__len);
                __s = (*this)._M_data() + __off;
              }
          }
        _M_copy((*this)._M_data() + this->size(), __s, __n);
        (*this)._M_rep()->_M_set_length_and_sharable(__len);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::append(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = __str.size();
    if (__size)
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = __size + this->size();
        if (__len > this->capacity() || (*this)._M_rep()->_M_is_shared())
          {
            this->reserve(__len);
          }
        _M_copy((*this)._M_data() + this->size(), __str._M_data(), __size);
        (*this)._M_rep()->_M_set_length_and_sharable(__len);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::append(const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
  {
    __str._M_check(__pos, "basic_string::append");
    __n = __str._M_limit(__pos, __n);
    if (__n)
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = __n + this->size();
        if (__len > this->capacity() || (*this)._M_rep()->_M_is_shared())
          {
            this->reserve(__len);
          }
        _M_copy((*this)._M_data() + this->size(), __str._M_data() + __pos, __n);
        (*this)._M_rep()->_M_set_length_and_sharable(__len);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::insert(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
  {
    ;
    (*this)._M_check(__pos, "basic_string::insert");
    (*this)._M_check_length(((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __n, "basic_string::insert");
    if ((*this)._M_disjunct(__s) || (*this)._M_rep()->_M_is_shared())
      {
        return (*this)._M_replace_safe(__pos, ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __s, __n);
      }
    else
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __off = __s - (*this)._M_data();
        (*this)._M_mutate(__pos, 0, __n);
        __s = (*this)._M_data() + __off;
        _CharT *__p = (*this)._M_data() + __pos;
        if (__s + __n <= __p)
          {
            _M_copy(__p, __s, __n);
          }
        else
          {
            if (__s >= __p)
              {
                _M_copy(__p, __s + __n, __n);
              }
            else
              {
                const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __nleft = __p - __s;
                _M_copy(__p, __s, __nleft);
                _M_copy(__p + __nleft, __p + __n, __n - __nleft);
              }
          }
        return *this;
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator basic_string<_CharT, _Traits, _Alloc>::erase(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __first, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __last)
  {
    ;
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = __last - __first;
    if (__size)
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __first - (*this)._M_ibegin();
        (*this)._M_mutate(__pos, __size, ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(0))));
        (*this)._M_rep()->_M_set_leaked();
        return ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data() + __pos)));
      }
    else
      {
        return __first;
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::replace(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2)
  {
    ;
    (*this)._M_check(__pos, "basic_string::replace");
    __n1 = (*this)._M_limit(__pos, __n1);
    (*this)._M_check_length(__n1, __n2, "basic_string::replace");
    bool __left;
    if ((*this)._M_disjunct(__s) || (*this)._M_rep()->_M_is_shared())
      {
        return (*this)._M_replace_safe(__pos, __n1, __s, __n2);
      }
    else
      {
        if ((__left = __s + __n2 <= (*this)._M_data() + __pos) || (*this)._M_data() + __pos + __n1 <= __s)
          {
            typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __off = __s - (*this)._M_data();
            __left ? __off : __off += __n2 - __n1;
            (*this)._M_mutate(__pos, __n1, __n2);
            _M_copy((*this)._M_data() + __pos, (*this)._M_data() + __off, __n2);
            return *this;
          }
        else
          {
            const ::std::basic_string<_CharT, _Traits, _Alloc> __tmp(__s, __n2);
            return (*this)._M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
          }
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_string<_CharT, _Traits, _Alloc>::_Rep::_M_destroy(const _Alloc &__a) throw()
  {
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = sizeof(typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep_base) + (this->_M_capacity + 1) * sizeof(_CharT);
    ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep::_Raw_bytes_alloc(__a))).deallocate(reinterpret_cast<char *>(this), __size);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_string<_CharT, _Traits, _Alloc>::_M_leak_hard()
  {
    if ((*this)._M_rep() == &_S_empty_rep())
      {
        return ;
      }
    if ((*this)._M_rep()->_M_is_shared())
      {
        (*this)._M_mutate(0, 0, 0);
      }
    (*this)._M_rep()->_M_set_leaked();
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_string<_CharT, _Traits, _Alloc>::_M_mutate(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len2)
  {
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __old_size = this->size();
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __new_size = __old_size + __len2 - __len1;
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __how_much = __old_size - __pos - __len1;
    if (__new_size > this->capacity() || (*this)._M_rep()->_M_is_shared())
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::allocator_type __a = (*this).get_allocator();
        typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *__r = _Rep::_S_create(__new_size, this->capacity(), __a);
        if (__pos)
          {
            _M_copy(__r->_M_refdata(), (*this)._M_data(), __pos);
          }
        if (__how_much)
          {
            _M_copy(__r->_M_refdata() + __pos + __len2, (*this)._M_data() + __pos + __len1, __how_much);
          }
        (*this)._M_rep()->_M_dispose(__a);
        (*this)._M_data(__r->_M_refdata());
      }
    else
      {
        if (__how_much && __len1 != __len2)
          {
            _M_move((*this)._M_data() + __pos + __len2, (*this)._M_data() + __pos + __len1, __how_much);
          }
      }
    (*this)._M_rep()->_M_set_length_and_sharable(__new_size);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_string<_CharT, _Traits, _Alloc>::reserve(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __res)
  {
    if (__res != this->capacity() || (*this)._M_rep()->_M_is_shared())
      {
        if (__res < this->size())
          {
            __res = this->size();
          }
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::allocator_type __a = (*this).get_allocator();
        _CharT *__tmp = (*this)._M_rep()->_M_clone(__a, __res - this->size());
        (*this)._M_rep()->_M_dispose(__a);
        (*this)._M_data(__tmp);
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_string<_CharT, _Traits, _Alloc>::swap(::std::basic_string<_CharT, _Traits, _Alloc> &__s)
  {
    if ((*this)._M_rep()->_M_is_leaked())
      {
        (*this)._M_rep()->_M_set_sharable();
      }
    if (__s._M_rep()->_M_is_leaked())
      {
        __s._M_rep()->_M_set_sharable();
      }
    if (this->get_allocator() == __s.get_allocator())
      {
        _CharT *__tmp = (*this)._M_data();
        (*this)._M_data(__s._M_data());
        __s._M_data(__tmp);
      }
    else
      {
        const ::std::basic_string<_CharT, _Traits, _Alloc> __tmp1((*this)._M_ibegin(), (*this)._M_iend(), __s.get_allocator());
        const ::std::basic_string<_CharT, _Traits, _Alloc> __tmp2(__s._M_ibegin(), __s._M_iend(), this->get_allocator());
        *this = __tmp2;
        __s = __tmp1;
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_create(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __capacity, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __old_capacity, const _Alloc &__alloc)
  {
    if (__capacity > ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_max_size)
      {
        ::std::__throw_length_error("basic_string::_S_create");
      }
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pagesize = 4096;
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __malloc_header_size = 4 * sizeof(void *);
    if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
      {
        __capacity = 2 * __old_capacity;
      }
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __adj_size = __size + __malloc_header_size;
    if (__adj_size > __pagesize && __capacity > __old_capacity)
      {
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __extra = __pagesize - __adj_size % __pagesize;
        __capacity += __extra / sizeof(_CharT);
        if (__capacity > ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_max_size)
          {
            __capacity = ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_max_size;
          }
        __size = (__capacity + 1) * sizeof(_CharT) + sizeof(typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep);
      }
    void *__place = ((typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep::_Raw_bytes_alloc(__alloc))).allocate(__size);
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *__p = new (__place)typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep();
    __p->_M_capacity = __capacity;
    __p->_M_set_sharable();
    return __p;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  _CharT *basic_string<_CharT, _Traits, _Alloc>::_Rep::_M_clone(const _Alloc &__alloc, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __res)
  {
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __requested_cap = this->_M_length + __res;
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::_Rep *__r = _Rep::_S_create(__requested_cap, this->_M_capacity, __alloc);
    if (this->_M_length)
      {
        _M_copy(__r->_M_refdata(), (*this)._M_refdata(), this->_M_length);
      }
    __r->_M_set_length_and_sharable(this->_M_length);
    return __r->_M_refdata();
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_string<_CharT, _Traits, _Alloc>::resize(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
  {
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    (*this)._M_check_length(__size, __n, "basic_string::resize");
    if (__size < __n)
      {
        this->append(__n - __size, __c);
      }
    else
      {
        if (__n < __size)
          {
            this->erase(__n);
          }
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  template < typename _InputIterator >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_dispatch(typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::iterator __i2, _InputIterator __k1, _InputIterator __k2, ::std::__false_type)
  {
    const ::std::basic_string<_CharT, _Traits, _Alloc> __s(__k1, __k2);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1 = __i2 - __i1;
    (*this)._M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
    return (*this)._M_replace_safe(__i1 - (*this)._M_ibegin(), __n1, __s._M_data(), __s.size());
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_aux(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, _CharT __c)
  {
    (*this)._M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
    (*this)._M_mutate(__pos1, __n1, __n2);
    if (__n2)
      {
        _M_assign((*this)._M_data() + __pos1, __n2, __c);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_safe(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2)
  {
    (*this)._M_mutate(__pos1, __n1, __n2);
    if (__n2)
      {
        _M_copy((*this)._M_data() + __pos1, __s, __n2);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> operator +(const _CharT *__lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    ;
    typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    const __size_type __len = _Traits::length(__lhs);
    __string_type __str;
    __str.reserve(__len + __rhs.size());
    __str.append(__lhs, __len);
    __str.append(__rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_string<_CharT, _Traits, _Alloc> operator +(_CharT __lhs, const ::std::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    __string_type __str;
    const __size_type __len = __rhs.size();
    __str.reserve(__len + 1);
    __str.append(__size_type(1), __lhs);
    __str.append(__rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::copy(_CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
  {
    (*this)._M_check(__pos, "basic_string::copy");
    __n = (*this)._M_limit(__pos, __n);
    ;
    if (__n)
      {
        _M_copy(__s, (*this)._M_data() + __pos, __n);
      }
    return __n;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
  {
    ;
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    const _CharT *__data = (*this)._M_data();
    if (__n == 0)
      {
        return __pos <= __size ? __pos : ::std::basic_string<_CharT, _Traits, _Alloc>::npos;
      }
    if (__n <= __size)
      {
        for (; __pos <= __size - __n;  ++__pos)
          {
            if (traits_type::eq(__data[__pos], __s[0]) && traits_type::compare(__data + __pos + 1, __s + 1, __n - 1) == 0)
              {
                return __pos;
              }
          }
      }
    return ::std::basic_string<_CharT, _Traits, _Alloc>::npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const  noexcept(true)
  {
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __ret = ::std::basic_string<_CharT, _Traits, _Alloc>::npos;
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    if (__pos < __size)
      {
        const _CharT *__data = (*this)._M_data();
        const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n = __size - __pos;
        const _CharT *__p = traits_type::find(__data + __pos, __n, __c);
        if (__p)
          {
            __ret = __p - __data;
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
  {
    ;
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    if (__n <= __size)
      {
        __pos = std::min(((typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type(__size - __n))), __pos);
        const _CharT *__data = (*this)._M_data();
        do
          {
            if (traits_type::compare(__data + __pos, __s, __n) == 0)
              {
                return __pos;
              }
          }
        while (__pos-- > 0);
      }
    return ::std::basic_string<_CharT, _Traits, _Alloc>::npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const  noexcept(true)
  {
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    if (__size)
      {
        if ( --__size > __pos)
          {
            __size = __pos;
          }
        for ( ++__size; __size-- > 0; )
          {
            if (traits_type::eq((*this)._M_data()[__size], __c))
              {
                return __size;
              }
          }
      }
    return ::std::basic_string<_CharT, _Traits, _Alloc>::npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
  {
    ;
    for (; __n && __pos < this->size();  ++__pos)
      {
        const _CharT *__p = traits_type::find(__s, __n, (*this)._M_data()[__pos]);
        if (__p)
          {
            return __pos;
          }
      }
    return ::std::basic_string<_CharT, _Traits, _Alloc>::npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
  {
    ;
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    if (__size && __n)
      {
        if ( --__size > __pos)
          {
            __size = __pos;
          }
        do
          {
            if (traits_type::find(__s, __n, (*this)._M_data()[__size]))
              {
                return __size;
              }
          }
        while (__size-- != 0);
      }
    return ::std::basic_string<_CharT, _Traits, _Alloc>::npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
  {
    ;
    for (; __pos < this->size();  ++__pos)
      {
        if (!traits_type::find(__s, __n, (*this)._M_data()[__pos]))
          {
            return __pos;
          }
      }
    return ::std::basic_string<_CharT, _Traits, _Alloc>::npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const  noexcept(true)
  {
    for (; __pos < this->size();  ++__pos)
      {
        if (!traits_type::eq((*this)._M_data()[__pos], __c))
          {
            return __pos;
          }
      }
    return ::std::basic_string<_CharT, _Traits, _Alloc>::npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
  {
    ;
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    if (__size)
      {
        if ( --__size > __pos)
          {
            __size = __pos;
          }
        do
          {
            if (!traits_type::find(__s, __n, (*this)._M_data()[__size]))
              {
                return __size;
              }
          }
        while (__size--);
      }
    return ::std::basic_string<_CharT, _Traits, _Alloc>::npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(_CharT __c, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const  noexcept(true)
  {
    typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    if (__size)
      {
        if ( --__size > __pos)
          {
            __size = __pos;
          }
        do
          {
            if (!traits_type::eq((*this)._M_data()[__size], __c))
              {
                return __size;
              }
          }
        while (__size--);
      }
    return ::std::basic_string<_CharT, _Traits, _Alloc>::npos;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str) const 
  {
    (*this)._M_check(__pos, "basic_string::compare");
    __n = (*this)._M_limit(__pos, __n);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = __str.size();
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n, __osize);
    int __r = traits_type::compare((*this)._M_data() + __pos, __str.data(), __len);
    if (!__r)
      {
        __r = _S_compare(__n, __osize);
      }
    return __r;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const ::std::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const 
  {
    (*this)._M_check(__pos1, "basic_string::compare");
    __str._M_check(__pos2, "basic_string::compare");
    __n1 = (*this)._M_limit(__pos1, __n1);
    __n2 = __str._M_limit(__pos2, __n2);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n1, __n2);
    int __r = traits_type::compare((*this)._M_data() + __pos1, __str.data() + __pos2, __len);
    if (!__r)
      {
        __r = _S_compare(__n1, __n2);
      }
    return __r;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  int basic_string<_CharT, _Traits, _Alloc>::compare(const _CharT *__s) const 
  {
    ;
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = traits_type::length(__s);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__size, __osize);
    int __r = traits_type::compare((*this)._M_data(), __s, __len);
    if (!__r)
      {
        __r = _S_compare(__size, __osize);
      }
    return __r;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s) const 
  {
    ;
    (*this)._M_check(__pos, "basic_string::compare");
    __n1 = (*this)._M_limit(__pos, __n1);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = traits_type::length(__s);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n1, __osize);
    int __r = traits_type::compare((*this)._M_data() + __pos, __s, __len);
    if (!__r)
      {
        __r = _S_compare(__n1, __osize);
      }
    return __r;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const 
  {
    ;
    (*this)._M_check(__pos, "basic_string::compare");
    __n1 = (*this)._M_limit(__pos, __n1);
    const typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n1, __n2);
    int __r = traits_type::compare((*this)._M_data() + __pos, __s, __len);
    if (!__r)
      {
        __r = _S_compare(__n1, __n2);
      }
    return __r;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, ::std::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    typedef ::std::ctype<_CharT> __ctype_type;
    typedef typename ::std::ctype<_CharT>::ctype_base __ctype_base;
    __size_type __extracted = 0;
    typename ::std::basic_istream<_CharT, _Traits>::ios_base::iostate __err = __ios_base::goodbit;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, false);
    if (__cerb)
      {
        try
        {
          __str.erase();
          _CharT __buf[128L];
          __size_type __len = 0;
          const ::std::streamsize __w = __in.width();
          const __size_type __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();
          const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
          const __int_type __eof = _Traits::eof();
          __int_type __c = __in.rdbuf()->sgetc();
          while ((__extracted < __n && !_Traits::eq_int_type(__c, __eof)) && !__ct.is(__ctype_base::space, _Traits::to_char_type(__c)))
            {
              if (__len == sizeof(__buf) / sizeof(_CharT))
                {
                  __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
                  __len = 0;
                }
              __buf[__len++] = _Traits::to_char_type(__c);
               ++__extracted;
              __c = __in.rdbuf()->snextc();
            }
          __str.append(__buf, __len);
          if (_Traits::eq_int_type(__c, __eof))
            {
              __err |= __ios_base::eofbit;
            }
          __in.width(0);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(__ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(__ios_base::badbit);
        }
      }
    if (!__extracted)
      {
        __err |= __ios_base::failbit;
      }
    if (__err)
      {
        __in.setstate(__err);
      }
    return __in;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__in, ::std::basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typedef typename ::std::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    __size_type __extracted = 0;
    const __size_type __n = __str.max_size();
    typename ::std::basic_istream<_CharT, _Traits>::ios_base::iostate __err = __ios_base::goodbit;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, true);
    if (__cerb)
      {
        try
        {
          __str.erase();
          const __int_type __idelim = _Traits::to_int_type(__delim);
          const __int_type __eof = _Traits::eof();
          __int_type __c = __in.rdbuf()->sgetc();
          while ((__extracted < __n && !_Traits::eq_int_type(__c, __eof)) && !_Traits::eq_int_type(__c, __idelim))
            {
              __str += _Traits::to_char_type(__c);
               ++__extracted;
              __c = __in.rdbuf()->snextc();
            }
          if (_Traits::eq_int_type(__c, __eof))
            {
              __err |= __ios_base::eofbit;
            }
          else
            {
              if (_Traits::eq_int_type(__c, __idelim))
                {
                   ++__extracted;
                  __in.rdbuf()->sbumpc();
                }
              else
                {
                  __err |= __ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(__ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(__ios_base::badbit);
        }
      }
    if (!__extracted)
      {
        __err |= __ios_base::failbit;
      }
    if (__err)
      {
        __in.setstate(__err);
      }
    return __in;
  }
  extern template class ::std::basic_string<char>;
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, ::std::basic_string<char> &);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, const ::std::basic_string<char> &);
  extern template ::std::basic_istream<char> &getline(::std::basic_istream<char> &, ::std::basic_string<char> &, char);
  extern template ::std::basic_istream<char> &getline(::std::basic_istream<char> &, ::std::basic_string<char> &);
  extern template class ::std::basic_string<wchar_t>;
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, ::std::basic_string<wchar_t> &);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, const ::std::basic_string<wchar_t> &);
  extern template ::std::basic_istream<wchar_t> &getline(::std::basic_istream<wchar_t> &, ::std::basic_string<wchar_t> &, wchar_t);
  extern template ::std::basic_istream<wchar_t> &getline(::std::basic_istream<wchar_t> &, ::std::basic_string<wchar_t> &);
  class  locale
  {
    public:
      typedef int category;
      class facet;
      class id;
      class _Impl;
      static const ::std::locale::category none = 0;
      static const ::std::locale::category ctype = 1L << 0;
      static const ::std::locale::category numeric = 1L << 1;
      static const ::std::locale::category collate = 1L << 2;
      static const ::std::locale::category time = 1L << 3;
      static const ::std::locale::category monetary = 1L << 4;
      static const ::std::locale::category messages = 1L << 5;
      static const ::std::locale::category all = ((((::std::locale::ctype | ::std::locale::numeric) | ::std::locale::collate) | ::std::locale::time) | ::std::locale::monetary) | ::std::locale::messages;
      locale() throw();
      locale(const ::std::locale &__other) throw();
      explicit locale(const char *__s);
      locale(const ::std::locale &__base, const char *__s, ::std::locale::category __cat);
      locale(const ::std::locale &__base, const ::std::locale &__add, ::std::locale::category __cat);
      template < typename _Facet >
      locale(const ::std::locale &__other, _Facet *__f);
      ~locale() throw();
      const ::std::locale &operator =(const ::std::locale &__other) throw();
      template < typename _Facet >
      ::std::locale combine(const ::std::locale &__other) const ;
      ::std::string name() const ;
      bool operator ==(const ::std::locale &__other) const  throw();
      inline bool operator !=(const ::std::locale &__other) const  throw()
      {
        return !(*this).::std::locale::operator ==(__other);
      }
      template < typename _Char, typename _Traits, typename _Alloc >
      bool operator ()(const ::std::basic_string<_Char, _Traits, _Alloc> &__s1, const ::std::basic_string<_Char, _Traits, _Alloc> &__s2) const ;
      static ::std::locale global(const ::std::locale &__loc);
      static const ::std::locale &classic();
    private:
      ::std::locale::_Impl *_M_impl;
      static ::std::locale::_Impl *_S_classic;
      static ::std::locale::_Impl *_S_global;
      static const char *const *const _S_categories;
      enum mcc_enum_anon_55
      {
        _S_categories_size = 6 + 6
      };
      static ::__gthread_once_t _S_once;
      explicit locale(::std::locale::_Impl *) throw();
      static void _S_initialize();
      static void _S_initialize_once() throw();
      static ::std::locale::category _S_normalize_category(::std::locale::category);
      void _M_coalesce(const ::std::locale &__base, const ::std::locale &__add, ::std::locale::category __cat);
    friend class ::std::locale::facet;
    friend class ::std::locale::_Impl;
    template < typename _Facet >
    friend bool (::std::has_facet)(const ::std::locale &) throw();
    template < typename _Facet >
    friend const _Facet &(::std::use_facet)(const ::std::locale &);
    template < typename _Cache >
    friend struct __use_cache;
  };
  class  locale::facet
  {
      mutable ::_Atomic_word _M_refcount;
      static ::std::__c_locale _S_c_locale;
      static const char _S_c_name[2L];
      static ::__gthread_once_t _S_once;
      static void _S_initialize_once();
    protected:
      inline explicit facet(::std::size_t __refs  = (0)) throw()
        : _M_refcount(__refs ? 1 : 0)
      {
      }
      virtual ~facet();
      static void _S_create_c_locale(::std::__c_locale &__cloc, const char *__s, ::std::__c_locale __old  = (0));
      static ::std::__c_locale _S_clone_c_locale(::std::__c_locale &__cloc) throw();
      static void _S_destroy_c_locale(::std::__c_locale &__cloc);
      static ::std::__c_locale _S_lc_ctype_c_locale(::std::__c_locale __cloc, const char *__s);
      static ::std::__c_locale _S_get_c_locale();
      static const char *_S_get_c_name() throw() __attribute__((__const__));
    private:
      inline void _M_add_reference() const  throw()
      {
        __gnu_cxx::__atomic_add_dispatch(&(*this)._M_refcount, 1);
      }
      inline void _M_remove_reference() const  throw()
      {
        ;
        if (__gnu_cxx::__exchange_and_add_dispatch(&(*this)._M_refcount,  -1) == 1)
          {
            ;
            try
            {
              delete this;
            }
            catch (...)
            {
            }
          }
      }
      facet(const ::std::locale::facet &);
      ::std::locale::facet &operator =(const ::std::locale::facet &);
    friend class locale;
    friend class ::std::locale::_Impl;
  };
  class  locale::id
  {
      mutable ::std::size_t _M_index;
      static ::_Atomic_word _S_refcount;
      void operator =(const ::std::locale::id &);
      id(const ::std::locale::id &);
    public:
      inline id()
      {
      }
      ::std::size_t _M_id() const  throw();
    friend class locale;
    friend class ::std::locale::_Impl;
    template < typename _Facet >
    friend const _Facet &(::std::use_facet)(const ::std::locale &);
    template < typename _Facet >
    friend bool (::std::has_facet)(const ::std::locale &) throw();
  };
  class  locale::_Impl
  {
      ::_Atomic_word _M_refcount;
      const ::std::locale::facet **_M_facets;
      ::std::size_t _M_facets_size;
      const ::std::locale::facet **_M_caches;
      char **_M_names;
      static const ::std::locale::id *const _S_id_ctype[];
      static const ::std::locale::id *const _S_id_numeric[];
      static const ::std::locale::id *const _S_id_collate[];
      static const ::std::locale::id *const _S_id_time[];
      static const ::std::locale::id *const _S_id_monetary[];
      static const ::std::locale::id *const _S_id_messages[];
      static const ::std::locale::id *const *const _S_facet_categories[];
      inline void _M_add_reference() throw()
      {
        __gnu_cxx::__atomic_add_dispatch(&(*this)._M_refcount, 1);
      }
      inline void _M_remove_reference() throw()
      {
        ;
        if (__gnu_cxx::__exchange_and_add_dispatch(&(*this)._M_refcount,  -1) == 1)
          {
            ;
            try
            {
              delete this;
            }
            catch (...)
            {
            }
          }
      }
      _Impl(const ::std::locale::_Impl &, ::std::size_t);
      _Impl(const char *, ::std::size_t);
      _Impl(::std::size_t) throw();
      ~_Impl() throw();
      _Impl(const ::std::locale::_Impl &);
      void operator =(const ::std::locale::_Impl &);
      inline bool _M_check_same_name()
      {
        bool __ret(true);
        if ((*this)._M_names[1])
          {
            for (::std::size_t __i(0); __ret && __i < ::std::locale::_S_categories_size - 1;  ++__i)
              {
                __ret = __builtin_strcmp((*this)._M_names[__i], (*this)._M_names[__i + 1]) == 0;
              }
          }
        return __ret;
      }
      void _M_replace_categories(const ::std::locale::_Impl *, ::std::locale::category);
      void _M_replace_category(const ::std::locale::_Impl *, const ::std::locale::id *const *);
      void _M_replace_facet(const ::std::locale::_Impl *, const ::std::locale::id *);
      void _M_install_facet(const ::std::locale::id *, const ::std::locale::facet *);
      template < typename _Facet >
      inline void _M_init_facet(_Facet *__facet)
      {
        _M_install_facet(&_Facet::id, __facet);
      }
      void _M_install_cache(const ::std::locale::facet *, ::std::size_t);
    friend class locale;
    friend class ::std::locale::facet;
    template < typename _Facet >
    friend bool (::std::has_facet)(const ::std::locale &) throw();
    template < typename _Facet >
    friend const _Facet &(::std::use_facet)(const ::std::locale &);
    template < typename _Cache >
    friend struct __use_cache;
  };
  template < typename _CharT >
  class  collate : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef ::std::basic_string<_CharT> string_type;
    protected:
      ::std::__c_locale _M_c_locale_collate;
    public:
      static ::std::locale::id id;
      inline explicit collate(::std::size_t __refs  = (0))
        : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      {
      }
      inline explicit collate(::std::__c_locale __cloc, ::std::size_t __refs  = (0))
        : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      {
      }
      inline int compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const 
      {
        return this->do_compare(__lo1, __hi1, __lo2, __hi2);
      }
      inline typename ::std::collate<_CharT>::string_type transform(const _CharT *__lo, const _CharT *__hi) const 
      {
        return this->do_transform(__lo, __hi);
      }
      inline long int hash(const _CharT *__lo, const _CharT *__hi) const 
      {
        return this->do_hash(__lo, __hi);
      }
      int _M_compare(const _CharT *, const _CharT *) const  throw();
      ::std::size_t _M_transform(_CharT *, const _CharT *, ::std::size_t) const  throw();
    protected:
      inline virtual ~collate()
      {
        _S_destroy_c_locale(::std::collate<_CharT>::_M_c_locale_collate);
      }
      virtual int do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const ;
      virtual typename ::std::collate<_CharT>::string_type do_transform(const _CharT *__lo, const _CharT *__hi) const ;
      virtual long int do_hash(const _CharT *__lo, const _CharT *__hi) const ;
  };
  template < typename _CharT >
  ::std::locale::id collate<_CharT>::id;
 /* Instantiation of class template '::std::collate<char>' */ 
  template <>
  int collate<char>::_M_compare(const char *, const char *) const  throw();
  template <>
  unsigned long int collate<char>::_M_transform(char *, const char *, unsigned long int) const  throw();
 /* Instantiation of class template '::std::collate<wchar_t>' */ 
  template <>
  int collate<wchar_t>::_M_compare(const wchar_t *, const wchar_t *) const  throw();
  template <>
  unsigned long int collate<wchar_t>::_M_transform(wchar_t *, const wchar_t *, unsigned long int) const  throw();
  template < typename _CharT >
  class  collate_byname : public ::std::collate<_CharT>
  {
    public:
      typedef _CharT char_type;
      typedef ::std::basic_string<_CharT> string_type;
      inline explicit collate_byname(const char *__s, ::std::size_t __refs  = (0))
        : collate<_CharT>(__refs)
      {
        if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0)
          {
            this->_S_destroy_c_locale(this->_M_c_locale_collate);
            this->_S_create_c_locale(this->_M_c_locale_collate, __s);
          }
      }
    protected:
      inline virtual ~collate_byname()
      {
      }
  };
  template < typename _Facet >
  locale::locale(const ::std::locale &__other, _Facet *__f)
  {
    (*this)._M_impl = new (::std::locale::_Impl)((*__other._M_impl), (1));
    try
    {
      (*(*this)._M_impl)._M_install_facet(&_Facet::id, __f);
    }
    catch (...)
    {
      (*(*this)._M_impl).::std::locale::_Impl::_M_remove_reference();
      throw;
    }
    delete[] (*(*this)._M_impl)._M_names[0];
    (*(*this)._M_impl)._M_names[0] = 0;
  }
  template < typename _Facet >
  ::std::locale locale::combine(const ::std::locale &__other) const 
  {
    ::std::locale::_Impl *__tmp(new (::std::locale::_Impl)((*(*this)._M_impl), (1)));
    try
    {
      (*__tmp)._M_replace_facet(__other._M_impl, &_Facet::id);
    }
    catch (...)
    {
      (*__tmp).::std::locale::_Impl::_M_remove_reference();
      throw;
    }
    return ::std::locale(__tmp);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  bool locale::operator ()(const ::std::basic_string<_CharT, _Traits, _Alloc> &__s1, const ::std::basic_string<_CharT, _Traits, _Alloc> &__s2) const 
  {
    typedef ::std::collate<_CharT> __collate_type;
    const __collate_type &__collate = use_facet<__collate_type>(*this);
    return __collate.compare(__s1.data(), __s1.data() + __s1.length(), __s2.data(), __s2.data() + __s2.length()) < 0;
  }
  template < typename _Facet >
  bool has_facet(const ::std::locale &__loc) throw()
  {
    const ::std::size_t __i = _Facet::id._M_id();
    const ::std::locale::facet **__facets((*__loc._M_impl)._M_facets);
    return __i < (*__loc._M_impl)._M_facets_size && dynamic_cast<const _Facet *>(__facets[__i]);
  }
  template < typename _Facet >
  const _Facet &use_facet(const ::std::locale &__loc)
  {
    const ::std::size_t __i = _Facet::id._M_id();
    const ::std::locale::facet **__facets((*__loc._M_impl)._M_facets);
    if (__i >= (*__loc._M_impl)._M_facets_size || !__facets[__i])
      {
        ::std::__throw_bad_cast();
      }
    return dynamic_cast<const _Facet &>(*__facets[__i]);
  }
  template < typename _CharT >
  int collate<_CharT>::_M_compare(const _CharT *, const _CharT *) const  throw()
  {
    return 0;
  }
  template < typename _CharT >
  ::std::size_t collate<_CharT>::_M_transform(_CharT *, const _CharT *, ::std::size_t) const  throw()
  {
    return 0;
  }
  template < typename _CharT >
  int collate<_CharT>::do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const 
  {
    const typename ::std::collate<_CharT>::string_type __one(__lo1, __hi1);
    const typename ::std::collate<_CharT>::string_type __two(__lo2, __hi2);
    const _CharT *__p = __one.c_str();
    const _CharT *__pend = __one.data() + __one.length();
    const _CharT *__q = __two.c_str();
    const _CharT *__qend = __two.data() + __two.length();
    for (; ; )
      {
        const int __res = (*this)._M_compare(__p, __q);
        if (__res)
          {
            return __res;
          }
        __p += char_traits<_CharT>::length(__p);
        __q += char_traits<_CharT>::length(__q);
        if (__p == __pend && __q == __qend)
          {
            return 0;
          }
        else
          {
            if (__p == __pend)
              {
                return  -1;
              }
            else
              {
                if (__q == __qend)
                  {
                    return 1;
                  }
              }
          }
        __p++;
        __q++;
      }
  }
  template < typename _CharT >
  typename ::std::collate<_CharT>::string_type collate<_CharT>::do_transform(const _CharT *__lo, const _CharT *__hi) const 
  {
    typename ::std::collate<_CharT>::string_type __ret;
    const typename ::std::collate<_CharT>::string_type __str(__lo, __hi);
    const _CharT *__p = __str.c_str();
    const _CharT *__pend = __str.data() + __str.length();
    ::std::size_t __len = (__hi - __lo) * 2;
    _CharT *__c = new _CharT [__len];
    try
    {
      for (; ; )
        {
          ::std::size_t __res = (*this)._M_transform(__c, __p, __len);
          if (__res >= __len)
            {
              __len = __res + 1;
              (delete[] __c, __c = 0);
              __c = (new _CharT [__len]);
              __res = (*this)._M_transform(__c, __p, __len);
            }
          __ret.append(__c, __res);
          __p += char_traits<_CharT>::length(__p);
          if (__p == __pend)
            {
              break;
            }
          __p++;
          __ret.push_back(_CharT());
        }
    }
    catch (...)
    {
      delete[] __c;
      throw;
    }
    delete[] __c;
    return __ret;
  }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<unsigned long int>, ::__gnu_cxx::__numeric_traits_floating<unsigned long int> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<unsigned long int>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<unsigned long int>' */ 
  template < typename _CharT >
  long int collate<_CharT>::do_hash(const _CharT *__lo, const _CharT *__hi) const 
  {
    unsigned long int __val(0);
    for (; __lo < __hi;  ++__lo)
      {
        __val = *__lo + (__val << 7 | __val >> (::__gnu_cxx::__numeric_traits_integer<unsigned long int>::__digits - 7));
      }
    return static_cast<long int>(__val);
  }
  extern template class ::std::collate<char>;
  extern template class ::std::collate_byname<char>;
  extern template const ::std::collate<char> &use_facet< ::std::collate<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::collate<char> >(const ::std::locale &);
  extern template class ::std::collate<wchar_t>;
  extern template class ::std::collate_byname<wchar_t>;
  extern template const ::std::collate<wchar_t> &use_facet< ::std::collate<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::collate<wchar_t> >(const ::std::locale &);
  enum _Ios_Fmtflags
  {
    _S_boolalpha = 1L << 0,
    _S_dec = 1L << 1,
    _S_fixed = 1L << 2,
    _S_hex = 1L << 3,
    _S_internal = 1L << 4,
    _S_left = 1L << 5,
    _S_oct = 1L << 6,
    _S_right = 1L << 7,
    _S_scientific = 1L << 8,
    _S_showbase = 1L << 9,
    _S_showpoint = 1L << 10,
    _S_showpos = 1L << 11,
    _S_skipws = 1L << 12,
    _S_unitbuf = 1L << 13,
    _S_uppercase = 1L << 14,
    _S_adjustfield = (::std::_S_left | ::std::_S_right) | ::std::_S_internal,
    _S_basefield = (::std::_S_dec | ::std::_S_oct) | ::std::_S_hex,
    _S_floatfield = ::std::_S_scientific | ::std::_S_fixed,
    _S_ios_fmtflags_end = 1L << 16
  };
  inline constexpr ::std::_Ios_Fmtflags operator &(::std::_Ios_Fmtflags __a, ::std::_Ios_Fmtflags __b)
  {
    return (::std::_Ios_Fmtflags)(static_cast<int>(__a) & static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Fmtflags operator |(::std::_Ios_Fmtflags __a, ::std::_Ios_Fmtflags __b)
  {
    return (::std::_Ios_Fmtflags)(static_cast<int>(__a) | static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Fmtflags operator ^(::std::_Ios_Fmtflags __a, ::std::_Ios_Fmtflags __b)
  {
    return (::std::_Ios_Fmtflags)(static_cast<int>(__a) ^ static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Fmtflags operator ~(::std::_Ios_Fmtflags __a)
  {
    return (::std::_Ios_Fmtflags)~static_cast<int>(__a);
  }
  inline const ::std::_Ios_Fmtflags &operator |=(::std::_Ios_Fmtflags &__a, ::std::_Ios_Fmtflags __b)
  {
    return __a = __a | __b;
  }
  inline const ::std::_Ios_Fmtflags &operator &=(::std::_Ios_Fmtflags &__a, ::std::_Ios_Fmtflags __b)
  {
    return __a = __a & __b;
  }
  inline const ::std::_Ios_Fmtflags &operator ^=(::std::_Ios_Fmtflags &__a, ::std::_Ios_Fmtflags __b)
  {
    return __a = __a ^ __b;
  }
  enum _Ios_Openmode
  {
    _S_app = 1L << 0,
    _S_ate = 1L << 1,
    _S_bin = 1L << 2,
    _S_in = 1L << 3,
    _S_out = 1L << 4,
    _S_trunc = 1L << 5,
    _S_ios_openmode_end = 1L << 16
  };
  inline constexpr ::std::_Ios_Openmode operator &(::std::_Ios_Openmode __a, ::std::_Ios_Openmode __b)
  {
    return (::std::_Ios_Openmode)(static_cast<int>(__a) & static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Openmode operator |(::std::_Ios_Openmode __a, ::std::_Ios_Openmode __b)
  {
    return (::std::_Ios_Openmode)(static_cast<int>(__a) | static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Openmode operator ^(::std::_Ios_Openmode __a, ::std::_Ios_Openmode __b)
  {
    return (::std::_Ios_Openmode)(static_cast<int>(__a) ^ static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Openmode operator ~(::std::_Ios_Openmode __a)
  {
    return (::std::_Ios_Openmode)~static_cast<int>(__a);
  }
  inline const ::std::_Ios_Openmode &operator |=(::std::_Ios_Openmode &__a, ::std::_Ios_Openmode __b)
  {
    return __a = __a | __b;
  }
  inline const ::std::_Ios_Openmode &operator &=(::std::_Ios_Openmode &__a, ::std::_Ios_Openmode __b)
  {
    return __a = __a & __b;
  }
  inline const ::std::_Ios_Openmode &operator ^=(::std::_Ios_Openmode &__a, ::std::_Ios_Openmode __b)
  {
    return __a = __a ^ __b;
  }
  enum _Ios_Iostate
  {
    _S_goodbit = 0,
    _S_badbit = 1L << 0,
    _S_eofbit = 1L << 1,
    _S_failbit = 1L << 2,
    _S_ios_iostate_end = 1L << 16
  };
  inline constexpr ::std::_Ios_Iostate operator &(::std::_Ios_Iostate __a, ::std::_Ios_Iostate __b)
  {
    return (::std::_Ios_Iostate)(static_cast<int>(__a) & static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Iostate operator |(::std::_Ios_Iostate __a, ::std::_Ios_Iostate __b)
  {
    return (::std::_Ios_Iostate)(static_cast<int>(__a) | static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Iostate operator ^(::std::_Ios_Iostate __a, ::std::_Ios_Iostate __b)
  {
    return (::std::_Ios_Iostate)(static_cast<int>(__a) ^ static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Iostate operator ~(::std::_Ios_Iostate __a)
  {
    return (::std::_Ios_Iostate)~static_cast<int>(__a);
  }
  inline const ::std::_Ios_Iostate &operator |=(::std::_Ios_Iostate &__a, ::std::_Ios_Iostate __b)
  {
    return __a = __a | __b;
  }
  inline const ::std::_Ios_Iostate &operator &=(::std::_Ios_Iostate &__a, ::std::_Ios_Iostate __b)
  {
    return __a = __a & __b;
  }
  inline const ::std::_Ios_Iostate &operator ^=(::std::_Ios_Iostate &__a, ::std::_Ios_Iostate __b)
  {
    return __a = __a ^ __b;
  }
  enum _Ios_Seekdir
  {
    _S_beg = 0,
    _S_cur = 1,
    _S_end = 2,
    _S_ios_seekdir_end = 1L << 16
  };
  class  ios_base
  {
    public:
      class  failure : public ::std::exception
      {
        public:
          explicit failure(const ::std::string &__str) throw();
          virtual ~failure() throw();
          virtual const char *what() const  throw();
        private:
          ::std::string _M_msg;
        public:
      };
      typedef ::std::_Ios_Fmtflags fmtflags;
      static const ::std::ios_base::fmtflags boolalpha = ::std::_S_boolalpha;
      static const ::std::ios_base::fmtflags dec = ::std::_S_dec;
      static const ::std::ios_base::fmtflags fixed = ::std::_S_fixed;
      static const ::std::ios_base::fmtflags hex = ::std::_S_hex;
      static const ::std::ios_base::fmtflags internal = ::std::_S_internal;
      static const ::std::ios_base::fmtflags left = ::std::_S_left;
      static const ::std::ios_base::fmtflags oct = ::std::_S_oct;
      static const ::std::ios_base::fmtflags right = ::std::_S_right;
      static const ::std::ios_base::fmtflags scientific = ::std::_S_scientific;
      static const ::std::ios_base::fmtflags showbase = ::std::_S_showbase;
      static const ::std::ios_base::fmtflags showpoint = ::std::_S_showpoint;
      static const ::std::ios_base::fmtflags showpos = ::std::_S_showpos;
      static const ::std::ios_base::fmtflags skipws = ::std::_S_skipws;
      static const ::std::ios_base::fmtflags unitbuf = ::std::_S_unitbuf;
      static const ::std::ios_base::fmtflags uppercase = ::std::_S_uppercase;
      static const ::std::ios_base::fmtflags adjustfield = ::std::_S_adjustfield;
      static const ::std::ios_base::fmtflags basefield = ::std::_S_basefield;
      static const ::std::ios_base::fmtflags floatfield = ::std::_S_floatfield;
      typedef ::std::_Ios_Iostate iostate;
      static const ::std::ios_base::iostate badbit = ::std::_S_badbit;
      static const ::std::ios_base::iostate eofbit = ::std::_S_eofbit;
      static const ::std::ios_base::iostate failbit = ::std::_S_failbit;
      static const ::std::ios_base::iostate goodbit = ::std::_S_goodbit;
      typedef ::std::_Ios_Openmode openmode;
      static const ::std::ios_base::openmode app = ::std::_S_app;
      static const ::std::ios_base::openmode ate = ::std::_S_ate;
      static const ::std::ios_base::openmode binary = ::std::_S_bin;
      static const ::std::ios_base::openmode in = ::std::_S_in;
      static const ::std::ios_base::openmode out = ::std::_S_out;
      static const ::std::ios_base::openmode trunc = ::std::_S_trunc;
      typedef ::std::_Ios_Seekdir seekdir;
      static const ::std::ios_base::seekdir beg = ::std::_S_beg;
      static const ::std::ios_base::seekdir cur = ::std::_S_cur;
      static const ::std::ios_base::seekdir end = ::std::_S_end;
      typedef int io_state;
      typedef int open_mode;
      typedef int seek_dir;
      typedef ::std::streampos streampos;
      typedef ::std::streamoff streamoff;
      enum event
      {
        erase_event = 0,
        imbue_event = 1,
        copyfmt_event = 2
      };
      typedef void (*event_callback)(::std::ios_base::event, ::std::ios_base &, int);
      void register_callback(::std::ios_base::event_callback __fn, int __index);
    protected:
      ::std::streamsize _M_precision;
      ::std::streamsize _M_width;
      ::std::ios_base::fmtflags _M_flags;
      ::std::ios_base::iostate _M_exception;
      ::std::ios_base::iostate _M_streambuf_state;
      struct  _Callback_list
      {
          ::std::ios_base::_Callback_list *_M_next;
          ::std::ios_base::event_callback _M_fn;
          int _M_index;
          ::_Atomic_word _M_refcount;
          inline _Callback_list(::std::ios_base::event_callback __fn, int __index, ::std::ios_base::_Callback_list *__cb)
            : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0)
          {
          }
          inline void _M_add_reference()
          {
            __gnu_cxx::__atomic_add_dispatch(&(*this)._M_refcount, 1);
          }
          inline int _M_remove_reference()
          {
            ;
            int __res(__gnu_cxx::__exchange_and_add_dispatch(&(*this)._M_refcount,  -1));
            if (__res == 0)
              {
                ;
              }
            return __res;
          }
      };
      ::std::ios_base::_Callback_list *_M_callbacks;
      void _M_call_callbacks(::std::ios_base::event __ev) throw();
      void _M_dispose_callbacks() throw();
      struct  _Words
      {
          void *_M_pword;
          long int _M_iword;
          inline _Words()
            : _M_pword(0), _M_iword(0)
          {
          }
      };
      ::std::ios_base::_Words _M_word_zero;
      enum mcc_enum_anon_56
      {
        _S_local_word_size = 8
      };
      ::std::ios_base::_Words _M_local_word[8L];
      int _M_word_size;
      ::std::ios_base::_Words *_M_word;
      ::std::ios_base::_Words &_M_grow_words(int __index, bool __iword);
      ::std::locale _M_ios_locale;
      void _M_init() throw();
    public:
      class  Init
      {
        public:
          Init();
          ~Init();
        private:
          static ::_Atomic_word _S_refcount;
          static bool _S_synced_with_stdio;
        public:
        friend class ios_base;
      };
      inline ::std::ios_base::fmtflags flags() const 
      {
        return (*this)._M_flags;
      }
      inline ::std::ios_base::fmtflags flags(::std::ios_base::fmtflags __fmtfl)
      {
        ::std::ios_base::fmtflags __old((*this)._M_flags);
        (*this)._M_flags = __fmtfl;
        return __old;
      }
      inline ::std::ios_base::fmtflags setf(::std::ios_base::fmtflags __fmtfl)
      {
        ::std::ios_base::fmtflags __old((*this)._M_flags);
        (*this)._M_flags |= __fmtfl;
        return __old;
      }
      inline ::std::ios_base::fmtflags setf(::std::ios_base::fmtflags __fmtfl, ::std::ios_base::fmtflags __mask)
      {
        ::std::ios_base::fmtflags __old((*this)._M_flags);
        (*this)._M_flags &=  ~__mask;
        (*this)._M_flags |= __fmtfl & __mask;
        return __old;
      }
      inline void unsetf(::std::ios_base::fmtflags __mask)
      {
        (*this)._M_flags &=  ~__mask;
      }
      inline ::std::streamsize precision() const 
      {
        return (*this)._M_precision;
      }
      inline ::std::streamsize precision(::std::streamsize __prec)
      {
        ::std::streamsize __old((*this)._M_precision);
        (*this)._M_precision = __prec;
        return __old;
      }
      inline ::std::streamsize width() const 
      {
        return (*this)._M_width;
      }
      inline ::std::streamsize width(::std::streamsize __wide)
      {
        ::std::streamsize __old((*this)._M_width);
        (*this)._M_width = __wide;
        return __old;
      }
      static bool sync_with_stdio(bool __sync  = (true));
      ::std::locale imbue(const ::std::locale &__loc) throw();
      inline ::std::locale getloc() const 
      {
        return (*this)._M_ios_locale;
      }
      inline const ::std::locale &_M_getloc() const 
      {
        return (*this)._M_ios_locale;
      }
      static int xalloc() throw();
      inline long int &iword(int __ix)
      {
        ::std::ios_base::_Words &__word(__ix < (*this)._M_word_size ? (*this)._M_word[__ix] : (*this).::std::ios_base::_M_grow_words(__ix, true));
        return __word._M_iword;
      }
      inline void *&pword(int __ix)
      {
        ::std::ios_base::_Words &__word(__ix < (*this)._M_word_size ? (*this)._M_word[__ix] : (*this).::std::ios_base::_M_grow_words(__ix, false));
        return __word._M_pword;
      }
      virtual ~ios_base();
    protected:
      ios_base() throw();
    private:
      ios_base(const ::std::ios_base &);
      ::std::ios_base &operator =(const ::std::ios_base &);
  };
  inline ::std::ios_base &boolalpha(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::boolalpha);
    return __base;
  }
  inline ::std::ios_base &noboolalpha(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::boolalpha);
    return __base;
  }
  inline ::std::ios_base &showbase(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::showbase);
    return __base;
  }
  inline ::std::ios_base &noshowbase(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::showbase);
    return __base;
  }
  inline ::std::ios_base &showpoint(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::showpoint);
    return __base;
  }
  inline ::std::ios_base &noshowpoint(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::showpoint);
    return __base;
  }
  inline ::std::ios_base &showpos(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::showpos);
    return __base;
  }
  inline ::std::ios_base &noshowpos(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::showpos);
    return __base;
  }
  inline ::std::ios_base &skipws(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::skipws);
    return __base;
  }
  inline ::std::ios_base &noskipws(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::skipws);
    return __base;
  }
  inline ::std::ios_base &uppercase(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::uppercase);
    return __base;
  }
  inline ::std::ios_base &nouppercase(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::uppercase);
    return __base;
  }
  inline ::std::ios_base &unitbuf(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::unitbuf);
    return __base;
  }
  inline ::std::ios_base &nounitbuf(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::unitbuf);
    return __base;
  }
  inline ::std::ios_base &internal(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::internal, ::std::ios_base::adjustfield);
    return __base;
  }
  inline ::std::ios_base &left(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::left, ::std::ios_base::adjustfield);
    return __base;
  }
  inline ::std::ios_base &right(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::right, ::std::ios_base::adjustfield);
    return __base;
  }
  inline ::std::ios_base &dec(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::dec, ::std::ios_base::basefield);
    return __base;
  }
  inline ::std::ios_base &hex(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::hex, ::std::ios_base::basefield);
    return __base;
  }
  inline ::std::ios_base &oct(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::oct, ::std::ios_base::basefield);
    return __base;
  }
  inline ::std::ios_base &fixed(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::fixed, ::std::ios_base::floatfield);
    return __base;
  }
  inline ::std::ios_base &scientific(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::scientific, ::std::ios_base::floatfield);
    return __base;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize __copy_streambufs_eof(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout, bool &__ineof);
  template < typename _CharT, typename _Traits >
  class  basic_streambuf
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_streambuf<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type> __streambuf_type;
    protected:
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_in_beg;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_in_cur;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_in_end;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_out_beg;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_out_cur;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_out_end;
      ::std::locale _M_buf_locale;
    public:
      inline virtual ~basic_streambuf()
      {
      }
      inline ::std::locale pubimbue(const ::std::locale &__loc)
      {
        ::std::locale __tmp(this->getloc());
        this->imbue(__loc);
        ::std::basic_streambuf<_CharT, _Traits>::_M_buf_locale = __loc;
        return __tmp;
      }
      inline ::std::locale getloc() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_buf_locale;
      }
      inline ::std::basic_streambuf<_CharT, _Traits> *pubsetbuf(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->setbuf(__s, __n);
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::pos_type pubseekoff(typename ::std::basic_streambuf<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __way, ::std::ios_base::openmode __mode  = (::std::ios_base::in | ::std::ios_base::out))
      {
        return this->seekoff(__off, __way, __mode);
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::pos_type pubseekpos(typename ::std::basic_streambuf<_CharT, _Traits>::pos_type __sp, ::std::ios_base::openmode __mode  = (::std::ios_base::in | ::std::ios_base::out))
      {
        return this->seekpos(__sp, __mode);
      }
      inline int pubsync()
      {
        return this->sync();
      }
      inline ::std::streamsize in_avail()
      {
        const ::std::streamsize __ret = this->egptr() - this->gptr();
        return __ret ? __ret : this->showmanyc();
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type snextc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret = traits_type::eof();
        if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), __ret), true))
          {
            __ret = this->sgetc();
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sbumpc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->gptr() < this->egptr(), true))
          {
            __ret = traits_type::to_int_type(*this->gptr());
            this->gbump(1);
          }
        else
          {
            __ret = this->uflow();
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sgetc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->gptr() < this->egptr(), true))
          {
            __ret = traits_type::to_int_type(*this->gptr());
          }
        else
          {
            __ret = this->underflow();
          }
        return __ret;
      }
      inline ::std::streamsize sgetn(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->xsgetn(__s, __n);
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sputbackc(typename ::std::basic_streambuf<_CharT, _Traits>::char_type __c)
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        const bool __testpos = this->eback() < this->gptr();
        if (__builtin_expect(!__testpos || !traits_type::eq(__c, this->gptr()[ -1]), false))
          {
            __ret = this->pbackfail(traits_type::to_int_type(__c));
          }
        else
          {
            this->gbump( -1);
            __ret = traits_type::to_int_type(*this->gptr());
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sungetc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->eback() < this->gptr(), true))
          {
            this->gbump( -1);
            __ret = traits_type::to_int_type(*this->gptr());
          }
        else
          {
            __ret = this->pbackfail();
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sputc(typename ::std::basic_streambuf<_CharT, _Traits>::char_type __c)
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->pptr() < this->epptr(), true))
          {
            *this->pptr() = __c;
            this->pbump(1);
            __ret = traits_type::to_int_type(__c);
          }
        else
          {
            __ret = this->overflow(traits_type::to_int_type(__c));
          }
        return __ret;
      }
      inline ::std::streamsize sputn(const typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->xsputn(__s, __n);
      }
    protected:
      inline basic_streambuf()
        : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), _M_out_beg(0), _M_out_cur(0), _M_out_end(0), _M_buf_locale(::std::locale())
      {
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *eback() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_in_beg;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *gptr() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_in_cur;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *egptr() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_in_end;
      }
      inline void gbump(int __n)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_cur += __n;
      }
      inline void setg(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__gbeg, typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__gnext, typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__gend)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_beg = __gbeg;
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_cur = __gnext;
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_end = __gend;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *pbase() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_out_beg;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *pptr() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_out_cur;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *epptr() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_out_end;
      }
      inline void pbump(int __n)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_out_cur += __n;
      }
      inline void setp(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__pbeg, typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__pend)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_out_beg = ::std::basic_streambuf<_CharT, _Traits>::_M_out_cur = __pbeg;
        ::std::basic_streambuf<_CharT, _Traits>::_M_out_end = __pend;
      }
      inline virtual void imbue(const ::std::locale &__loc)
      {
      }
      inline virtual ::std::basic_streambuf<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, _Traits> *setbuf(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *, ::std::streamsize)
      {
        return this;
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::pos_type seekoff(typename ::std::basic_streambuf<_CharT, _Traits>::off_type, ::std::ios_base::seekdir, ::std::ios_base::openmode  = (::std::ios_base::in | ::std::ios_base::out))
      {
        return ((typename ::std::basic_streambuf<_CharT, _Traits>::pos_type(((typename ::std::basic_streambuf<_CharT, _Traits>::off_type( -1))))));
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::pos_type seekpos(typename ::std::basic_streambuf<_CharT, _Traits>::pos_type, ::std::ios_base::openmode  = (::std::ios_base::in | ::std::ios_base::out))
      {
        return ((typename ::std::basic_streambuf<_CharT, _Traits>::pos_type(((typename ::std::basic_streambuf<_CharT, _Traits>::off_type( -1))))));
      }
      inline virtual int sync()
      {
        return 0;
      }
      inline virtual ::std::streamsize showmanyc()
      {
        return 0;
      }
      virtual ::std::streamsize xsgetn(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type underflow()
      {
        return traits_type::eof();
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type uflow()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret = traits_type::eof();
        const bool __testeof = traits_type::eq_int_type(this->underflow(), __ret);
        if (!__testeof)
          {
            __ret = traits_type::to_int_type(*this->gptr());
            this->gbump(1);
          }
        return __ret;
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type pbackfail(typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c  = (traits_type::eof()))
      {
        return traits_type::eof();
      }
      virtual ::std::streamsize xsputn(const typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type overflow(typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c  = (traits_type::eof()))
      {
        return traits_type::eof();
      }
    public:
      inline void stossc()
      {
        if (this->gptr() < this->egptr())
          {
            this->gbump(1);
          }
        else
          {
            this->uflow();
          }
      }
      inline void __safe_gbump(::std::streamsize __n)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_cur += __n;
      }
      inline void __safe_pbump(::std::streamsize __n)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_out_cur += __n;
      }
    private:
      inline basic_streambuf(const ::std::basic_streambuf<_CharT, _Traits> &__sb)
        : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur), _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg), _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur), _M_buf_locale(__sb._M_buf_locale)
      {
      }
      inline ::std::basic_streambuf<_CharT, _Traits> &operator =(const ::std::basic_streambuf<_CharT, _Traits> &)
      {
        return *this;
      }
    friend class ::std::basic_ios<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::basic_istream<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::basic_ostream<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::istreambuf_iterator<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::ostreambuf_iterator<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend ::std::streamsize __copy_streambufs_eof<>(::std::basic_streambuf<_CharT, _Traits> *, ::std::basic_streambuf<_CharT, _Traits> *, bool &);
    template < bool _IsMove, typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, _CharT2 *);
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::istreambuf_iterator<_CharT2> >::__type find(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, const _CharT2 &);
    template < typename _CharT2, typename _Traits2 >
    friend ::std::basic_istream<_CharT2, _Traits2> &operator >>(::std::basic_istream<_CharT2, _Traits2> &, _CharT2 *);
    template < typename _CharT2, typename _Traits2, typename _Alloc >
    friend ::std::basic_istream<_CharT2, _Traits2> &operator >>(::std::basic_istream<_CharT2, _Traits2> &, ::std::basic_string<_CharT2, _Traits2, _Alloc> &);
    template < typename _CharT2, typename _Traits2, typename _Alloc >
    friend ::std::basic_istream<_CharT2, _Traits2> &getline(::std::basic_istream<_CharT2, _Traits2> &, ::std::basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
  };
  template <>
  long int __copy_streambufs_eof<char, ::std::char_traits<char> >(::std::basic_streambuf<char> *__sbin, ::std::basic_streambuf<char> *__sbout, bool &__ineof);
  template <>
  long int __copy_streambufs_eof<wchar_t, ::std::char_traits<wchar_t> >(::std::basic_streambuf<wchar_t> *__sbin, ::std::basic_streambuf<wchar_t> *__sbout, bool &__ineof);
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_streambuf<_CharT, _Traits>::xsgetn(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    ::std::streamsize __ret(0);
    while (__ret < __n)
      {
        const ::std::streamsize __buf_len = this->egptr() - this->gptr();
        if (__buf_len)
          {
            const ::std::streamsize __remaining(__n - __ret);
            const ::std::streamsize __len = std::min(__buf_len, __remaining);
            traits_type::copy(__s, this->gptr(), __len);
            __ret += __len;
            __s += __len;
            this->__safe_gbump(__len);
          }
        if (__ret < __n)
          {
            const typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c = this->uflow();
            if (!traits_type::eq_int_type(__c, traits_type::eof()))
              {
                traits_type::assign(*__s++, traits_type::to_char_type(__c));
                 ++__ret;
              }
            else
              {
                break;
              }
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_streambuf<_CharT, _Traits>::xsputn(const typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    ::std::streamsize __ret(0);
    while (__ret < __n)
      {
        const ::std::streamsize __buf_len = this->epptr() - this->pptr();
        if (__buf_len)
          {
            const ::std::streamsize __remaining(__n - __ret);
            const ::std::streamsize __len = std::min(__buf_len, __remaining);
            traits_type::copy(this->pptr(), __s, __len);
            __ret += __len;
            __s += __len;
            this->__safe_pbump(__len);
          }
        if (__ret < __n)
          {
            typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c = this->overflow(traits_type::to_int_type(*__s));
            if (!traits_type::eq_int_type(__c, traits_type::eof()))
              {
                 ++__ret;
                 ++__s;
              }
            else
              {
                break;
              }
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize __copy_streambufs_eof(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout, bool &__ineof)
  {
    ::std::streamsize __ret(0);
    __ineof = true;
    typename _Traits::int_type __c = __sbin->sgetc();
    while (!_Traits::eq_int_type(__c, _Traits::eof()))
      {
        __c = __sbout->sputc(_Traits::to_char_type(__c));
        if (_Traits::eq_int_type(__c, _Traits::eof()))
          {
            __ineof = false;
            break;
          }
         ++__ret;
        __c = __sbin->snextc();
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  inline ::std::streamsize __copy_streambufs(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout);
  template < typename _CharT, typename _Traits >
  inline ::std::streamsize __copy_streambufs(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout)
  {
    bool __ineof;
    return __copy_streambufs_eof(__sbin, __sbout, __ineof);
  }
  extern template class ::std::basic_streambuf<char>;
  extern template long int __copy_streambufs(::std::basic_streambuf<char> *, ::std::basic_streambuf<char> *);
  extern template long int __copy_streambufs_eof(::std::basic_streambuf<char> *, ::std::basic_streambuf<char> *, bool &);
  extern template class ::std::basic_streambuf<wchar_t>;
  extern template long int __copy_streambufs(::std::basic_streambuf<wchar_t> *, ::std::basic_streambuf<wchar_t> *);
  extern template long int __copy_streambufs_eof(::std::basic_streambuf<wchar_t> *, ::std::basic_streambuf<wchar_t> *, bool &);
}
typedef unsigned long int wctype_t;
enum mcc_enum_anon_57
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,
  _ISwupper = ::__ISwupper < 8 ? (int)(1LU << ::__ISwupper << 24) : ::__ISwupper < 16 ? (int)(1LU << ::__ISwupper << 8) : ::__ISwupper < 24 ? (int)(1LU << ::__ISwupper >> 8) : (int)(1LU << ::__ISwupper >> 24),
  _ISwlower = ::__ISwlower < 8 ? (int)(1LU << ::__ISwlower << 24) : ::__ISwlower < 16 ? (int)(1LU << ::__ISwlower << 8) : ::__ISwlower < 24 ? (int)(1LU << ::__ISwlower >> 8) : (int)(1LU << ::__ISwlower >> 24),
  _ISwalpha = ::__ISwalpha < 8 ? (int)(1LU << ::__ISwalpha << 24) : ::__ISwalpha < 16 ? (int)(1LU << ::__ISwalpha << 8) : ::__ISwalpha < 24 ? (int)(1LU << ::__ISwalpha >> 8) : (int)(1LU << ::__ISwalpha >> 24),
  _ISwdigit = ::__ISwdigit < 8 ? (int)(1LU << ::__ISwdigit << 24) : ::__ISwdigit < 16 ? (int)(1LU << ::__ISwdigit << 8) : ::__ISwdigit < 24 ? (int)(1LU << ::__ISwdigit >> 8) : (int)(1LU << ::__ISwdigit >> 24),
  _ISwxdigit = ::__ISwxdigit < 8 ? (int)(1LU << ::__ISwxdigit << 24) : ::__ISwxdigit < 16 ? (int)(1LU << ::__ISwxdigit << 8) : ::__ISwxdigit < 24 ? (int)(1LU << ::__ISwxdigit >> 8) : (int)(1LU << ::__ISwxdigit >> 24),
  _ISwspace = ::__ISwspace < 8 ? (int)(1LU << ::__ISwspace << 24) : ::__ISwspace < 16 ? (int)(1LU << ::__ISwspace << 8) : ::__ISwspace < 24 ? (int)(1LU << ::__ISwspace >> 8) : (int)(1LU << ::__ISwspace >> 24),
  _ISwprint = ::__ISwprint < 8 ? (int)(1LU << ::__ISwprint << 24) : ::__ISwprint < 16 ? (int)(1LU << ::__ISwprint << 8) : ::__ISwprint < 24 ? (int)(1LU << ::__ISwprint >> 8) : (int)(1LU << ::__ISwprint >> 24),
  _ISwgraph = ::__ISwgraph < 8 ? (int)(1LU << ::__ISwgraph << 24) : ::__ISwgraph < 16 ? (int)(1LU << ::__ISwgraph << 8) : ::__ISwgraph < 24 ? (int)(1LU << ::__ISwgraph >> 8) : (int)(1LU << ::__ISwgraph >> 24),
  _ISwblank = ::__ISwblank < 8 ? (int)(1LU << ::__ISwblank << 24) : ::__ISwblank < 16 ? (int)(1LU << ::__ISwblank << 8) : ::__ISwblank < 24 ? (int)(1LU << ::__ISwblank >> 8) : (int)(1LU << ::__ISwblank >> 24),
  _ISwcntrl = ::__ISwcntrl < 8 ? (int)(1LU << ::__ISwcntrl << 24) : ::__ISwcntrl < 16 ? (int)(1LU << ::__ISwcntrl << 8) : ::__ISwcntrl < 24 ? (int)(1LU << ::__ISwcntrl >> 8) : (int)(1LU << ::__ISwcntrl >> 24),
  _ISwpunct = ::__ISwpunct < 8 ? (int)(1LU << ::__ISwpunct << 24) : ::__ISwpunct < 16 ? (int)(1LU << ::__ISwpunct << 8) : ::__ISwpunct < 24 ? (int)(1LU << ::__ISwpunct >> 8) : (int)(1LU << ::__ISwpunct >> 24),
  _ISwalnum = ::__ISwalnum < 8 ? (int)(1LU << ::__ISwalnum << 24) : ::__ISwalnum < 16 ? (int)(1LU << ::__ISwalnum << 8) : ::__ISwalnum < 24 ? (int)(1LU << ::__ISwalnum >> 8) : (int)(1LU << ::__ISwalnum >> 24)
};
extern "C"
{
  extern int iswalnum(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswalpha(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswcntrl(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswdigit(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswgraph(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswlower(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswprint(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswpunct(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswspace(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswupper(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswxdigit(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswblank(::wint_t __wc) throw();
}
extern "C"
{
  extern ::wctype_t wctype(const char *__property) throw();
}
extern "C"
{
  extern int iswctype(::wint_t __wc, ::wctype_t __desc) throw();
}
typedef const ::__int32_t *wctrans_t;
extern "C"
{
  extern ::wint_t towlower(::wint_t __wc) throw();
}
extern "C"
{
  extern ::wint_t towupper(::wint_t __wc) throw();
}
extern "C"
{
  extern ::wctrans_t wctrans(const char *__property) throw();
}
extern "C"
{
  extern ::wint_t towctrans(::wint_t __wc, ::wctrans_t __desc) throw();
}
extern "C"
{
  extern int iswalnum_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswalpha_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswcntrl_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswdigit_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswgraph_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswlower_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswprint_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswpunct_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswspace_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswupper_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswxdigit_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswblank_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wctype_t wctype_l(const char *__property, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswctype_l(::wint_t __wc, ::wctype_t __desc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wint_t towlower_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wint_t towupper_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wctrans_t wctrans_l(const char *__property, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wint_t towctrans_l(::wint_t __wc, ::wctrans_t __desc, ::__locale_t __locale) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;
  using ::iswalnum;
  using ::iswalpha;
  using ::iswblank;
  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
  struct  ctype_base
  {
      typedef const int *__to_type;
      typedef unsigned short int mask;
      static const ::std::ctype_base::mask upper = ::_ISupper;
      static const ::std::ctype_base::mask lower = ::_ISlower;
      static const ::std::ctype_base::mask alpha = ::_ISalpha;
      static const ::std::ctype_base::mask digit = ::_ISdigit;
      static const ::std::ctype_base::mask xdigit = ::_ISxdigit;
      static const ::std::ctype_base::mask space = ::_ISspace;
      static const ::std::ctype_base::mask print = ::_ISprint;
      static const ::std::ctype_base::mask graph = (::_ISalpha | ::_ISdigit) | ::_ISpunct;
      static const ::std::ctype_base::mask cntrl = ::_IScntrl;
      static const ::std::ctype_base::mask punct = ::_ISpunct;
      static const ::std::ctype_base::mask alnum = ::_ISalpha | ::_ISdigit;
  };
  template < typename _CharT, typename _Traits >
  class  istreambuf_iterator : public ::std::iterator< ::std::input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef ::std::basic_istream<_CharT, _Traits> istream_type;
    private:
      mutable typename ::std::istreambuf_iterator<_CharT, _Traits>::streambuf_type *_M_sbuf;
      mutable typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type _M_c;
    public:
      inline constexpr istreambuf_iterator() noexcept(true)
        : _M_sbuf(0), _M_c(traits_type::eof())
      {
      }
      istreambuf_iterator(const ::std::istreambuf_iterator<_CharT, _Traits> &) noexcept(true) = default ;
      ~istreambuf_iterator() = default ;
      inline istreambuf_iterator(typename ::std::istreambuf_iterator<_CharT, _Traits>::istream_type &__s) noexcept(true)
        : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof())
      {
      }
      inline istreambuf_iterator(typename ::std::istreambuf_iterator<_CharT, _Traits>::streambuf_type *__s) noexcept(true)
        : _M_sbuf(__s), _M_c(traits_type::eof())
      {
      }
      inline typename ::std::istreambuf_iterator<_CharT, _Traits>::char_type operator *() const 
      {
        return traits_type::to_char_type((*this)._M_get());
      }
      inline ::std::istreambuf_iterator<_CharT, _Traits> &operator ++()
      {
        ;
        if (::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf)
          {
            ::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf->sbumpc();
            ::std::istreambuf_iterator<_CharT, _Traits>::_M_c = traits_type::eof();
          }
        return *this;
      }
      inline ::std::istreambuf_iterator<_CharT, _Traits> operator ++(int)
      {
        ;
        ::std::istreambuf_iterator<_CharT, _Traits> __old = *this;
        if (::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf)
          {
            __old._M_c = ::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf->sbumpc();
            ::std::istreambuf_iterator<_CharT, _Traits>::_M_c = traits_type::eof();
          }
        return __old;
      }
      inline bool equal(const ::std::istreambuf_iterator<_CharT, _Traits> &__b) const 
      {
        return (*this)._M_at_eof() == __b._M_at_eof();
      }
    private:
      inline typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type _M_get() const 
      {
        const typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type __eof = traits_type::eof();
        typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type __ret = __eof;
        if (::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf)
          {
            if (!traits_type::eq_int_type(::std::istreambuf_iterator<_CharT, _Traits>::_M_c, __eof))
              {
                __ret = ::std::istreambuf_iterator<_CharT, _Traits>::_M_c;
              }
            else
              {
                if (!traits_type::eq_int_type(__ret = ::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf->sgetc(), __eof))
                  {
                    ::std::istreambuf_iterator<_CharT, _Traits>::_M_c = __ret;
                  }
                else
                  {
                    ::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf = 0;
                  }
              }
          }
        return __ret;
      }
      inline bool _M_at_eof() const 
      {
        const typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type __eof = traits_type::eof();
        return traits_type::eq_int_type((*this)._M_get(), __eof);
      }
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::ostreambuf_iterator<_CharT2> >::__type copy(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, ::std::ostreambuf_iterator<_CharT2>);
    template < bool _IsMove, typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, _CharT2 *);
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::istreambuf_iterator<_CharT2> >::__type find(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, const _CharT2 &);
  };
  template < typename _CharT, typename _Traits >
  inline bool operator ==(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b);
  template < typename _CharT, typename _Traits >
  inline bool operator ==(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b)
  {
    return __a.equal(__b);
  }
  template < typename _CharT, typename _Traits >
  inline bool operator !=(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b);
  template < typename _CharT, typename _Traits >
  inline bool operator !=(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b)
  {
    return !__a.equal(__b);
  }
  template < typename _CharT, typename _Traits >
  class  ostreambuf_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef ::std::basic_ostream<_CharT, _Traits> ostream_type;
    private:
      typename ::std::ostreambuf_iterator<_CharT, _Traits>::streambuf_type *_M_sbuf;
      bool _M_failed;
    public:
      inline ostreambuf_iterator(typename ::std::ostreambuf_iterator<_CharT, _Traits>::ostream_type &__s) noexcept(true)
        : _M_sbuf(__s.rdbuf()), _M_failed(!::std::ostreambuf_iterator<_CharT, _Traits>::_M_sbuf)
      {
      }
      inline ostreambuf_iterator(typename ::std::ostreambuf_iterator<_CharT, _Traits>::streambuf_type *__s) noexcept(true)
        : _M_sbuf(__s), _M_failed(!::std::ostreambuf_iterator<_CharT, _Traits>::_M_sbuf)
      {
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator =(_CharT __c)
      {
        if (!::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed && _Traits::eq_int_type(::std::ostreambuf_iterator<_CharT, _Traits>::_M_sbuf->sputc(__c), _Traits::eof()))
          {
            ::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed = true;
          }
        return *this;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator *()
      {
        return *this;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator ++(int)
      {
        return *this;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator ++()
      {
        return *this;
      }
      inline bool failed() const  noexcept(true)
      {
        return ::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &_M_put(const _CharT *__ws, ::std::streamsize __len)
      {
        if (__builtin_expect(!::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed, true) && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))
          {
            ::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed = true;
          }
        return *this;
      }
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::ostreambuf_iterator<_CharT2> >::__type copy(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, ::std::ostreambuf_iterator<_CharT2>);
  };
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT> >::__type copy(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, ::std::ostreambuf_iterator<_CharT> __result);
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT> >::__type copy(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, ::std::ostreambuf_iterator<_CharT> __result)
  {
    if ((__first._M_sbuf && !__last._M_sbuf) && !__result._M_failed)
      {
        bool __ineof;
        __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
        if (!__ineof)
          {
            __result._M_failed = true;
          }
      }
    return __result;
  }
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(_CharT *__first, _CharT *__last, ::std::ostreambuf_iterator<_CharT> __result)
  {
    const ::std::streamsize __num = __last - __first;
    if (__num > 0)
      {
        __result._M_put(__first, __num);
      }
    return __result;
  }
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(const _CharT *__first, const _CharT *__last, ::std::ostreambuf_iterator<_CharT> __result)
  {
    const ::std::streamsize __num = __last - __first;
    if (__num > 0)
      {
        __result._M_put(__first, __num);
      }
    return __result;
  }
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, _CharT *__result)
  {
    typedef ::std::istreambuf_iterator<_CharT> __is_iterator_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::traits_type traits_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::streambuf_type streambuf_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::traits_type::int_type int_type;
    if (__first._M_sbuf && !__last._M_sbuf)
      {
        streambuf_type *__sb = __first._M_sbuf;
        int_type __c = __sb->sgetc();
        while (!traits_type::eq_int_type(__c, traits_type::eof()))
          {
            const ::std::streamsize __n = __sb->egptr() - __sb->gptr();
            if (__n > 1)
              {
                traits_type::copy(__result, __sb->gptr(), __n);
                __sb->__safe_gbump(__n);
                __result += __n;
                __c = __sb->underflow();
              }
            else
              {
                *__result++ = traits_type::to_char_type(__c);
                __c = __sb->snextc();
              }
          }
      }
    return __result;
  }
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::istreambuf_iterator<_CharT> >::__type find(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, const _CharT &__val);
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::istreambuf_iterator<_CharT> >::__type find(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, const _CharT &__val)
  {
    typedef ::std::istreambuf_iterator<_CharT> __is_iterator_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::traits_type traits_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::streambuf_type streambuf_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::traits_type::int_type int_type;
    if (__first._M_sbuf && !__last._M_sbuf)
      {
        const int_type __ival = traits_type::to_int_type(__val);
        streambuf_type *__sb = __first._M_sbuf;
        int_type __c = __sb->sgetc();
        while (!traits_type::eq_int_type(__c, traits_type::eof()) && !traits_type::eq_int_type(__c, __ival))
          {
            ::std::streamsize __n = __sb->egptr() - __sb->gptr();
            if (__n > 1)
              {
                const _CharT *__p = traits_type::find(__sb->gptr(), __n, __val);
                if (__p)
                  {
                    __n = __p - __sb->gptr();
                  }
                __sb->__safe_gbump(__n);
                __c = __sb->sgetc();
              }
            else
              {
                __c = __sb->snextc();
              }
          }
        if (!traits_type::eq_int_type(__c, traits_type::eof()))
          {
            __first._M_c = __c;
          }
        else
          {
            __first._M_sbuf = 0;
          }
      }
    return __first;
  }
  template < typename _Tp >
  void __convert_to_v(const char *, _Tp &, ::std::ios_base::iostate &, const ::std::__c_locale &) throw();
  template <>
  void __convert_to_v<float>(const char *, float &, ::std::_Ios_Iostate &, ::__locale_struct *const &) throw();
  template <>
  void __convert_to_v<double>(const char *, double &, ::std::_Ios_Iostate &, ::__locale_struct *const &) throw();
  template <>
  void __convert_to_v<long double>(const char *, long double &, ::std::_Ios_Iostate &, ::__locale_struct *const &) throw();
  template < typename _CharT, typename _Traits >
  struct  __pad
  {
      static void _S_pad(::std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, ::std::streamsize __newlen, ::std::streamsize __oldlen);
  };
  template < typename _CharT >
  _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, ::std::size_t __gsize, const _CharT *__first, const _CharT *__last);
  template < typename _CharT >
  inline ::std::ostreambuf_iterator<_CharT> __write(::std::ostreambuf_iterator<_CharT> __s, const _CharT *__ws, int __len);
  template < typename _CharT >
  inline ::std::ostreambuf_iterator<_CharT> __write(::std::ostreambuf_iterator<_CharT> __s, const _CharT *__ws, int __len)
  {
    __s._M_put(__ws, __len);
    return __s;
  }
  template < typename _CharT, typename _OutIter >
  inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len);
  template < typename _CharT, typename _OutIter >
  inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len)
  {
    for (int __j(0); __j < __len; (__j++,  ++__s))
      {
        *__s = __ws[__j];
      }
    return __s;
  }
  template < typename _CharT >
  class  __ctype_abstract_base : public ::std::locale::facet, public ::std::ctype_base
  {
    public:
      typedef _CharT char_type;
      inline bool is(::std::ctype_base::mask __m, typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const 
      {
        return this->do_is(__m, __c);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *is(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, ::std::ctype_base::mask *__vec) const 
      {
        return this->do_is(__lo, __hi, __vec);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *scan_is(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_scan_is(__m, __lo, __hi);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *scan_not(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_scan_not(__m, __lo, __hi);
      }
      inline typename ::std::__ctype_abstract_base<_CharT>::char_type toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const 
      {
        return this->do_toupper(__c);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_toupper(__lo, __hi);
      }
      inline typename ::std::__ctype_abstract_base<_CharT>::char_type tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const 
      {
        return this->do_tolower(__c);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_tolower(__lo, __hi);
      }
      inline typename ::std::__ctype_abstract_base<_CharT>::char_type widen(char __c) const 
      {
        return this->do_widen(__c);
      }
      inline const char *widen(const char *__lo, const char *__hi, typename ::std::__ctype_abstract_base<_CharT>::char_type *__to) const 
      {
        return this->do_widen(__lo, __hi, __to);
      }
      inline char narrow(typename ::std::__ctype_abstract_base<_CharT>::char_type __c, char __dfault) const 
      {
        return this->do_narrow(__c, __dfault);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *narrow(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, char __dfault, char *__to) const 
      {
        return this->do_narrow(__lo, __hi, __dfault, __to);
      }
    protected:
      inline explicit __ctype_abstract_base(::std::size_t __refs  = (0))
        : facet(__refs)
      {
      }
      inline virtual ~__ctype_abstract_base()
      {
      }
      virtual bool do_is(::std::ctype_base::mask __m, typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_is(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, ::std::ctype_base::mask *__vec) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_scan_is(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_scan_not(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual typename ::std::__ctype_abstract_base<_CharT>::char_type do_toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual typename ::std::__ctype_abstract_base<_CharT>::char_type do_tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual typename ::std::__ctype_abstract_base<_CharT>::char_type do_widen(char __c) const  = 0 ;
      virtual const char *do_widen(const char *__lo, const char *__hi, typename ::std::__ctype_abstract_base<_CharT>::char_type *__to) const  = 0 ;
      virtual char do_narrow(typename ::std::__ctype_abstract_base<_CharT>::char_type __c, char __dfault) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_narrow(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, char __dfault, char *__to) const  = 0 ;
  };
  template < typename _CharT >
  class  ctype : public ::std::__ctype_abstract_base<_CharT>
  {
    public:
      typedef _CharT char_type;
      typedef typename ::std::__ctype_abstract_base<_CharT>::mask mask;
      static ::std::locale::id id;
      inline explicit ctype(::std::size_t __refs  = (0))
        : __ctype_abstract_base<_CharT>(__refs)
      {
      }
    protected:
      virtual ~ctype();
      virtual bool do_is(typename ::std::ctype<_CharT>::mask __m, typename ::std::ctype<_CharT>::char_type __c) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_is(const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi, typename ::std::ctype<_CharT>::mask *__vec) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_scan_is(typename ::std::ctype<_CharT>::mask __m, const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_scan_not(typename ::std::ctype<_CharT>::mask __m, const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual typename ::std::ctype<_CharT>::char_type do_toupper(typename ::std::ctype<_CharT>::char_type __c) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_toupper(typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual typename ::std::ctype<_CharT>::char_type do_tolower(typename ::std::ctype<_CharT>::char_type __c) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_tolower(typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual typename ::std::ctype<_CharT>::char_type do_widen(char __c) const ;
      virtual const char *do_widen(const char *__lo, const char *__hi, typename ::std::ctype<_CharT>::char_type *__dest) const ;
      virtual char do_narrow(typename ::std::ctype<_CharT>::char_type, char __dfault) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_narrow(const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi, char __dfault, char *__to) const ;
  };
  template < typename _CharT >
  ::std::locale::id ctype<_CharT>::id;
  template <>
  class  ctype<char> : public ::std::locale::facet, public ::std::ctype_base
  {
    public:
      typedef char char_type;
    protected:
      ::std::__c_locale _M_c_locale_ctype;
      bool _M_del;
      ::std::ctype_base::__to_type _M_toupper;
      ::std::ctype_base::__to_type _M_tolower;
      const ::std::ctype_base::mask *_M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[256L];
      mutable char _M_narrow[256L];
      mutable char _M_narrow_ok;
    public:
      static ::std::locale::id id;
      static const ::std::size_t table_size = 1 + static_cast<unsigned char>( -1);
      explicit ctype(const ::std::ctype_base::mask *__table  = (0), bool __del  = (false), ::std::size_t __refs  = (0));
      explicit ctype(::std::__c_locale __cloc, const ::std::ctype_base::mask *__table  = (0), bool __del  = (false), ::std::size_t __refs  = (0));
      inline bool is(::std::ctype_base::mask __m, char __c) const ;
      inline const char *is(const char *__low, const char *__high, ::std::ctype_base::mask *__vec) const ;
      inline const char *scan_is(::std::ctype_base::mask __m, const char *__low, const char *__high) const ;
      inline const char *scan_not(::std::ctype_base::mask __m, const char *__low, const char *__high) const ;
      inline ::std::ctype<char>::char_type toupper(::std::ctype<char>::char_type __c) const 
      {
        return (*this).do_toupper(__c);
      }
      inline const ::std::ctype<char>::char_type *toupper(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const 
      {
        return (*this).do_toupper(__lo, __hi);
      }
      inline ::std::ctype<char>::char_type tolower(::std::ctype<char>::char_type __c) const 
      {
        return (*this).do_tolower(__c);
      }
      inline const ::std::ctype<char>::char_type *tolower(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const 
      {
        return (*this).do_tolower(__lo, __hi);
      }
      inline ::std::ctype<char>::char_type widen(char __c) const 
      {
        if ((*this)._M_widen_ok)
          {
            return (*this)._M_widen[static_cast<unsigned char>(__c)];
          }
        (*this).::std::ctype<char>::_M_widen_init();
        return (*this).do_widen(__c);
      }
      inline const char *widen(const char *__lo, const char *__hi, ::std::ctype<char>::char_type *__to) const 
      {
        if ((*this)._M_widen_ok == 1)
          {
            __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
          }
        if (!(*this)._M_widen_ok)
          {
            (*this).::std::ctype<char>::_M_widen_init();
          }
        return (*this).do_widen(__lo, __hi, __to);
      }
      inline char narrow(::std::ctype<char>::char_type __c, char __dfault) const 
      {
        if ((*this)._M_narrow[static_cast<unsigned char>(__c)])
          {
            return (*this)._M_narrow[static_cast<unsigned char>(__c)];
          }
        const char __t((*this).do_narrow(__c, __dfault));
        if (__t != __dfault)
          {
            (*this)._M_narrow[static_cast<unsigned char>(__c)] = __t;
          }
        return __t;
      }
      inline const ::std::ctype<char>::char_type *narrow(const ::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi, char __dfault, char *__to) const 
      {
        if (__builtin_expect((*this)._M_narrow_ok == 1, true))
          {
            __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
          }
        if (!(*this)._M_narrow_ok)
          {
            (*this).::std::ctype<char>::_M_narrow_init();
          }
        return (*this).do_narrow(__lo, __hi, __dfault, __to);
      }
      inline const ::std::ctype_base::mask *table() const  throw()
      {
        return (*this)._M_table;
      }
      static const ::std::ctype_base::mask *classic_table() throw();
    protected:
      virtual ~ctype();
      virtual ::std::ctype<char>::char_type do_toupper(::std::ctype<char>::char_type __c) const ;
      virtual const ::std::ctype<char>::char_type *do_toupper(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const ;
      virtual ::std::ctype<char>::char_type do_tolower(::std::ctype<char>::char_type __c) const ;
      virtual const ::std::ctype<char>::char_type *do_tolower(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const ;
      virtual inline ::std::ctype<char>::char_type do_widen(char __c) const 
      {
        return __c;
      }
      virtual inline const char *do_widen(const char *__lo, const char *__hi, ::std::ctype<char>::char_type *__to) const 
      {
        __builtin_memcpy(__to, __lo, __hi - __lo);
        return __hi;
      }
      virtual inline char do_narrow(::std::ctype<char>::char_type __c, char __dfault) const 
      {
        return __c;
      }
      virtual inline const ::std::ctype<char>::char_type *do_narrow(const ::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi, char __dfault, char *__to) const 
      {
        __builtin_memcpy(__to, __lo, __hi - __lo);
        return __hi;
      }
    private:
      void _M_narrow_init() const ;
      void _M_widen_init() const ;
    public:
  };
 /* Instantiation of class template '::std::__ctype_abstract_base<wchar_t>' */ 
  template <>
  class  ctype<wchar_t> : public ::std::__ctype_abstract_base<wchar_t>
  {
    public:
      typedef wchar_t char_type;
      typedef ::wctype_t __wmask_type;
    protected:
      ::std::__c_locale _M_c_locale_ctype;
      bool _M_narrow_ok;
      char _M_narrow[128L];
      ::wint_t _M_widen[256L];
      ::std::ctype_base::mask _M_bit[16L];
      ::std::ctype<wchar_t>::__wmask_type _M_wmask[16L];
    public:
      static ::std::locale::id id;
      explicit ctype(::std::size_t __refs  = (0));
      explicit ctype(::std::__c_locale __cloc, ::std::size_t __refs  = (0));
    protected:
      ::std::ctype<wchar_t>::__wmask_type _M_convert_to_wmask(const ::std::ctype_base::mask __m) const  throw();
      virtual ~ctype();
      virtual bool do_is(::std::ctype_base::mask __m, ::std::ctype<wchar_t>::char_type __c) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_is(const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi, ::std::ctype_base::mask *__vec) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_scan_is(::std::ctype_base::mask __m, const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_scan_not(::std::ctype_base::mask __m, const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual ::std::ctype<wchar_t>::char_type do_toupper(::std::ctype<wchar_t>::char_type __c) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_toupper(::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual ::std::ctype<wchar_t>::char_type do_tolower(::std::ctype<wchar_t>::char_type __c) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_tolower(::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual ::std::ctype<wchar_t>::char_type do_widen(char __c) const ;
      virtual const char *do_widen(const char *__lo, const char *__hi, ::std::ctype<wchar_t>::char_type *__to) const ;
      virtual char do_narrow(::std::ctype<wchar_t>::char_type __c, char __dfault) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_narrow(const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi, char __dfault, char *__to) const ;
      void _M_initialize_ctype() throw();
    public:
  };
  template < typename _CharT >
  class  ctype_byname : public ::std::ctype<_CharT>
  {
    public:
      typedef typename ::std::ctype<_CharT>::mask mask;
      explicit ctype_byname(const char *__s, ::std::size_t __refs  = (0));
    protected:
      inline virtual ~ctype_byname()
      {
      }
  };
  template <>
  class  ctype_byname<char> : public ::std::ctype<char>
  {
    public:
      explicit ctype_byname(const char *__s, ::std::size_t __refs  = (0));
    protected:
      virtual ~ctype_byname();
    public:
  };
  template <>
  class  ctype_byname<wchar_t> : public ::std::ctype<wchar_t>
  {
    public:
      explicit ctype_byname(const char *__s, ::std::size_t __refs  = (0));
    protected:
      virtual ~ctype_byname();
    public:
  };
  inline bool ctype<char>::is(::std::ctype_base::mask __m, char __c) const 
  {
    return (*this)._M_table[static_cast<unsigned char>(__c)] & __m;
  }
  inline const char *ctype<char>::is(const char *__low, const char *__high, ::std::ctype_base::mask *__vec) const 
  {
    while (__low < __high)
      {
        *__vec++ = (*this)._M_table[static_cast<unsigned char>(*__low++)];
      }
    return __high;
  }
  inline const char *ctype<char>::scan_is(::std::ctype_base::mask __m, const char *__low, const char *__high) const 
  {
    while (__low < __high && !((*this)._M_table[static_cast<unsigned char>(*__low)] & __m))
      {
         ++__low;
      }
    return __low;
  }
  inline const char *ctype<char>::scan_not(::std::ctype_base::mask __m, const char *__low, const char *__high) const 
  {
    while (__low < __high && ((*this)._M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      {
         ++__low;
      }
    return __low;
  }
  class  __num_base
  {
    public:
      enum mcc_enum_anon_58
      {
        _S_ominus = 0,
        _S_oplus = 1,
        _S_ox = 2,
        _S_oX = 3,
        _S_odigits = 4,
        _S_odigits_end = ::std::__num_base::_S_odigits + 16,
        _S_oudigits = ::std::__num_base::_S_odigits_end,
        _S_oudigits_end = ::std::__num_base::_S_oudigits + 16,
        _S_oe = ::std::__num_base::_S_odigits + 14,
        _S_oE = ::std::__num_base::_S_oudigits + 14,
        _S_oend = ::std::__num_base::_S_oudigits_end
      };
      static const char *_S_atoms_out;
      static const char *_S_atoms_in;
      enum mcc_enum_anon_59
      {
        _S_iminus = 0,
        _S_iplus = 1,
        _S_ix = 2,
        _S_iX = 3,
        _S_izero = 4,
        _S_ie = ::std::__num_base::_S_izero + 14,
        _S_iE = ::std::__num_base::_S_izero + 20,
        _S_iend = 26
      };
      static void _S_format_float(const ::std::ios_base &__io, char *__fptr, char __mod) throw();
  };
  template < typename _CharT >
  struct  __numpunct_cache : ::std::locale::facet
  {
      const char *_M_grouping;
      ::std::size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT *_M_truename;
      ::std::size_t _M_truename_size;
      const _CharT *_M_falsename;
      ::std::size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      _CharT _M_atoms_out[36L];
      _CharT _M_atoms_in[26L];
      bool _M_allocated;
      inline __numpunct_cache(::std::size_t __refs  = (0))
        : facet(__refs), _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false), _M_truename(0), _M_truename_size(0), _M_falsename(0), _M_falsename_size(0), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_allocated(false)
      {
      }
      virtual ~__numpunct_cache();
      void _M_cache(const ::std::locale &__loc);
    private:
      ::std::__numpunct_cache<_CharT> &operator =(const ::std::__numpunct_cache<_CharT> &);
      explicit __numpunct_cache(const ::std::__numpunct_cache<_CharT> &);
  };
  template < typename _CharT >
  __numpunct_cache<_CharT>::~__numpunct_cache()
  {
    if (::std::__numpunct_cache<_CharT>::_M_allocated)
      {
        delete[] ::std::__numpunct_cache<_CharT>::_M_grouping;
        delete[] ::std::__numpunct_cache<_CharT>::_M_truename;
        delete[] ::std::__numpunct_cache<_CharT>::_M_falsename;
      }
  }
  template < typename _CharT >
  class  numpunct : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef ::std::basic_string<_CharT> string_type;
      typedef ::std::__numpunct_cache<_CharT> __cache_type;
    protected:
      typename ::std::numpunct<_CharT>::__cache_type *_M_data;
    public:
      static ::std::locale::id id;
      inline explicit numpunct(::std::size_t __refs  = (0))
        : facet(__refs), _M_data(0)
      {
        (*this)._M_initialize_numpunct();
      }
      inline explicit numpunct(typename ::std::numpunct<_CharT>::__cache_type *__cache, ::std::size_t __refs  = (0))
        : facet(__refs), _M_data(__cache)
      {
        (*this)._M_initialize_numpunct();
      }
      inline explicit numpunct(::std::__c_locale __cloc, ::std::size_t __refs  = (0))
        : facet(__refs), _M_data(0)
      {
        (*this)._M_initialize_numpunct(__cloc);
      }
      inline typename ::std::numpunct<_CharT>::char_type decimal_point() const 
      {
        return this->do_decimal_point();
      }
      inline typename ::std::numpunct<_CharT>::char_type thousands_sep() const 
      {
        return this->do_thousands_sep();
      }
      inline ::std::string grouping() const 
      {
        return this->do_grouping();
      }
      inline typename ::std::numpunct<_CharT>::string_type truename() const 
      {
        return this->do_truename();
      }
      inline typename ::std::numpunct<_CharT>::string_type falsename() const 
      {
        return this->do_falsename();
      }
    protected:
      virtual ~numpunct();
      inline virtual typename ::std::numpunct<_CharT>::char_type do_decimal_point() const 
      {
        return ::std::numpunct<_CharT>::_M_data->_M_decimal_point;
      }
      inline virtual typename ::std::numpunct<_CharT>::char_type do_thousands_sep() const 
      {
        return ::std::numpunct<_CharT>::_M_data->_M_thousands_sep;
      }
      inline virtual ::std::string do_grouping() const 
      {
        return ::std::numpunct<_CharT>::_M_data->_M_grouping;
      }
      inline virtual typename ::std::numpunct<_CharT>::string_type do_truename() const 
      {
        return ::std::numpunct<_CharT>::_M_data->_M_truename;
      }
      inline virtual typename ::std::numpunct<_CharT>::string_type do_falsename() const 
      {
        return ::std::numpunct<_CharT>::_M_data->_M_falsename;
      }
      void _M_initialize_numpunct(::std::__c_locale __cloc  = (0));
  };
  template < typename _CharT >
  ::std::locale::id numpunct<_CharT>::id;
 /* Instantiation of class template '::std::numpunct<char>' */ 
  template <>
  numpunct<char>::~numpunct();
  template <>
  void numpunct<char>::_M_initialize_numpunct(::__locale_struct *__cloc);
 /* Instantiation of class template '::std::numpunct<wchar_t>' */ 
  template <>
  numpunct<wchar_t>::~numpunct();
  template <>
  void numpunct<wchar_t>::_M_initialize_numpunct(::__locale_struct *__cloc);
  template < typename _CharT >
  class  numpunct_byname : public ::std::numpunct<_CharT>
  {
    public:
      typedef _CharT char_type;
      typedef ::std::basic_string<_CharT> string_type;
      inline explicit numpunct_byname(const char *__s, ::std::size_t __refs  = (0))
        : numpunct<_CharT>(__refs)
      {
        if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0)
          {
            ::std::__c_locale __tmp;
            this->_S_create_c_locale(__tmp, __s);
            this->_M_initialize_numpunct(__tmp);
            this->_S_destroy_c_locale(__tmp);
          }
      }
    protected:
      inline virtual ~numpunct_byname()
      {
      }
  };
  template < typename _CharT, typename _InIter >
  class  num_get : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      static ::std::locale::id id;
      inline explicit num_get(::std::size_t __refs  = (0))
        : facet(__refs)
      {
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, bool &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned short int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, float &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, double &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, void *&__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
    protected:
      inline virtual ~num_get()
      {
      }
      typename ::std::num_get<_CharT, _InIter>::iter_type _M_extract_float(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::std::string &__xtrc) const ;
      template < typename _ValueT >
      typename ::std::num_get<_CharT, _InIter>::iter_type _M_extract_int(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, _ValueT &__v) const ;
      template < typename _CharT2 >
      inline typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, ::std::size_t __len, _CharT2 __c) const 
      {
        int __ret( -1);
        if (__len <= 10)
          {
            if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
              {
                __ret = __c - _CharT2('0');
              }
          }
        else
          {
            if (__c >= _CharT2('0') && __c <= _CharT2('9'))
              {
                __ret = __c - _CharT2('0');
              }
            else
              {
                if (__c >= _CharT2('a') && __c <= _CharT2('f'))
                  {
                    __ret = 10 + (__c - _CharT2('a'));
                  }
                else
                  {
                    if (__c >= _CharT2('A') && __c <= _CharT2('F'))
                      {
                        __ret = 10 + (__c - _CharT2('A'));
                      }
                  }
              }
          }
        return __ret;
      }
      template < typename _CharT2 >
      inline typename ::__gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, ::std::size_t __len, _CharT2 __c) const 
      {
        int __ret( -1);
        const typename ::std::num_get<_CharT, _InIter>::char_type *__q = char_traits<_CharT2>::find(__zero, __len, __c);
        if (__q)
          {
            __ret = __q - __zero;
            if (__ret > 15)
              {
                __ret -= 6;
              }
          }
        return __ret;
      }
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, bool &__v) const ;
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned short int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long long int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long long int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, float &__v) const ;
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, double &__v) const ;
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__v) const ;
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, void *&__v) const ;
  };
  template < typename _CharT, typename _InIter >
  ::std::locale::id num_get<_CharT, _InIter>::id;
  template < typename _CharT, typename _OutIter >
  class  num_put : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      static ::std::locale::id id;
      inline explicit num_put(::std::size_t __refs  = (0))
        : facet(__refs)
      {
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, bool __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, double __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long double __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, const void *__v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
    protected:
      template < typename _ValueT >
      typename ::std::num_put<_CharT, _OutIter>::iter_type _M_insert_float(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, char __mod, _ValueT __v) const ;
      void _M_group_float(const char *__grouping, ::std::size_t __grouping_size, typename ::std::num_put<_CharT, _OutIter>::char_type __sep, const typename ::std::num_put<_CharT, _OutIter>::char_type *__p, typename ::std::num_put<_CharT, _OutIter>::char_type *__new, typename ::std::num_put<_CharT, _OutIter>::char_type *__cs, int &__len) const ;
      template < typename _ValueT >
      typename ::std::num_put<_CharT, _OutIter>::iter_type _M_insert_int(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, _ValueT __v) const ;
      void _M_group_int(const char *__grouping, ::std::size_t __grouping_size, typename ::std::num_put<_CharT, _OutIter>::char_type __sep, ::std::ios_base &, typename ::std::num_put<_CharT, _OutIter>::char_type *__new, typename ::std::num_put<_CharT, _OutIter>::char_type *__cs, int &__len) const ;
      void _M_pad(typename ::std::num_put<_CharT, _OutIter>::char_type __fill, ::std::streamsize __w, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type *__new, const typename ::std::num_put<_CharT, _OutIter>::char_type *__cs, int &__len) const ;
      inline virtual ~num_put()
      {
      }
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, bool __v) const ;
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long int __v) const 
      {
        return (*this)._M_insert_int(__s, __io, __fill, __v);
      }
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long int __v) const 
      {
        return (*this)._M_insert_int(__s, __io, __fill, __v);
      }
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long long int __v) const 
      {
        return (*this)._M_insert_int(__s, __io, __fill, __v);
      }
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long long int __v) const 
      {
        return (*this)._M_insert_int(__s, __io, __fill, __v);
      }
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, double __v) const ;
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long double __v) const ;
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, const void *__v) const ;
  };
  template < typename _CharT, typename _OutIter >
  ::std::locale::id num_put<_CharT, _OutIter>::id;
  template < typename _CharT >
  inline bool isspace(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::space, __c);
  }
  template < typename _CharT >
  inline bool isprint(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::print, __c);
  }
  template < typename _CharT >
  inline bool iscntrl(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::cntrl, __c);
  }
  template < typename _CharT >
  inline bool isupper(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::upper, __c);
  }
  template < typename _CharT >
  inline bool islower(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::lower, __c);
  }
  template < typename _CharT >
  inline bool isalpha(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::alpha, __c);
  }
  template < typename _CharT >
  inline bool isdigit(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::digit, __c);
  }
  template < typename _CharT >
  inline bool ispunct(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::punct, __c);
  }
  template < typename _CharT >
  inline bool isxdigit(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::xdigit, __c);
  }
  template < typename _CharT >
  inline bool isalnum(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::alnum, __c);
  }
  template < typename _CharT >
  inline bool isgraph(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::graph, __c);
  }
  template < typename _CharT >
  inline _CharT toupper(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).toupper(__c);
  }
  template < typename _CharT >
  inline _CharT tolower(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).tolower(__c);
  }
  template < typename _Facet >
  struct  __use_cache
  {
      const _Facet *operator ()(const ::std::locale &__loc) const ;
  };
  template < typename _CharT >
  struct  __use_cache< ::std::__numpunct_cache<_CharT> >
  {
      inline const ::std::__numpunct_cache<_CharT> *operator ()(const ::std::locale &__loc) const 
      {
        const ::std::size_t __i = numpunct<_CharT>::id._M_id();
        const ::std::locale::facet **__caches((*__loc._M_impl)._M_caches);
        if (!__caches[__i])
          {
            ::std::__numpunct_cache<_CharT> *__tmp = 0;
            try
            {
              __tmp = (new ::std::__numpunct_cache<_CharT>());
              __tmp->_M_cache(__loc);
            }
            catch (...)
            {
              delete __tmp;
              throw;
            }
            (*__loc._M_impl)._M_install_cache(__tmp, __i);
          }
        return static_cast<const ::std::__numpunct_cache<_CharT> *>(__caches[__i]);
      }
  };
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<char>, ::__gnu_cxx::__numeric_traits_floating<char> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<char>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<char>' */ 
  template < typename _CharT >
  void __numpunct_cache<_CharT>::_M_cache(const ::std::locale &__loc)
  {
    ::std::__numpunct_cache<_CharT>::_M_allocated = true;
    const ::std::numpunct<_CharT> &__np = use_facet< ::std::numpunct<_CharT> >(__loc);
    char *__grouping(0);
    _CharT *__truename = 0;
    _CharT *__falsename = 0;
    try
    {
      ::std::__numpunct_cache<_CharT>::_M_grouping_size = __np.grouping().size();
      __grouping = (new char [::std::__numpunct_cache<_CharT>::_M_grouping_size]);
      __np.grouping().copy(__grouping, ::std::__numpunct_cache<_CharT>::_M_grouping_size);
      ::std::__numpunct_cache<_CharT>::_M_grouping = __grouping;
      ::std::__numpunct_cache<_CharT>::_M_use_grouping = (::std::__numpunct_cache<_CharT>::_M_grouping_size && static_cast<signed char>(::std::__numpunct_cache<_CharT>::_M_grouping[0]) > 0) && ::std::__numpunct_cache<_CharT>::_M_grouping[0] != ::__gnu_cxx::__numeric_traits_integer<char>::__max;
      ::std::__numpunct_cache<_CharT>::_M_truename_size = __np.truename().size();
      __truename = (new _CharT [::std::__numpunct_cache<_CharT>::_M_truename_size]);
      __np.truename().copy(__truename, ::std::__numpunct_cache<_CharT>::_M_truename_size);
      ::std::__numpunct_cache<_CharT>::_M_truename = __truename;
      ::std::__numpunct_cache<_CharT>::_M_falsename_size = __np.falsename().size();
      __falsename = (new _CharT [::std::__numpunct_cache<_CharT>::_M_falsename_size]);
      __np.falsename().copy(__falsename, ::std::__numpunct_cache<_CharT>::_M_falsename_size);
      ::std::__numpunct_cache<_CharT>::_M_falsename = __falsename;
      ::std::__numpunct_cache<_CharT>::_M_decimal_point = __np.decimal_point();
      ::std::__numpunct_cache<_CharT>::_M_thousands_sep = __np.thousands_sep();
      const ::std::ctype<_CharT> &__ct = use_facet< ::std::ctype<_CharT> >(__loc);
      __ct.widen(::std::__num_base::_S_atoms_out, ::std::__num_base::_S_atoms_out + ::std::__num_base::_S_oend, ::std::__numpunct_cache<_CharT>::_M_atoms_out);
      __ct.widen(::std::__num_base::_S_atoms_in, ::std::__num_base::_S_atoms_in + ::std::__num_base::_S_iend, ::std::__numpunct_cache<_CharT>::_M_atoms_in);
    }
    catch (...)
    {
      delete[] __grouping;
      delete[] __truename;
      delete[] __falsename;
      throw;
    }
  }
  bool __verify_grouping(const char *__grouping, ::std::size_t __grouping_size, const ::std::string &__grouping_tmp) throw() __attribute__((__pure__));
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::_M_extract_float(_InIter __beg, _InIter __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::std::string &__xtrc) const 
  {
    typedef ::std::char_traits<_CharT> __traits_type;
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_in;
    typename ::std::num_get<_CharT, _InIter>::char_type __c = ((typename ::std::num_get<_CharT, _InIter>::char_type()));
    bool __testeof = __beg == __end;
    if (!__testeof)
      {
        __c = *__beg;
        const bool __plus = __c == __lit[::std::__num_base::_S_iplus];
        if (((__plus || __c == __lit[::std::__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)) && !(__c == __lc->_M_decimal_point))
          {
            __xtrc += __plus ? '+' : '-';
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    bool __found_mantissa(false);
    int __sep_pos(0);
    while (!__testeof)
      {
        if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
          {
            break;
          }
        else
          {
            if (__c == __lit[::std::__num_base::_S_izero])
              {
                if (!__found_mantissa)
                  {
                    __xtrc += '0';
                    __found_mantissa = true;
                  }
                 ++__sep_pos;
                if ( ++__beg != __end)
                  {
                    __c = *__beg;
                  }
                else
                  {
                    __testeof = true;
                  }
              }
            else
              {
                break;
              }
          }
      }
    bool __found_dec(false);
    bool __found_sci(false);
    ::std::string __found_grouping /* () */ ;
    if (__lc->_M_use_grouping)
      {
        __found_grouping.::std::basic_string<char>::reserve(32);
      }
    const typename ::std::num_get<_CharT, _InIter>::char_type *__lit_zero = __lit + ::std::__num_base::_S_izero;
    if (!__lc->_M_allocated)
      {
        while (!__testeof)
          {
            const int __digit = (*this)._M_find(__lit_zero, 10, __c);
            if (__digit !=  -1)
              {
                __xtrc += '0' + __digit;
                __found_mantissa = true;
              }
            else
              {
                if ((__c == __lc->_M_decimal_point && !__found_dec) && !__found_sci)
                  {
                    __xtrc += '.';
                    __found_dec = true;
                  }
                else
                  {
                    if (((__c == __lit[::std::__num_base::_S_ie] || __c == __lit[::std::__num_base::_S_iE]) && !__found_sci) && __found_mantissa)
                      {
                        __xtrc += 'e';
                        __found_sci = true;
                        if ( ++__beg != __end)
                          {
                            __c = *__beg;
                            const bool __plus = __c == __lit[::std::__num_base::_S_iplus];
                            if (__plus || __c == __lit[::std::__num_base::_S_iminus])
                              {
                                __xtrc += __plus ? '+' : '-';
                              }
                            else
                              {
                                continue;
                              }
                          }
                        else
                          {
                            __testeof = true;
                            break;
                          }
                      }
                    else
                      {
                        break;
                      }
                  }
              }
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    else
      {
        while (!__testeof)
          {
            if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
              {
                if (!__found_dec && !__found_sci)
                  {
                    if (__sep_pos)
                      {
                        __found_grouping += static_cast<char>(__sep_pos);
                        __sep_pos = 0;
                      }
                    else
                      {
                        __xtrc.::std::basic_string<char>::clear();
                        break;
                      }
                  }
                else
                  {
                    break;
                  }
              }
            else
              {
                if (__c == __lc->_M_decimal_point)
                  {
                    if (!__found_dec && !__found_sci)
                      {
                        if (__found_grouping.::std::basic_string<char>::size())
                          {
                            __found_grouping += static_cast<char>(__sep_pos);
                          }
                        __xtrc += '.';
                        __found_dec = true;
                      }
                    else
                      {
                        break;
                      }
                  }
                else
                  {
                    const typename ::std::num_get<_CharT, _InIter>::char_type *__q = __traits_type::find(__lit_zero, 10, __c);
                    if (__q)
                      {
                        __xtrc += '0' + (__q - __lit_zero);
                        __found_mantissa = true;
                         ++__sep_pos;
                      }
                    else
                      {
                        if (((__c == __lit[::std::__num_base::_S_ie] || __c == __lit[::std::__num_base::_S_iE]) && !__found_sci) && __found_mantissa)
                          {
                            if (__found_grouping.::std::basic_string<char>::size() && !__found_dec)
                              {
                                __found_grouping += static_cast<char>(__sep_pos);
                              }
                            __xtrc += 'e';
                            __found_sci = true;
                            if ( ++__beg != __end)
                              {
                                __c = *__beg;
                                const bool __plus = __c == __lit[::std::__num_base::_S_iplus];
                                if (((__plus || __c == __lit[::std::__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)) && !(__c == __lc->_M_decimal_point))
                                  {
                                    __xtrc += __plus ? '+' : '-';
                                  }
                                else
                                  {
                                    continue;
                                  }
                              }
                            else
                              {
                                __testeof = true;
                                break;
                              }
                          }
                        else
                          {
                            break;
                          }
                      }
                  }
              }
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    if (__found_grouping.::std::basic_string<char>::size())
      {
        if (!__found_dec && !__found_sci)
          {
            __found_grouping += static_cast<char>(__sep_pos);
          }
        if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
          {
            __err = ::std::ios_base::failbit;
          }
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  template < typename _ValueT >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::_M_extract_int(_InIter __beg, _InIter __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, _ValueT &__v) const 
  {
    typedef ::std::char_traits<_CharT> __traits_type;
    using ::__gnu_cxx::__add_unsigned;
    typedef typename ::__gnu_cxx::__add_unsigned<_ValueT>::__type __unsigned_type;
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_in;
    typename ::std::num_get<_CharT, _InIter>::char_type __c = ((typename ::std::num_get<_CharT, _InIter>::char_type()));
    const ::std::ios_base::fmtflags __basefield(__io.::std::ios_base::flags() & ::std::ios_base::basefield);
    const bool __oct(__basefield == ::std::ios_base::oct);
    int __base(__oct ? 8 : __basefield == ::std::ios_base::hex ? 16 : 10);
    bool __testeof = __beg == __end;
    bool __negative(false);
    if (!__testeof)
      {
        __c = *__beg;
        __negative = __c == __lit[::std::__num_base::_S_iminus];
        if (((__negative || __c == __lit[::std::__num_base::_S_iplus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)) && !(__c == __lc->_M_decimal_point))
          {
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    bool __found_zero(false);
    int __sep_pos(0);
    while (!__testeof)
      {
        if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
          {
            break;
          }
        else
          {
            if (__c == __lit[::std::__num_base::_S_izero] && (!__found_zero || __base == 10))
              {
                __found_zero = true;
                 ++__sep_pos;
                if (__basefield == 0)
                  {
                    __base = 8;
                  }
                if (__base == 8)
                  {
                    __sep_pos = 0;
                  }
              }
            else
              {
                if (__found_zero && (__c == __lit[::std::__num_base::_S_ix] || __c == __lit[::std::__num_base::_S_iX]))
                  {
                    if (__basefield == 0)
                      {
                        __base = 16;
                      }
                    if (__base == 16)
                      {
                        __found_zero = false;
                        __sep_pos = 0;
                      }
                    else
                      {
                        break;
                      }
                  }
                else
                  {
                    break;
                  }
              }
          }
        if ( ++__beg != __end)
          {
            __c = *__beg;
            if (!__found_zero)
              {
                break;
              }
          }
        else
          {
            __testeof = true;
          }
      }
    const ::std::size_t __len(__base == 16 ? ::std::__num_base::_S_iend - ::std::__num_base::_S_izero : __base);
    ::std::string __found_grouping /* () */ ;
    if (__lc->_M_use_grouping)
      {
        __found_grouping.::std::basic_string<char>::reserve(32);
      }
    bool __testfail(false);
    bool __testoverflow(false);
    const __unsigned_type __max = __negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed ?  -__gnu_cxx::__numeric_traits<_ValueT>::__min : __gnu_cxx::__numeric_traits<_ValueT>::__max;
    const __unsigned_type __smax = __max / __base;
    __unsigned_type __result = 0;
    int __digit(0);
    const typename ::std::num_get<_CharT, _InIter>::char_type *__lit_zero = __lit + ::std::__num_base::_S_izero;
    if (!__lc->_M_allocated)
      {
        while (!__testeof)
          {
            __digit = (*this)._M_find(__lit_zero, __len, __c);
            if (__digit ==  -1)
              {
                break;
              }
            if (__result > __smax)
              {
                __testoverflow = true;
              }
            else
              {
                __result *= __base;
                __testoverflow |= __result > __max - __digit;
                __result += __digit;
                 ++__sep_pos;
              }
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    else
      {
        while (!__testeof)
          {
            if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
              {
                if (__sep_pos)
                  {
                    __found_grouping += static_cast<char>(__sep_pos);
                    __sep_pos = 0;
                  }
                else
                  {
                    __testfail = true;
                    break;
                  }
              }
            else
              {
                if (__c == __lc->_M_decimal_point)
                  {
                    break;
                  }
                else
                  {
                    const typename ::std::num_get<_CharT, _InIter>::char_type *__q = __traits_type::find(__lit_zero, __len, __c);
                    if (!__q)
                      {
                        break;
                      }
                    __digit = __q - __lit_zero;
                    if (__digit > 15)
                      {
                        __digit -= 6;
                      }
                    if (__result > __smax)
                      {
                        __testoverflow = true;
                      }
                    else
                      {
                        __result *= __base;
                        __testoverflow |= __result > __max - __digit;
                        __result += __digit;
                         ++__sep_pos;
                      }
                  }
              }
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    if (__found_grouping.::std::basic_string<char>::size())
      {
        __found_grouping += static_cast<char>(__sep_pos);
        if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
          {
            __err = ::std::ios_base::failbit;
          }
      }
    if (((!__sep_pos && !__found_zero) && !__found_grouping.::std::basic_string<char>::size()) || __testfail)
      {
        __v = 0;
        __err = ::std::ios_base::failbit;
      }
    else
      {
        if (__testoverflow)
          {
            if (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
              {
                __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
              }
            else
              {
                __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
              }
            __err = ::std::ios_base::failbit;
          }
        else
          {
            __v = __negative ?  -__result : __result;
          }
      }
    if (__testeof)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, bool &__v) const 
  {
    if (!(__io.::std::ios_base::flags() & ::std::ios_base::boolalpha))
      {
        long int __l( -1);
        __beg = (*this)._M_extract_int(__beg, __end, __io, __err, __l);
        if (__l == 0 || __l == 1)
          {
            __v = (bool)__l;
          }
        else
          {
            __v = true;
            __err = ::std::ios_base::failbit;
            if (__beg == __end)
              {
                __err |= ::std::ios_base::eofbit;
              }
          }
      }
    else
      {
        typedef ::std::__numpunct_cache<_CharT> __cache_type;
        ::std::__use_cache<__cache_type> __uc;
        const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
        const __cache_type *__lc = __uc(__loc);
        bool __testf(true);
        bool __testt(true);
        bool __donef = __lc->_M_falsename_size == 0;
        bool __donet = __lc->_M_truename_size == 0;
        bool __testeof(false);
        ::std::size_t __n(0);
        while (!__donef || !__donet)
          {
            if (__beg == __end)
              {
                __testeof = true;
                break;
              }
            const typename ::std::num_get<_CharT, _InIter>::char_type __c = *__beg;
            if (!__donef)
              {
                __testf = __c == __lc->_M_falsename[__n];
              }
            if (!__testf && __donet)
              {
                break;
              }
            if (!__donet)
              {
                __testt = __c == __lc->_M_truename[__n];
              }
            if (!__testt && __donef)
              {
                break;
              }
            if (!__testt && !__testf)
              {
                break;
              }
             ++__n;
             ++__beg;
            __donef = !__testf || __n >= __lc->_M_falsename_size;
            __donet = !__testt || __n >= __lc->_M_truename_size;
          }
        if ((__testf && __n == __lc->_M_falsename_size) && __n)
          {
            __v = false;
            if (__testt && __n == __lc->_M_truename_size)
              {
                __err = ::std::ios_base::failbit;
              }
            else
              {
                __err = __testeof ? ::std::ios_base::eofbit : ::std::ios_base::goodbit;
              }
          }
        else
          {
            if ((__testt && __n == __lc->_M_truename_size) && __n)
              {
                __v = true;
                __err = __testeof ? ::std::ios_base::eofbit : ::std::ios_base::goodbit;
              }
            else
              {
                __v = false;
                __err = ::std::ios_base::failbit;
                if (__testeof)
                  {
                    __err |= ::std::ios_base::eofbit;
                  }
              }
          }
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, float &__v) const 
  {
    ::std::string __xtrc /* () */ ;
    __xtrc.::std::basic_string<char>::reserve(32);
    __beg = (*this)._M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.::std::basic_string<char>::c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, double &__v) const 
  {
    ::std::string __xtrc /* () */ ;
    __xtrc.::std::basic_string<char>::reserve(32);
    __beg = (*this)._M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.::std::basic_string<char>::c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__v) const 
  {
    ::std::string __xtrc /* () */ ;
    __xtrc.::std::basic_string<char>::reserve(32);
    __beg = (*this)._M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.::std::basic_string<char>::c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, unsigned long int, unsigned long long int>' */ 
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, void *&__v) const 
  {
    typedef ::std::ios_base::fmtflags fmtflags;
    const fmtflags __fmt(__io.::std::ios_base::flags());
    __io.::std::ios_base::flags(__fmt &  ~::std::ios_base::basefield | ::std::ios_base::hex);
    typedef ::__gnu_cxx::__conditional_type<true, unsigned long int, unsigned long long int>::__type _UIntPtrType;
    _UIntPtrType __ul;
    __beg = (*this)._M_extract_int(__beg, __end, __io, __err, __ul);
    __io.::std::ios_base::flags(__fmt);
    __v = reinterpret_cast<void *>(__ul);
    return __beg;
  }
  template < typename _CharT, typename _OutIter >
  void num_put<_CharT, _OutIter>::_M_pad(_CharT __fill, ::std::streamsize __w, ::std::ios_base &__io, _CharT *__new, const _CharT *__cs, int &__len) const 
  {
    __pad<_CharT, ::std::char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs, __w, __len);
    __len = static_cast<int>(__w);
  }
  template < typename _CharT, typename _ValueT >
  int __int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ::std::ios_base::fmtflags __flags, bool __dec);
  template < typename _CharT, typename _ValueT >
  int __int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ::std::ios_base::fmtflags __flags, bool __dec)
  {
    _CharT *__buf = __bufend;
    if (__builtin_expect(__dec, true))
      {
        do
          {
            * --__buf = __lit[__v % 10 + ::std::__num_base::_S_odigits];
            __v /= 10;
          }
        while (__v != 0);
      }
    else
      {
        if ((__flags & ::std::ios_base::basefield) == ::std::ios_base::oct)
          {
            do
              {
                * --__buf = __lit[(__v & 7) + ::std::__num_base::_S_odigits];
                __v >>= 3;
              }
            while (__v != 0);
          }
        else
          {
            const bool __uppercase(__flags & ::std::ios_base::uppercase);
            const int __case_offset(__uppercase ? ::std::__num_base::_S_oudigits : ::std::__num_base::_S_odigits);
            do
              {
                * --__buf = __lit[(__v & 15) + __case_offset];
                __v >>= 4;
              }
            while (__v != 0);
          }
      }
    return __bufend - __buf;
  }
  template < typename _CharT, typename _OutIter >
  void num_put<_CharT, _OutIter>::_M_group_int(const char *__grouping, ::std::size_t __grouping_size, _CharT __sep, ::std::ios_base &, _CharT *__new, _CharT *__cs, int &__len) const 
  {
    _CharT *__p = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __len);
    __len = __p - __new;
  }
  template < typename _CharT, typename _OutIter >
  template < typename _ValueT >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::_M_insert_int(_OutIter __s, ::std::ios_base &__io, _CharT __fill, _ValueT __v) const 
  {
    using ::__gnu_cxx::__add_unsigned;
    typedef typename ::__gnu_cxx::__add_unsigned<_ValueT>::__type __unsigned_type;
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_out;
    const ::std::ios_base::fmtflags __flags(__io.::std::ios_base::flags());
    const int __ilen = 5 * sizeof(_ValueT);
    _CharT *__cs = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __ilen));
    const ::std::ios_base::fmtflags __basefield(__flags & ::std::ios_base::basefield);
    const bool __dec(__basefield != ::std::ios_base::oct && __basefield != ::std::ios_base::hex);
    const __unsigned_type __u = __v > 0 || !__dec ? __unsigned_type(__v) :  -__unsigned_type(__v);
    int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
    __cs += __ilen - __len;
    if (__lc->_M_use_grouping)
      {
        _CharT *__cs2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * (__len + 1) * 2));
        (*this)._M_group_int(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
        __cs = __cs2 + 2;
      }
    if (__builtin_expect(__dec, true))
      {
        if (__v >= 0)
          {
            if ((bool)(__flags & ::std::ios_base::showpos) && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
              {
                (* --__cs = __lit[::std::__num_base::_S_oplus],  ++__len);
              }
          }
        else
          {
            (* --__cs = __lit[::std::__num_base::_S_ominus],  ++__len);
          }
      }
    else
      {
        if ((bool)(__flags & ::std::ios_base::showbase) && __v)
          {
            if (__basefield == ::std::ios_base::oct)
              {
                (* --__cs = __lit[::std::__num_base::_S_odigits],  ++__len);
              }
            else
              {
                const bool __uppercase(__flags & ::std::ios_base::uppercase);
                * --__cs = __lit[::std::__num_base::_S_ox + __uppercase];
                * --__cs = __lit[::std::__num_base::_S_odigits];
                __len += 2;
              }
          }
      }
    const ::std::streamsize __w(__io.::std::ios_base::width());
    if (__w > static_cast< ::std::streamsize>(__len))
      {
        _CharT *__cs3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
        (*this)._M_pad(__fill, __w, __io, __cs3, __cs, __len);
        __cs = __cs3;
      }
    __io.::std::ios_base::width(0);
    return std::__write(__s, __cs, __len);
  }
  template < typename _CharT, typename _OutIter >
  void num_put<_CharT, _OutIter>::_M_group_float(const char *__grouping, ::std::size_t __grouping_size, _CharT __sep, const _CharT *__p, _CharT *__new, _CharT *__cs, int &__len) const 
  {
    const int __declen = __p ? __p - __cs : __len;
    _CharT *__p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __declen);
    int __newlen = __p2 - __new;
    if (__p)
      {
        char_traits<_CharT>::copy(__p2, __p, __len - __declen);
        __newlen += __len - __declen;
      }
    __len = __newlen;
  }
  template < typename _CharT, typename _OutIter >
  template < typename _ValueT >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::_M_insert_float(_OutIter __s, ::std::ios_base &__io, _CharT __fill, char __mod, _ValueT __v) const 
  {
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const ::std::streamsize __prec(__io.::std::ios_base::precision() < 0 ? 6 : __io.::std::ios_base::precision());
    const int __max_digits = __gnu_cxx::__numeric_traits<_ValueT>::__digits10;
    int __len;
    char __fbuf[16L];
    __num_base::_S_format_float(__io, __fbuf, __mod);
    int __cs_size = __max_digits * 3;
    char *__cs(static_cast<char *>(__builtin_alloca(__cs_size)));
    __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
    if (__len >= __cs_size)
      {
        __cs_size = __len + 1;
        __cs = static_cast<char *>(__builtin_alloca(__cs_size));
        __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
      }
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    _CharT *__ws = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len));
    __ctype.widen(__cs, __cs + __len, __ws);
    _CharT *__wp = 0;
    const char *__p = char_traits<char>::find(__cs, __len, '.');
    if (__p)
      {
        __wp = __ws + (__p - __cs);
        *__wp = __lc->_M_decimal_point;
      }
    if (__lc->_M_use_grouping && ((__wp || __len < 3) || (((__cs[1] <= '9' && __cs[2] <= '9') && __cs[1] >= '0') && __cs[2] >= '0')))
      {
        _CharT *__ws2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len * 2));
        ::std::streamsize __off(0);
        if (__cs[0] == '-' || __cs[0] == '+')
          {
            __off = 1;
            __ws2[0] = __ws[0];
            __len -= 1;
          }
        (*this)._M_group_float(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __wp, __ws2 + __off, __ws + __off, __len);
        __len += __off;
        __ws = __ws2;
      }
    const ::std::streamsize __w(__io.::std::ios_base::width());
    if (__w > static_cast< ::std::streamsize>(__len))
      {
        _CharT *__ws3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
        (*this)._M_pad(__fill, __w, __io, __ws3, __ws, __len);
        __ws = __ws3;
      }
    __io.::std::ios_base::width(0);
    return std::__write(__s, __ws, __len);
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, bool __v) const 
  {
    const ::std::ios_base::fmtflags __flags(__io.::std::ios_base::flags());
    if ((__flags & ::std::ios_base::boolalpha) == 0)
      {
        const long int __l(__v);
        __s = (*this)._M_insert_int(__s, __io, __fill, __l);
      }
    else
      {
        typedef ::std::__numpunct_cache<_CharT> __cache_type;
        ::std::__use_cache<__cache_type> __uc;
        const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__name = __v ? __lc->_M_truename : __lc->_M_falsename;
        int __len = __v ? __lc->_M_truename_size : __lc->_M_falsename_size;
        const ::std::streamsize __w(__io.::std::ios_base::width());
        if (__w > static_cast< ::std::streamsize>(__len))
          {
            const ::std::streamsize __plen = __w - __len;
            _CharT *__ps = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __plen));
            char_traits<_CharT>::assign(__ps, __plen, __fill);
            __io.::std::ios_base::width(0);
            if ((__flags & ::std::ios_base::adjustfield) == ::std::ios_base::left)
              {
                __s = std::__write(__s, __name, __len);
                __s = std::__write(__s, __ps, __plen);
              }
            else
              {
                __s = std::__write(__s, __ps, __plen);
                __s = std::__write(__s, __name, __len);
              }
            return __s;
          }
        __io.::std::ios_base::width(0);
        __s = std::__write(__s, __name, __len);
      }
    return __s;
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, double __v) const 
  {
    return (*this)._M_insert_float(__s, __io, __fill, char(), __v);
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long double __v) const 
  {
    return (*this)._M_insert_float(__s, __io, __fill, 'L', __v);
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, const void *__v) const 
  {
    const ::std::ios_base::fmtflags __flags(__io.::std::ios_base::flags());
    const ::std::ios_base::fmtflags __fmt( ~(::std::ios_base::basefield | ::std::ios_base::uppercase));
    __io.::std::ios_base::flags(__flags & __fmt | (::std::ios_base::hex | ::std::ios_base::showbase));
    typedef ::__gnu_cxx::__conditional_type<true, unsigned long int, unsigned long long int>::__type _UIntPtrType;
    __s = (*this)._M_insert_int(__s, __io, __fill, reinterpret_cast<_UIntPtrType>(__v));
    __io.::std::ios_base::flags(__flags);
    return __s;
  }
  template < typename _CharT, typename _Traits >
  void __pad<_CharT, _Traits>::_S_pad(::std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, ::std::streamsize __newlen, ::std::streamsize __oldlen)
  {
    const ::std::size_t __plen(static_cast< ::std::size_t>(__newlen - __oldlen));
    const ::std::ios_base::fmtflags __adjust(__io.::std::ios_base::flags() & ::std::ios_base::adjustfield);
    if (__adjust == ::std::ios_base::left)
      {
        _Traits::copy(__news, __olds, __oldlen);
        _Traits::assign(__news + __oldlen, __plen, __fill);
        return ;
      }
    ::std::size_t __mod(0);
    if (__adjust == ::std::ios_base::internal)
      {
        const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
        const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
        if (__ctype.widen('-') == __olds[0] || __ctype.widen('+') == __olds[0])
          {
            __news[0] = __olds[0];
            __mod = 1;
             ++__news;
          }
        else
          {
            if ((__ctype.widen('0') == __olds[0] && __oldlen > 1) && (__ctype.widen('x') == __olds[1] || __ctype.widen('X') == __olds[1]))
              {
                __news[0] = __olds[0];
                __news[1] = __olds[1];
                __mod = 2;
                __news += 2;
              }
          }
      }
    _Traits::assign(__news, __plen, __fill);
    _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
  }
  template < typename _CharT >
  _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, ::std::size_t __gsize, const _CharT *__first, const _CharT *__last)
  {
    ::std::size_t __idx(0);
    ::std::size_t __ctr(0);
    while ((__last - __first > __gbeg[__idx] && static_cast<signed char>(__gbeg[__idx]) > 0) && __gbeg[__idx] != ::__gnu_cxx::__numeric_traits_integer<char>::__max)
      {
        __last -= __gbeg[__idx];
        __idx < __gsize - 1 ?  ++__idx :  ++__ctr;
      }
    while (__first != __last)
      {
        *__s++ = *__first++;
      }
    while (__ctr--)
      {
        *__s++ = __sep;
        for (char __i(__gbeg[__idx]); __i > 0;  --__i)
          {
            *__s++ = *__first++;
          }
      }
    while (__idx--)
      {
        *__s++ = __sep;
        for (char __i(__gbeg[__idx]); __i > 0;  --__i)
          {
            *__s++ = *__first++;
          }
      }
    return __s;
  }
  extern template class ::std::numpunct<char>;
  extern template class ::std::numpunct_byname<char>;
  extern template class ::std::num_get<char>;
  extern template class ::std::num_put<char>;
  extern template class ::std::ctype_byname<char>;
  extern template const ::std::ctype<char> &use_facet< ::std::ctype<char> >(const ::std::locale &);
  extern template const ::std::numpunct<char> &use_facet< ::std::numpunct<char> >(const ::std::locale &);
  extern template const ::std::num_put<char> &use_facet< ::std::num_put<char> >(const ::std::locale &);
  extern template const ::std::num_get<char> &use_facet< ::std::num_get<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::ctype<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::numpunct<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::num_put<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::num_get<char> >(const ::std::locale &);
  extern template class ::std::numpunct<wchar_t>;
  extern template class ::std::numpunct_byname<wchar_t>;
  extern template class ::std::num_get<wchar_t>;
  extern template class ::std::num_put<wchar_t>;
  extern template class ::std::ctype_byname<wchar_t>;
  extern template const ::std::ctype<wchar_t> &use_facet< ::std::ctype<wchar_t> >(const ::std::locale &);
  extern template const ::std::numpunct<wchar_t> &use_facet< ::std::numpunct<wchar_t> >(const ::std::locale &);
  extern template const ::std::num_put<wchar_t> &use_facet< ::std::num_put<wchar_t> >(const ::std::locale &);
  extern template const ::std::num_get<wchar_t> &use_facet< ::std::num_get<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::ctype<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::numpunct<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::num_put<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::num_get<wchar_t> >(const ::std::locale &);
  template < typename _Facet >
  inline const _Facet &__check_facet(const _Facet *__f);
  template < typename _Facet >
  inline const _Facet &__check_facet(const _Facet *__f)
  {
    if (!__f)
      {
        ::std::__throw_bad_cast();
      }
    return *__f;
  }
  template < typename _CharT, typename _Traits >
  class  basic_ios : public ::std::ios_base
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::ctype<_CharT> __ctype_type;
      typedef ::std::num_put<_CharT, ::std::ostreambuf_iterator<_CharT, _Traits> > __num_put_type;
      typedef ::std::num_get<_CharT, ::std::istreambuf_iterator<_CharT, _Traits> > __num_get_type;
    protected:
      ::std::basic_ostream<_CharT, _Traits> *_M_tie;
      mutable typename ::std::basic_ios<_CharT, _Traits>::char_type _M_fill;
      mutable bool _M_fill_init;
      ::std::basic_streambuf<_CharT, _Traits> *_M_streambuf;
      const typename ::std::basic_ios<_CharT, _Traits>::__ctype_type *_M_ctype;
      const typename ::std::basic_ios<_CharT, _Traits>::__num_put_type *_M_num_put;
      const typename ::std::basic_ios<_CharT, _Traits>::__num_get_type *_M_num_get;
    public:
      inline operator void *() const 
      {
        return this->fail() ? 0 : const_cast< ::std::basic_ios<_CharT, _Traits> *>(this);
      }
      inline bool operator !() const 
      {
        return this->fail();
      }
      inline ::std::ios_base::iostate rdstate() const 
      {
        return (*this)._M_streambuf_state;
      }
      void clear(::std::ios_base::iostate __state  = (::std::ios_base::goodbit));
      inline void setstate(::std::ios_base::iostate __state)
      {
        this->clear(this->rdstate() | __state);
      }
      inline void _M_setstate(::std::ios_base::iostate __state)
      {
        (*this)._M_streambuf_state |= __state;
        if (this->exceptions() & __state)
          {
            throw;
          }
      }
      inline bool good() const 
      {
        return this->rdstate() == 0;
      }
      inline bool eof() const 
      {
        return (this->rdstate() & ::std::ios_base::eofbit) != 0;
      }
      inline bool fail() const 
      {
        return (this->rdstate() & (::std::ios_base::badbit | ::std::ios_base::failbit)) != 0;
      }
      inline bool bad() const 
      {
        return (this->rdstate() & ::std::ios_base::badbit) != 0;
      }
      inline ::std::ios_base::iostate exceptions() const 
      {
        return (*this)._M_exception;
      }
      inline void exceptions(::std::ios_base::iostate __except)
      {
        (*this)._M_exception = __except;
        this->clear((*this)._M_streambuf_state);
      }
      inline explicit basic_ios(::std::basic_streambuf<_CharT, _Traits> *__sb)
        : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      {
        this->init(__sb);
      }
      inline virtual ~basic_ios()
      {
      }
      inline ::std::basic_ostream<_CharT, _Traits> *tie() const 
      {
        return ::std::basic_ios<_CharT, _Traits>::_M_tie;
      }
      inline ::std::basic_ostream<_CharT, _Traits> *tie(::std::basic_ostream<_CharT, _Traits> *__tiestr)
      {
        ::std::basic_ostream<_CharT, _Traits> *__old = ::std::basic_ios<_CharT, _Traits>::_M_tie;
        ::std::basic_ios<_CharT, _Traits>::_M_tie = __tiestr;
        return __old;
      }
      inline ::std::basic_streambuf<_CharT, _Traits> *rdbuf() const 
      {
        return ::std::basic_ios<_CharT, _Traits>::_M_streambuf;
      }
      ::std::basic_streambuf<_CharT, _Traits> *rdbuf(::std::basic_streambuf<_CharT, _Traits> *__sb);
      ::std::basic_ios<_CharT, _Traits> &copyfmt(const ::std::basic_ios<_CharT, _Traits> &__rhs);
      inline typename ::std::basic_ios<_CharT, _Traits>::char_type fill() const 
      {
        if (!::std::basic_ios<_CharT, _Traits>::_M_fill_init)
          {
            ::std::basic_ios<_CharT, _Traits>::_M_fill = this->widen(' ');
            ::std::basic_ios<_CharT, _Traits>::_M_fill_init = true;
          }
        return ::std::basic_ios<_CharT, _Traits>::_M_fill;
      }
      inline typename ::std::basic_ios<_CharT, _Traits>::char_type fill(typename ::std::basic_ios<_CharT, _Traits>::char_type __ch)
      {
        typename ::std::basic_ios<_CharT, _Traits>::char_type __old = this->fill();
        ::std::basic_ios<_CharT, _Traits>::_M_fill = __ch;
        return __old;
      }
      ::std::locale imbue(const ::std::locale &__loc);
      inline char narrow(typename ::std::basic_ios<_CharT, _Traits>::char_type __c, char __dfault) const 
      {
        return __check_facet(::std::basic_ios<_CharT, _Traits>::_M_ctype).narrow(__c, __dfault);
      }
      inline typename ::std::basic_ios<_CharT, _Traits>::char_type widen(char __c) const 
      {
        return __check_facet(::std::basic_ios<_CharT, _Traits>::_M_ctype).widen(__c);
      }
    protected:
      inline basic_ios()
        : ios_base(), _M_tie(0), _M_fill(((typename ::std::basic_ios<_CharT, _Traits>::char_type()))), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      {
      }
      void init(::std::basic_streambuf<_CharT, _Traits> *__sb);
      void _M_cache_locale(const ::std::locale &__loc);
  };
  template < typename _CharT, typename _Traits >
  void basic_ios<_CharT, _Traits>::clear(::std::ios_base::iostate __state)
  {
    if (this->rdbuf())
      {
        (*this)._M_streambuf_state = __state;
      }
    else
      {
        (*this)._M_streambuf_state = __state | ::std::ios_base::badbit;
      }
    if (this->exceptions() & this->rdstate())
      {
        ::std::__throw_ios_failure("basic_ios::clear");
      }
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_streambuf<_CharT, _Traits> *basic_ios<_CharT, _Traits>::rdbuf(::std::basic_streambuf<_CharT, _Traits> *__sb)
  {
    ::std::basic_streambuf<_CharT, _Traits> *__old = ::std::basic_ios<_CharT, _Traits>::_M_streambuf;
    ::std::basic_ios<_CharT, _Traits>::_M_streambuf = __sb;
    this->clear();
    return __old;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ios<_CharT, _Traits> &basic_ios<_CharT, _Traits>::copyfmt(const ::std::basic_ios<_CharT, _Traits> &__rhs)
  {
    if (this != &__rhs)
      {
        ::std::ios_base::_Words *__words = __rhs._M_word_size <= ::std::ios_base::_S_local_word_size ? (*this)._M_local_word : new ::std::ios_base::_Words [__rhs._M_word_size];
        ::std::ios_base::_Callback_list *__cb = __rhs._M_callbacks;
        if (__cb)
          {
            (*__cb).::std::ios_base::_Callback_list::_M_add_reference();
          }
        (*this)._M_call_callbacks(::std::ios_base::erase_event);
        if ((*this)._M_word != (*this)._M_local_word)
          {
            delete[] (*this)._M_word;
            (*this)._M_word = 0;
          }
        (*this)._M_dispose_callbacks();
        (*this)._M_callbacks = __cb;
        for (int __i(0); __i < __rhs._M_word_size;  ++__i)
          {
            __words[__i] = __rhs._M_word[__i];
          }
        (*this)._M_word = __words;
        (*this)._M_word_size = __rhs._M_word_size;
        this->flags(__rhs.flags());
        this->width(__rhs.width());
        this->precision(__rhs.precision());
        this->tie(__rhs.tie());
        this->fill(__rhs.fill());
        (*this)._M_ios_locale = __rhs.getloc();
        (*this)._M_cache_locale((*this)._M_ios_locale);
        (*this)._M_call_callbacks(::std::ios_base::copyfmt_event);
        this->exceptions(__rhs.exceptions());
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::locale basic_ios<_CharT, _Traits>::imbue(const ::std::locale &__loc)
  {
    ::std::locale __old(this->getloc());
    ios_base::imbue(__loc);
    (*this)._M_cache_locale(__loc);
    if (this->rdbuf() != 0)
      {
        this->rdbuf()->pubimbue(__loc);
      }
    return __old;
  }
  template < typename _CharT, typename _Traits >
  void basic_ios<_CharT, _Traits>::init(::std::basic_streambuf<_CharT, _Traits> *__sb)
  {
    ios_base::_M_init();
    (*this)._M_cache_locale((*this)._M_ios_locale);
    ::std::basic_ios<_CharT, _Traits>::_M_fill = _CharT();
    ::std::basic_ios<_CharT, _Traits>::_M_fill_init = false;
    ::std::basic_ios<_CharT, _Traits>::_M_tie = 0;
    (*this)._M_exception = ::std::ios_base::goodbit;
    ::std::basic_ios<_CharT, _Traits>::_M_streambuf = __sb;
    (*this)._M_streambuf_state = __sb ? ::std::ios_base::goodbit : ::std::ios_base::badbit;
  }
  template < typename _CharT, typename _Traits >
  void basic_ios<_CharT, _Traits>::_M_cache_locale(const ::std::locale &__loc)
  {
    if (__builtin_expect(has_facet<typename ::std::basic_ios<_CharT, _Traits>::__ctype_type>(__loc), true))
      {
        ::std::basic_ios<_CharT, _Traits>::_M_ctype = &use_facet<typename ::std::basic_ios<_CharT, _Traits>::__ctype_type>(__loc);
      }
    else
      {
        ::std::basic_ios<_CharT, _Traits>::_M_ctype = 0;
      }
    if (__builtin_expect(has_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_put_type>(__loc), true))
      {
        ::std::basic_ios<_CharT, _Traits>::_M_num_put = &use_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_put_type>(__loc);
      }
    else
      {
        ::std::basic_ios<_CharT, _Traits>::_M_num_put = 0;
      }
    if (__builtin_expect(has_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_get_type>(__loc), true))
      {
        ::std::basic_ios<_CharT, _Traits>::_M_num_get = &use_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_get_type>(__loc);
      }
    else
      {
        ::std::basic_ios<_CharT, _Traits>::_M_num_get = 0;
      }
  }
  extern template class ::std::basic_ios<char>;
  extern template class ::std::basic_ios<wchar_t>;
  template < typename _CharT, typename _Traits >
  class  basic_ostream : virtual public ::std::basic_ios<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef ::std::basic_ios<_CharT, _Traits> __ios_type;
      typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef ::std::num_put<_CharT, ::std::ostreambuf_iterator<_CharT, _Traits> > __num_put_type;
      typedef ::std::ctype<_CharT> __ctype_type;
      inline explicit basic_ostream(typename ::std::basic_ostream<_CharT, _Traits>::__streambuf_type *__sb)
      {
        this->init(__sb);
      }
      inline virtual ~basic_ostream()
      {
      }
      class sentry;
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &(*__pf)(typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &))
      {
        return __pf(*this);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__ios_type &(*__pf)(typename ::std::basic_ostream<_CharT, _Traits>::__ios_type &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(::std::ios_base &(*__pf)(::std::ios_base &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(long int __n)
      {
        return (*this)._M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned long int __n)
      {
        return (*this)._M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(bool __n)
      {
        return (*this)._M_insert(__n);
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(short int __n);
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned short int __n)
      {
        return (*this)._M_insert(static_cast<unsigned long int>(__n));
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(int __n);
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned int __n)
      {
        return (*this)._M_insert(static_cast<unsigned long int>(__n));
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(long long int __n)
      {
        return (*this)._M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned long long int __n)
      {
        return (*this)._M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(double __f)
      {
        return (*this)._M_insert(__f);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(float __f)
      {
        return (*this)._M_insert(static_cast<double>(__f));
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(long double __f)
      {
        return (*this)._M_insert(__f);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(const void *__p)
      {
        return (*this)._M_insert(__p);
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__streambuf_type *__sbin);
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &put(typename ::std::basic_ostream<_CharT, _Traits>::char_type __c);
      inline void _M_write(const typename ::std::basic_ostream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        const ::std::streamsize __put = this->rdbuf()->sputn(__s, __n);
        if (__put != __n)
          {
            this->setstate(::std::ios_base::badbit);
          }
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &write(const typename ::std::basic_ostream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &flush();
      typename ::std::basic_ostream<_CharT, _Traits>::pos_type tellp();
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &seekp(typename ::std::basic_ostream<_CharT, _Traits>::pos_type __pos);
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &seekp(typename ::std::basic_ostream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir);
    protected:
      inline basic_ostream()
      {
        this->init(0);
      }
      template < typename _ValueT >
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &_M_insert(_ValueT __v);
    friend class sentry;
  };
  template < typename _CharT, typename _Traits >
  class  basic_ostream<_CharT, _Traits>::sentry
  {
      bool _M_ok;
      ::std::basic_ostream<_CharT, _Traits> &_M_os;
    public:
      explicit sentry(::std::basic_ostream<_CharT, _Traits> &__os);
      inline ~sentry()
      {
        if (bool(::std::basic_ostream<_CharT, _Traits>::sentry::_M_os.flags() & ::std::ios_base::unitbuf) && !::std::uncaught_exception())
          {
            if (::std::basic_ostream<_CharT, _Traits>::sentry::_M_os.rdbuf() && ::std::basic_ostream<_CharT, _Traits>::sentry::_M_os.rdbuf()->pubsync() ==  -1)
              {
                ::std::basic_ostream<_CharT, _Traits>::sentry::_M_os.setstate(::std::ios_base::badbit);
              }
          }
      }
      inline explicit operator bool() const 
      {
        return ::std::basic_ostream<_CharT, _Traits>::sentry::_M_ok;
      }
  };
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, _CharT __c);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, _CharT __c)
  {
    return __ostream_insert(__out, &__c, 1);
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, char __c);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, char __c)
  {
    return __out << __out.widen(__c);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, char __c);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, char __c)
  {
    return __ostream_insert(__out, &__c, 1);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, signed char __c);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, signed char __c)
  {
    return __out << static_cast<char>(__c);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, unsigned char __c);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, unsigned char __c)
  {
    return __out << static_cast<char>(__c);
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s)
  {
    if (!__s)
      {
        __out.setstate(::std::ios_base::badbit);
      }
    else
      {
        __ostream_insert(__out, __s, static_cast< ::std::streamsize>(_Traits::length(__s)));
      }
    return __out;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const char *__s)
  {
    if (!__s)
      {
        __out.setstate(::std::ios_base::badbit);
      }
    else
      {
        __ostream_insert(__out, __s, static_cast< ::std::streamsize>(_Traits::length(__s)));
      }
    return __out;
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const signed char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const signed char *__s)
  {
    return __out << reinterpret_cast<const char *>(__s);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const unsigned char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const unsigned char *__s)
  {
    return __out << reinterpret_cast<const char *>(__s);
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &endl(::std::basic_ostream<_CharT, _Traits> &__os);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &endl(::std::basic_ostream<_CharT, _Traits> &__os)
  {
    return flush(__os.put(__os.widen('\n')));
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &ends(::std::basic_ostream<_CharT, _Traits> &__os);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &ends(::std::basic_ostream<_CharT, _Traits> &__os)
  {
    return __os.put(_CharT());
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &flush(::std::basic_ostream<_CharT, _Traits> &__os);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &flush(::std::basic_ostream<_CharT, _Traits> &__os)
  {
    return __os.flush();
  }
  template < typename _CharT, typename _Traits, typename _Tp >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &&__os, const _Tp &__x);
  template < typename _CharT, typename _Traits, typename _Tp >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &&__os, const _Tp &__x)
  {
    __os << __x;
    return __os;
  }
  template < typename _CharT, typename _Traits >
  basic_ostream<_CharT, _Traits>::sentry::sentry(::std::basic_ostream<_CharT, _Traits> &__os)
    : _M_ok(false), _M_os(__os)
  {
    if (__os.tie() && __os.good())
      {
        __os.tie()->flush();
      }
    if (__os.good())
      {
        ::std::basic_ostream<_CharT, _Traits>::sentry::_M_ok = true;
      }
    else
      {
        __os.setstate(::std::ios_base::failbit);
      }
  }
  template < typename _CharT, typename _Traits >
  template < typename _ValueT >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::_M_insert(_ValueT __v)
  {
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::__num_put_type &__np = __check_facet(this->_M_num_put);
          if (__np.put(*this, *this, this->fill(), __v).failed())
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::operator <<(short int __n)
  {
    const ::std::ios_base::fmtflags __fmt = this->flags() & ::std::ios_base::basefield;
    if (__fmt == ::std::ios_base::oct || __fmt == ::std::ios_base::hex)
      {
        return (*this)._M_insert(static_cast<long int>(static_cast<unsigned short int>(__n)));
      }
    else
      {
        return (*this)._M_insert(static_cast<long int>(__n));
      }
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::operator <<(int __n)
  {
    const ::std::ios_base::fmtflags __fmt = this->flags() & ::std::ios_base::basefield;
    if (__fmt == ::std::ios_base::oct || __fmt == ::std::ios_base::hex)
      {
        return (*this)._M_insert(static_cast<long int>(static_cast<unsigned int>(__n)));
      }
    else
      {
        return (*this)._M_insert(static_cast<long int>(__n));
      }
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__streambuf_type *__sbin)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb && __sbin)
      {
        try
        {
          if (!__copy_streambufs(__sbin, this->rdbuf()))
            {
              __err |= ::std::ios_base::failbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::failbit);
        }
      }
    else
      {
        if (!__sbin)
          {
            __err |= ::std::ios_base::badbit;
          }
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::put(typename ::std::basic_ostream<_CharT, _Traits>::char_type __c)
  {
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::int_type __put = this->rdbuf()->sputc(__c);
          if (traits_type::eq_int_type(__put, traits_type::eof()))
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::write(const _CharT *__s, ::std::streamsize __n)
  {
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb)
      {
        try
        {
          (*this)._M_write(__s, __n);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::flush()
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    try
    {
      if (this->rdbuf() && this->rdbuf()->pubsync() ==  -1)
        {
          __err |= ::std::ios_base::badbit;
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::pos_type basic_ostream<_CharT, _Traits>::tellp()
  {
    typename ::std::basic_ostream<_CharT, _Traits>::pos_type __ret = ((typename ::std::basic_ostream<_CharT, _Traits>::pos_type( -1)));
    try
    {
      if (!this->fail())
        {
          __ret = this->rdbuf()->pubseekoff(0, ::std::ios_base::cur, ::std::ios_base::out);
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::seekp(typename ::std::basic_ostream<_CharT, _Traits>::pos_type __pos)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    try
    {
      if (!this->fail())
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekpos(__pos, ::std::ios_base::out);
          if (__p == ((typename ::std::basic_ostream<_CharT, _Traits>::pos_type(((typename ::std::basic_ostream<_CharT, _Traits>::off_type( -1)))))))
            {
              __err |= ::std::ios_base::failbit;
            }
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::seekp(typename ::std::basic_ostream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    try
    {
      if (!this->fail())
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ::std::ios_base::out);
          if (__p == ((typename ::std::basic_ostream<_CharT, _Traits>::pos_type(((typename ::std::basic_ostream<_CharT, _Traits>::off_type( -1)))))))
            {
              __err |= ::std::ios_base::failbit;
            }
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const char *__s)
  {
    if (!__s)
      {
        __out.setstate(::std::ios_base::badbit);
      }
    else
      {
        const ::std::size_t __clen(char_traits<char>::length(__s));
        try
        {
          struct  __ptr_guard
          {
              _CharT *__p;
              inline __ptr_guard(_CharT *__ip)
                : __p(__ip)
              {
              }
              inline ~__ptr_guard()
              {
                delete[] __ptr_guard::__p;
              }
              inline _CharT *__get()
              {
                return __ptr_guard::__p;
              }
          };
          __ptr_guard __pg(new _CharT [__clen]);
          _CharT *__ws = __pg.__get();
          for (::std::size_t __i(0); __i < __clen;  ++__i)
            {
              __ws[__i] = __out.widen(__s[__i]);
            }
          __ostream_insert(__out, __ws, __clen);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __out._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __out._M_setstate(::std::ios_base::badbit);
        }
      }
    return __out;
  }
  extern template class ::std::basic_ostream<char>;
  extern template ::std::basic_ostream<char> &endl(::std::basic_ostream<char> &);
  extern template ::std::basic_ostream<char> &ends(::std::basic_ostream<char> &);
  extern template ::std::basic_ostream<char> &flush(::std::basic_ostream<char> &);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, char);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, unsigned char);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, signed char);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, const char *);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, const unsigned char *);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, const signed char *);
 /* Instantiation of class template '::std::basic_ios<char>' */ 
 /* Instantiation of class template '::std::basic_ostream<char>' */ 
  extern template ::std::basic_ostream<char> &ostream::_M_insert(long int);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(unsigned long int);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(bool);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(long long int);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(unsigned long long int);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(double);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(long double);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(const void *);
  extern template class ::std::basic_ostream<wchar_t>;
  extern template ::std::basic_ostream<wchar_t> &endl(::std::basic_ostream<wchar_t> &);
  extern template ::std::basic_ostream<wchar_t> &ends(::std::basic_ostream<wchar_t> &);
  extern template ::std::basic_ostream<wchar_t> &flush(::std::basic_ostream<wchar_t> &);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, wchar_t);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, char);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, const wchar_t *);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, const char *);
 /* Instantiation of class template '::std::basic_ios<wchar_t>' */ 
 /* Instantiation of class template '::std::basic_ostream<wchar_t>' */ 
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(long int);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(unsigned long int);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(bool);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(long long int);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(unsigned long long int);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(double);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(long double);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(const void *);
  template < typename _CharT, typename _Traits >
  class  basic_istream : virtual public ::std::basic_ios<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef ::std::basic_ios<_CharT, _Traits> __ios_type;
      typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
      typedef ::std::num_get<_CharT, ::std::istreambuf_iterator<_CharT, _Traits> > __num_get_type;
      typedef ::std::ctype<_CharT> __ctype_type;
    protected:
      ::std::streamsize _M_gcount;
    public:
      inline explicit basic_istream(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb)
        : _M_gcount((long int)0)
      {
        this->init(__sb);
      }
      inline virtual ~basic_istream()
      {
        ::std::basic_istream<_CharT, _Traits>::_M_gcount = (long int)0;
      }
      class sentry;
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(typename ::std::basic_istream<_CharT, _Traits>::__istream_type &(*__pf)(typename ::std::basic_istream<_CharT, _Traits>::__istream_type &))
      {
        return __pf(*this);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(typename ::std::basic_istream<_CharT, _Traits>::__ios_type &(*__pf)(typename ::std::basic_istream<_CharT, _Traits>::__ios_type &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(::std::ios_base &(*__pf)(::std::ios_base &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(bool &__n)
      {
        return (*this)._M_extract(__n);
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(short int &__n);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned short int &__n)
      {
        return (*this)._M_extract(__n);
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(int &__n);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(long int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned long int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(long long int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned long long int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(float &__f)
      {
        return (*this)._M_extract(__f);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(double &__f)
      {
        return (*this)._M_extract(__f);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(long double &__f)
      {
        return (*this)._M_extract(__f);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(void *&__p)
      {
        return (*this)._M_extract(__p);
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sbout);
      inline ::std::streamsize gcount() const 
      {
        return ::std::basic_istream<_CharT, _Traits>::_M_gcount;
      }
      typename ::std::basic_istream<_CharT, _Traits>::int_type get();
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::char_type &__c);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->get(__s, __n, this->widen('\n'));
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type &__sb, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type &__sb)
      {
        return this->get(__sb, this->widen('\n'));
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &getline(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &getline(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->getline(__s, __n, this->widen('\n'));
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &ignore(::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::int_type __delim);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &ignore(::std::streamsize __n);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &ignore();
      typename ::std::basic_istream<_CharT, _Traits>::int_type peek();
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &read(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      ::std::streamsize readsome(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &putback(typename ::std::basic_istream<_CharT, _Traits>::char_type __c);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &unget();
      int sync();
      typename ::std::basic_istream<_CharT, _Traits>::pos_type tellg();
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &seekg(typename ::std::basic_istream<_CharT, _Traits>::pos_type __pos);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &seekg(typename ::std::basic_istream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir);
    protected:
      inline basic_istream()
        : _M_gcount((long int)0)
      {
        this->init(0);
      }
      template < typename _ValueT >
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &_M_extract(_ValueT &__v);
    friend class sentry;
  };
 /* Instantiation of class template '::std::basic_istream<char>' */ 
  template <>
  ::std::basic_istream<char> &basic_istream<char>::getline(char *__s, long int __n, char __delim);
  template <>
  ::std::basic_istream<char> &basic_istream<char>::ignore(long int __n);
  template <>
  ::std::basic_istream<char> &basic_istream<char>::ignore(long int __n, ::std::char_traits<char>::int_type __delim);
 /* Instantiation of class template '::std::basic_istream<wchar_t>' */ 
  template <>
  ::std::basic_istream<wchar_t> &basic_istream<wchar_t>::getline(wchar_t *__s, long int __n, wchar_t __delim);
  template <>
  ::std::basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(long int __n);
  template <>
  ::std::basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(long int __n, ::std::char_traits<wchar_t>::int_type __delim);
  template < typename _CharT, typename _Traits >
  class  basic_istream<_CharT, _Traits>::sentry
  {
      bool _M_ok;
    public:
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename ::std::basic_istream<_CharT, _Traits>::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
      explicit sentry(::std::basic_istream<_CharT, _Traits> &__in, bool __noskip  = (false));
      inline explicit operator bool() const 
      {
        return ::std::basic_istream<_CharT, _Traits>::sentry::_M_ok;
      }
  };
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT &__c);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char &__c);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char &__c)
  {
    return __in >> reinterpret_cast<char &>(__c);
  }
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char &__c);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char &__c)
  {
    return __in >> reinterpret_cast<char &>(__c);
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT *__s);
  template <>
  ::std::basic_istream<char> &operator >><char, ::std::char_traits<char> >(::std::basic_istream<char> &__in, char *__s);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char *__s);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char *__s)
  {
    return __in >> reinterpret_cast<char *>(__s);
  }
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char *__s);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char *__s)
  {
    return __in >> reinterpret_cast<char *>(__s);
  }
  template < typename _CharT, typename _Traits >
  class  basic_iostream : public ::std::basic_istream<_CharT, _Traits>, public ::std::basic_ostream<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
      typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
      inline explicit basic_iostream(::std::basic_streambuf<_CharT, _Traits> *__sb)
        : __istream_type(__sb), __ostream_type(__sb)
      {
      }
      inline virtual ~basic_iostream()
      {
      }
    protected:
      inline basic_iostream()
        : __istream_type(), __ostream_type()
      {
      }
  };
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &ws(::std::basic_istream<_CharT, _Traits> &__in);
  template < typename _CharT, typename _Traits, typename _Tp >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &&__is, _Tp &__x);
  template < typename _CharT, typename _Traits, typename _Tp >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &&__is, _Tp &__x)
  {
    __is >> __x;
    return __is;
  }
  template < typename _CharT, typename _Traits >
  basic_istream<_CharT, _Traits>::sentry::sentry(::std::basic_istream<_CharT, _Traits> &__in, bool __noskip)
    : _M_ok(false)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    if (__in.good())
      {
        if (__in.tie())
          {
            __in.tie()->flush();
          }
        if (!__noskip && bool(__in.flags() & ::std::ios_base::skipws))
          {
            const typename ::std::basic_istream<_CharT, _Traits>::sentry::__int_type __eof = traits_type::eof();
            typename ::std::basic_istream<_CharT, _Traits>::sentry::__streambuf_type *__sb = __in.rdbuf();
            typename ::std::basic_istream<_CharT, _Traits>::sentry::__int_type __c = __sb->sgetc();
            const typename ::std::basic_istream<_CharT, _Traits>::sentry::__ctype_type &__ct = __check_facet(__in._M_ctype);
            while (!traits_type::eq_int_type(__c, __eof) && __ct.is(::std::ctype_base::space, traits_type::to_char_type(__c)))
              {
                __c = __sb->snextc();
              }
            if (traits_type::eq_int_type(__c, __eof))
              {
                __err |= ::std::ios_base::eofbit;
              }
          }
      }
    if (__in.good() && __err == ::std::ios_base::goodbit)
      {
        ::std::basic_istream<_CharT, _Traits>::sentry::_M_ok = true;
      }
    else
      {
        __err |= ::std::ios_base::failbit;
        __in.setstate(__err);
      }
  }
  template < typename _CharT, typename _Traits >
  template < typename _ValueT >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::_M_extract(_ValueT &__v)
  {
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::__num_get_type &__ng = __check_facet(this->_M_num_get);
          __ng.get(*this, 0, *this, __err, __v);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<short int>, ::__gnu_cxx::__numeric_traits_floating<short int> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<short int>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<short int>' */ 
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::operator >>(short int &__n)
  {
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          long int __l;
          const typename ::std::basic_istream<_CharT, _Traits>::__num_get_type &__ng = __check_facet(this->_M_num_get);
          __ng.get(*this, 0, *this, __err, __l);
          if (__l < ::__gnu_cxx::__numeric_traits_integer<short int>::__min)
            {
              __err |= ::std::ios_base::failbit;
              __n = ::__gnu_cxx::__numeric_traits_integer<short int>::__min;
            }
          else
            {
              if (__l > ::__gnu_cxx::__numeric_traits_integer<short int>::__max)
                {
                  __err |= ::std::ios_base::failbit;
                  __n = ::__gnu_cxx::__numeric_traits_integer<short int>::__max;
                }
              else
                {
                  __n = (short int)__l;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::operator >>(int &__n)
  {
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          long int __l;
          const typename ::std::basic_istream<_CharT, _Traits>::__num_get_type &__ng = __check_facet(this->_M_num_get);
          __ng.get(*this, 0, *this, __err, __l);
          if (__l < ::__gnu_cxx::__numeric_traits_integer<int>::__min)
            {
              __err |= ::std::ios_base::failbit;
              __n = ::__gnu_cxx::__numeric_traits_integer<int>::__min;
            }
          else
            {
              if (__l > ::__gnu_cxx::__numeric_traits_integer<int>::__max)
                {
                  __err |= ::std::ios_base::failbit;
                  __n = ::__gnu_cxx::__numeric_traits_integer<int>::__max;
                }
              else
                {
                  __n = (int)__l;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::operator >>(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sbout)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb && __sbout)
      {
        try
        {
          bool __ineof;
          if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
            {
              __err |= ::std::ios_base::failbit;
            }
          if (__ineof)
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::failbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::failbit);
        }
      }
    else
      {
        if (!__sbout)
          {
            __err |= ::std::ios_base::failbit;
          }
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::get()
  {
    const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
    typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __eof;
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          __c = this->rdbuf()->sbumpc();
          if (!traits_type::eq_int_type(__c, __eof))
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = 1;
            }
          else
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return __c;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::get(typename ::std::basic_istream<_CharT, _Traits>::char_type &__c)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __cb = this->rdbuf()->sbumpc();
          if (!traits_type::eq_int_type(__cb, traits_type::eof()))
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = 1;
              __c = traits_type::to_char_type(__cb);
            }
          else
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::get(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __idelim = traits_type::to_int_type(__delim);
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          while ((::std::basic_istream<_CharT, _Traits>::_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __idelim))
            {
              *__s++ = traits_type::to_char_type(__c);
               ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
              __c = __sb->snextc();
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (__n > 0)
      {
        *__s = ((typename ::std::basic_istream<_CharT, _Traits>::char_type()));
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::get(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type &__sb, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __idelim = traits_type::to_int_type(__delim);
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__this_sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __this_sb->sgetc();
          typename ::std::basic_istream<_CharT, _Traits>::char_type __c2 = traits_type::to_char_type(__c);
          while ((!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim)) && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
            {
               ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
              __c = __this_sb->snextc();
              __c2 = traits_type::to_char_type(__c);
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::getline(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __idelim = traits_type::to_int_type(__delim);
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          while ((::std::basic_istream<_CharT, _Traits>::_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __idelim))
            {
              *__s++ = traits_type::to_char_type(__c);
              __c = __sb->snextc();
               ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          else
            {
              if (traits_type::eq_int_type(__c, __idelim))
                {
                  __sb->sbumpc();
                   ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
                }
              else
                {
                  __err |= ::std::ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (__n > 0)
      {
        *__s = ((typename ::std::basic_istream<_CharT, _Traits>::char_type()));
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::ignore()
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          else
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = 1;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<long int>, ::__gnu_cxx::__numeric_traits_floating<long int> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<long int>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<long int>' */ 
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::ignore(::std::streamsize __n)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb && __n > 0)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          bool __large_ignore(false);
          while (true)
            {
              while (::std::basic_istream<_CharT, _Traits>::_M_gcount < __n && !traits_type::eq_int_type(__c, __eof))
                {
                   ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
                  __c = __sb->snextc();
                }
              if (__n == ::__gnu_cxx::__numeric_traits_integer<long int>::__max && !traits_type::eq_int_type(__c, __eof))
                {
                  ::std::basic_istream<_CharT, _Traits>::_M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__min;
                  __large_ignore = true;
                }
              else
                {
                  break;
                }
            }
          if (__large_ignore)
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__max;
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::ignore(::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::int_type __delim)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb && __n > 0)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          bool __large_ignore(false);
          while (true)
            {
              while ((::std::basic_istream<_CharT, _Traits>::_M_gcount < __n && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __delim))
                {
                   ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
                  __c = __sb->snextc();
                }
              if ((__n == ::__gnu_cxx::__numeric_traits_integer<long int>::__max && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __delim))
                {
                  ::std::basic_istream<_CharT, _Traits>::_M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__min;
                  __large_ignore = true;
                }
              else
                {
                  break;
                }
            }
          if (__large_ignore)
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__max;
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          else
            {
              if (traits_type::eq_int_type(__c, __delim))
                {
                  if (::std::basic_istream<_CharT, _Traits>::_M_gcount < ::__gnu_cxx::__numeric_traits_integer<long int>::__max)
                    {
                       ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
                    }
                  __sb->sbumpc();
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::peek()
  {
    typename ::std::basic_istream<_CharT, _Traits>::int_type __c = traits_type::eof();
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          __c = this->rdbuf()->sgetc();
          if (traits_type::eq_int_type(__c, traits_type::eof()))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return __c;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::read(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          ::std::basic_istream<_CharT, _Traits>::_M_gcount = this->rdbuf()->sgetn(__s, __n);
          if (::std::basic_istream<_CharT, _Traits>::_M_gcount != __n)
            {
              __err |= ::std::ios_base::eofbit | ::std::ios_base::failbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_istream<_CharT, _Traits>::readsome(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const ::std::streamsize __num = this->rdbuf()->in_avail();
          if (__num > 0)
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
            }
          else
            {
              if (__num ==  -1)
                {
                  __err |= ::std::ios_base::eofbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return ::std::basic_istream<_CharT, _Traits>::_M_gcount;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::putback(typename ::std::basic_istream<_CharT, _Traits>::char_type __c)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (!__sb || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::unget()
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (!__sb || traits_type::eq_int_type(__sb->sungetc(), __eof))
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  int basic_istream<_CharT, _Traits>::sync()
  {
    int __ret( -1);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (__sb)
            {
              if (__sb->pubsync() ==  -1)
                {
                  __err |= ::std::ios_base::badbit;
                }
              else
                {
                  __ret = 0;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::pos_type basic_istream<_CharT, _Traits>::tellg()
  {
    typename ::std::basic_istream<_CharT, _Traits>::pos_type __ret = ((typename ::std::basic_istream<_CharT, _Traits>::pos_type( -1)));
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          if (!this->fail())
            {
              __ret = this->rdbuf()->pubseekoff(0, ::std::ios_base::cur, ::std::ios_base::in);
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::seekg(typename ::std::basic_istream<_CharT, _Traits>::pos_type __pos)
  {
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          if (!this->fail())
            {
              const typename ::std::basic_istream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekpos(__pos, ::std::ios_base::in);
              if (__p == ((typename ::std::basic_istream<_CharT, _Traits>::pos_type(((typename ::std::basic_istream<_CharT, _Traits>::off_type( -1)))))))
                {
                  __err |= ::std::ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::seekg(typename ::std::basic_istream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir)
  {
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          if (!this->fail())
            {
              const typename ::std::basic_istream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ::std::ios_base::in);
              if (__p == ((typename ::std::basic_istream<_CharT, _Traits>::pos_type(((typename ::std::basic_istream<_CharT, _Traits>::off_type( -1)))))))
                {
                  __err |= ::std::ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT &__c)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const __int_type __cb = __in.rdbuf()->sbumpc();
          if (!_Traits::eq_int_type(__cb, _Traits::eof()))
            {
              __c = _Traits::to_char_type(__cb);
            }
          else
            {
              __err |= ::std::ios_base::eofbit | ::std::ios_base::failbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            __in.setstate(__err);
          }
      }
    return __in;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT *__s)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
    typedef typename _Traits::int_type int_type;
    typedef _CharT char_type;
    typedef ::std::ctype<_CharT> __ctype_type;
    ::std::streamsize __extracted(0);
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, false);
    if (__cerb)
      {
        try
        {
          ::std::streamsize __num = __in.width();
          if (__num <= 0)
            {
              __num = ::__gnu_cxx::__numeric_traits_integer<long int>::__max;
            }
          const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
          const int_type __eof = _Traits::eof();
          __streambuf_type *__sb = __in.rdbuf();
          int_type __c = __sb->sgetc();
          while ((__extracted < __num - 1 && !_Traits::eq_int_type(__c, __eof)) && !__ct.is(::std::ctype_base::space, _Traits::to_char_type(__c)))
            {
              *__s++ = _Traits::to_char_type(__c);
               ++__extracted;
              __c = __sb->snextc();
            }
          if (_Traits::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          *__s = char_type();
          __in.width(0);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(::std::ios_base::badbit);
        }
      }
    if (!__extracted)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        __in.setstate(__err);
      }
    return __in;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &ws(::std::basic_istream<_CharT, _Traits> &__in)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typedef ::std::ctype<_CharT> __ctype_type;
    const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
    const __int_type __eof = _Traits::eof();
    __streambuf_type *__sb = __in.rdbuf();
    __int_type __c = __sb->sgetc();
    while (!_Traits::eq_int_type(__c, __eof) && __ct.is(::std::ctype_base::space, _Traits::to_char_type(__c)))
      {
        __c = __sb->snextc();
      }
    if (_Traits::eq_int_type(__c, __eof))
      {
        __in.setstate(::std::ios_base::eofbit);
      }
    return __in;
  }
  extern template class ::std::basic_istream<char>;
  extern template ::std::basic_istream<char> &ws(::std::basic_istream<char> &);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, char &);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, char *);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, unsigned char &);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, signed char &);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, unsigned char *);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, signed char *);
  extern template ::std::basic_istream<char> &istream::_M_extract(unsigned short int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(unsigned int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(long int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(unsigned long int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(bool &);
  extern template ::std::basic_istream<char> &istream::_M_extract(long long int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(unsigned long long int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(float &);
  extern template ::std::basic_istream<char> &istream::_M_extract(double &);
  extern template ::std::basic_istream<char> &istream::_M_extract(long double &);
  extern template ::std::basic_istream<char> &istream::_M_extract(void *&);
  extern template class ::std::basic_iostream<char>;
  extern template class ::std::basic_istream<wchar_t>;
  extern template ::std::basic_istream<wchar_t> &ws(::std::basic_istream<wchar_t> &);
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, wchar_t &);
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, wchar_t *);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(unsigned short int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(unsigned int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(long int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(unsigned long int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(bool &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(long long int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(unsigned long long int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(float &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(double &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(long double &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(void *&);
  extern template class ::std::basic_iostream<wchar_t>;
  template < typename _CharT, typename _Traits, typename _Alloc >
  class  basic_stringbuf : public ::std::basic_streambuf<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef _Alloc allocator_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_streambuf<typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::traits_type> __streambuf_type;
      typedef ::std::basic_string<typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type, _Traits, _Alloc> __string_type;
      typedef typename ::std::basic_string<typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type, _Traits, _Alloc>::size_type __size_type;
    protected:
      ::std::ios_base::openmode _M_mode;
      typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__string_type _M_string;
    public:
      inline explicit basic_stringbuf(::std::ios_base::openmode __mode  = (::std::ios_base::in | ::std::ios_base::out))
        : __streambuf_type(), _M_mode(__mode), _M_string()
      {
      }
      inline explicit basic_stringbuf(const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__string_type &__str, ::std::ios_base::openmode __mode  = (::std::ios_base::in | ::std::ios_base::out))
        : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      {
        (*this)._M_stringbuf_init(__mode);
      }
      inline typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__string_type str() const 
      {
        typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__string_type __ret;
        if (this->pptr())
          {
            if (this->pptr() > this->egptr())
              {
                __ret = ((typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__string_type(this->pbase(), this->pptr())));
              }
            else
              {
                __ret = ((typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__string_type(this->pbase(), this->egptr())));
              }
          }
        else
          {
            __ret = ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_string;
          }
        return __ret;
      }
      inline void str(const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__string_type &__s)
      {
        ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_string.assign(__s.data(), __s.size());
        (*this)._M_stringbuf_init(::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_mode);
      }
    protected:
      inline void _M_stringbuf_init(::std::ios_base::openmode __mode)
      {
        ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_mode = __mode;
        typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __len = 0;
        if (::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_mode & (::std::ios_base::ate | ::std::ios_base::app))
          {
            __len = ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_string.size();
          }
        (*this)._M_sync(const_cast<typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *>(::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_string.data()), 0, __len);
      }
      inline virtual ::std::streamsize showmanyc()
      {
        ::std::streamsize __ret( -1);
        if (::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_mode & ::std::ios_base::in)
          {
            (*this)._M_update_egptr();
            __ret = this->egptr() - this->gptr();
          }
        return __ret;
      }
      virtual typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type underflow();
      virtual typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type pbackfail(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type __c  = (traits_type::eof()));
      virtual typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type overflow(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type __c  = (traits_type::eof()));
      inline virtual typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__streambuf_type *setbuf(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__s, ::std::streamsize __n)
      {
        if (__s && __n >= 0)
          {
            ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_string.clear();
            (*this)._M_sync(__s, __n, 0);
          }
        return this;
      }
      virtual typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type seekoff(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type __off, ::std::ios_base::seekdir __way, ::std::ios_base::openmode __mode  = (::std::ios_base::in | ::std::ios_base::out));
      virtual typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type seekpos(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type __sp, ::std::ios_base::openmode __mode  = (::std::ios_base::in | ::std::ios_base::out));
      void _M_sync(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__base, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __i, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __o);
      inline void _M_update_egptr()
      {
        const bool __testin = ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_mode & ::std::ios_base::in;
        if (this->pptr() && this->pptr() > this->egptr())
          {
            if (__testin)
              {
                this->setg(this->eback(), this->gptr(), this->pptr());
              }
            else
              {
                this->setg(this->pptr(), this->pptr(), this->pptr());
              }
          }
      }
      void _M_pbump(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__pbeg, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__pend, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type __off);
  };
  template < typename _CharT, typename _Traits, typename _Alloc >
  class  basic_istringstream : public ::std::basic_istream<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef _Alloc allocator_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef ::std::basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef ::std::basic_istream<typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::char_type, typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::traits_type> __istream_type;
    private:
      typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::__stringbuf_type _M_stringbuf;
    public:
      inline explicit basic_istringstream(::std::ios_base::openmode __mode  = (::std::ios_base::in))
        : __istream_type(), _M_stringbuf(__mode | ::std::ios_base::in)
      {
        this->init(&(*this).::std::basic_istringstream<_CharT, _Traits, _Alloc>::_M_stringbuf);
      }
      inline explicit basic_istringstream(const typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::__string_type &__str, ::std::ios_base::openmode __mode  = (::std::ios_base::in))
        : __istream_type(), _M_stringbuf(__str, __mode | ::std::ios_base::in)
      {
        this->init(&(*this).::std::basic_istringstream<_CharT, _Traits, _Alloc>::_M_stringbuf);
      }
      inline ~basic_istringstream()
      {
      }
      inline typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::__stringbuf_type *rdbuf() const 
      {
        return const_cast<typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::__stringbuf_type *>(&(*this).::std::basic_istringstream<_CharT, _Traits, _Alloc>::_M_stringbuf);
      }
      inline typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::__string_type str() const 
      {
        return ::std::basic_istringstream<_CharT, _Traits, _Alloc>::_M_stringbuf.str();
      }
      inline void str(const typename ::std::basic_istringstream<_CharT, _Traits, _Alloc>::__string_type &__s)
      {
        ::std::basic_istringstream<_CharT, _Traits, _Alloc>::_M_stringbuf.str(__s);
      }
  };
  template < typename _CharT, typename _Traits, typename _Alloc >
  class  basic_ostringstream : public ::std::basic_ostream<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef _Alloc allocator_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef ::std::basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef ::std::basic_ostream<typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::char_type, typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::traits_type> __ostream_type;
    private:
      typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::__stringbuf_type _M_stringbuf;
    public:
      inline explicit basic_ostringstream(::std::ios_base::openmode __mode  = (::std::ios_base::out))
        : __ostream_type(), _M_stringbuf(__mode | ::std::ios_base::out)
      {
        this->init(&(*this).::std::basic_ostringstream<_CharT, _Traits, _Alloc>::_M_stringbuf);
      }
      inline explicit basic_ostringstream(const typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::__string_type &__str, ::std::ios_base::openmode __mode  = (::std::ios_base::out))
        : __ostream_type(), _M_stringbuf(__str, __mode | ::std::ios_base::out)
      {
        this->init(&(*this).::std::basic_ostringstream<_CharT, _Traits, _Alloc>::_M_stringbuf);
      }
      inline ~basic_ostringstream()
      {
      }
      inline typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::__stringbuf_type *rdbuf() const 
      {
        return const_cast<typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::__stringbuf_type *>(&(*this).::std::basic_ostringstream<_CharT, _Traits, _Alloc>::_M_stringbuf);
      }
      inline typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::__string_type str() const 
      {
        return ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::_M_stringbuf.str();
      }
      inline void str(const typename ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::__string_type &__s)
      {
        ::std::basic_ostringstream<_CharT, _Traits, _Alloc>::_M_stringbuf.str(__s);
      }
  };
  template < typename _CharT, typename _Traits, typename _Alloc >
  class  basic_stringstream : public ::std::basic_iostream<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef _Alloc allocator_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef ::std::basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef ::std::basic_iostream<typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::char_type, typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::traits_type> __iostream_type;
    private:
      typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::__stringbuf_type _M_stringbuf;
    public:
      inline explicit basic_stringstream(::std::ios_base::openmode __m  = (::std::ios_base::out | ::std::ios_base::in))
        : __iostream_type(), _M_stringbuf(__m)
      {
        this->init(&(*this).::std::basic_stringstream<_CharT, _Traits, _Alloc>::_M_stringbuf);
      }
      inline explicit basic_stringstream(const typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::__string_type &__str, ::std::ios_base::openmode __m  = (::std::ios_base::out | ::std::ios_base::in))
        : __iostream_type(), _M_stringbuf(__str, __m)
      {
        this->init(&(*this).::std::basic_stringstream<_CharT, _Traits, _Alloc>::_M_stringbuf);
      }
      inline ~basic_stringstream()
      {
      }
      inline typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::__stringbuf_type *rdbuf() const 
      {
        return const_cast<typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::__stringbuf_type *>(&(*this).::std::basic_stringstream<_CharT, _Traits, _Alloc>::_M_stringbuf);
      }
      inline typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::__string_type str() const 
      {
        return ::std::basic_stringstream<_CharT, _Traits, _Alloc>::_M_stringbuf.str();
      }
      inline void str(const typename ::std::basic_stringstream<_CharT, _Traits, _Alloc>::__string_type &__s)
      {
        ::std::basic_stringstream<_CharT, _Traits, _Alloc>::_M_stringbuf.str(__s);
      }
  };
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type basic_stringbuf<_CharT, _Traits, _Alloc>::pbackfail(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type __c)
  {
    typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type __ret = traits_type::eof();
    if (this->eback() < this->gptr())
      {
        const bool __testeof = traits_type::eq_int_type(__c, __ret);
        if (!__testeof)
          {
            const bool __testeq = traits_type::eq(traits_type::to_char_type(__c), this->gptr()[ -1]);
            const bool __testout = this->_M_mode & ::std::ios_base::out;
            if (__testeq || __testout)
              {
                this->gbump( -1);
                if (!__testeq)
                  {
                    *this->gptr() = traits_type::to_char_type(__c);
                  }
                __ret = __c;
              }
          }
        else
          {
            this->gbump( -1);
            __ret = traits_type::not_eof(__c);
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type basic_stringbuf<_CharT, _Traits, _Alloc>::overflow(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type __c)
  {
    const bool __testout = this->_M_mode & ::std::ios_base::out;
    if (__builtin_expect(!__testout, false))
      {
        return traits_type::eof();
      }
    const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
    if (__builtin_expect(__testeof, false))
      {
        return traits_type::not_eof(__c);
      }
    const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __capacity = ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_string.capacity();
    const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __max_size = ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_string.max_size();
    const bool __testput = this->pptr() < this->epptr();
    if (__builtin_expect(!__testput && __capacity == __max_size, false))
      {
        return traits_type::eof();
      }
    const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type __conv = traits_type::to_char_type(__c);
    if (!__testput)
      {
        const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __opt_len = std::max(((typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type(2 * __capacity))), ((typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type(512))));
        const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __len = std::min(__opt_len, __max_size);
        typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__string_type __tmp;
        __tmp.reserve(__len);
        if (this->pbase())
          {
            __tmp.assign(this->pbase(), this->epptr() - this->pbase());
          }
        __tmp.push_back(__conv);
        ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_string.swap(__tmp);
        (*this)._M_sync(const_cast<typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *>(::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_string.data()), this->gptr() - this->eback(), this->pptr() - this->pbase());
      }
    else
      {
        *this->pptr() = __conv;
      }
    this->pbump(1);
    return __c;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type basic_stringbuf<_CharT, _Traits, _Alloc>::underflow()
  {
    typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::int_type __ret = traits_type::eof();
    const bool __testin = this->_M_mode & ::std::ios_base::in;
    if (__testin)
      {
        (*this)._M_update_egptr();
        if (this->gptr() < this->egptr())
          {
            __ret = traits_type::to_int_type(*this->gptr());
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type basic_stringbuf<_CharT, _Traits, _Alloc>::seekoff(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type __off, ::std::ios_base::seekdir __way, ::std::ios_base::openmode __mode)
  {
    typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type __ret = ((typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type(((typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type( -1))))));
    bool __testin = ((::std::ios_base::in & this->_M_mode) & __mode) != 0;
    bool __testout = ((::std::ios_base::out & this->_M_mode) & __mode) != 0;
    const bool __testboth = (__testin && __testout) && __way != ::std::ios_base::cur;
    __testin &= !(__mode & ::std::ios_base::out);
    __testout &= !(__mode & ::std::ios_base::in);
    const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__beg = __testin ? this->eback() : this->pbase();
    if ((__beg || !__off) && ((__testin || __testout) || __testboth))
      {
        (*this)._M_update_egptr();
        typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type __newoffi = __off;
        typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type __newoffo = __newoffi;
        if (__way == ::std::ios_base::cur)
          {
            __newoffi += this->gptr() - __beg;
            __newoffo += this->pptr() - __beg;
          }
        else
          {
            if (__way == ::std::ios_base::end)
              {
                __newoffo = __newoffi += this->egptr() - __beg;
              }
          }
        if (((__testin || __testboth) && __newoffi >= 0) && this->egptr() - __beg >= __newoffi)
          {
            this->setg(this->eback(), this->eback() + __newoffi, this->egptr());
            __ret = ((typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type(__newoffi)));
          }
        if (((__testout || __testboth) && __newoffo >= 0) && this->egptr() - __beg >= __newoffo)
          {
            (*this)._M_pbump(this->pbase(), this->epptr(), __newoffo);
            __ret = ((typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type(__newoffo)));
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type basic_stringbuf<_CharT, _Traits, _Alloc>::seekpos(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type __sp, ::std::ios_base::openmode __mode)
  {
    typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type __ret = ((typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type(((typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type( -1))))));
    const bool __testin = ((::std::ios_base::in & this->_M_mode) & __mode) != 0;
    const bool __testout = ((::std::ios_base::out & this->_M_mode) & __mode) != 0;
    const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__beg = __testin ? this->eback() : this->pbase();
    if ((__beg || !((typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type(__sp)))) && (__testin || __testout))
      {
        (*this)._M_update_egptr();
        const typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type __pos(__sp);
        const bool __testpos = 0 <= __pos && __pos <= this->egptr() - __beg;
        if (__testpos)
          {
            if (__testin)
              {
                this->setg(this->eback(), this->eback() + __pos, this->egptr());
              }
            if (__testout)
              {
                (*this)._M_pbump(this->pbase(), this->epptr(), __pos);
              }
            __ret = __sp;
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_stringbuf<_CharT, _Traits, _Alloc>::_M_sync(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__base, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __i, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::__size_type __o)
  {
    const bool __testin = ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_mode & ::std::ios_base::in;
    const bool __testout = ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_mode & ::std::ios_base::out;
    typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__endg = __base + ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_string.size();
    typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__endp = __base + ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_string.capacity();
    if (__base != ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::_M_string.data())
      {
        __endg += __i;
        __i = 0;
        __endp = __endg;
      }
    if (__testin)
      {
        this->setg(__base, __base + __i, __endg);
      }
    if (__testout)
      {
        (*this)._M_pbump(__base, __endp, __o);
        if (!__testin)
          {
            this->setg(__endg, __endg, __endg);
          }
      }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  void basic_stringbuf<_CharT, _Traits, _Alloc>::_M_pbump(typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__pbeg, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::char_type *__pend, typename ::std::basic_stringbuf<_CharT, _Traits, _Alloc>::off_type __off)
  {
    this->setp(__pbeg, __pend);
    while (__off > ::__gnu_cxx::__numeric_traits_integer<int>::__max)
      {
        this->pbump(::__gnu_cxx::__numeric_traits_integer<int>::__max);
        __off -= ::__gnu_cxx::__numeric_traits_integer<int>::__max;
      }
    this->pbump(__off);
  }
  extern template class ::std::basic_stringbuf<char>;
  extern template class ::std::basic_istringstream<char>;
  extern template class ::std::basic_ostringstream<char>;
  extern template class ::std::basic_stringstream<char>;
  extern template class ::std::basic_stringbuf<wchar_t>;
  extern template class ::std::basic_istringstream<wchar_t>;
  extern template class ::std::basic_ostringstream<wchar_t>;
  extern template class ::std::basic_stringstream<wchar_t>;
  template < typename _Tp >
  class  __has_element_type_helper : ::std::__sfinae_types
  {
      template < typename _Up >
      struct  _Wrap_type
      {
      };
      template < typename _Up >
      static ::std::__sfinae_types::__one __test(typename ::std::__has_element_type_helper<_Tp>::template _Wrap_type<typename _Up::element_type> *);
      template < typename _Up >
      static ::std::__sfinae_types::__two __test(...);
    public:
      static constexpr const bool value = sizeof(__test<_Tp>(0)) == 1;
  };
  template < typename _Tp >
  struct  __has_element_type : ::std::integral_constant<bool, __has_element_type_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename _Tp >
  class  __has_difference_type_helper : ::std::__sfinae_types
  {
      template < typename _Up >
      struct  _Wrap_type
      {
      };
      template < typename _Up >
      static ::std::__sfinae_types::__one __test(typename ::std::__has_difference_type_helper<_Tp>::template _Wrap_type<typename _Up::difference_type> *);
      template < typename _Up >
      static ::std::__sfinae_types::__two __test(...);
    public:
      static constexpr const bool value = sizeof(__test<_Tp>(0)) == 1;
  };
  template < typename _Tp >
  struct  __has_difference_type : ::std::integral_constant<bool, __has_difference_type_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __has_element_type<_Tp>::value >
  struct __ptrtr_elt_type;
  template < typename _Tp >
  struct  __ptrtr_elt_type<_Tp, true>
  {
      typedef typename _Tp::element_type __type;
  };
  template <   template < typename __type_tpl__param_1_0__, typename ...__type_tpl__param_1_1__ > class _SomePtr, typename _Tp, typename ..._Args >
  struct  __ptrtr_elt_type<_SomePtr<_Tp, _Args ...>, false>
  {
      typedef _Tp __type;
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __has_difference_type<_Tp>::value >
  struct  __ptrtr_diff_type
  {
      typedef typename _Tp::difference_type __type;
  };
  template < typename _Tp >
  struct  __ptrtr_diff_type<_Tp, false>
  {
      typedef ::std::ptrdiff_t __type;
  };
  template < typename _Ptr, typename _Up >
  class  __ptrtr_rebind_helper
  {
      template < typename _Ptr2, typename _Up2 >
      static inline constexpr bool _S_chk(typename _Ptr2::template rebind< _Up2> *)
      {
        return true;
      }
      template < typename __type_tpl__param_2_0__, typename __type_tpl__param_2_1__ >
      static inline constexpr bool _S_chk(...)
      {
        return false;
      }
    public:
      static const bool __value = _S_chk<_Ptr, _Up>(nullptr);
  };
  template < typename _Tp, typename _Up, bool __nontype_tpl_param_1_2__ = __ptrtr_rebind_helper<_Tp, _Up>::__value >
  struct __ptrtr_rebind;
  template < typename _Tp, typename _Up >
  struct  __ptrtr_rebind<_Tp, _Up, true>
  {
      typedef typename _Tp::template rebind< _Up> __type;
  };
  template <   template < typename __type_tpl__param_1_0__, typename ...__type_tpl__param_1_1__ > class _SomePtr, typename _Up, typename _Tp, typename ..._Args >
  struct  __ptrtr_rebind<_SomePtr<_Tp, _Args ...>, _Up, false>
  {
      typedef _SomePtr<_Up, _Args ...> __type;
  };
  template < typename _Tp, typename __type_tpl__param_1_1__ = typename ::std::remove_cv<_Tp>::type >
  struct  __ptrtr_not_void
  {
      typedef _Tp __type;
  };
  template < typename _Tp >
  struct  __ptrtr_not_void<_Tp, void>
  {
      struct  __type
      {
      };
  };
  template < typename _Ptr >
  class  __ptrtr_pointer_to
  {
      typedef typename ::std::__ptrtr_elt_type<_Ptr>::__type __orig_type;
      typedef typename ::std::__ptrtr_not_void<typename ::std::__ptrtr_pointer_to<_Ptr>::__orig_type>::__type __element_type;
    public:
      static inline _Ptr pointer_to(typename ::std::__ptrtr_pointer_to<_Ptr>::__element_type &__e)
      {
        return _Ptr::pointer_to(__e);
      }
  };
  template < typename _Ptr >
  struct  pointer_traits : ::std::__ptrtr_pointer_to<_Ptr>
  {
      typedef _Ptr pointer;
      typedef typename ::std::__ptrtr_elt_type<_Ptr>::__type element_type;
      typedef typename ::std::__ptrtr_diff_type<_Ptr>::__type difference_type;
      template < typename _Up >
      using rebind = typename ::std::__ptrtr_rebind<_Ptr, _Up>::__type;
  };
  template < typename _Tp >
  struct  pointer_traits<_Tp *>
  {
      typedef _Tp *pointer;
      typedef _Tp element_type;
      typedef ::std::ptrdiff_t difference_type;
      template < typename _Up >
      using rebind = _Up *;
      static inline typename ::std::pointer_traits<_Tp *>::pointer pointer_to(typename ::std::__ptrtr_not_void<typename ::std::pointer_traits<_Tp *>::element_type>::__type &__r) noexcept(true)
      {
        return std::addressof(__r);
      }
  };
  template < typename _Alloc, typename _Tp >
  class  __alloctr_rebind_helper
  {
      template < typename _Alloc2, typename _Tp2 >
      static inline constexpr bool _S_chk(typename _Alloc2::template rebind< _Tp2>::other *)
      {
        return true;
      }
      template < typename __type_tpl__param_2_0__, typename __type_tpl__param_2_1__ >
      static inline constexpr bool _S_chk(...)
      {
        return false;
      }
    public:
      static const bool __value = _S_chk<_Alloc, _Tp>(nullptr);
  };
  template < typename _Alloc, typename _Tp, bool __nontype_tpl_param_1_2__ = __alloctr_rebind_helper<_Alloc, _Tp>::__value >
  struct __alloctr_rebind;
  template < typename _Alloc, typename _Tp >
  struct  __alloctr_rebind<_Alloc, _Tp, true>
  {
      typedef typename _Alloc::template rebind< _Tp>::other __type;
  };
  template <   template < typename __type_tpl__param_1_0__, typename ...__type_tpl__param_1_1__ > class _Alloc, typename _Tp, typename _Up, typename ..._Args >
  struct  __alloctr_rebind<_Alloc<_Up, _Args ...>, _Tp, false>
  {
      typedef _Alloc<_Tp, _Args ...> __type;
  };
  template < typename _Alloc >
  struct  allocator_traits
  {
      typedef _Alloc allocator_type;
      typedef typename _Alloc::value_type value_type;
    private:
      template < typename _Tp >
      static typename _Tp::pointer _S_pointer_helper(_Tp *);
      static typename ::std::allocator_traits<_Alloc>::value_type *_S_pointer_helper(...);
      typedef decltype(_S_pointer_helper((_Alloc *)0)) __pointer;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__pointer pointer;
    private:
      template < typename _Tp >
      static typename _Tp::const_pointer _S_const_pointer_helper(_Tp *);
      static typename ::std::pointer_traits<typename ::std::allocator_traits<_Alloc>::pointer>::template rebind< const typename ::std::allocator_traits<_Alloc>::value_type> _S_const_pointer_helper(...);
      typedef decltype(_S_const_pointer_helper((_Alloc *)0)) __const_pointer;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__const_pointer const_pointer;
    private:
      template < typename _Tp >
      static typename _Tp::void_pointer _S_void_pointer_helper(_Tp *);
      static typename ::std::pointer_traits<typename ::std::allocator_traits<_Alloc>::pointer>::template rebind< void> _S_void_pointer_helper(...);
      typedef decltype(_S_void_pointer_helper((_Alloc *)0)) __void_pointer;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__void_pointer void_pointer;
    private:
      template < typename _Tp >
      static typename _Tp::const_void_pointer _S_const_void_pointer_helper(_Tp *);
      static typename ::std::pointer_traits<typename ::std::allocator_traits<_Alloc>::pointer>::template rebind< const void> _S_const_void_pointer_helper(...);
      typedef decltype(_S_const_void_pointer_helper((_Alloc *)0)) __const_void_pointer;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__const_void_pointer const_void_pointer;
    private:
      template < typename _Tp >
      static typename _Tp::difference_type _S_difference_type_helper(_Tp *);
      static typename ::std::pointer_traits<typename ::std::allocator_traits<_Alloc>::pointer>::difference_type _S_difference_type_helper(...);
      typedef decltype(_S_difference_type_helper((_Alloc *)0)) __difference_type;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__difference_type difference_type;
    private:
      template < typename _Tp >
      static typename _Tp::size_type _S_size_type_helper(_Tp *);
      static typename ::std::make_unsigned<typename ::std::allocator_traits<_Alloc>::difference_type>::type _S_size_type_helper(...);
      typedef decltype(_S_size_type_helper((_Alloc *)0)) __size_type;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__size_type size_type;
    private:
      template < typename _Tp >
      static typename _Tp::propagate_on_container_copy_assignment _S_propagate_on_container_copy_assignment_helper(_Tp *);
      static ::std::false_type _S_propagate_on_container_copy_assignment_helper(...);
      typedef decltype(_S_propagate_on_container_copy_assignment_helper((_Alloc *)0)) __propagate_on_container_copy_assignment;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__propagate_on_container_copy_assignment propagate_on_container_copy_assignment;
    private:
      template < typename _Tp >
      static typename _Tp::propagate_on_container_move_assignment _S_propagate_on_container_move_assignment_helper(_Tp *);
      static ::std::false_type _S_propagate_on_container_move_assignment_helper(...);
      typedef decltype(_S_propagate_on_container_move_assignment_helper((_Alloc *)0)) __propagate_on_container_move_assignment;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__propagate_on_container_move_assignment propagate_on_container_move_assignment;
    private:
      template < typename _Tp >
      static typename _Tp::propagate_on_container_swap _S_propagate_on_container_swap_helper(_Tp *);
      static ::std::false_type _S_propagate_on_container_swap_helper(...);
      typedef decltype(_S_propagate_on_container_swap_helper((_Alloc *)0)) __propagate_on_container_swap;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__propagate_on_container_swap propagate_on_container_swap;
      template < typename _Tp >
      using rebind_alloc = typename ::std::__alloctr_rebind<_Alloc, _Tp>::__type;
      template < typename _Tp >
      using rebind_traits = ::std::allocator_traits<typename ::std::allocator_traits<_Alloc>::template rebind_alloc<_Tp> >;
    private:
      template < typename _Alloc2 >
      struct  __allocate_helper
      {
          template < typename _Alloc3, typename __type_tpl__param_3_1__ = decltype(std::declval<_Alloc3 *>()->allocate(std::declval<typename ::std::allocator_traits<_Alloc>::size_type>(), std::declval<typename ::std::allocator_traits<_Alloc>::const_void_pointer>())) >
          static ::std::true_type __test(int);
          template < typename __type_tpl__param_3_0__ >
          static ::std::false_type __test(...);
          typedef decltype(__test<_Alloc>(0)) type;
          static const bool value = type::value;
      };
      template < typename _Alloc2 >
      static inline typename ::std::enable_if<__allocate_helper<_Alloc2>::value, typename ::std::allocator_traits<_Alloc>::pointer>::type _S_allocate(_Alloc2 &__a, typename ::std::allocator_traits<_Alloc>::size_type __n, typename ::std::allocator_traits<_Alloc>::const_void_pointer __hint)
      {
        return __a.allocate(__n, __hint);
      }
      template < typename _Alloc2 >
      static inline typename ::std::enable_if<!__allocate_helper<_Alloc2>::value, typename ::std::allocator_traits<_Alloc>::pointer>::type _S_allocate(_Alloc2 &__a, typename ::std::allocator_traits<_Alloc>::size_type __n, ...)
      {
        return __a.allocate(__n);
      }
      template < typename _Tp, typename ..._Args >
      struct  __construct_helper
      {
          template < typename _Alloc2, typename __type_tpl__param_3_1__ = decltype(std::declval<_Alloc2 *>()->construct(std::declval<_Tp *>(), std::declval<_Args>() ...)) >
          static ::std::true_type __test(int);
          template < typename __type_tpl__param_3_0__ >
          static ::std::false_type __test(...);
          typedef decltype(__test<_Alloc>(0)) type;
          static const bool value = type::value;
      };
      template < typename _Tp, typename ..._Args >
      static inline typename ::std::enable_if<__construct_helper<_Tp, _Args ...>::value, void>::type _S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args)
      {
        __a.construct(__p, std::forward<_Args>(__args) ...);
      }
      template < typename _Tp, typename ..._Args >
      static inline typename ::std::enable_if<__and_< ::std::__not_<typename ::std::allocator_traits<_Alloc>::template __construct_helper<_Tp, _Args ...> >, ::std::is_constructible<_Tp, _Args ...> >::value, void>::type _S_construct(_Alloc &, _Tp *__p, _Args &&...__args)
      {
        ::new ((void *)__p)_Tp(std::forward<_Args>(__args) ...);
      }
      template < typename _Tp >
      struct  __destroy_helper
      {
          template < typename _Alloc2, typename __type_tpl__param_3_1__ = decltype(std::declval<_Alloc2 *>()->destroy(std::declval<_Tp *>())) >
          static ::std::true_type __test(int);
          template < typename __type_tpl__param_3_0__ >
          static ::std::false_type __test(...);
          typedef decltype(__test<_Alloc>(0)) type;
          static const bool value = type::value;
      };
      template < typename _Tp >
      static inline typename ::std::enable_if<__destroy_helper<_Tp>::value, void>::type _S_destroy(_Alloc &__a, _Tp *__p)
      {
        __a.destroy(__p);
      }
      template < typename _Tp >
      static inline typename ::std::enable_if<!__destroy_helper<_Tp>::value, void>::type _S_destroy(_Alloc &, _Tp *__p)
      {
        __p->~_Tp();
      }
      template < typename _Alloc2 >
      struct  __maxsize_helper
      {
          template < typename _Alloc3, typename __type_tpl__param_3_1__ = decltype(std::declval<_Alloc3 *>()->max_size()) >
          static ::std::true_type __test(int);
          template < typename __type_tpl__param_3_0__ >
          static ::std::false_type __test(...);
          typedef decltype(__test<_Alloc2>(0)) type;
          static const bool value = type::value;
      };
      template < typename _Alloc2 >
      static inline typename ::std::enable_if<__maxsize_helper<_Alloc2>::value, typename ::std::allocator_traits<_Alloc>::size_type>::type _S_max_size(_Alloc2 &__a)
      {
        return __a.max_size();
      }
      template < typename _Alloc2 >
      static inline typename ::std::enable_if<!__maxsize_helper<_Alloc2>::value, typename ::std::allocator_traits<_Alloc>::size_type>::type _S_max_size(_Alloc2 &)
      {
        return __gnu_cxx::__numeric_traits<typename ::std::allocator_traits<_Alloc>::size_type>::__max;
      }
      template < typename _Alloc2 >
      struct  __select_helper
      {
          template < typename _Alloc3, typename __type_tpl__param_3_1__ = decltype(std::declval<_Alloc3 *>()->select_on_container_copy_construction()) >
          static ::std::true_type __test(int);
          template < typename __type_tpl__param_3_0__ >
          static ::std::false_type __test(...);
          typedef decltype(__test<_Alloc2>(0)) type;
          static const bool value = type::value;
      };
      template < typename _Alloc2 >
      static inline typename ::std::enable_if<__select_helper<_Alloc2>::value, _Alloc2>::type _S_select(_Alloc2 &__a)
      {
        return __a.select_on_container_copy_construction();
      }
      template < typename _Alloc2 >
      static inline typename ::std::enable_if<!__select_helper<_Alloc2>::value, _Alloc2>::type _S_select(_Alloc2 &__a)
      {
        return __a;
      }
    public:
      static inline typename ::std::allocator_traits<_Alloc>::pointer allocate(_Alloc &__a, typename ::std::allocator_traits<_Alloc>::size_type __n)
      {
        return __a.allocate(__n);
      }
      static inline typename ::std::allocator_traits<_Alloc>::pointer allocate(_Alloc &__a, typename ::std::allocator_traits<_Alloc>::size_type __n, typename ::std::allocator_traits<_Alloc>::const_void_pointer __hint)
      {
        return _S_allocate(__a, __n, __hint);
      }
      static inline void deallocate(_Alloc &__a, typename ::std::allocator_traits<_Alloc>::pointer __p, typename ::std::allocator_traits<_Alloc>::size_type __n)
      {
        __a.deallocate(__p, __n);
      }
      template < typename _Tp, typename ..._Args >
      static inline auto construct(_Alloc &__a, _Tp *__p, _Args &&...__args) -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args) ...))
      {
        _S_construct(__a, __p, std::forward<_Args>(__args) ...);
      }
      template < typename _Tp >
      static inline void destroy(_Alloc &__a, _Tp *__p)
      {
        _S_destroy(__a, __p);
      }
      static inline typename ::std::allocator_traits<_Alloc>::size_type max_size(const _Alloc &__a)
      {
        return _S_max_size(__a);
      }
      static inline _Alloc select_on_container_copy_construction(const _Alloc &__rhs)
      {
        return _S_select(__rhs);
      }
  };
  template < typename _Alloc >
  inline void __do_alloc_on_copy(_Alloc &__one, const _Alloc &__two, ::std::true_type);
  template < typename _Alloc >
  inline void __do_alloc_on_copy(_Alloc &__one, const _Alloc &__two, ::std::true_type)
  {
    __one = __two;
  }
  template < typename _Alloc >
  inline void __do_alloc_on_copy(_Alloc &, const _Alloc &, ::std::false_type);
  template < typename _Alloc >
  inline void __do_alloc_on_copy(_Alloc &, const _Alloc &, ::std::false_type)
  {
  }
  template < typename _Alloc >
  inline void __alloc_on_copy(_Alloc &__one, const _Alloc &__two);
  template < typename _Alloc >
  inline void __alloc_on_copy(_Alloc &__one, const _Alloc &__two)
  {
    typedef ::std::allocator_traits<_Alloc> __traits;
    typedef typename ::std::allocator_traits<_Alloc>::propagate_on_container_copy_assignment __pocca;
    __do_alloc_on_copy(__one, __two, __pocca());
  }
  template < typename _Alloc >
  inline _Alloc __alloc_on_copy(const _Alloc &__a);
  template < typename _Alloc >
  inline _Alloc __alloc_on_copy(const _Alloc &__a)
  {
    typedef ::std::allocator_traits<_Alloc> __traits;
    return __traits::select_on_container_copy_construction(__a);
  }
  template < typename _Alloc >
  inline void __do_alloc_on_move(_Alloc &__one, _Alloc &__two, ::std::true_type);
  template < typename _Alloc >
  inline void __do_alloc_on_move(_Alloc &__one, _Alloc &__two, ::std::true_type)
  {
    __one = std::move(__two);
  }
  template < typename _Alloc >
  inline void __do_alloc_on_move(_Alloc &, _Alloc &, ::std::false_type);
  template < typename _Alloc >
  inline void __do_alloc_on_move(_Alloc &, _Alloc &, ::std::false_type)
  {
  }
  template < typename _Alloc >
  inline void __alloc_on_move(_Alloc &__one, _Alloc &__two);
  template < typename _Alloc >
  inline void __alloc_on_move(_Alloc &__one, _Alloc &__two)
  {
    typedef ::std::allocator_traits<_Alloc> __traits;
    typedef typename ::std::allocator_traits<_Alloc>::propagate_on_container_move_assignment __pocma;
    __do_alloc_on_move(__one, __two, __pocma());
  }
  template < typename _Alloc >
  inline void __do_alloc_on_swap(_Alloc &__one, _Alloc &__two, ::std::true_type);
  template < typename _Alloc >
  inline void __do_alloc_on_swap(_Alloc &__one, _Alloc &__two, ::std::true_type)
  {
    using ::std::swap;
    swap(__one, __two);
  }
  template < typename _Alloc >
  inline void __do_alloc_on_swap(_Alloc &, _Alloc &, ::std::false_type);
  template < typename _Alloc >
  inline void __do_alloc_on_swap(_Alloc &, _Alloc &, ::std::false_type)
  {
  }
  template < typename _Alloc >
  inline void __alloc_on_swap(_Alloc &__one, _Alloc &__two);
  template < typename _Alloc >
  inline void __alloc_on_swap(_Alloc &__one, _Alloc &__two)
  {
    typedef ::std::allocator_traits<_Alloc> __traits;
    typedef typename ::std::allocator_traits<_Alloc>::propagate_on_container_swap __pocs;
    __do_alloc_on_swap(__one, __two, __pocs());
  }
  template < typename _Alloc >
  class  __is_copy_insertable_impl
  {
      typedef ::std::allocator_traits<_Alloc> _Traits;
      template < typename _Up, typename __type_tpl__param_2_1__ = decltype(_Traits::construct(std::declval<_Alloc &>(), std::declval<_Up *>(), std::declval<const _Up &>())) >
      static ::std::true_type _M_select(int);
      template < typename _Up >
      static ::std::false_type _M_select(...);
    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
  };
  template < typename _Alloc >
  struct  __is_copy_insertable : ::std::__is_copy_insertable_impl<_Alloc>::type
  {
  };
  template < typename _Tp >
  struct  __is_copy_insertable< ::std::allocator<_Tp> > : ::std::is_copy_constructible<_Tp>
  {
  };
  template < bool __nontype_tpl_param_1_0__ >
  struct  __allow_copy_cons
  {
  };
  template <>
  struct  __allow_copy_cons<false>
  {
      constexpr __allow_copy_cons() = default ;
      __allow_copy_cons(const ::std::__allow_copy_cons<false> &) = delete ;
      __allow_copy_cons(::std::__allow_copy_cons<false> &&) = default ;
      ::std::__allow_copy_cons<false> &operator =(const ::std::__allow_copy_cons<false> &) = default ;
      ::std::__allow_copy_cons<false> &operator =(::std::__allow_copy_cons<false> &&) = default ;
  };
  template < typename _Alloc >
  using __check_copy_constructible = ::std::__allow_copy_cons<__is_copy_insertable<_Alloc>::value>;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < typename _Alloc >
  struct  __allocator_always_compares_equal
  {
      static const bool value = false;
  };
  template < typename _Tp >
  struct  __allocator_always_compares_equal< ::std::allocator<_Tp> >
  {
      static const bool value = true;
  };
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct array_allocator;
  template < typename _Tp, typename _Array >
  struct  __allocator_always_compares_equal< ::__gnu_cxx::array_allocator<_Tp, _Array> >
  {
      static const bool value = true;
  };
  template < typename __type_tpl__param_1_0__ >
  struct bitmap_allocator;
  template < typename _Tp >
  struct  __allocator_always_compares_equal< ::__gnu_cxx::bitmap_allocator<_Tp> >
  {
      static const bool value = true;
  };
  template < typename __type_tpl__param_1_0__ >
  struct malloc_allocator;
  template < typename _Tp >
  struct  __allocator_always_compares_equal< ::__gnu_cxx::malloc_allocator<_Tp> >
  {
      static const bool value = true;
  };
  template < typename __type_tpl__param_1_0__ >
  struct mt_allocator;
  template < typename _Tp >
  struct  __allocator_always_compares_equal< ::__gnu_cxx::mt_allocator<_Tp> >
  {
      static const bool value = true;
  };
  template < typename __type_tpl__param_1_0__ >
  class new_allocator;
  template < typename _Tp >
  struct  __allocator_always_compares_equal< ::__gnu_cxx::new_allocator<_Tp> >
  {
      static const bool value = true;
  };
  template < typename __type_tpl__param_1_0__ >
  struct pool_allocator;
  template < typename _Tp >
  struct  __allocator_always_compares_equal< ::__gnu_cxx::pool_allocator<_Tp> >
  {
      static const bool value = true;
  };
  template < typename _Alloc >
  struct  __alloc_traits : ::std::allocator_traits<_Alloc>
  {
      typedef _Alloc allocator_type;
      typedef ::std::allocator_traits<_Alloc> _Base_type;
      typedef typename ::std::allocator_traits<_Alloc>::value_type value_type;
      typedef typename ::std::allocator_traits<_Alloc>::pointer pointer;
      typedef typename ::std::allocator_traits<_Alloc>::const_pointer const_pointer;
      typedef typename ::std::allocator_traits<_Alloc>::size_type size_type;
      typedef typename ::std::allocator_traits<_Alloc>::difference_type difference_type;
      typedef typename ::__gnu_cxx::__alloc_traits<_Alloc>::value_type &reference;
      typedef const typename ::__gnu_cxx::__alloc_traits<_Alloc>::value_type &const_reference;
      using ::std::allocator_traits<_Alloc>::allocate;
      using ::std::allocator_traits<_Alloc>::deallocate;
      using ::std::allocator_traits<_Alloc>::construct;
      using ::std::allocator_traits<_Alloc>::destroy;
      using ::std::allocator_traits<_Alloc>::max_size;
    private:
      template < typename _Ptr >
      struct  __is_custom_pointer : ::std::integral_constant<bool, std::is_same<typename ::__gnu_cxx::__alloc_traits<_Alloc>::pointer, _Ptr>::value && !std::is_pointer<_Ptr>::value>
      {
      };
    public:
      template < typename _Ptr, typename ..._Args >
      static inline typename ::std::enable_if<__is_custom_pointer<_Ptr>::value>::type construct(_Alloc &__a, _Ptr __p, _Args &&...__args)
      {
        _Base_type::construct(__a, std::addressof(*__p), std::forward<_Args>(__args) ...);
      }
      template < typename _Ptr >
      static inline typename ::std::enable_if<__is_custom_pointer<_Ptr>::value>::type destroy(_Alloc &__a, _Ptr __p)
      {
        _Base_type::destroy(__a, std::addressof(*__p));
      }
      static inline _Alloc _S_select_on_copy(const _Alloc &__a)
      {
        return _Base_type::select_on_container_copy_construction(__a);
      }
      static inline void _S_on_swap(_Alloc &__a, _Alloc &__b)
      {
        std::__alloc_on_swap(__a, __b);
      }
      static inline constexpr bool _S_propagate_on_copy_assign()
      {
        return _Base_type::propagate_on_container_copy_assignment::value;
      }
      static inline constexpr bool _S_propagate_on_move_assign()
      {
        return _Base_type::propagate_on_container_move_assignment::value;
      }
      static inline constexpr bool _S_propagate_on_swap()
      {
        return _Base_type::propagate_on_container_swap::value;
      }
      static inline constexpr bool _S_always_equal()
      {
        return __allocator_always_compares_equal<_Alloc>::value;
      }
      static inline constexpr bool _S_nothrow_move()
      {
        return _S_propagate_on_move_assign() || _S_always_equal();
      }
      static inline constexpr bool _S_nothrow_swap()
      {
        using ::std::swap;
        return !_S_propagate_on_swap() || (noexcept(swap(std::declval<_Alloc &>(), std::declval<_Alloc &>())));
      }
      template < typename _Tp >
      struct  rebind
      {
          typedef typename ::__gnu_cxx::__alloc_traits<_Alloc>::_Base_type::template rebind_alloc< _Tp> other;
      };
  };
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _T1, typename ..._Args >
  inline void _Construct(_T1 *__p, _Args &&...__args);
  template < typename _T1, typename ..._Args >
  inline void _Construct(_T1 *__p, _Args &&...__args)
  {
    ::new (static_cast<void *>(__p))_T1(std::forward<_Args>(__args) ...);
  }
  template < typename _Tp >
  inline void _Destroy(_Tp *__pointer);
  template < typename _Tp >
  inline void _Destroy(_Tp *__pointer)
  {
    __pointer->~_Tp();
  }
  template < bool __nontype_tpl_param_1_0__ >
  struct  _Destroy_aux
  {
      template < typename _ForwardIterator >
      static inline void __destroy(_ForwardIterator __first, _ForwardIterator __last)
      {
        for (; __first != __last;  ++__first)
          {
            std::_Destroy(std::__addressof(*__first));
          }
      }
  };
  template <>
  struct  _Destroy_aux<true>
  {
      template < typename _ForwardIterator >
      static inline void __destroy(_ForwardIterator, _ForwardIterator)
      {
      }
  };
  template < typename _ForwardIterator >
  inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last);
  template < typename _ForwardIterator >
  inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _Value_type;
    std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::__destroy(__first, __last);
  }
  template < typename _ForwardIterator, typename _Allocator >
  void _Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc);
  template < typename _ForwardIterator, typename _Allocator >
  void _Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc)
  {
    typedef ::__gnu_cxx::__alloc_traits<_Allocator> __traits;
    for (; __first != __last;  ++__first)
      {
        __traits::destroy(__alloc, std::__addressof(*__first));
      }
  }
  template < typename _ForwardIterator, typename _Tp >
  inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last, ::std::allocator<_Tp> &);
  template < typename _ForwardIterator, typename _Tp >
  inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last, ::std::allocator<_Tp> &)
  {
    _Destroy(__first, __last);
  }
  template < bool _TrivialValueTypes >
  struct  __uninitialized_copy
  {
      template < typename _InputIterator, typename _ForwardIterator >
      static inline _ForwardIterator __uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result)
      {
        _ForwardIterator __cur = __result;
        try
        {
          for (; __first != __last; ( ++__first,  ++__cur))
            {
              std::_Construct(std::__addressof(*__cur), *__first);
            }
          return __cur;
        }
        catch (...)
        {
          std::_Destroy(__result, __cur);
          throw;
        }
      }
  };
  template <>
  struct  __uninitialized_copy<true>
  {
      template < typename _InputIterator, typename _ForwardIterator >
      static inline _ForwardIterator __uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result)
      {
        return std::copy(__first, __last, __result);
      }
  };
  template < typename _InputIterator, typename _ForwardIterator >
  inline _ForwardIterator uninitialized_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result);
  template < typename _InputIterator, typename _ForwardIterator >
  inline _ForwardIterator uninitialized_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType2;
    return std::__uninitialized_copy<(__is_trivial(_ValueType1)) && (__is_trivial(_ValueType2))>::__uninit_copy(__first, __last, __result);
  }
  template < bool _TrivialValueType >
  struct  __uninitialized_fill
  {
      template < typename _ForwardIterator, typename _Tp >
      static inline void __uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x)
      {
        _ForwardIterator __cur = __first;
        try
        {
          for (; __cur != __last;  ++__cur)
            {
              std::_Construct(std::__addressof(*__cur), __x);
            }
        }
        catch (...)
        {
          std::_Destroy(__first, __cur);
          throw;
        }
      }
  };
  template <>
  struct  __uninitialized_fill<true>
  {
      template < typename _ForwardIterator, typename _Tp >
      static inline void __uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x)
      {
        std::fill(__first, __last, __x);
      }
  };
  template < typename _ForwardIterator, typename _Tp >
  inline void uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x);
  template < typename _ForwardIterator, typename _Tp >
  inline void uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    std::__uninitialized_fill<__is_trivial(_ValueType)>::__uninit_fill(__first, __last, __x);
  }
  template < bool _TrivialValueType >
  struct  __uninitialized_fill_n
  {
      template < typename _ForwardIterator, typename _Size, typename _Tp >
      static inline void __uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x)
      {
        _ForwardIterator __cur = __first;
        try
        {
          for (; __n > 0; ( --__n,  ++__cur))
            {
              std::_Construct(std::__addressof(*__cur), __x);
            }
        }
        catch (...)
        {
          std::_Destroy(__first, __cur);
          throw;
        }
      }
  };
  template <>
  struct  __uninitialized_fill_n<true>
  {
      template < typename _ForwardIterator, typename _Size, typename _Tp >
      static inline void __uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x)
      {
        std::fill_n(__first, __n, __x);
      }
  };
  template < typename _ForwardIterator, typename _Size, typename _Tp >
  inline void uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x);
  template < typename _ForwardIterator, typename _Size, typename _Tp >
  inline void uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    std::__uninitialized_fill_n<__is_trivial(_ValueType)>::__uninit_fill_n(__first, __n, __x);
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc)
  {
    _ForwardIterator __cur = __result;
    try
    {
      typedef ::__gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ( ++__first,  ++__cur))
        {
          __traits::construct(__alloc, std::__addressof(*__cur), *__first);
        }
      return __cur;
    }
    catch (...)
    {
      std::_Destroy(__result, __cur, __alloc);
      throw;
    }
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Tp >
  inline _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, ::std::allocator<_Tp> &);
  template < typename _InputIterator, typename _ForwardIterator, typename _Tp >
  inline _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, ::std::allocator<_Tp> &)
  {
    return std::uninitialized_copy(__first, __last, __result);
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc)
  {
    return std::__uninitialized_copy_a(std::make_move_iterator(__first), std::make_move_iterator(__last), __result, __alloc);
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_if_noexcept_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_if_noexcept_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc)
  {
    return std::__uninitialized_copy_a(std::__make_move_if_noexcept_iterator(__first), std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
  }
  template < typename _ForwardIterator, typename _Tp, typename _Allocator >
  void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, _Allocator &__alloc);
  template < typename _ForwardIterator, typename _Tp, typename _Allocator >
  void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, _Allocator &__alloc)
  {
    _ForwardIterator __cur = __first;
    try
    {
      typedef ::__gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __cur != __last;  ++__cur)
        {
          __traits::construct(__alloc, std::__addressof(*__cur), __x);
        }
    }
    catch (...)
    {
      std::_Destroy(__first, __cur, __alloc);
      throw;
    }
  }
  template < typename _ForwardIterator, typename _Tp, typename _Tp2 >
  inline void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, ::std::allocator<_Tp2> &);
  template < typename _ForwardIterator, typename _Tp, typename _Tp2 >
  inline void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, ::std::allocator<_Tp2> &)
  {
    std::uninitialized_fill(__first, __last, __x);
  }
  template < typename _ForwardIterator, typename _Size, typename _Tp, typename _Allocator >
  void __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, _Allocator &__alloc);
  template < typename _ForwardIterator, typename _Size, typename _Tp, typename _Allocator >
  void __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, _Allocator &__alloc)
  {
    _ForwardIterator __cur = __first;
    try
    {
      typedef ::__gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __n > 0; ( --__n,  ++__cur))
        {
          __traits::construct(__alloc, std::__addressof(*__cur), __x);
        }
    }
    catch (...)
    {
      std::_Destroy(__first, __cur, __alloc);
      throw;
    }
  }
  template < typename _ForwardIterator, typename _Size, typename _Tp, typename _Tp2 >
  inline void __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, ::std::allocator<_Tp2> &);
  template < typename _ForwardIterator, typename _Size, typename _Tp, typename _Tp2 >
  inline void __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &__x, ::std::allocator<_Tp2> &)
  {
    std::uninitialized_fill_n(__first, __n, __x);
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_copy_move(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_copy_move(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc)
  {
    _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1, __result, __alloc);
    try
    {
      return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
    }
    catch (...)
    {
      std::_Destroy(__result, __mid, __alloc);
      throw;
    }
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_copy(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc);
  template < typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_move_copy(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc)
  {
    _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1, __result, __alloc);
    try
    {
      return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
    }
    catch (...)
    {
      std::_Destroy(__result, __mid, __alloc);
      throw;
    }
  }
  template < typename _ForwardIterator, typename _Tp, typename _InputIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid, const _Tp &__x, _InputIterator __first, _InputIterator __last, _Allocator &__alloc);
  template < typename _ForwardIterator, typename _Tp, typename _InputIterator, typename _Allocator >
  inline _ForwardIterator __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid, const _Tp &__x, _InputIterator __first, _InputIterator __last, _Allocator &__alloc)
  {
    std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
    try
    {
      return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
    }
    catch (...)
    {
      std::_Destroy(__result, __mid, __alloc);
      throw;
    }
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _Tp, typename _Allocator >
  inline void __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, const _Tp &__x, _Allocator &__alloc);
  template < typename _InputIterator, typename _ForwardIterator, typename _Tp, typename _Allocator >
  inline void __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, const _Tp &__x, _Allocator &__alloc)
  {
    _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1, __first2, __alloc);
    try
    {
      std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
    }
    catch (...)
    {
      std::_Destroy(__first2, __mid2, __alloc);
      throw;
    }
  }
  template < bool _TrivialValueType >
  struct  __uninitialized_default_1
  {
      template < typename _ForwardIterator >
      static inline void __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
      {
        _ForwardIterator __cur = __first;
        try
        {
          for (; __cur != __last;  ++__cur)
            {
              std::_Construct(std::__addressof(*__cur));
            }
        }
        catch (...)
        {
          std::_Destroy(__first, __cur);
          throw;
        }
      }
  };
  template <>
  struct  __uninitialized_default_1<true>
  {
      template < typename _ForwardIterator >
      static inline void __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
      {
        typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
        std::fill(__first, __last, _ValueType());
      }
  };
  template < bool _TrivialValueType >
  struct  __uninitialized_default_n_1
  {
      template < typename _ForwardIterator, typename _Size >
      static inline void __uninit_default_n(_ForwardIterator __first, _Size __n)
      {
        _ForwardIterator __cur = __first;
        try
        {
          for (; __n > 0; ( --__n,  ++__cur))
            {
              std::_Construct(std::__addressof(*__cur));
            }
        }
        catch (...)
        {
          std::_Destroy(__first, __cur);
          throw;
        }
      }
  };
  template <>
  struct  __uninitialized_default_n_1<true>
  {
      template < typename _ForwardIterator, typename _Size >
      static inline void __uninit_default_n(_ForwardIterator __first, _Size __n)
      {
        typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
        std::fill_n(__first, __n, _ValueType());
      }
  };
  template < typename _ForwardIterator >
  inline void __uninitialized_default(_ForwardIterator __first, _ForwardIterator __last);
  template < typename _ForwardIterator >
  inline void __uninitialized_default(_ForwardIterator __first, _ForwardIterator __last)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    std::__uninitialized_default_1<__is_trivial(_ValueType)>::__uninit_default(__first, __last);
  }
  template < typename _ForwardIterator, typename _Size >
  inline void __uninitialized_default_n(_ForwardIterator __first, _Size __n);
  template < typename _ForwardIterator, typename _Size >
  inline void __uninitialized_default_n(_ForwardIterator __first, _Size __n)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    std::__uninitialized_default_n_1<__is_trivial(_ValueType)>::__uninit_default_n(__first, __n);
  }
  template < typename _ForwardIterator, typename _Allocator >
  void __uninitialized_default_a(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc);
  template < typename _ForwardIterator, typename _Allocator >
  void __uninitialized_default_a(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc)
  {
    _ForwardIterator __cur = __first;
    try
    {
      typedef ::__gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __cur != __last;  ++__cur)
        {
          __traits::construct(__alloc, std::__addressof(*__cur));
        }
    }
    catch (...)
    {
      std::_Destroy(__first, __cur, __alloc);
      throw;
    }
  }
  template < typename _ForwardIterator, typename _Tp >
  inline void __uninitialized_default_a(_ForwardIterator __first, _ForwardIterator __last, ::std::allocator<_Tp> &);
  template < typename _ForwardIterator, typename _Tp >
  inline void __uninitialized_default_a(_ForwardIterator __first, _ForwardIterator __last, ::std::allocator<_Tp> &)
  {
    std::__uninitialized_default(__first, __last);
  }
  template < typename _ForwardIterator, typename _Size, typename _Allocator >
  void __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, _Allocator &__alloc);
  template < typename _ForwardIterator, typename _Size, typename _Allocator >
  void __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, _Allocator &__alloc)
  {
    _ForwardIterator __cur = __first;
    try
    {
      typedef ::__gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __n > 0; ( --__n,  ++__cur))
        {
          __traits::construct(__alloc, std::__addressof(*__cur));
        }
    }
    catch (...)
    {
      std::_Destroy(__first, __cur, __alloc);
      throw;
    }
  }
  template < typename _ForwardIterator, typename _Size, typename _Tp >
  inline void __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, ::std::allocator<_Tp> &);
  template < typename _ForwardIterator, typename _Size, typename _Tp >
  inline void __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, ::std::allocator<_Tp> &)
  {
    std::__uninitialized_default_n(__first, __n);
  }
  template < typename _InputIterator, typename _Size, typename _ForwardIterator >
  _ForwardIterator __uninitialized_copy_n(_InputIterator __first, _Size __n, _ForwardIterator __result, ::std::input_iterator_tag);
  template < typename _InputIterator, typename _Size, typename _ForwardIterator >
  _ForwardIterator __uninitialized_copy_n(_InputIterator __first, _Size __n, _ForwardIterator __result, ::std::input_iterator_tag)
  {
    _ForwardIterator __cur = __result;
    try
    {
      for (; __n > 0; ((( --__n,  ++__first)),  ++__cur))
        {
          std::_Construct(std::__addressof(*__cur), *__first);
        }
      return __cur;
    }
    catch (...)
    {
      std::_Destroy(__result, __cur);
      throw;
    }
  }
  template < typename _RandomAccessIterator, typename _Size, typename _ForwardIterator >
  inline _ForwardIterator __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n, _ForwardIterator __result, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator, typename _Size, typename _ForwardIterator >
  inline _ForwardIterator __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n, _ForwardIterator __result, ::std::random_access_iterator_tag)
  {
    return std::uninitialized_copy(__first, __first + __n, __result);
  }
  template < typename _InputIterator, typename _Size, typename _ForwardIterator >
  inline _ForwardIterator uninitialized_copy_n(_InputIterator __first, _Size __n, _ForwardIterator __result);
  template < typename _InputIterator, typename _Size, typename _ForwardIterator >
  inline _ForwardIterator uninitialized_copy_n(_InputIterator __first, _Size __n, _ForwardIterator __result)
  {
    return std::__uninitialized_copy_n(__first, __n, __result, std::__iterator_category(__first));
  }
  template < typename _Tp, typename _Alloc >
  struct  _Vector_base
  {
      typedef typename ::__gnu_cxx::__alloc_traits<_Alloc>::template rebind< _Tp>::other _Tp_alloc_type;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type>::pointer pointer;
      struct  _Vector_impl : ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type
      {
          typename ::std::_Vector_base<_Tp, _Alloc>::pointer _M_start;
          typename ::std::_Vector_base<_Tp, _Alloc>::pointer _M_finish;
          typename ::std::_Vector_base<_Tp, _Alloc>::pointer _M_end_of_storage;
          inline _Vector_impl()
            : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
          {
          }
          inline _Vector_impl(const typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type &__a)
            : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
          {
          }
          inline _Vector_impl(typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type &&__a)
            : _Tp_alloc_type(std::move(__a)), _M_start(0), _M_finish(0), _M_end_of_storage(0)
          {
          }
          inline void _M_swap_data(typename ::std::_Vector_base<_Tp, _Alloc>::_Vector_impl &__x)
          {
            std::swap(::std::_Vector_base<_Tp, _Alloc>::_Vector_impl::_M_start, __x._M_start);
            std::swap(::std::_Vector_base<_Tp, _Alloc>::_Vector_impl::_M_finish, __x._M_finish);
            std::swap(::std::_Vector_base<_Tp, _Alloc>::_Vector_impl::_M_end_of_storage, __x._M_end_of_storage);
          }
      };
      typedef _Alloc allocator_type;
      inline typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type &_M_get_Tp_allocator() noexcept(true)
      {
        return *static_cast<typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type *>(&this->_M_impl);
      }
      inline const typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type &_M_get_Tp_allocator() const  noexcept(true)
      {
        return *static_cast<const typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type *>(&this->_M_impl);
      }
      inline typename ::std::_Vector_base<_Tp, _Alloc>::allocator_type get_allocator() const  noexcept(true)
      {
        return ((typename ::std::_Vector_base<_Tp, _Alloc>::allocator_type((*this)._M_get_Tp_allocator())));
      }
      inline _Vector_base()
        : _M_impl()
      {
      }
      inline _Vector_base(const typename ::std::_Vector_base<_Tp, _Alloc>::allocator_type &__a)
        : _M_impl(__a)
      {
      }
      inline _Vector_base(::std::size_t __n)
        : _M_impl()
      {
        (*this)._M_create_storage(__n);
      }
      inline _Vector_base(::std::size_t __n, const typename ::std::_Vector_base<_Tp, _Alloc>::allocator_type &__a)
        : _M_impl(__a)
      {
        (*this)._M_create_storage(__n);
      }
      inline _Vector_base(typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type &&__a)
        : _M_impl(std::move(__a))
      {
      }
      inline _Vector_base(::std::_Vector_base<_Tp, _Alloc> &&__x)
        : _M_impl(std::move(__x._M_get_Tp_allocator()))
      {
        this->_M_impl._M_swap_data(__x._M_impl);
      }
      inline _Vector_base(::std::_Vector_base<_Tp, _Alloc> &&__x, const typename ::std::_Vector_base<_Tp, _Alloc>::allocator_type &__a)
        : _M_impl(__a)
      {
        if (__x.get_allocator() == __a)
          {
            this->_M_impl._M_swap_data(__x._M_impl);
          }
        else
          {
            ::std::size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
            (*this)._M_create_storage(__n);
          }
      }
      inline ~_Vector_base()
      {
        (*this)._M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
      }
      typename ::std::_Vector_base<_Tp, _Alloc>::_Vector_impl _M_impl;
      inline typename ::std::_Vector_base<_Tp, _Alloc>::pointer _M_allocate(::std::size_t __n)
      {
        return __n != 0 ? ::std::_Vector_base<_Tp, _Alloc>::_M_impl.allocate(__n) : 0;
      }
      inline void _M_deallocate(typename ::std::_Vector_base<_Tp, _Alloc>::pointer __p, ::std::size_t __n)
      {
        if (__p)
          {
            ::std::_Vector_base<_Tp, _Alloc>::_M_impl.deallocate(__p, __n);
          }
      }
    private:
      inline void _M_create_storage(::std::size_t __n)
      {
        this->_M_impl._M_start = this->_M_allocate(__n);
        this->_M_impl._M_finish = this->_M_impl._M_start;
        this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
  };
  template < typename _Tp, typename _Alloc = ::std::allocator<_Tp> >
  class  vector : protected ::std::_Vector_base<_Tp, _Alloc>
  {
      typedef typename _Alloc::value_type _Alloc_value_type;
      typedef ::std::_Vector_base<_Tp, _Alloc> _Base;
      typedef typename ::std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type _Tp_alloc_type;
      typedef ::__gnu_cxx::__alloc_traits<typename ::std::vector<_Tp, _Alloc>::_Tp_alloc_type> _Alloc_traits;
    public:
      typedef _Tp value_type;
      typedef typename ::std::_Vector_base<_Tp, _Alloc>::pointer pointer;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::vector<_Tp, _Alloc>::_Tp_alloc_type>::const_pointer const_pointer;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::vector<_Tp, _Alloc>::_Tp_alloc_type>::reference reference;
      typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::vector<_Tp, _Alloc>::_Tp_alloc_type>::const_reference const_reference;
      typedef ::__gnu_cxx::__normal_iterator<typename ::std::vector<_Tp, _Alloc>::pointer, ::std::vector<_Tp, _Alloc> > iterator;
      typedef ::__gnu_cxx::__normal_iterator<typename ::std::vector<_Tp, _Alloc>::const_pointer, ::std::vector<_Tp, _Alloc> > const_iterator;
      typedef ::std::reverse_iterator<typename ::std::vector<_Tp, _Alloc>::const_iterator> const_reverse_iterator;
      typedef ::std::reverse_iterator<typename ::std::vector<_Tp, _Alloc>::iterator> reverse_iterator;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
    protected:
      using ::std::_Vector_base<_Tp, _Alloc>::_M_allocate;
      using ::std::_Vector_base<_Tp, _Alloc>::_M_deallocate;
      using ::std::_Vector_base<_Tp, _Alloc>::_M_impl;
      using ::std::_Vector_base<_Tp, _Alloc>::_M_get_Tp_allocator;
    public:
      inline vector()
        : _Base()
      {
      }
      inline explicit vector(const typename ::std::vector<_Tp, _Alloc>::allocator_type &__a)
        : _Base(__a)
      {
      }
      inline explicit vector(typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::allocator_type &__a  = (((typename ::std::vector<_Tp, _Alloc>::allocator_type()))))
        : _Base(__n, __a)
      {
        (*this)._M_default_initialize(__n);
      }
      inline vector(typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__value, const typename ::std::vector<_Tp, _Alloc>::allocator_type &__a  = (((typename ::std::vector<_Tp, _Alloc>::allocator_type()))))
        : _Base(__n, __a)
      {
        (*this)._M_fill_initialize(__n, __value);
      }
      inline vector(const ::std::vector<_Tp, _Alloc> &__x)
        : _Base(__x.size(), _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      {
        this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, (_M_get_Tp_allocator)());
      }
      inline vector(::std::vector<_Tp, _Alloc> &&__x) noexcept(true)
        : _Base(std::move(__x))
      {
      }
      inline vector(const ::std::vector<_Tp, _Alloc> &__x, const typename ::std::vector<_Tp, _Alloc>::allocator_type &__a)
        : _Base(__x.size(), __a)
      {
        this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, (_M_get_Tp_allocator)());
      }
      inline vector(::std::vector<_Tp, _Alloc> &&__rv, const typename ::std::vector<_Tp, _Alloc>::allocator_type &__m)
        : _Base(std::move(__rv), __m)
      {
        if (__rv.get_allocator() != __m)
          {
            this->_M_impl._M_finish = std::__uninitialized_move_a(__rv.begin(), __rv.end(), this->_M_impl._M_start, (_M_get_Tp_allocator)());
            __rv.clear();
          }
      }
      inline vector(::std::initializer_list<typename ::std::vector<_Tp, _Alloc>::value_type> __l, const typename ::std::vector<_Tp, _Alloc>::allocator_type &__a  = (((typename ::std::vector<_Tp, _Alloc>::allocator_type()))))
        : _Base(__a)
      {
        (*this)._M_range_initialize(__l.begin(), __l.end(), ::std::random_access_iterator_tag());
      }
      template < typename _InputIterator, typename __type_tpl__param_2_1__ = ::std::_RequireInputIter<_InputIterator> >
      inline vector(_InputIterator __first, _InputIterator __last, const typename ::std::vector<_Tp, _Alloc>::allocator_type &__a  = (((typename ::std::vector<_Tp, _Alloc>::allocator_type()))))
        : _Base(__a)
      {
        (*this)._M_initialize_dispatch(__first, __last, ::std::__false_type());
      }
      inline ~vector() noexcept(true)
      {
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
      }
      ::std::vector<_Tp, _Alloc> &operator =(const ::std::vector<_Tp, _Alloc> &__x);
      inline ::std::vector<_Tp, _Alloc> &operator =(::std::vector<_Tp, _Alloc> &&__x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
        constexpr const bool __move_storage = _Alloc_traits::_S_propagate_on_move_assign() || _Alloc_traits::_S_always_equal();
        (*this)._M_move_assign(std::move(__x), ::std::integral_constant<bool, __move_storage>());
        return *this;
      }
      inline ::std::vector<_Tp, _Alloc> &operator =(::std::initializer_list<typename ::std::vector<_Tp, _Alloc>::value_type> __l)
      {
        this->assign(__l.begin(), __l.end());
        return *this;
      }
      inline void assign(typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__val)
      {
        (*this)._M_fill_assign(__n, __val);
      }
      template < typename _InputIterator, typename __type_tpl__param_2_1__ = ::std::_RequireInputIter<_InputIterator> >
      inline void assign(_InputIterator __first, _InputIterator __last)
      {
        (*this)._M_assign_dispatch(__first, __last, ::std::__false_type());
      }
      inline void assign(::std::initializer_list<typename ::std::vector<_Tp, _Alloc>::value_type> __l)
      {
        this->assign(__l.begin(), __l.end());
      }
      using ::std::_Vector_base<_Tp, _Alloc>::get_allocator;
      inline typename ::std::vector<_Tp, _Alloc>::iterator begin() noexcept(true)
      {
        return ((typename ::std::vector<_Tp, _Alloc>::iterator(this->_M_impl._M_start)));
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_iterator begin() const  noexcept(true)
      {
        return ((typename ::std::vector<_Tp, _Alloc>::const_iterator(this->_M_impl._M_start)));
      }
      inline typename ::std::vector<_Tp, _Alloc>::iterator end() noexcept(true)
      {
        return ((typename ::std::vector<_Tp, _Alloc>::iterator(this->_M_impl._M_finish)));
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_iterator end() const  noexcept(true)
      {
        return ((typename ::std::vector<_Tp, _Alloc>::const_iterator(this->_M_impl._M_finish)));
      }
      inline typename ::std::vector<_Tp, _Alloc>::reverse_iterator rbegin() noexcept(true)
      {
        return ((typename ::std::vector<_Tp, _Alloc>::reverse_iterator((*this).end())));
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reverse_iterator rbegin() const  noexcept(true)
      {
        return ((typename ::std::vector<_Tp, _Alloc>::const_reverse_iterator((*this).end())));
      }
      inline typename ::std::vector<_Tp, _Alloc>::reverse_iterator rend() noexcept(true)
      {
        return ((typename ::std::vector<_Tp, _Alloc>::reverse_iterator((*this).begin())));
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reverse_iterator rend() const  noexcept(true)
      {
        return ((typename ::std::vector<_Tp, _Alloc>::const_reverse_iterator((*this).begin())));
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_iterator cbegin() const  noexcept(true)
      {
        return ((typename ::std::vector<_Tp, _Alloc>::const_iterator(this->_M_impl._M_start)));
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_iterator cend() const  noexcept(true)
      {
        return ((typename ::std::vector<_Tp, _Alloc>::const_iterator(this->_M_impl._M_finish)));
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reverse_iterator crbegin() const  noexcept(true)
      {
        return ((typename ::std::vector<_Tp, _Alloc>::const_reverse_iterator((*this).end())));
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reverse_iterator crend() const  noexcept(true)
      {
        return ((typename ::std::vector<_Tp, _Alloc>::const_reverse_iterator((*this).begin())));
      }
      inline typename ::std::vector<_Tp, _Alloc>::size_type size() const  noexcept(true)
      {
        return ((typename ::std::vector<_Tp, _Alloc>::size_type(this->_M_impl._M_finish - this->_M_impl._M_start)));
      }
      inline typename ::std::vector<_Tp, _Alloc>::size_type max_size() const  noexcept(true)
      {
        return _Alloc_traits::max_size((_M_get_Tp_allocator)());
      }
      inline void resize(typename ::std::vector<_Tp, _Alloc>::size_type __new_size)
      {
        if (__new_size > (*this).size())
          {
            (*this)._M_default_append(__new_size - (*this).size());
          }
        else
          {
            if (__new_size < (*this).size())
              {
                (*this)._M_erase_at_end(this->_M_impl._M_start + __new_size);
              }
          }
      }
      inline void resize(typename ::std::vector<_Tp, _Alloc>::size_type __new_size, const typename ::std::vector<_Tp, _Alloc>::value_type &__x)
      {
        if (__new_size > (*this).size())
          {
            (*this).insert((*this).end(), __new_size - (*this).size(), __x);
          }
        else
          {
            if (__new_size < (*this).size())
              {
                (*this)._M_erase_at_end(this->_M_impl._M_start + __new_size);
              }
          }
      }
      inline void shrink_to_fit()
      {
        (*this)._M_shrink_to_fit();
      }
      inline typename ::std::vector<_Tp, _Alloc>::size_type capacity() const  noexcept(true)
      {
        return ((typename ::std::vector<_Tp, _Alloc>::size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_start)));
      }
      inline bool empty() const  noexcept(true)
      {
        return (*this).begin() == (*this).end();
      }
      void reserve(typename ::std::vector<_Tp, _Alloc>::size_type __n);
      inline typename ::std::vector<_Tp, _Alloc>::reference operator [](typename ::std::vector<_Tp, _Alloc>::size_type __n)
      {
        return *(this->_M_impl._M_start + __n);
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reference operator [](typename ::std::vector<_Tp, _Alloc>::size_type __n) const 
      {
        return *(this->_M_impl._M_start + __n);
      }
    protected:
      inline void _M_range_check(typename ::std::vector<_Tp, _Alloc>::size_type __n) const 
      {
        if (__n >= this->size())
          {
            ::std::__throw_out_of_range("vector::_M_range_check");
          }
      }
    public:
      inline typename ::std::vector<_Tp, _Alloc>::reference at(typename ::std::vector<_Tp, _Alloc>::size_type __n)
      {
        (*this)._M_range_check(__n);
        return (*this)[__n];
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reference at(typename ::std::vector<_Tp, _Alloc>::size_type __n) const 
      {
        (*this)._M_range_check(__n);
        return (*this)[__n];
      }
      inline typename ::std::vector<_Tp, _Alloc>::reference front()
      {
        return *(*this).begin();
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reference front() const 
      {
        return *(*this).begin();
      }
      inline typename ::std::vector<_Tp, _Alloc>::reference back()
      {
        return *((*this).end() - 1);
      }
      inline typename ::std::vector<_Tp, _Alloc>::const_reference back() const 
      {
        return *((*this).end() - 1);
      }
      inline _Tp *data() noexcept(true)
      {
        return std::__addressof((*this).front());
      }
      inline const _Tp *data() const  noexcept(true)
      {
        return std::__addressof((*this).front());
      }
      inline void push_back(const typename ::std::vector<_Tp, _Alloc>::value_type &__x)
      {
        if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
          {
            _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
             ++this->_M_impl._M_finish;
          }
        else
          {
            (*this)._M_emplace_back_aux(__x);
          }
      }
      inline void push_back(typename ::std::vector<_Tp, _Alloc>::value_type &&__x)
      {
        (*this).emplace_back(std::move(__x));
      }
      template < typename ..._Args >
      void emplace_back(_Args &&...__args);
      inline void pop_back()
      {
         --this->_M_impl._M_finish;
        _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
      template < typename ..._Args >
      typename ::std::vector<_Tp, _Alloc>::iterator emplace(typename ::std::vector<_Tp, _Alloc>::iterator __position, _Args &&...__args);
      typename ::std::vector<_Tp, _Alloc>::iterator insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, const typename ::std::vector<_Tp, _Alloc>::value_type &__x);
      inline typename ::std::vector<_Tp, _Alloc>::iterator insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, typename ::std::vector<_Tp, _Alloc>::value_type &&__x)
      {
        return (*this).emplace(__position, std::move(__x));
      }
      inline void insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, ::std::initializer_list<typename ::std::vector<_Tp, _Alloc>::value_type> __l)
      {
        this->insert(__position, __l.begin(), __l.end());
      }
      inline void insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__x)
      {
        (*this)._M_fill_insert(__position, __n, __x);
      }
      template < typename _InputIterator, typename __type_tpl__param_2_1__ = ::std::_RequireInputIter<_InputIterator> >
      inline void insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, _InputIterator __first, _InputIterator __last)
      {
        (*this)._M_insert_dispatch(__position, __first, __last, ::std::__false_type());
      }
      typename ::std::vector<_Tp, _Alloc>::iterator erase(typename ::std::vector<_Tp, _Alloc>::iterator __position);
      typename ::std::vector<_Tp, _Alloc>::iterator erase(typename ::std::vector<_Tp, _Alloc>::iterator __first, typename ::std::vector<_Tp, _Alloc>::iterator __last);
      inline void swap(::std::vector<_Tp, _Alloc> &__x) noexcept(_Alloc_traits::_S_nothrow_swap())
      {
        this->_M_impl._M_swap_data(__x._M_impl);
        _Alloc_traits::_S_on_swap((_M_get_Tp_allocator)(), __x._M_get_Tp_allocator());
      }
      inline void clear() noexcept(true)
      {
        (*this)._M_erase_at_end(this->_M_impl._M_start);
      }
    protected:
      template < typename _ForwardIterator >
      inline typename ::std::vector<_Tp, _Alloc>::pointer _M_allocate_and_copy(typename ::std::vector<_Tp, _Alloc>::size_type __n, _ForwardIterator __first, _ForwardIterator __last)
      {
        typename ::std::vector<_Tp, _Alloc>::pointer __result = this->_M_allocate(__n);
        try
        {
          std::__uninitialized_copy_a(__first, __last, __result, (_M_get_Tp_allocator)());
          return __result;
        }
        catch (...)
        {
          _M_deallocate(__result, __n);
          throw;
        }
      }
      template < typename _Integer >
      inline void _M_initialize_dispatch(_Integer __n, _Integer __value, ::std::__true_type)
      {
        this->_M_impl._M_start = (_M_allocate)(static_cast<typename ::std::vector<_Tp, _Alloc>::size_type>(__n));
        this->_M_impl._M_end_of_storage = this->_M_impl._M_start + static_cast<typename ::std::vector<_Tp, _Alloc>::size_type>(__n);
        (*this)._M_fill_initialize(static_cast<typename ::std::vector<_Tp, _Alloc>::size_type>(__n), __value);
      }
      template < typename _InputIterator >
      inline void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        typedef typename ::std::iterator_traits<_InputIterator>::iterator_category _IterCategory;
        (*this)._M_range_initialize(__first, __last, _IterCategory());
      }
      template < typename _InputIterator >
      inline void _M_range_initialize(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
      {
        for (; __first != __last;  ++__first)
          {
            (*this).emplace_back(*__first);
          }
      }
      template < typename _ForwardIterator >
      inline void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
      {
        const typename ::std::vector<_Tp, _Alloc>::size_type __n = std::distance(__first, __last);
        this->_M_impl._M_start = this->_M_allocate(__n);
        this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
        this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, (_M_get_Tp_allocator)());
      }
      inline void _M_fill_initialize(typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__value)
      {
        std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, (_M_get_Tp_allocator)());
        this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
      inline void _M_default_initialize(typename ::std::vector<_Tp, _Alloc>::size_type __n)
      {
        std::__uninitialized_default_n_a(this->_M_impl._M_start, __n, (_M_get_Tp_allocator)());
        this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
      template < typename _Integer >
      inline void _M_assign_dispatch(_Integer __n, _Integer __val, ::std::__true_type)
      {
        (*this)._M_fill_assign(__n, __val);
      }
      template < typename _InputIterator >
      inline void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        typedef typename ::std::iterator_traits<_InputIterator>::iterator_category _IterCategory;
        (*this)._M_assign_aux(__first, __last, _IterCategory());
      }
      template < typename _InputIterator >
      void _M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag);
      template < typename _ForwardIterator >
      void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag);
      void _M_fill_assign(typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__val);
      template < typename _Integer >
      inline void _M_insert_dispatch(typename ::std::vector<_Tp, _Alloc>::iterator __pos, _Integer __n, _Integer __val, ::std::__true_type)
      {
        (*this)._M_fill_insert(__pos, __n, __val);
      }
      template < typename _InputIterator >
      inline void _M_insert_dispatch(typename ::std::vector<_Tp, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        typedef typename ::std::iterator_traits<_InputIterator>::iterator_category _IterCategory;
        (*this)._M_range_insert(__pos, __first, __last, _IterCategory());
      }
      template < typename _InputIterator >
      void _M_range_insert(typename ::std::vector<_Tp, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::input_iterator_tag);
      template < typename _ForwardIterator >
      void _M_range_insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag);
      void _M_fill_insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__x);
      void _M_default_append(typename ::std::vector<_Tp, _Alloc>::size_type __n);
      bool _M_shrink_to_fit();
      template < typename ..._Args >
      void _M_insert_aux(typename ::std::vector<_Tp, _Alloc>::iterator __position, _Args &&...__args);
      template < typename ..._Args >
      void _M_emplace_back_aux(_Args &&...__args);
      inline typename ::std::vector<_Tp, _Alloc>::size_type _M_check_len(typename ::std::vector<_Tp, _Alloc>::size_type __n, const char *__s) const 
      {
        if ((*this).max_size() - (*this).size() < __n)
          {
            ::std::__throw_length_error(__s);
          }
        const typename ::std::vector<_Tp, _Alloc>::size_type __len = (*this).size() + std::max((*this).size(), __n);
        return __len < (*this).size() || __len > (*this).max_size() ? (*this).max_size() : __len;
      }
      inline void _M_erase_at_end(typename ::std::vector<_Tp, _Alloc>::pointer __pos)
      {
        std::_Destroy(__pos, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
        this->_M_impl._M_finish = __pos;
      }
    private:
      inline void _M_move_assign(::std::vector<_Tp, _Alloc> &&__x, ::std::true_type) noexcept(true)
      {
        ::std::vector<_Tp, _Alloc> __tmp((get_allocator)());
        this->_M_impl._M_swap_data(__tmp._M_impl);
        this->_M_impl._M_swap_data(__x._M_impl);
        if (_Alloc_traits::_S_propagate_on_move_assign())
          {
            std::__alloc_on_move((_M_get_Tp_allocator)(), __x._M_get_Tp_allocator());
          }
      }
      inline void _M_move_assign(::std::vector<_Tp, _Alloc> &&__x, ::std::false_type)
      {
        if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
          {
            (*this)._M_move_assign(std::move(__x), ::std::integral_constant<bool, true>());
          }
        else
          {
            this->assign(std::__make_move_if_noexcept_iterator(__x.begin()), std::__make_move_if_noexcept_iterator(__x.end()));
            __x.clear();
          }
      }
  };
  template < typename _Tp, typename _Alloc >
  inline bool operator ==(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator ==(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator <(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator <(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator !=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator !=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator >(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator >(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator <=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator <=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator >=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator >=(const ::std::vector<_Tp, _Alloc> &__x, const ::std::vector<_Tp, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Tp, typename _Alloc >
  inline void swap(::std::vector<_Tp, _Alloc> &__x, ::std::vector<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline void swap(::std::vector<_Tp, _Alloc> &__x, ::std::vector<_Tp, _Alloc> &__y)
  {
    __x.swap(__y);
  }
  typedef unsigned long int _Bit_type;
  enum mcc_enum_anon_60
  {
    _S_word_bit = (int)(8 * sizeof(::std::_Bit_type))
  };
  struct  _Bit_reference
  {
      ::std::_Bit_type *_M_p;
      ::std::_Bit_type _M_mask;
      inline _Bit_reference(::std::_Bit_type *__x, ::std::_Bit_type __y)
        : _M_p(__x), _M_mask(__y)
      {
      }
      inline _Bit_reference() noexcept(true)
        : _M_p(0), _M_mask(0)
      {
      }
      inline operator bool() const  noexcept(true)
      {
        return !!(*(*this)._M_p & (*this)._M_mask);
      }
      inline ::std::_Bit_reference &operator =(bool __x) noexcept(true)
      {
        if (__x)
          {
            *(*this)._M_p |= (*this)._M_mask;
          }
        else
          {
            *(*this)._M_p &= ~(*this)._M_mask;
          }
        return *this;
      }
      inline ::std::_Bit_reference &operator =(const ::std::_Bit_reference &__x) noexcept(true)
      {
        return *this = (bool)__x;
      }
      inline bool operator ==(const ::std::_Bit_reference &__x) const 
      {
        return (bool)*this == (bool)__x;
      }
      inline bool operator <(const ::std::_Bit_reference &__x) const 
      {
        return !((bool)*this) && (bool)__x;
      }
      inline void flip() noexcept(true)
      {
        *(*this)._M_p ^= (*this)._M_mask;
      }
  };
  inline void swap(::std::_Bit_reference __x, ::std::_Bit_reference __y) noexcept(true)
  {
    bool __tmp(__x);
    __x = __y;
    __y = __tmp;
  }
  inline void swap(::std::_Bit_reference __x, bool &__y) noexcept(true)
  {
    bool __tmp(__x);
    __x = __y;
    __y = __tmp;
  }
  inline void swap(bool &__x, ::std::_Bit_reference __y) noexcept(true)
  {
    bool __tmp(__x);
    __x = __y;
    __y = __tmp;
  }
 /* Instantiation of class template '::std::iterator< ::std::random_access_iterator_tag, bool>' */ 
  struct  _Bit_iterator_base : ::std::iterator< ::std::random_access_iterator_tag, bool>
  {
      ::std::_Bit_type *_M_p;
      unsigned int _M_offset;
      inline _Bit_iterator_base(::std::_Bit_type *__x, unsigned int __y)
        : _M_p(__x), _M_offset(__y)
      {
      }
      inline void _M_bump_up()
      {
        if ((*this)._M_offset++ == (int)::std::_S_word_bit - 1)
          {
            (*this)._M_offset = 0;
             ++(*this)._M_p;
          }
      }
      inline void _M_bump_down()
      {
        if ((*this)._M_offset-- == 0)
          {
            (*this)._M_offset = (int)::std::_S_word_bit - 1;
             --(*this)._M_p;
          }
      }
      inline void _M_incr(::std::ptrdiff_t __i)
      {
        ::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __n(__i + (*this)._M_offset);
        (*this)._M_p += __n / (int)::std::_S_word_bit;
        __n = __n % (int)::std::_S_word_bit;
        if (__n < 0)
          {
            __n += (int)::std::_S_word_bit;
             --(*this)._M_p;
          }
        (*this)._M_offset = static_cast<unsigned int>(__n);
      }
      inline bool operator ==(const ::std::_Bit_iterator_base &__i) const 
      {
        return (*this)._M_p == __i._M_p && (*this)._M_offset == __i._M_offset;
      }
      inline bool operator <(const ::std::_Bit_iterator_base &__i) const 
      {
        return (*this)._M_p < __i._M_p || ((*this)._M_p == __i._M_p && (*this)._M_offset < __i._M_offset);
      }
      inline bool operator !=(const ::std::_Bit_iterator_base &__i) const 
      {
        return !(*this == __i);
      }
      inline bool operator >(const ::std::_Bit_iterator_base &__i) const 
      {
        return __i < *this;
      }
      inline bool operator <=(const ::std::_Bit_iterator_base &__i) const 
      {
        return !(__i < *this);
      }
      inline bool operator >=(const ::std::_Bit_iterator_base &__i) const 
      {
        return !(*this < __i);
      }
  };
  inline ::std::ptrdiff_t operator -(const ::std::_Bit_iterator_base &__x, const ::std::_Bit_iterator_base &__y)
  {
    return (int)::std::_S_word_bit * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;
  }
  struct  _Bit_iterator : ::std::_Bit_iterator_base
  {
      typedef ::std::_Bit_reference reference;
      typedef ::std::_Bit_reference *pointer;
      typedef ::std::_Bit_iterator iterator;
      inline _Bit_iterator()
        : ::std::_Bit_iterator_base(0, 0)
      {
      }
      inline _Bit_iterator(::std::_Bit_type *__x, unsigned int __y)
        : ::std::_Bit_iterator_base(__x, __y)
      {
      }
      inline ::std::_Bit_iterator::reference operator *() const 
      {
        return ::std::_Bit_reference((*this)._M_p, 1LU << (*this)._M_offset);
      }
      inline ::std::_Bit_iterator::iterator &operator ++()
      {
        (*this).::std::_Bit_iterator_base::_M_bump_up();
        return *this;
      }
      inline ::std::_Bit_iterator::iterator operator ++(int)
      {
        ::std::_Bit_iterator::iterator __tmp((*this));
        (*this).::std::_Bit_iterator_base::_M_bump_up();
        return __tmp;
      }
      inline ::std::_Bit_iterator::iterator &operator --()
      {
        (*this).::std::_Bit_iterator_base::_M_bump_down();
        return *this;
      }
      inline ::std::_Bit_iterator::iterator operator --(int)
      {
        ::std::_Bit_iterator::iterator __tmp((*this));
        (*this).::std::_Bit_iterator_base::_M_bump_down();
        return __tmp;
      }
      inline ::std::_Bit_iterator::iterator &operator +=(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i)
      {
        (*this).::std::_Bit_iterator_base::_M_incr(__i);
        return *this;
      }
      inline ::std::_Bit_iterator::iterator &operator -=(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i)
      {
        *this +=  -__i;
        return *this;
      }
      inline ::std::_Bit_iterator::iterator operator +(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i) const 
      {
        ::std::_Bit_iterator::iterator __tmp((*this));
        return __tmp += __i;
      }
      inline ::std::_Bit_iterator::iterator operator -(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i) const 
      {
        ::std::_Bit_iterator::iterator __tmp((*this));
        return __tmp -= __i;
      }
      inline ::std::_Bit_iterator::reference operator [](::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i) const 
      {
        return  *(*this + __i);
      }
  };
  inline ::std::_Bit_iterator operator +(::std::ptrdiff_t __n, const ::std::_Bit_iterator &__x)
  {
    return __x + __n;
  }
  struct  _Bit_const_iterator : ::std::_Bit_iterator_base
  {
      typedef bool reference;
      typedef bool const_reference;
      typedef const bool *pointer;
      typedef ::std::_Bit_const_iterator const_iterator;
      inline _Bit_const_iterator()
        : ::std::_Bit_iterator_base(0, 0)
      {
      }
      inline _Bit_const_iterator(::std::_Bit_type *__x, unsigned int __y)
        : ::std::_Bit_iterator_base(__x, __y)
      {
      }
      inline _Bit_const_iterator(const ::std::_Bit_iterator &__x)
        : ::std::_Bit_iterator_base(__x._M_p, __x._M_offset)
      {
      }
      inline ::std::_Bit_const_iterator::const_reference operator *() const 
      {
        return ::std::_Bit_reference((*this)._M_p, 1LU << (*this)._M_offset);
      }
      inline ::std::_Bit_const_iterator::const_iterator &operator ++()
      {
        (*this).::std::_Bit_iterator_base::_M_bump_up();
        return *this;
      }
      inline ::std::_Bit_const_iterator::const_iterator operator ++(int)
      {
        ::std::_Bit_const_iterator::const_iterator __tmp((*this));
        (*this).::std::_Bit_iterator_base::_M_bump_up();
        return __tmp;
      }
      inline ::std::_Bit_const_iterator::const_iterator &operator --()
      {
        (*this).::std::_Bit_iterator_base::_M_bump_down();
        return *this;
      }
      inline ::std::_Bit_const_iterator::const_iterator operator --(int)
      {
        ::std::_Bit_const_iterator::const_iterator __tmp((*this));
        (*this).::std::_Bit_iterator_base::_M_bump_down();
        return __tmp;
      }
      inline ::std::_Bit_const_iterator::const_iterator &operator +=(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i)
      {
        (*this).::std::_Bit_iterator_base::_M_incr(__i);
        return *this;
      }
      inline ::std::_Bit_const_iterator::const_iterator &operator -=(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i)
      {
        *this +=  -__i;
        return *this;
      }
      inline ::std::_Bit_const_iterator::const_iterator operator +(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i) const 
      {
        ::std::_Bit_const_iterator::const_iterator __tmp((*this));
        return __tmp += __i;
      }
      inline ::std::_Bit_const_iterator::const_iterator operator -(::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i) const 
      {
        ::std::_Bit_const_iterator::const_iterator __tmp((*this));
        return __tmp -= __i;
      }
      inline ::std::_Bit_const_iterator::const_reference operator [](::std::iterator< ::std::random_access_iterator_tag, bool>::difference_type __i) const 
      {
        return  *(*this + __i);
      }
  };
  inline ::std::_Bit_const_iterator operator +(::std::ptrdiff_t __n, const ::std::_Bit_const_iterator &__x)
  {
    return __x + __n;
  }
  inline void __fill_bvector(::std::_Bit_iterator __first, ::std::_Bit_iterator __last, bool __x)
  {
    for (; __first != __last;  ++__first)
      {
         *__first = __x;
      }
  }
 /* Instantiation of template function 'void ::std::fill<unsigned long int *, int>(unsigned long int *, unsigned long int *, const int &)' */ 
  inline void fill(::std::_Bit_iterator __first, ::std::_Bit_iterator __last, const bool &__x)
  {
    if (__first._M_p != __last._M_p)
      {
        std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
        ::std::__fill_bvector(__first, ::std::_Bit_iterator(__first._M_p + 1, 0), __x);
        ::std::__fill_bvector(::std::_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      {
        ::std::__fill_bvector(__first, __last, __x);
      }
  }
  template < typename _Alloc >
  struct  _Bvector_base
  {
      typedef typename _Alloc::template rebind< ::std::_Bit_type>::other _Bit_alloc_type;
      struct  _Bvector_impl : ::std::_Bvector_base<_Alloc>::_Bit_alloc_type
      {
          ::std::_Bit_iterator _M_start;
          ::std::_Bit_iterator _M_finish;
          ::std::_Bit_type *_M_end_of_storage;
          inline _Bvector_impl()
            : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
          {
          }
          inline _Bvector_impl(const typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type &__a)
            : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
          {
          }
          inline _Bvector_impl(typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type &&__a)
            : _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(), _M_end_of_storage(0)
          {
          }
      };
      typedef _Alloc allocator_type;
      inline typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type &_M_get_Bit_allocator() noexcept(true)
      {
        return *static_cast<typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type *>(&this->_M_impl);
      }
      inline const typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type &_M_get_Bit_allocator() const  noexcept(true)
      {
        return *static_cast<const typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type *>(&this->_M_impl);
      }
      inline typename ::std::_Bvector_base<_Alloc>::allocator_type get_allocator() const  noexcept(true)
      {
        return ((typename ::std::_Bvector_base<_Alloc>::allocator_type((*this)._M_get_Bit_allocator())));
      }
      inline _Bvector_base()
        : _M_impl()
      {
      }
      inline _Bvector_base(const typename ::std::_Bvector_base<_Alloc>::allocator_type &__a)
        : _M_impl(__a)
      {
      }
      inline _Bvector_base(::std::_Bvector_base<_Alloc> &&__x) noexcept(true)
        : _M_impl(std::move(__x._M_get_Bit_allocator()))
      {
        this->_M_impl._M_start = __x._M_impl._M_start;
        this->_M_impl._M_finish = __x._M_impl._M_finish;
        this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
        __x._M_impl._M_start = ::std::_Bit_iterator();
        __x._M_impl._M_finish = ::std::_Bit_iterator();
        __x._M_impl._M_end_of_storage = 0;
      }
      inline ~_Bvector_base()
      {
        this->_M_deallocate();
      }
    protected:
      typename ::std::_Bvector_base<_Alloc>::_Bvector_impl _M_impl;
      inline ::std::_Bit_type *_M_allocate(::std::size_t __n)
      {
        return ::std::_Bvector_base<_Alloc>::_M_impl.allocate(_S_nword(__n));
      }
      inline void _M_deallocate()
      {
        if (::std::_Bvector_base<_Alloc>::_M_impl._M_start._M_p)
          {
            ::std::_Bvector_base<_Alloc>::_M_impl.deallocate(::std::_Bvector_base<_Alloc>::_M_impl._M_start._M_p, ::std::_Bvector_base<_Alloc>::_M_impl._M_end_of_storage - ::std::_Bvector_base<_Alloc>::_M_impl._M_start._M_p);
          }
      }
      static inline ::std::size_t _S_nword(::std::size_t __n)
      {
        return (__n + (int)::std::_S_word_bit - 1) / (int)::std::_S_word_bit;
      }
  };
 /* Instantiation of class template '::std::initializer_list<bool>' */ 
 /* Instantiation of template function 'const bool *::std::initializer_list<bool>::begin() const ' */ 
 /* Instantiation of template function 'unsigned long int ::std::initializer_list<bool>::size() const ' */ 
 /* Instantiation of template function 'const bool *::std::initializer_list<bool>::end() const ' */ 
 /* Instantiation of class template '::std::remove_volatile< ::std::_Bit_iterator>' */ 
 /* Instantiation of class template '::std::remove_const< ::std::_Bit_iterator>' */ 
 /* Instantiation of class template '::std::remove_cv< ::std::_Bit_iterator>' */ 
 /* Instantiation of class template '::std::__has_iterator_category_helper< ::std::_Bit_iterator>' */ 
 /* Instantiation of class template '::std::__has_iterator_category< ::std::_Bit_iterator>' */ 
 /* Instantiation of class template '::std::__iterator_traits< ::std::_Bit_iterator, true>' */ 
 /* Instantiation of class template '::std::iterator_traits< ::std::_Bit_iterator>' */ 
 /* Instantiation of class template '::std::iterator< ::std::random_access_iterator_tag, bool, long int, ::std::_Bit_reference *, ::std::_Bit_reference>' */ 
 /* Instantiation of class template '::std::reverse_iterator< ::std::_Bit_iterator>' */ 
 /* Instantiation of class template '::std::remove_volatile< ::std::_Bit_const_iterator>' */ 
 /* Instantiation of class template '::std::remove_const< ::std::_Bit_const_iterator>' */ 
 /* Instantiation of class template '::std::remove_cv< ::std::_Bit_const_iterator>' */ 
 /* Instantiation of class template '::std::__has_iterator_category_helper< ::std::_Bit_const_iterator>' */ 
 /* Instantiation of class template '::std::__has_iterator_category< ::std::_Bit_const_iterator>' */ 
 /* Instantiation of class template '::std::__iterator_traits< ::std::_Bit_const_iterator, true>' */ 
 /* Instantiation of class template '::std::iterator_traits< ::std::_Bit_const_iterator>' */ 
 /* Instantiation of class template '::std::iterator< ::std::random_access_iterator_tag, bool, long int, const bool *, bool>' */ 
 /* Instantiation of class template '::std::reverse_iterator< ::std::_Bit_const_iterator>' */ 
  template < typename _Alloc >
  class  vector<bool, _Alloc> : protected ::std::_Bvector_base<_Alloc>
  {
      typedef ::std::_Bvector_base<_Alloc> _Base;
    public:
      typedef bool value_type;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef ::std::_Bit_reference reference;
      typedef bool const_reference;
      typedef ::std::_Bit_reference *pointer;
      typedef const bool *const_pointer;
      typedef ::std::_Bit_iterator iterator;
      typedef ::std::_Bit_const_iterator const_iterator;
      typedef ::std::reverse_iterator< ::std::_Bit_const_iterator> const_reverse_iterator;
      typedef ::std::reverse_iterator< ::std::_Bit_iterator> reverse_iterator;
      typedef _Alloc allocator_type;
      inline typename ::std::vector<bool, _Alloc>::allocator_type get_allocator() const 
      {
        return _Base::get_allocator();
      }
    protected:
      using ::std::_Bvector_base<_Alloc>::_M_allocate;
      using ::std::_Bvector_base<_Alloc>::_M_deallocate;
      using ::std::_Bvector_base<_Alloc>::_S_nword;
      using ::std::_Bvector_base<_Alloc>::_M_get_Bit_allocator;
    public:
      inline vector()
        : _Base()
      {
      }
      inline explicit vector(const typename ::std::vector<bool, _Alloc>::allocator_type &__a)
        : _Base(__a)
      {
      }
      inline explicit vector(typename ::std::vector<bool, _Alloc>::size_type __n, const typename ::std::vector<bool, _Alloc>::allocator_type &__a  = (((typename ::std::vector<bool, _Alloc>::allocator_type()))))
        : vector(__n, false, __a)
      {
      }
      inline vector(typename ::std::vector<bool, _Alloc>::size_type __n, const bool &__value, const typename ::std::vector<bool, _Alloc>::allocator_type &__a  = (((typename ::std::vector<bool, _Alloc>::allocator_type()))))
        : _Base(__a)
      {
        (*this)._M_initialize(__n);
        std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, __value ? ~0 : 0);
      }
      inline vector(const ::std::vector<bool, _Alloc> &__x)
        : _Base(__x._M_get_Bit_allocator())
      {
        (*this)._M_initialize(__x.size());
        (*this)._M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }
      inline vector(::std::vector<bool, _Alloc> &&__x) noexcept(true)
        : _Base(std::move(__x))
      {
      }
      inline vector(::std::initializer_list<bool> __l, const typename ::std::vector<bool, _Alloc>::allocator_type &__a  = (((typename ::std::vector<bool, _Alloc>::allocator_type()))))
        : _Base(__a)
      {
        (*this)._M_initialize_range(__l.::std::initializer_list<bool>::begin(), __l.::std::initializer_list<bool>::end(), ::std::random_access_iterator_tag());
      }
      template < typename _InputIterator, typename __type_tpl__param_2_1__ = ::std::_RequireInputIter<_InputIterator> >
      inline vector(_InputIterator __first, _InputIterator __last, const typename ::std::vector<bool, _Alloc>::allocator_type &__a  = (((typename ::std::vector<bool, _Alloc>::allocator_type()))))
        : _Base(__a)
      {
        (*this)._M_initialize_dispatch(__first, __last, ::std::__false_type());
      }
      inline ~vector() noexcept(true)
      {
      }
      inline ::std::vector<bool, _Alloc> &operator =(const ::std::vector<bool, _Alloc> &__x)
      {
        if (&__x == this)
          {
            return *this;
          }
        if (__x.size() > (*this).capacity())
          {
            this->_M_deallocate();
            (*this)._M_initialize(__x.size());
          }
        this->_M_impl._M_finish = (*this)._M_copy_aligned(__x.begin(), __x.end(), (*this).begin());
        return *this;
      }
      inline ::std::vector<bool, _Alloc> &operator =(::std::vector<bool, _Alloc> &&__x)
      {
        this->clear();
        this->swap(__x);
        return *this;
      }
      inline ::std::vector<bool, _Alloc> &operator =(::std::initializer_list<bool> __l)
      {
        this->assign(__l.::std::initializer_list<bool>::begin(), __l.::std::initializer_list<bool>::end());
        return *this;
      }
      inline void assign(typename ::std::vector<bool, _Alloc>::size_type __n, const bool &__x)
      {
        (*this)._M_fill_assign(__n, __x);
      }
      template < typename _InputIterator, typename __type_tpl__param_2_1__ = ::std::_RequireInputIter<_InputIterator> >
      inline void assign(_InputIterator __first, _InputIterator __last)
      {
        (*this)._M_assign_dispatch(__first, __last, ::std::__false_type());
      }
      inline void assign(::std::initializer_list<bool> __l)
      {
        this->assign(__l.::std::initializer_list<bool>::begin(), __l.::std::initializer_list<bool>::end());
      }
      inline typename ::std::vector<bool, _Alloc>::iterator begin() noexcept(true)
      {
        return this->_M_impl._M_start;
      }
      inline typename ::std::vector<bool, _Alloc>::const_iterator begin() const  noexcept(true)
      {
        return this->_M_impl._M_start;
      }
      inline typename ::std::vector<bool, _Alloc>::iterator end() noexcept(true)
      {
        return this->_M_impl._M_finish;
      }
      inline typename ::std::vector<bool, _Alloc>::const_iterator end() const  noexcept(true)
      {
        return this->_M_impl._M_finish;
      }
      inline typename ::std::vector<bool, _Alloc>::reverse_iterator rbegin() noexcept(true)
      {
        return ((typename ::std::vector<bool, _Alloc>::reverse_iterator((*this).end())));
      }
      inline typename ::std::vector<bool, _Alloc>::const_reverse_iterator rbegin() const  noexcept(true)
      {
        return ((typename ::std::vector<bool, _Alloc>::const_reverse_iterator((*this).end())));
      }
      inline typename ::std::vector<bool, _Alloc>::reverse_iterator rend() noexcept(true)
      {
        return ((typename ::std::vector<bool, _Alloc>::reverse_iterator((*this).begin())));
      }
      inline typename ::std::vector<bool, _Alloc>::const_reverse_iterator rend() const  noexcept(true)
      {
        return ((typename ::std::vector<bool, _Alloc>::const_reverse_iterator((*this).begin())));
      }
      inline typename ::std::vector<bool, _Alloc>::const_iterator cbegin() const  noexcept(true)
      {
        return this->_M_impl._M_start;
      }
      inline typename ::std::vector<bool, _Alloc>::const_iterator cend() const  noexcept(true)
      {
        return this->_M_impl._M_finish;
      }
      inline typename ::std::vector<bool, _Alloc>::const_reverse_iterator crbegin() const  noexcept(true)
      {
        return ((typename ::std::vector<bool, _Alloc>::const_reverse_iterator((*this).end())));
      }
      inline typename ::std::vector<bool, _Alloc>::const_reverse_iterator crend() const  noexcept(true)
      {
        return ((typename ::std::vector<bool, _Alloc>::const_reverse_iterator((*this).begin())));
      }
      inline typename ::std::vector<bool, _Alloc>::size_type size() const  noexcept(true)
      {
        return ((typename ::std::vector<bool, _Alloc>::size_type((*this).end() - (*this).begin())));
      }
      inline typename ::std::vector<bool, _Alloc>::size_type max_size() const  noexcept(true)
      {
        const typename ::std::vector<bool, _Alloc>::size_type __isize(::__gnu_cxx::__numeric_traits_integer<long int>::__max - (int)::std::_S_word_bit + 1);
        const typename ::std::vector<bool, _Alloc>::size_type __asize = (_M_get_Bit_allocator)().max_size();
        return __asize <= __isize / (int)::std::_S_word_bit ? __asize * (int)::std::_S_word_bit : __isize;
      }
      inline typename ::std::vector<bool, _Alloc>::size_type capacity() const  noexcept(true)
      {
        return ((typename ::std::vector<bool, _Alloc>::size_type(((typename ::std::vector<bool, _Alloc>::const_iterator(this->_M_impl._M_end_of_storage, 0))) - (*this).begin())));
      }
      inline bool empty() const  noexcept(true)
      {
        return (*this).begin() == (*this).end();
      }
      inline typename ::std::vector<bool, _Alloc>::reference operator [](typename ::std::vector<bool, _Alloc>::size_type __n)
      {
        return  *((typename ::std::vector<bool, _Alloc>::iterator(this->_M_impl._M_start._M_p + __n / (int)::std::_S_word_bit, __n % (int)::std::_S_word_bit)));
      }
      inline typename ::std::vector<bool, _Alloc>::const_reference operator [](typename ::std::vector<bool, _Alloc>::size_type __n) const 
      {
        return  *((typename ::std::vector<bool, _Alloc>::const_iterator(this->_M_impl._M_start._M_p + __n / (int)::std::_S_word_bit, __n % (int)::std::_S_word_bit)));
      }
    protected:
      inline void _M_range_check(typename ::std::vector<bool, _Alloc>::size_type __n) const 
      {
        if (__n >= this->size())
          {
            ::std::__throw_out_of_range("vector<bool>::_M_range_check");
          }
      }
    public:
      inline typename ::std::vector<bool, _Alloc>::reference at(typename ::std::vector<bool, _Alloc>::size_type __n)
      {
        (*this)._M_range_check(__n);
        return (*this)[__n];
      }
      inline typename ::std::vector<bool, _Alloc>::const_reference at(typename ::std::vector<bool, _Alloc>::size_type __n) const 
      {
        (*this)._M_range_check(__n);
        return (*this)[__n];
      }
      inline void reserve(typename ::std::vector<bool, _Alloc>::size_type __n)
      {
        if (__n > (*this).max_size())
          {
            ::std::__throw_length_error("vector::reserve");
          }
        if ((*this).capacity() < __n)
          {
            (*this)._M_reallocate(__n);
          }
      }
      inline typename ::std::vector<bool, _Alloc>::reference front()
      {
        return *(*this).begin();
      }
      inline typename ::std::vector<bool, _Alloc>::const_reference front() const 
      {
        return *(*this).begin();
      }
      inline typename ::std::vector<bool, _Alloc>::reference back()
      {
        return *((*this).end() - 1);
      }
      inline typename ::std::vector<bool, _Alloc>::const_reference back() const 
      {
        return *((*this).end() - 1);
      }
      inline void data() noexcept(true)
      {
      }
      inline void push_back(bool __x)
      {
        if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
          {
            *this->_M_impl._M_finish++ = __x;
          }
        else
          {
            (*this)._M_insert_aux((*this).end(), __x);
          }
      }
      inline void swap(::std::vector<bool, _Alloc> &__x)
      {
        std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
        std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
        std::swap(this->_M_impl._M_end_of_storage, __x._M_impl._M_end_of_storage);
        std::__alloc_swap<typename ::std::_Bvector_base<_Alloc>::_Bit_alloc_type>::_S_do_it((_M_get_Bit_allocator)(), __x._M_get_Bit_allocator());
      }
      static inline void swap(typename ::std::vector<bool, _Alloc>::reference __x, typename ::std::vector<bool, _Alloc>::reference __y) noexcept(true)
      {
        bool __tmp(__x);
        __x = __y;
        __y = __tmp;
      }
      inline typename ::std::vector<bool, _Alloc>::iterator insert(typename ::std::vector<bool, _Alloc>::iterator __position, const bool &__x  = (bool()))
      {
        const typename ::std::vector<bool, _Alloc>::difference_type __n = __position - (*this).begin();
        if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage && __position == (*this).end())
          {
            *this->_M_impl._M_finish++ = __x;
          }
        else
          {
            (*this)._M_insert_aux(__position, __x);
          }
        return (*this).begin() + __n;
      }
      template < typename _InputIterator, typename __type_tpl__param_2_1__ = ::std::_RequireInputIter<_InputIterator> >
      inline void insert(typename ::std::vector<bool, _Alloc>::iterator __position, _InputIterator __first, _InputIterator __last)
      {
        (*this)._M_insert_dispatch(__position, __first, __last, ::std::__false_type());
      }
      inline void insert(typename ::std::vector<bool, _Alloc>::iterator __position, typename ::std::vector<bool, _Alloc>::size_type __n, const bool &__x)
      {
        (*this)._M_fill_insert(__position, __n, __x);
      }
      inline void insert(typename ::std::vector<bool, _Alloc>::iterator __p, ::std::initializer_list<bool> __l)
      {
        this->insert(__p, __l.::std::initializer_list<bool>::begin(), __l.::std::initializer_list<bool>::end());
      }
      inline void pop_back()
      {
         --this->_M_impl._M_finish;
      }
      inline typename ::std::vector<bool, _Alloc>::iterator erase(typename ::std::vector<bool, _Alloc>::iterator __position)
      {
        if (__position + 1 != (*this).end())
          {
            std::copy(__position + 1, (*this).end(), __position);
          }
         --this->_M_impl._M_finish;
        return __position;
      }
      inline typename ::std::vector<bool, _Alloc>::iterator erase(typename ::std::vector<bool, _Alloc>::iterator __first, typename ::std::vector<bool, _Alloc>::iterator __last)
      {
        if (__first != __last)
          {
            (*this)._M_erase_at_end(std::copy(__last, (*this).end(), __first));
          }
        return __first;
      }
      inline void resize(typename ::std::vector<bool, _Alloc>::size_type __new_size, bool __x  = (bool()))
      {
        if (__new_size < (*this).size())
          {
            (*this)._M_erase_at_end((*this).begin() + (typename ::std::vector<bool, _Alloc>::difference_type)__new_size);
          }
        else
          {
            (*this).insert((*this).end(), __new_size - (*this).size(), __x);
          }
      }
      inline void shrink_to_fit()
      {
        (*this)._M_shrink_to_fit();
      }
      inline void flip() noexcept(true)
      {
        for (::std::_Bit_type *__p = this->_M_impl._M_start._M_p; __p != this->_M_impl._M_end_of_storage;  ++__p)
          {
            *__p = ~*__p;
          }
      }
      inline void clear() noexcept(true)
      {
        (*this)._M_erase_at_end((*this).begin());
      }
    protected:
      inline typename ::std::vector<bool, _Alloc>::iterator _M_copy_aligned(typename ::std::vector<bool, _Alloc>::const_iterator __first, typename ::std::vector<bool, _Alloc>::const_iterator __last, typename ::std::vector<bool, _Alloc>::iterator __result)
      {
        ::std::_Bit_type *__q(std::copy(__first._M_p, __last._M_p, __result._M_p));
        return std::copy(::std::_Bit_const_iterator(__last._M_p, 0), __last, ::std::_Bit_iterator(__q, 0));
      }
      inline void _M_initialize(typename ::std::vector<bool, _Alloc>::size_type __n)
      {
        ::std::_Bit_type *__q = this->_M_allocate(__n);
        this->_M_impl._M_end_of_storage = __q + (_S_nword)(__n);
        this->_M_impl._M_start = ::std::_Bit_iterator(__q, 0);
        this->_M_impl._M_finish = this->_M_impl._M_start + (typename ::std::vector<bool, _Alloc>::difference_type)__n;
      }
      void _M_reallocate(typename ::std::vector<bool, _Alloc>::size_type __n);
      bool _M_shrink_to_fit();
      template < typename _Integer >
      inline void _M_initialize_dispatch(_Integer __n, _Integer __x, ::std::__true_type)
      {
        (*this)._M_initialize(static_cast<typename ::std::vector<bool, _Alloc>::size_type>(__n));
        std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }
      template < typename _InputIterator >
      inline void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        (*this)._M_initialize_range(__first, __last, std::__iterator_category(__first));
      }
      template < typename _InputIterator >
      inline void _M_initialize_range(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
      {
        for (; __first != __last;  ++__first)
          {
            (*this).push_back(*__first);
          }
      }
      template < typename _ForwardIterator >
      inline void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
      {
        const typename ::std::vector<bool, _Alloc>::size_type __n = std::distance(__first, __last);
        (*this)._M_initialize(__n);
        std::copy(__first, __last, this->_M_impl._M_start);
      }
      template < typename _Integer >
      inline void _M_assign_dispatch(_Integer __n, _Integer __val, ::std::__true_type)
      {
        (*this)._M_fill_assign(__n, __val);
      }
      template < typename _InputIterator >
      inline void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        (*this)._M_assign_aux(__first, __last, std::__iterator_category(__first));
      }
      inline void _M_fill_assign(::std::size_t __n, bool __x)
      {
        if (__n > (*this).size())
          {
            std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
            (*this).insert((*this).end(), __n - (*this).size(), __x);
          }
        else
          {
            (*this)._M_erase_at_end((*this).begin() + __n);
            std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
          }
      }
      template < typename _InputIterator >
      inline void _M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
      {
        typename ::std::vector<bool, _Alloc>::iterator __cur = (*this).begin();
        for (; __first != __last && __cur != (*this).end(); ( ++__cur,  ++__first))
          {
             *__cur = *__first;
          }
        if (__first == __last)
          {
            (*this)._M_erase_at_end(__cur);
          }
        else
          {
            (*this).insert((*this).end(), __first, __last);
          }
      }
      template < typename _ForwardIterator >
      inline void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
      {
        const typename ::std::vector<bool, _Alloc>::size_type __len = std::distance(__first, __last);
        if (__len < (*this).size())
          {
            (*this)._M_erase_at_end(std::copy(__first, __last, (*this).begin()));
          }
        else
          {
            _ForwardIterator __mid = __first;
            std::advance(__mid, (*this).size());
            std::copy(__first, __mid, (*this).begin());
            (*this).insert((*this).end(), __mid, __last);
          }
      }
      template < typename _Integer >
      inline void _M_insert_dispatch(typename ::std::vector<bool, _Alloc>::iterator __pos, _Integer __n, _Integer __x, ::std::__true_type)
      {
        (*this)._M_fill_insert(__pos, __n, __x);
      }
      template < typename _InputIterator >
      inline void _M_insert_dispatch(typename ::std::vector<bool, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        (*this)._M_insert_range(__pos, __first, __last, std::__iterator_category(__first));
      }
      void _M_fill_insert(typename ::std::vector<bool, _Alloc>::iterator __position, typename ::std::vector<bool, _Alloc>::size_type __n, bool __x);
      template < typename _InputIterator >
      inline void _M_insert_range(typename ::std::vector<bool, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
      {
        for (; __first != __last;  ++__first)
          {
            __pos = (*this).insert(__pos, *__first);
             ++__pos;
          }
      }
      template < typename _ForwardIterator >
      void _M_insert_range(typename ::std::vector<bool, _Alloc>::iterator __position, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag);
      void _M_insert_aux(typename ::std::vector<bool, _Alloc>::iterator __position, bool __x);
      inline typename ::std::vector<bool, _Alloc>::size_type _M_check_len(typename ::std::vector<bool, _Alloc>::size_type __n, const char *__s) const 
      {
        if ((*this).max_size() - (*this).size() < __n)
          {
            ::std::__throw_length_error(__s);
          }
        const typename ::std::vector<bool, _Alloc>::size_type __len = (*this).size() + std::max((*this).size(), __n);
        return __len < (*this).size() || __len > (*this).max_size() ? (*this).max_size() : __len;
      }
      inline void _M_erase_at_end(typename ::std::vector<bool, _Alloc>::iterator __pos)
      {
        this->_M_impl._M_finish = __pos;
      }
    template < typename __type_tpl__param_2_0__ >
    friend struct hash;
  };
  template < typename _Alloc >
  struct  hash< ::std::vector<bool, _Alloc> > : ::std::__hash_base<unsigned long int, ::std::vector<bool, _Alloc> >
  {
      ::std::size_t operator ()(const ::std::vector<bool, _Alloc> &__b) const  noexcept(true);
  };
  template < typename _Tp, typename _Alloc >
  void vector<_Tp, _Alloc>::reserve(typename ::std::vector<_Tp, _Alloc>::size_type __n)
  {
    if (__n > this->max_size())
      {
        ::std::__throw_length_error("vector::reserve");
      }
    if (this->capacity() < __n)
      {
        const typename ::std::vector<_Tp, _Alloc>::size_type __old_size = (*this).size();
        typename ::std::vector<_Tp, _Alloc>::pointer __tmp = (*this)._M_allocate_and_copy(__n, std::__make_move_if_noexcept_iterator(this->_M_impl._M_start), std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
        _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        this->_M_impl._M_start = __tmp;
        this->_M_impl._M_finish = __tmp + __old_size;
        this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename ..._Args >
  void vector<_Tp, _Alloc>::emplace_back(_Args &&...__args)
  {
    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
      {
        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::forward<_Args>(__args) ...);
         ++this->_M_impl._M_finish;
      }
    else
      {
        (*this)._M_emplace_back_aux(std::forward<_Args>(__args) ...);
      }
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, const typename ::std::vector<_Tp, _Alloc>::value_type &__x)
  {
    const typename ::std::vector<_Tp, _Alloc>::size_type __n = __position - (*this).begin();
    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage && __position == (*this).end())
      {
        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
         ++this->_M_impl._M_finish;
      }
    else
      {
        if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
          {
            _Tp __x_copy = __x;
            (*this)._M_insert_aux(__position, std::move(__x_copy));
          }
        else
          {
            (*this)._M_insert_aux(__position, __x);
          }
      }
    return ((typename ::std::vector<_Tp, _Alloc>::iterator(this->_M_impl._M_start + __n)));
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::erase(typename ::std::vector<_Tp, _Alloc>::iterator __position)
  {
    if (__position + 1 != (*this).end())
      {
        std::move(__position + 1, (*this).end(), __position);
      }
     --this->_M_impl._M_finish;
    _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
    return __position;
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::erase(typename ::std::vector<_Tp, _Alloc>::iterator __first, typename ::std::vector<_Tp, _Alloc>::iterator __last)
  {
    if (__first != __last)
      {
        if (__last != (*this).end())
          {
            std::move(__last, (*this).end(), __first);
          }
        (*this)._M_erase_at_end(__first.base() + ((*this).end() - __last));
      }
    return __first;
  }
  template < typename _Tp, typename _Alloc >
  ::std::vector<_Tp, _Alloc> &vector<_Tp, _Alloc>::operator =(const ::std::vector<_Tp, _Alloc> &__x)
  {
    if (&__x != this)
      {
        if (_Alloc_traits::_S_propagate_on_copy_assign())
          {
            if (!_Alloc_traits::_S_always_equal() && (_M_get_Tp_allocator)() != __x._M_get_Tp_allocator())
              {
                this->clear();
                _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
                this->_M_impl._M_start = nullptr;
                this->_M_impl._M_finish = nullptr;
                this->_M_impl._M_end_of_storage = nullptr;
              }
            std::__alloc_on_copy((_M_get_Tp_allocator)(), __x._M_get_Tp_allocator());
          }
        const typename ::std::vector<_Tp, _Alloc>::size_type __xlen = __x.size();
        if (__xlen > (*this).capacity())
          {
            typename ::std::vector<_Tp, _Alloc>::pointer __tmp = (*this)._M_allocate_and_copy(__xlen, __x.begin(), __x.end());
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __tmp;
            this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
          }
        else
          {
            if ((*this).size() >= __xlen)
              {
                std::_Destroy(std::copy(__x.begin(), __x.end(), (*this).begin()), (*this).end(), (_M_get_Tp_allocator)());
              }
            else
              {
                std::copy(__x._M_impl._M_start, __x._M_impl._M_start + (*this).size(), this->_M_impl._M_start);
                std::__uninitialized_copy_a(__x._M_impl._M_start + (*this).size(), __x._M_impl._M_finish, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
              }
          }
        this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
      }
    return *this;
  }
  template < typename _Tp, typename _Alloc >
  void vector<_Tp, _Alloc>::_M_fill_assign(::std::size_t __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__val)
  {
    if (__n > (*this).capacity())
      {
        ::std::vector<_Tp, _Alloc> __tmp(__n, __val, (_M_get_Tp_allocator)());
        __tmp.swap(*this);
      }
    else
      {
        if (__n > (*this).size())
          {
            std::fill((*this).begin(), (*this).end(), __val);
            std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - (*this).size(), __val, (_M_get_Tp_allocator)());
            this->_M_impl._M_finish += __n - (*this).size();
          }
        else
          {
            (*this)._M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _InputIterator >
  void vector<_Tp, _Alloc>::_M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
  {
    typename ::std::vector<_Tp, _Alloc>::pointer __cur(this->_M_impl._M_start);
    for (; __first != __last && __cur != this->_M_impl._M_finish; ( ++__cur,  ++__first))
      {
        *__cur = *__first;
      }
    if (__first == __last)
      {
        (*this)._M_erase_at_end(__cur);
      }
    else
      {
        (*this).insert((*this).end(), __first, __last);
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _ForwardIterator >
  void vector<_Tp, _Alloc>::_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
  {
    const typename ::std::vector<_Tp, _Alloc>::size_type __len = std::distance(__first, __last);
    if (__len > (*this).capacity())
      {
        typename ::std::vector<_Tp, _Alloc>::pointer __tmp((*this)._M_allocate_and_copy(__len, __first, __last));
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
        _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        this->_M_impl._M_start = __tmp;
        this->_M_impl._M_finish = this->_M_impl._M_start + __len;
        this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
      }
    else
      {
        if ((*this).size() >= __len)
          {
            (*this)._M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
          }
        else
          {
            _ForwardIterator __mid = __first;
            std::advance(__mid, (*this).size());
            std::copy(__first, __mid, this->_M_impl._M_start);
            this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename ..._Args >
  typename ::std::vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::emplace(typename ::std::vector<_Tp, _Alloc>::iterator __position, _Args &&...__args)
  {
    const typename ::std::vector<_Tp, _Alloc>::size_type __n = __position - (*this).begin();
    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage && __position == (*this).end())
      {
        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::forward<_Args>(__args) ...);
         ++this->_M_impl._M_finish;
      }
    else
      {
        (*this)._M_insert_aux(__position, std::forward<_Args>(__args) ...);
      }
    return ((typename ::std::vector<_Tp, _Alloc>::iterator(this->_M_impl._M_start + __n)));
  }
  template < typename _Tp, typename _Alloc >
  template < typename ..._Args >
  void vector<_Tp, _Alloc>::_M_insert_aux(typename ::std::vector<_Tp, _Alloc>::iterator __position, _Args &&...__args)
  {
    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
      {
        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, std::move(*(this->_M_impl._M_finish - 1)));
         ++this->_M_impl._M_finish;
        std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);
        *__position = _Tp(std::forward<_Args>(__args) ...);
      }
    else
      {
        const typename ::std::vector<_Tp, _Alloc>::size_type __len = (*this)._M_check_len((typename ::std::vector<_Tp, _Alloc>::size_type)1, "vector::_M_insert_aux");
        const typename ::std::vector<_Tp, _Alloc>::size_type __elems_before = __position - (*this).begin();
        typename ::std::vector<_Tp, _Alloc>::pointer __new_start(this->_M_allocate(__len));
        typename ::std::vector<_Tp, _Alloc>::pointer __new_finish(__new_start);
        try
        {
          _Alloc_traits::construct(this->_M_impl, __new_start + __elems_before, std::forward<_Args>(__args) ...);
          __new_finish = 0;
          __new_finish = std::__uninitialized_move_if_noexcept_a(this->_M_impl._M_start, __position.base(), __new_start, (_M_get_Tp_allocator)());
           ++__new_finish;
          __new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), this->_M_impl._M_finish, __new_finish, (_M_get_Tp_allocator)());
        }
        catch (...)
        {
          if (!__new_finish)
            {
              _Alloc_traits::destroy(this->_M_impl, __new_start + __elems_before);
            }
          else
            {
              std::_Destroy(__new_start, __new_finish, (_M_get_Tp_allocator)());
            }
          _M_deallocate(__new_start, __len);
          throw;
        }
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
        _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        this->_M_impl._M_start = __new_start;
        this->_M_impl._M_finish = __new_finish;
        this->_M_impl._M_end_of_storage = __new_start + __len;
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename ..._Args >
  void vector<_Tp, _Alloc>::_M_emplace_back_aux(_Args &&...__args)
  {
    const typename ::std::vector<_Tp, _Alloc>::size_type __len = (*this)._M_check_len((typename ::std::vector<_Tp, _Alloc>::size_type)1, "vector::_M_emplace_back_aux");
    typename ::std::vector<_Tp, _Alloc>::pointer __new_start(this->_M_allocate(__len));
    typename ::std::vector<_Tp, _Alloc>::pointer __new_finish(__new_start);
    try
    {
      _Alloc_traits::construct(this->_M_impl, __new_start + (*this).size(), std::forward<_Args>(__args) ...);
      __new_finish = 0;
      __new_finish = std::__uninitialized_move_if_noexcept_a(this->_M_impl._M_start, this->_M_impl._M_finish, __new_start, (_M_get_Tp_allocator)());
       ++__new_finish;
    }
    catch (...)
    {
      if (!__new_finish)
        {
          _Alloc_traits::destroy(this->_M_impl, __new_start + (*this).size());
        }
      else
        {
          std::_Destroy(__new_start, __new_finish, (_M_get_Tp_allocator)());
        }
      _M_deallocate(__new_start, __len);
      throw;
    }
    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
    _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
    this->_M_impl._M_start = __new_start;
    this->_M_impl._M_finish = __new_finish;
    this->_M_impl._M_end_of_storage = __new_start + __len;
  }
  template < typename _Tp, typename _Alloc >
  void vector<_Tp, _Alloc>::_M_fill_insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, typename ::std::vector<_Tp, _Alloc>::size_type __n, const typename ::std::vector<_Tp, _Alloc>::value_type &__x)
  {
    if (__n != 0)
      {
        if (((typename ::std::vector<_Tp, _Alloc>::size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish))) >= __n)
          {
            typename ::std::vector<_Tp, _Alloc>::value_type __x_copy = __x;
            const typename ::std::vector<_Tp, _Alloc>::size_type __elems_after = (*this).end() - __position;
            typename ::std::vector<_Tp, _Alloc>::pointer __old_finish(this->_M_impl._M_finish);
            if (__elems_after > __n)
              {
                std::__uninitialized_move_a(this->_M_impl._M_finish - __n, this->_M_impl._M_finish, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
                this->_M_impl._M_finish += __n;
                std::move_backward(__position.base(), __old_finish - __n, __old_finish);
                std::fill(__position.base(), __position.base() + __n, __x_copy);
              }
            else
              {
                std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - __elems_after, __x_copy, (_M_get_Tp_allocator)());
                this->_M_impl._M_finish += __n - __elems_after;
                std::__uninitialized_move_a(__position.base(), __old_finish, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
                this->_M_impl._M_finish += __elems_after;
                std::fill(__position.base(), __old_finish, __x_copy);
              }
          }
        else
          {
            const typename ::std::vector<_Tp, _Alloc>::size_type __len = (*this)._M_check_len(__n, "vector::_M_fill_insert");
            const typename ::std::vector<_Tp, _Alloc>::size_type __elems_before = __position - (*this).begin();
            typename ::std::vector<_Tp, _Alloc>::pointer __new_start(this->_M_allocate(__len));
            typename ::std::vector<_Tp, _Alloc>::pointer __new_finish(__new_start);
            try
            {
              std::__uninitialized_fill_n_a(__new_start + __elems_before, __n, __x, (_M_get_Tp_allocator)());
              __new_finish = 0;
              __new_finish = std::__uninitialized_move_if_noexcept_a(this->_M_impl._M_start, __position.base(), __new_start, (_M_get_Tp_allocator)());
              __new_finish += __n;
              __new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), this->_M_impl._M_finish, __new_finish, (_M_get_Tp_allocator)());
            }
            catch (...)
            {
              if (!__new_finish)
                {
                  std::_Destroy(__new_start + __elems_before, __new_start + __elems_before + __n, (_M_get_Tp_allocator)());
                }
              else
                {
                  std::_Destroy(__new_start, __new_finish, (_M_get_Tp_allocator)());
                }
              _M_deallocate(__new_start, __len);
              throw;
            }
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __new_start;
            this->_M_impl._M_finish = __new_finish;
            this->_M_impl._M_end_of_storage = __new_start + __len;
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  void vector<_Tp, _Alloc>::_M_default_append(typename ::std::vector<_Tp, _Alloc>::size_type __n)
  {
    if (__n != 0)
      {
        if (((typename ::std::vector<_Tp, _Alloc>::size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish))) >= __n)
          {
            std::__uninitialized_default_n_a(this->_M_impl._M_finish, __n, (_M_get_Tp_allocator)());
            this->_M_impl._M_finish += __n;
          }
        else
          {
            const typename ::std::vector<_Tp, _Alloc>::size_type __len = (*this)._M_check_len(__n, "vector::_M_default_append");
            const typename ::std::vector<_Tp, _Alloc>::size_type __old_size = this->size();
            typename ::std::vector<_Tp, _Alloc>::pointer __new_start(this->_M_allocate(__len));
            typename ::std::vector<_Tp, _Alloc>::pointer __new_finish(__new_start);
            try
            {
              __new_finish = std::__uninitialized_move_if_noexcept_a(this->_M_impl._M_start, this->_M_impl._M_finish, __new_start, (_M_get_Tp_allocator)());
              std::__uninitialized_default_n_a(__new_finish, __n, (_M_get_Tp_allocator)());
              __new_finish += __n;
            }
            catch (...)
            {
              std::_Destroy(__new_start, __new_finish, (_M_get_Tp_allocator)());
              _M_deallocate(__new_start, __len);
              throw;
            }
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __new_start;
            this->_M_impl._M_finish = __new_finish;
            this->_M_impl._M_end_of_storage = __new_start + __len;
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  bool vector<_Tp, _Alloc>::_M_shrink_to_fit()
  {
    if ((*this).capacity() == (*this).size())
      {
        return false;
      }
    return std::__shrink_to_fit_aux< ::std::vector<_Tp, _Alloc> >::_S_do_it(*this);
  }
  template < typename _Tp, typename _Alloc >
  template < typename _InputIterator >
  void vector<_Tp, _Alloc>::_M_range_insert(typename ::std::vector<_Tp, _Alloc>::iterator __pos, _InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
  {
    for (; __first != __last;  ++__first)
      {
        __pos = (*this).insert(__pos, *__first);
         ++__pos;
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _ForwardIterator >
  void vector<_Tp, _Alloc>::_M_range_insert(typename ::std::vector<_Tp, _Alloc>::iterator __position, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
  {
    if (__first != __last)
      {
        const typename ::std::vector<_Tp, _Alloc>::size_type __n = std::distance(__first, __last);
        if (((typename ::std::vector<_Tp, _Alloc>::size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish))) >= __n)
          {
            const typename ::std::vector<_Tp, _Alloc>::size_type __elems_after = (*this).end() - __position;
            typename ::std::vector<_Tp, _Alloc>::pointer __old_finish(this->_M_impl._M_finish);
            if (__elems_after > __n)
              {
                std::__uninitialized_move_a(this->_M_impl._M_finish - __n, this->_M_impl._M_finish, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
                this->_M_impl._M_finish += __n;
                std::move_backward(__position.base(), __old_finish - __n, __old_finish);
                std::copy(__first, __last, __position);
              }
            else
              {
                _ForwardIterator __mid = __first;
                std::advance(__mid, __elems_after);
                std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
                this->_M_impl._M_finish += __n - __elems_after;
                std::__uninitialized_move_a(__position.base(), __old_finish, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
                this->_M_impl._M_finish += __elems_after;
                std::copy(__first, __mid, __position);
              }
          }
        else
          {
            const typename ::std::vector<_Tp, _Alloc>::size_type __len = (*this)._M_check_len(__n, "vector::_M_range_insert");
            typename ::std::vector<_Tp, _Alloc>::pointer __new_start(this->_M_allocate(__len));
            typename ::std::vector<_Tp, _Alloc>::pointer __new_finish(__new_start);
            try
            {
              __new_finish = std::__uninitialized_move_if_noexcept_a(this->_M_impl._M_start, __position.base(), __new_start, (_M_get_Tp_allocator)());
              __new_finish = std::__uninitialized_copy_a(__first, __last, __new_finish, (_M_get_Tp_allocator)());
              __new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), this->_M_impl._M_finish, __new_finish, (_M_get_Tp_allocator)());
            }
            catch (...)
            {
              std::_Destroy(__new_start, __new_finish, (_M_get_Tp_allocator)());
              _M_deallocate(__new_start, __len);
              throw;
            }
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, (_M_get_Tp_allocator)());
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __new_start;
            this->_M_impl._M_finish = __new_finish;
            this->_M_impl._M_end_of_storage = __new_start + __len;
          }
      }
  }
  template < typename _Alloc >
  void vector<bool, _Alloc>::_M_reallocate(typename ::std::vector<bool, _Alloc>::size_type __n)
  {
    ::std::_Bit_type *__q = this->_M_allocate(__n);
    this->_M_impl._M_finish = (*this)._M_copy_aligned((*this).begin(), (*this).end(), ::std::_Bit_iterator(__q, 0));
    this->_M_deallocate();
    this->_M_impl._M_start = ::std::_Bit_iterator(__q, 0);
    this->_M_impl._M_end_of_storage = __q + (_S_nword)(__n);
  }
  template < typename _Alloc >
  void vector<bool, _Alloc>::_M_fill_insert(typename ::std::vector<bool, _Alloc>::iterator __position, typename ::std::vector<bool, _Alloc>::size_type __n, bool __x)
  {
    if (__n == 0)
      {
        return ;
      }
    if ((*this).capacity() - (*this).size() >= __n)
      {
        std::copy_backward(__position, (*this).end(), this->_M_impl._M_finish + (typename ::std::vector<bool, _Alloc>::difference_type)__n);
        std::fill(__position, __position + (typename ::std::vector<bool, _Alloc>::difference_type)__n, __x);
        this->_M_impl._M_finish += (typename ::std::vector<bool, _Alloc>::difference_type)__n;
      }
    else
      {
        const typename ::std::vector<bool, _Alloc>::size_type __len = (*this)._M_check_len(__n, "vector<bool>::_M_fill_insert");
        ::std::_Bit_type *__q = this->_M_allocate(__len);
        typename ::std::vector<bool, _Alloc>::iterator __i = (*this)._M_copy_aligned((*this).begin(), __position, ::std::_Bit_iterator(__q, 0));
        std::fill(__i, __i + (typename ::std::vector<bool, _Alloc>::difference_type)__n, __x);
        this->_M_impl._M_finish = std::copy(__position, (*this).end(), __i + (typename ::std::vector<bool, _Alloc>::difference_type)__n);
        this->_M_deallocate();
        this->_M_impl._M_end_of_storage = __q + (_S_nword)(__len);
        this->_M_impl._M_start = ::std::_Bit_iterator(__q, 0);
      }
  }
  template < typename _Alloc >
  template < typename _ForwardIterator >
  void vector<bool, _Alloc>::_M_insert_range(typename ::std::vector<bool, _Alloc>::iterator __position, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag)
  {
    if (__first != __last)
      {
        typename ::std::vector<bool, _Alloc>::size_type __n = std::distance(__first, __last);
        if ((*this).capacity() - (*this).size() >= __n)
          {
            std::copy_backward(__position, (*this).end(), this->_M_impl._M_finish + (typename ::std::vector<bool, _Alloc>::difference_type)__n);
            std::copy(__first, __last, __position);
            this->_M_impl._M_finish += (typename ::std::vector<bool, _Alloc>::difference_type)__n;
          }
        else
          {
            const typename ::std::vector<bool, _Alloc>::size_type __len = (*this)._M_check_len(__n, "vector<bool>::_M_insert_range");
            ::std::_Bit_type *__q = this->_M_allocate(__len);
            typename ::std::vector<bool, _Alloc>::iterator __i = (*this)._M_copy_aligned((*this).begin(), __position, ::std::_Bit_iterator(__q, 0));
            __i = std::copy(__first, __last, __i);
            this->_M_impl._M_finish = std::copy(__position, (*this).end(), __i);
            this->_M_deallocate();
            this->_M_impl._M_end_of_storage = __q + (_S_nword)(__len);
            this->_M_impl._M_start = ::std::_Bit_iterator(__q, 0);
          }
      }
  }
  template < typename _Alloc >
  void vector<bool, _Alloc>::_M_insert_aux(typename ::std::vector<bool, _Alloc>::iterator __position, bool __x)
  {
    if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
      {
        std::copy_backward(__position, this->_M_impl._M_finish, this->_M_impl._M_finish + 1);
         *__position = __x;
         ++this->_M_impl._M_finish;
      }
    else
      {
        const typename ::std::vector<bool, _Alloc>::size_type __len = (*this)._M_check_len((typename ::std::vector<bool, _Alloc>::size_type)1, "vector<bool>::_M_insert_aux");
        ::std::_Bit_type *__q = this->_M_allocate(__len);
        typename ::std::vector<bool, _Alloc>::iterator __i = (*this)._M_copy_aligned((*this).begin(), __position, ::std::_Bit_iterator(__q, 0));
         *__i++ = __x;
        this->_M_impl._M_finish = std::copy(__position, (*this).end(), __i);
        this->_M_deallocate();
        this->_M_impl._M_end_of_storage = __q + (_S_nword)(__len);
        this->_M_impl._M_start = ::std::_Bit_iterator(__q, 0);
      }
  }
  template < typename _Alloc >
  bool vector<bool, _Alloc>::_M_shrink_to_fit()
  {
    if ((*this).capacity() - (*this).size() < (int)::std::_S_word_bit)
      {
        return false;
      }
    try
    {
      (*this)._M_reallocate((*this).size());
      return true;
    }
    catch (...)
    {
      return false;
    }
  }
  template < typename _Alloc >
  ::std::size_t hash< ::std::vector<bool, _Alloc> >::operator ()(const ::std::vector<bool, _Alloc> &__b) const  noexcept(true)
  {
    ::std::size_t __hash(0);
    using ::std::_S_word_bit;
    using ::std::_Bit_type;
    const ::std::size_t __words = __b.size() / ::std::_S_word_bit;
    if (__words)
      {
        const ::std::size_t __clength = __words * sizeof(::std::_Bit_type);
        __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
      }
    const ::std::size_t __extrabits = __b.size() % ::std::_S_word_bit;
    if (__extrabits)
      {
        ::std::_Bit_type __hiword = *__b._M_impl._M_finish._M_p;
        __hiword &= ~(~static_cast<unsigned long int>(0) << __extrabits);
        const ::std::size_t __clength = (__extrabits + 8 - 1) / 8;
        if (__words)
          {
            __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
          }
        else
          {
            __hash = std::_Hash_impl::hash(&__hiword, __clength);
          }
      }
    return __hash;
  }
  namespace rel_ops {
    template < typename _Tp >
    inline bool operator !=(const _Tp &__x, const _Tp &__y);
    template < typename _Tp >
    inline bool operator !=(const _Tp &__x, const _Tp &__y)
    {
      return !(__x == __y);
    }
    template < typename _Tp >
    inline bool operator >(const _Tp &__x, const _Tp &__y);
    template < typename _Tp >
    inline bool operator >(const _Tp &__x, const _Tp &__y)
    {
      return __y < __x;
    }
    template < typename _Tp >
    inline bool operator <=(const _Tp &__x, const _Tp &__y);
    template < typename _Tp >
    inline bool operator <=(const _Tp &__x, const _Tp &__y)
    {
      return !(__y < __x);
    }
    template < typename _Tp >
    inline bool operator >=(const _Tp &__x, const _Tp &__y);
    template < typename _Tp >
    inline bool operator >=(const _Tp &__x, const _Tp &__y)
    {
      return !(__x < __y);
    }
  }
  template < typename _Tp >
  class tuple_size;
  template < ::std::size_t _Int, typename _Tp >
  class tuple_element;
 /* Instantiation of class template '::std::integral_constant<unsigned long int, 2>' */ 
  template < typename _Tp1, typename _Tp2 >
  struct  tuple_size< ::std::pair<_Tp1, _Tp2> > : ::std::integral_constant<unsigned long int, 2>
  {
  };
  template < typename _Tp1, typename _Tp2 >
  struct  tuple_element<0LU, ::std::pair<_Tp1, _Tp2> >
  {
      typedef _Tp1 type;
  };
  template < typename _Tp1, typename _Tp2 >
  struct  tuple_element<1LU, ::std::pair<_Tp1, _Tp2> >
  {
      typedef _Tp2 type;
  };
  template < ::std::size_t _Int >
  struct __pair_get;
  template <>
  struct  __pair_get<0LU>
  {
      template < typename _Tp1, typename _Tp2 >
      static inline constexpr _Tp1 &__get(::std::pair<_Tp1, _Tp2> &__pair) noexcept(true)
      {
        return __pair.first;
      }
      template < typename _Tp1, typename _Tp2 >
      static inline constexpr _Tp1 &&__move_get(::std::pair<_Tp1, _Tp2> &&__pair) noexcept(true)
      {
        return std::forward<_Tp1>(__pair.first);
      }
      template < typename _Tp1, typename _Tp2 >
      static inline constexpr const _Tp1 &__const_get(const ::std::pair<_Tp1, _Tp2> &__pair) noexcept(true)
      {
        return __pair.first;
      }
  };
  template <>
  struct  __pair_get<1LU>
  {
      template < typename _Tp1, typename _Tp2 >
      static inline constexpr _Tp2 &__get(::std::pair<_Tp1, _Tp2> &__pair) noexcept(true)
      {
        return __pair.second;
      }
      template < typename _Tp1, typename _Tp2 >
      static inline constexpr _Tp2 &&__move_get(::std::pair<_Tp1, _Tp2> &&__pair) noexcept(true)
      {
        return std::forward<_Tp2>(__pair.second);
      }
      template < typename _Tp1, typename _Tp2 >
      static inline constexpr const _Tp2 &__const_get(const ::std::pair<_Tp1, _Tp2> &__pair) noexcept(true)
      {
        return __pair.second;
      }
  };
  template < ::std::size_t _Int, typename _Tp1, typename _Tp2 >
  inline constexpr typename ::std::tuple_element<_Int, ::std::pair<_Tp1, _Tp2> >::type &get(::std::pair<_Tp1, _Tp2> &__in) noexcept(true);
  template < ::std::size_t _Int, typename _Tp1, typename _Tp2 >
  inline constexpr typename ::std::tuple_element<_Int, ::std::pair<_Tp1, _Tp2> >::type &get(::std::pair<_Tp1, _Tp2> &__in) noexcept(true)
  {
    return __pair_get<_Int>::__get(__in);
  }
  template < ::std::size_t _Int, typename _Tp1, typename _Tp2 >
  inline constexpr typename ::std::tuple_element<_Int, ::std::pair<_Tp1, _Tp2> >::type &&get(::std::pair<_Tp1, _Tp2> &&__in) noexcept(true);
  template < ::std::size_t _Int, typename _Tp1, typename _Tp2 >
  inline constexpr typename ::std::tuple_element<_Int, ::std::pair<_Tp1, _Tp2> >::type &&get(::std::pair<_Tp1, _Tp2> &&__in) noexcept(true)
  {
    return __pair_get<_Int>::__move_get(std::move(__in));
  }
  template < ::std::size_t _Int, typename _Tp1, typename _Tp2 >
  inline constexpr const typename ::std::tuple_element<_Int, ::std::pair<_Tp1, _Tp2> >::type &get(const ::std::pair<_Tp1, _Tp2> &__in) noexcept(true);
  template < ::std::size_t _Int, typename _Tp1, typename _Tp2 >
  inline constexpr const typename ::std::tuple_element<_Int, ::std::pair<_Tp1, _Tp2> >::type &get(const ::std::pair<_Tp1, _Tp2> &__in) noexcept(true)
  {
    return __pair_get<_Int>::__const_get(__in);
  }
}
typedef ::__socklen_t socklen_t;
extern "C"
{
  extern int access(const char *__name, int __type) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int euidaccess(const char *__name, int __type) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int eaccess(const char *__name, int __type) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int faccessat(int __fd, const char *__file, int __type, int __flag) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern ::__off_t lseek(int __fd, ::__off_t __offset, int __whence) throw();
}
extern "C"
{
  extern ::__off64_t lseek64(int __fd, ::__off64_t __offset, int __whence) throw();
}
extern "C"
{
  extern int close(int __fd);
}
extern "C"
{
  extern ::ssize_t read(int __fd, void *__buf, ::size_t __nbytes);
}
extern "C"
{
  extern ::ssize_t write(int __fd, const void *__buf, ::size_t __n);
}
extern "C"
{
  extern ::ssize_t pread(int __fd, void *__buf, ::size_t __nbytes, ::__off_t __offset);
}
extern "C"
{
  extern ::ssize_t pwrite(int __fd, const void *__buf, ::size_t __n, ::__off_t __offset);
}
extern "C"
{
  extern ::ssize_t pread64(int __fd, void *__buf, ::size_t __nbytes, ::__off64_t __offset);
}
extern "C"
{
  extern ::ssize_t pwrite64(int __fd, const void *__buf, ::size_t __n, ::__off64_t __offset);
}
extern "C"
{
  extern int pipe(int __pipedes[2L]) throw();
}
extern "C"
{
  extern int pipe2(int __pipedes[2L], int __flags) throw();
}
extern "C"
{
  extern unsigned int alarm(unsigned int __seconds) throw();
}
extern "C"
{
  extern unsigned int sleep(unsigned int __seconds);
}
extern "C"
{
  extern ::__useconds_t ualarm(::__useconds_t __value, ::__useconds_t __interval) throw();
}
extern "C"
{
  extern int usleep(::__useconds_t __useconds);
}
extern "C"
{
  extern int pause();
}
extern "C"
{
  extern int chown(const char *__file, ::__uid_t __owner, ::__gid_t __group) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int fchown(int __fd, ::__uid_t __owner, ::__gid_t __group) throw();
}
extern "C"
{
  extern int lchown(const char *__file, ::__uid_t __owner, ::__gid_t __group) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int fchownat(int __fd, const char *__file, ::__uid_t __owner, ::__gid_t __group, int __flag) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int chdir(const char *__path) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int fchdir(int __fd) throw();
}
extern "C"
{
  extern char *getcwd(char *__buf, ::size_t __size) throw();
}
extern "C"
{
  extern char *get_current_dir_name() throw();
}
extern "C"
{
  extern char *getwd(char *__buf) throw() __attribute__((__nonnull__(1))) __attribute__((__deprecated__));
}
extern "C"
{
  extern int dup(int __fd) throw();
}
extern "C"
{
  extern int dup2(int __fd, int __fd2) throw();
}
extern "C"
{
  extern int dup3(int __fd, int __fd2, int __flags) throw();
}
extern "C"
{
  extern char **__environ;
}
extern "C"
{
  extern char **environ;
}
extern "C"
{
  extern int execve(const char *__path, char *const __argv[], char *const __envp[]) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int fexecve(int __fd, char *const __argv[], char *const __envp[]) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int execv(const char *__path, char *const __argv[]) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int execle(const char *__path, const char *__arg, ...) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int execl(const char *__path, const char *__arg, ...) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int execvp(const char *__file, char *const __argv[]) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int execlp(const char *__file, const char *__arg, ...) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int execvpe(const char *__file, char *const __argv[], char *const __envp[]) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int nice(int __inc) throw();
}
extern "C"
{
  extern void _exit(int __status) __attribute__((__noreturn__));
}
enum mcc_enum_anon_61
{
  _PC_LINK_MAX = 0,
  _PC_MAX_CANON = 1,
  _PC_MAX_INPUT = 2,
  _PC_NAME_MAX = 3,
  _PC_PATH_MAX = 4,
  _PC_PIPE_BUF = 5,
  _PC_CHOWN_RESTRICTED = 6,
  _PC_NO_TRUNC = 7,
  _PC_VDISABLE = 8,
  _PC_SYNC_IO = 9,
  _PC_ASYNC_IO = 10,
  _PC_PRIO_IO = 11,
  _PC_SOCK_MAXBUF = 12,
  _PC_FILESIZEBITS = 13,
  _PC_REC_INCR_XFER_SIZE = 14,
  _PC_REC_MAX_XFER_SIZE = 15,
  _PC_REC_MIN_XFER_SIZE = 16,
  _PC_REC_XFER_ALIGN = 17,
  _PC_ALLOC_SIZE_MIN = 18,
  _PC_SYMLINK_MAX = 19,
  _PC_2_SYMLINKS = 20
};
enum mcc_enum_anon_62
{
  _SC_ARG_MAX = 0,
  _SC_CHILD_MAX = 1,
  _SC_CLK_TCK = 2,
  _SC_NGROUPS_MAX = 3,
  _SC_OPEN_MAX = 4,
  _SC_STREAM_MAX = 5,
  _SC_TZNAME_MAX = 6,
  _SC_JOB_CONTROL = 7,
  _SC_SAVED_IDS = 8,
  _SC_REALTIME_SIGNALS = 9,
  _SC_PRIORITY_SCHEDULING = 10,
  _SC_TIMERS = 11,
  _SC_ASYNCHRONOUS_IO = 12,
  _SC_PRIORITIZED_IO = 13,
  _SC_SYNCHRONIZED_IO = 14,
  _SC_FSYNC = 15,
  _SC_MAPPED_FILES = 16,
  _SC_MEMLOCK = 17,
  _SC_MEMLOCK_RANGE = 18,
  _SC_MEMORY_PROTECTION = 19,
  _SC_MESSAGE_PASSING = 20,
  _SC_SEMAPHORES = 21,
  _SC_SHARED_MEMORY_OBJECTS = 22,
  _SC_AIO_LISTIO_MAX = 23,
  _SC_AIO_MAX = 24,
  _SC_AIO_PRIO_DELTA_MAX = 25,
  _SC_DELAYTIMER_MAX = 26,
  _SC_MQ_OPEN_MAX = 27,
  _SC_MQ_PRIO_MAX = 28,
  _SC_VERSION = 29,
  _SC_PAGESIZE = 30,
  _SC_RTSIG_MAX = 31,
  _SC_SEM_NSEMS_MAX = 32,
  _SC_SEM_VALUE_MAX = 33,
  _SC_SIGQUEUE_MAX = 34,
  _SC_TIMER_MAX = 35,
  _SC_BC_BASE_MAX = 36,
  _SC_BC_DIM_MAX = 37,
  _SC_BC_SCALE_MAX = 38,
  _SC_BC_STRING_MAX = 39,
  _SC_COLL_WEIGHTS_MAX = 40,
  _SC_EQUIV_CLASS_MAX = 41,
  _SC_EXPR_NEST_MAX = 42,
  _SC_LINE_MAX = 43,
  _SC_RE_DUP_MAX = 44,
  _SC_CHARCLASS_NAME_MAX = 45,
  _SC_2_VERSION = 46,
  _SC_2_C_BIND = 47,
  _SC_2_C_DEV = 48,
  _SC_2_FORT_DEV = 49,
  _SC_2_FORT_RUN = 50,
  _SC_2_SW_DEV = 51,
  _SC_2_LOCALEDEF = 52,
  _SC_PII = 53,
  _SC_PII_XTI = 54,
  _SC_PII_SOCKET = 55,
  _SC_PII_INTERNET = 56,
  _SC_PII_OSI = 57,
  _SC_POLL = 58,
  _SC_SELECT = 59,
  _SC_UIO_MAXIOV = 60,
  _SC_IOV_MAX = ::_SC_UIO_MAXIOV,
  _SC_PII_INTERNET_STREAM = 61,
  _SC_PII_INTERNET_DGRAM = 62,
  _SC_PII_OSI_COTS = 63,
  _SC_PII_OSI_CLTS = 64,
  _SC_PII_OSI_M = 65,
  _SC_T_IOV_MAX = 66,
  _SC_THREADS = 67,
  _SC_THREAD_SAFE_FUNCTIONS = 68,
  _SC_GETGR_R_SIZE_MAX = 69,
  _SC_GETPW_R_SIZE_MAX = 70,
  _SC_LOGIN_NAME_MAX = 71,
  _SC_TTY_NAME_MAX = 72,
  _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
  _SC_THREAD_KEYS_MAX = 74,
  _SC_THREAD_STACK_MIN = 75,
  _SC_THREAD_THREADS_MAX = 76,
  _SC_THREAD_ATTR_STACKADDR = 77,
  _SC_THREAD_ATTR_STACKSIZE = 78,
  _SC_THREAD_PRIORITY_SCHEDULING = 79,
  _SC_THREAD_PRIO_INHERIT = 80,
  _SC_THREAD_PRIO_PROTECT = 81,
  _SC_THREAD_PROCESS_SHARED = 82,
  _SC_NPROCESSORS_CONF = 83,
  _SC_NPROCESSORS_ONLN = 84,
  _SC_PHYS_PAGES = 85,
  _SC_AVPHYS_PAGES = 86,
  _SC_ATEXIT_MAX = 87,
  _SC_PASS_MAX = 88,
  _SC_XOPEN_VERSION = 89,
  _SC_XOPEN_XCU_VERSION = 90,
  _SC_XOPEN_UNIX = 91,
  _SC_XOPEN_CRYPT = 92,
  _SC_XOPEN_ENH_I18N = 93,
  _SC_XOPEN_SHM = 94,
  _SC_2_CHAR_TERM = 95,
  _SC_2_C_VERSION = 96,
  _SC_2_UPE = 97,
  _SC_XOPEN_XPG2 = 98,
  _SC_XOPEN_XPG3 = 99,
  _SC_XOPEN_XPG4 = 100,
  _SC_CHAR_BIT = 101,
  _SC_CHAR_MAX = 102,
  _SC_CHAR_MIN = 103,
  _SC_INT_MAX = 104,
  _SC_INT_MIN = 105,
  _SC_LONG_BIT = 106,
  _SC_WORD_BIT = 107,
  _SC_MB_LEN_MAX = 108,
  _SC_NZERO = 109,
  _SC_SSIZE_MAX = 110,
  _SC_SCHAR_MAX = 111,
  _SC_SCHAR_MIN = 112,
  _SC_SHRT_MAX = 113,
  _SC_SHRT_MIN = 114,
  _SC_UCHAR_MAX = 115,
  _SC_UINT_MAX = 116,
  _SC_ULONG_MAX = 117,
  _SC_USHRT_MAX = 118,
  _SC_NL_ARGMAX = 119,
  _SC_NL_LANGMAX = 120,
  _SC_NL_MSGMAX = 121,
  _SC_NL_NMAX = 122,
  _SC_NL_SETMAX = 123,
  _SC_NL_TEXTMAX = 124,
  _SC_XBS5_ILP32_OFF32 = 125,
  _SC_XBS5_ILP32_OFFBIG = 126,
  _SC_XBS5_LP64_OFF64 = 127,
  _SC_XBS5_LPBIG_OFFBIG = 128,
  _SC_XOPEN_LEGACY = 129,
  _SC_XOPEN_REALTIME = 130,
  _SC_XOPEN_REALTIME_THREADS = 131,
  _SC_ADVISORY_INFO = 132,
  _SC_BARRIERS = 133,
  _SC_BASE = 134,
  _SC_C_LANG_SUPPORT = 135,
  _SC_C_LANG_SUPPORT_R = 136,
  _SC_CLOCK_SELECTION = 137,
  _SC_CPUTIME = 138,
  _SC_THREAD_CPUTIME = 139,
  _SC_DEVICE_IO = 140,
  _SC_DEVICE_SPECIFIC = 141,
  _SC_DEVICE_SPECIFIC_R = 142,
  _SC_FD_MGMT = 143,
  _SC_FIFO = 144,
  _SC_PIPE = 145,
  _SC_FILE_ATTRIBUTES = 146,
  _SC_FILE_LOCKING = 147,
  _SC_FILE_SYSTEM = 148,
  _SC_MONOTONIC_CLOCK = 149,
  _SC_MULTI_PROCESS = 150,
  _SC_SINGLE_PROCESS = 151,
  _SC_NETWORKING = 152,
  _SC_READER_WRITER_LOCKS = 153,
  _SC_SPIN_LOCKS = 154,
  _SC_REGEXP = 155,
  _SC_REGEX_VERSION = 156,
  _SC_SHELL = 157,
  _SC_SIGNALS = 158,
  _SC_SPAWN = 159,
  _SC_SPORADIC_SERVER = 160,
  _SC_THREAD_SPORADIC_SERVER = 161,
  _SC_SYSTEM_DATABASE = 162,
  _SC_SYSTEM_DATABASE_R = 163,
  _SC_TIMEOUTS = 164,
  _SC_TYPED_MEMORY_OBJECTS = 165,
  _SC_USER_GROUPS = 166,
  _SC_USER_GROUPS_R = 167,
  _SC_2_PBS = 168,
  _SC_2_PBS_ACCOUNTING = 169,
  _SC_2_PBS_LOCATE = 170,
  _SC_2_PBS_MESSAGE = 171,
  _SC_2_PBS_TRACK = 172,
  _SC_SYMLOOP_MAX = 173,
  _SC_STREAMS = 174,
  _SC_2_PBS_CHECKPOINT = 175,
  _SC_V6_ILP32_OFF32 = 176,
  _SC_V6_ILP32_OFFBIG = 177,
  _SC_V6_LP64_OFF64 = 178,
  _SC_V6_LPBIG_OFFBIG = 179,
  _SC_HOST_NAME_MAX = 180,
  _SC_TRACE = 181,
  _SC_TRACE_EVENT_FILTER = 182,
  _SC_TRACE_INHERIT = 183,
  _SC_TRACE_LOG = 184,
  _SC_LEVEL1_ICACHE_SIZE = 185,
  _SC_LEVEL1_ICACHE_ASSOC = 186,
  _SC_LEVEL1_ICACHE_LINESIZE = 187,
  _SC_LEVEL1_DCACHE_SIZE = 188,
  _SC_LEVEL1_DCACHE_ASSOC = 189,
  _SC_LEVEL1_DCACHE_LINESIZE = 190,
  _SC_LEVEL2_CACHE_SIZE = 191,
  _SC_LEVEL2_CACHE_ASSOC = 192,
  _SC_LEVEL2_CACHE_LINESIZE = 193,
  _SC_LEVEL3_CACHE_SIZE = 194,
  _SC_LEVEL3_CACHE_ASSOC = 195,
  _SC_LEVEL3_CACHE_LINESIZE = 196,
  _SC_LEVEL4_CACHE_SIZE = 197,
  _SC_LEVEL4_CACHE_ASSOC = 198,
  _SC_LEVEL4_CACHE_LINESIZE = 199,
  _SC_IPV6 = ::_SC_LEVEL1_ICACHE_SIZE + 50,
  _SC_RAW_SOCKETS = 236,
  _SC_V7_ILP32_OFF32 = 237,
  _SC_V7_ILP32_OFFBIG = 238,
  _SC_V7_LP64_OFF64 = 239,
  _SC_V7_LPBIG_OFFBIG = 240,
  _SC_SS_REPL_MAX = 241,
  _SC_TRACE_EVENT_NAME_MAX = 242,
  _SC_TRACE_NAME_MAX = 243,
  _SC_TRACE_SYS_MAX = 244,
  _SC_TRACE_USER_EVENT_MAX = 245,
  _SC_XOPEN_STREAMS = 246,
  _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
  _SC_THREAD_ROBUST_PRIO_PROTECT = 248
};
enum mcc_enum_anon_63
{
  _CS_PATH = 0,
  _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
  _CS_GNU_LIBC_VERSION = 2,
  _CS_GNU_LIBPTHREAD_VERSION = 3,
  _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
  _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
  _CS_LFS_CFLAGS = 1000,
  _CS_LFS_LDFLAGS = 1001,
  _CS_LFS_LIBS = 1002,
  _CS_LFS_LINTFLAGS = 1003,
  _CS_LFS64_CFLAGS = 1004,
  _CS_LFS64_LDFLAGS = 1005,
  _CS_LFS64_LIBS = 1006,
  _CS_LFS64_LINTFLAGS = 1007,
  _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
  _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
  _CS_XBS5_ILP32_OFF32_LIBS = 1102,
  _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
  _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
  _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
  _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
  _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
  _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
  _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
  _CS_XBS5_LP64_OFF64_LIBS = 1110,
  _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
  _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
  _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
  _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
  _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
  _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
  _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
  _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
  _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
  _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
  _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
  _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
  _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
  _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
  _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
  _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
  _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
  _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
  _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
  _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
  _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
  _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
  _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
  _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
  _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
  _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
  _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
  _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
  _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
  _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
  _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
  _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
  _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
  _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
  _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
  _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
  _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
  _CS_V6_ENV = 1148,
  _CS_V7_ENV = 1149
};
extern "C"
{
  extern long int pathconf(const char *__path, int __name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int fpathconf(int __fd, int __name) throw();
}
extern "C"
{
  extern long int sysconf(int __name) throw();
}
extern "C"
{
  extern ::size_t confstr(int __name, char *__buf, ::size_t __len) throw();
}
extern "C"
{
  extern ::__pid_t getpid() throw();
}
extern "C"
{
  extern ::__pid_t getppid() throw();
}
extern "C"
{
  extern ::__pid_t getpgrp() throw();
}
extern "C"
{
  extern ::__pid_t __getpgid(::__pid_t __pid) throw();
}
extern "C"
{
  extern ::__pid_t getpgid(::__pid_t __pid) throw();
}
extern "C"
{
  extern int setpgid(::__pid_t __pid, ::__pid_t __pgid) throw();
}
extern "C"
{
  extern int setpgrp() throw();
}
extern "C"
{
  extern ::__pid_t setsid() throw();
}
extern "C"
{
  extern ::__pid_t getsid(::__pid_t __pid) throw();
}
extern "C"
{
  extern ::__uid_t getuid() throw();
}
extern "C"
{
  extern ::__uid_t geteuid() throw();
}
extern "C"
{
  extern ::__gid_t getgid() throw();
}
extern "C"
{
  extern ::__gid_t getegid() throw();
}
extern "C"
{
  extern int getgroups(int __size, ::__gid_t __list[]) throw();
}
extern "C"
{
  extern int group_member(::__gid_t __gid) throw();
}
extern "C"
{
  extern int setuid(::__uid_t __uid) throw();
}
extern "C"
{
  extern int setreuid(::__uid_t __ruid, ::__uid_t __euid) throw();
}
extern "C"
{
  extern int seteuid(::__uid_t __uid) throw();
}
extern "C"
{
  extern int setgid(::__gid_t __gid) throw();
}
extern "C"
{
  extern int setregid(::__gid_t __rgid, ::__gid_t __egid) throw();
}
extern "C"
{
  extern int setegid(::__gid_t __gid) throw();
}
extern "C"
{
  extern int getresuid(::__uid_t *__ruid, ::__uid_t *__euid, ::__uid_t *__suid) throw();
}
extern "C"
{
  extern int getresgid(::__gid_t *__rgid, ::__gid_t *__egid, ::__gid_t *__sgid) throw();
}
extern "C"
{
  extern int setresuid(::__uid_t __ruid, ::__uid_t __euid, ::__uid_t __suid) throw();
}
extern "C"
{
  extern int setresgid(::__gid_t __rgid, ::__gid_t __egid, ::__gid_t __sgid) throw();
}
extern "C"
{
  extern ::__pid_t fork() throw();
}
extern "C"
{
  extern ::__pid_t vfork() throw();
}
extern "C"
{
  extern char *ttyname(int __fd) throw();
}
extern "C"
{
  extern int ttyname_r(int __fd, char *__buf, ::size_t __buflen) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int isatty(int __fd) throw();
}
extern "C"
{
  extern int ttyslot() throw();
}
extern "C"
{
  extern int link(const char *__from, const char *__to) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int linkat(int __fromfd, const char *__from, int __tofd, const char *__to, int __flags) throw() __attribute__((__nonnull__(2, 4)));
}
extern "C"
{
  extern int symlink(const char *__from, const char *__to) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern ::ssize_t readlink(const char *__restrict __path, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int symlinkat(const char *__from, int __tofd, const char *__to) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern ::ssize_t readlinkat(int __fd, const char *__restrict __path, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(2, 3)));
}
extern "C"
{
  extern int unlink(const char *__name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int unlinkat(int __fd, const char *__name, int __flag) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int rmdir(const char *__path) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern ::__pid_t tcgetpgrp(int __fd) throw();
}
extern "C"
{
  extern int tcsetpgrp(int __fd, ::__pid_t __pgrp_id) throw();
}
extern "C"
{
  extern char *getlogin();
}
extern "C"
{
  extern int getlogin_r(char *__name, ::size_t __name_len) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int setlogin(const char *__name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *optarg;
}
extern "C"
{
  extern int optind;
}
extern "C"
{
  extern int opterr;
}
extern "C"
{
  extern int optopt;
}
extern "C"
{
  extern int getopt(int ___argc, char *const *___argv, const char *__shortopts) throw();
}
extern "C"
{
  extern int gethostname(char *__name, ::size_t __len) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int sethostname(const char *__name, ::size_t __len) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int sethostid(long int __id) throw();
}
extern "C"
{
  extern int getdomainname(char *__name, ::size_t __len) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int setdomainname(const char *__name, ::size_t __len) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int vhangup() throw();
}
extern "C"
{
  extern int revoke(const char *__file) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int profil(unsigned short int *__sample_buffer, ::size_t __size, ::size_t __offset, unsigned int __scale) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int acct(const char *__name) throw();
}
extern "C"
{
  extern char *getusershell() throw();
}
extern "C"
{
  extern void endusershell() throw();
}
extern "C"
{
  extern void setusershell() throw();
}
extern "C"
{
  extern int daemon(int __nochdir, int __noclose) throw();
}
extern "C"
{
  extern int chroot(const char *__path) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *getpass(const char *__prompt) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int fsync(int __fd);
}
extern "C"
{
  extern int syncfs(int __fd) throw();
}
extern "C"
{
  extern long int gethostid();
}
extern "C"
{
  extern void sync() throw();
}
extern "C"
{
  extern int getpagesize() throw() __attribute__((__const__));
}
extern "C"
{
  extern int getdtablesize() throw();
}
extern "C"
{
  extern int truncate(const char *__file, ::__off_t __length) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int truncate64(const char *__file, ::__off64_t __length) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int ftruncate(int __fd, ::__off_t __length) throw();
}
extern "C"
{
  extern int ftruncate64(int __fd, ::__off64_t __length) throw();
}
extern "C"
{
  extern int brk(void *__addr) throw();
}
extern "C"
{
  extern void *sbrk(::intptr_t __delta) throw();
}
extern "C"
{
  extern long int syscall(long int __sysno, ...) throw();
}
extern "C"
{
  extern int lockf(int __fd, int __cmd, ::__off_t __len);
}
extern "C"
{
  extern int lockf64(int __fd, int __cmd, ::__off64_t __len);
}
extern "C"
{
  extern int fdatasync(int __fildes);
}
extern "C"
{
  extern char *crypt(const char *__key, const char *__salt) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern void encrypt(char *__glibc_block, int __edflag) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void swab(const void *__restrict __from, void *__restrict __to, ::ssize_t __n) throw() __attribute__((__nonnull__(1, 2)));
}
namespace boost {
  __extension__ typedef long long int long_long_type;
  __extension__ typedef unsigned long long int ulong_long_type;
  __extension__ typedef __int128 int128_type;
  __extension__ typedef unsigned __int128 uint128_type;
}
extern "C"
{
  extern void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function) throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function) throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern void __assert(const char *__assertion, const char *__file, int __line) throw() __attribute__((__noreturn__));
}
namespace std __attribute__((__visibility__("default"))) {
  extern ::std::istream cin;
  extern ::std::ostream cout;
  extern ::std::ostream cerr;
  extern ::std::ostream clog;
  extern ::std::wistream wcin;
  extern ::std::wostream wcout;
  extern ::std::wostream wcerr;
  extern ::std::wostream wclog;
  static ::std::ios_base::Init __ioinit /* () */ ;
}
namespace boost {
  namespace detail {
    inline void current_function_helper()
    {
    }
 /* Instantiation of template function '::std::basic_ostream<char> &::std::operator <<< ::std::char_traits<char> >(::std::basic_ostream<char> &, const char *)' */ 
 /* Instantiation of template function '::std::basic_ostream<char> &::std::operator <<< ::std::char_traits<char> >(::std::basic_ostream<char> &, char)' */ 
 /* Instantiation of template function '::std::basic_ostream<char> &::std::basic_ostream<char>::operator <<(long int)' */ 
 /* Instantiation of template function '::std::basic_ostream<char> &::std::basic_ostream<char>::operator <<(::std::basic_ostream<char> &(*)(::std::basic_ostream<char> &))' */ 
  }
  namespace assertion {
    namespace detail {
      inline void assertion_failed_msg(const char *expr, const char *msg, const char *function, const char *file, long int line)
      {
        ::std::cerr << "***** Internal Program Error - assertion (" << expr << ") failed in " << function << ":\n" << file << '(' << line << "): " << msg << ::std::endl<char, ::std::char_traits<char> >;
        ::std::abort();
      }
    }
  }
}
namespace std __attribute__((__visibility__("default"))) {
   using ::clock_t;
  using ::time_t;
  using ::tm;
  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
  class  time_base
  {
    public:
      enum dateorder
      {
        no_order = 0,
        dmy = 1,
        mdy = 2,
        ymd = 3,
        ydm = 4
      };
  };
  template < typename _CharT >
  struct  __timepunct_cache : ::std::locale::facet
  {
      static const _CharT *_S_timezones[14L];
      const _CharT *_M_date_format;
      const _CharT *_M_date_era_format;
      const _CharT *_M_time_format;
      const _CharT *_M_time_era_format;
      const _CharT *_M_date_time_format;
      const _CharT *_M_date_time_era_format;
      const _CharT *_M_am;
      const _CharT *_M_pm;
      const _CharT *_M_am_pm_format;
      const _CharT *_M_day1;
      const _CharT *_M_day2;
      const _CharT *_M_day3;
      const _CharT *_M_day4;
      const _CharT *_M_day5;
      const _CharT *_M_day6;
      const _CharT *_M_day7;
      const _CharT *_M_aday1;
      const _CharT *_M_aday2;
      const _CharT *_M_aday3;
      const _CharT *_M_aday4;
      const _CharT *_M_aday5;
      const _CharT *_M_aday6;
      const _CharT *_M_aday7;
      const _CharT *_M_month01;
      const _CharT *_M_month02;
      const _CharT *_M_month03;
      const _CharT *_M_month04;
      const _CharT *_M_month05;
      const _CharT *_M_month06;
      const _CharT *_M_month07;
      const _CharT *_M_month08;
      const _CharT *_M_month09;
      const _CharT *_M_month10;
      const _CharT *_M_month11;
      const _CharT *_M_month12;
      const _CharT *_M_amonth01;
      const _CharT *_M_amonth02;
      const _CharT *_M_amonth03;
      const _CharT *_M_amonth04;
      const _CharT *_M_amonth05;
      const _CharT *_M_amonth06;
      const _CharT *_M_amonth07;
      const _CharT *_M_amonth08;
      const _CharT *_M_amonth09;
      const _CharT *_M_amonth10;
      const _CharT *_M_amonth11;
      const _CharT *_M_amonth12;
      bool _M_allocated;
      inline __timepunct_cache(::std::size_t __refs  = (0))
        : facet(__refs), _M_date_format(0), _M_date_era_format(0), _M_time_format(0), _M_time_era_format(0), _M_date_time_format(0), _M_date_time_era_format(0), _M_am(0), _M_pm(0), _M_am_pm_format(0), _M_day1(0), _M_day2(0), _M_day3(0), _M_day4(0), _M_day5(0), _M_day6(0), _M_day7(0), _M_aday1(0), _M_aday2(0), _M_aday3(0), _M_aday4(0), _M_aday5(0), _M_aday6(0), _M_aday7(0), _M_month01(0), _M_month02(0), _M_month03(0), _M_month04(0), _M_month05(0), _M_month06(0), _M_month07(0), _M_month08(0), _M_month09(0), _M_month10(0), _M_month11(0), _M_month12(0), _M_amonth01(0), _M_amonth02(0), _M_amonth03(0), _M_amonth04(0), _M_amonth05(0), _M_amonth06(0), _M_amonth07(0), _M_amonth08(0), _M_amonth09(0), _M_amonth10(0), _M_amonth11(0), _M_amonth12(0), _M_allocated(false)
      {
      }
      virtual ~__timepunct_cache();
      void _M_cache(const ::std::locale &__loc);
    private:
      ::std::__timepunct_cache<_CharT> &operator =(const ::std::__timepunct_cache<_CharT> &);
      explicit __timepunct_cache(const ::std::__timepunct_cache<_CharT> &);
  };
  template < typename _CharT >
  __timepunct_cache<_CharT>::~__timepunct_cache()
  {
    if (::std::__timepunct_cache<_CharT>::_M_allocated)
      {
      }
  }
 /* Instantiation of class template '::std::__timepunct_cache<char>' */ 
  template <>
  const char *__timepunct_cache<char>::_S_timezones[14L];
 /* Instantiation of class template '::std::__timepunct_cache<wchar_t>' */ 
  template <>
  const wchar_t *__timepunct_cache<wchar_t>::_S_timezones[14L];
  template < typename _CharT >
  const _CharT *__timepunct_cache<_CharT>::_S_timezones[14L];
  template < typename _CharT >
  class  __timepunct : public ::std::locale::facet
  {
    public:
      typedef _CharT __char_type;
      typedef ::std::basic_string<_CharT> __string_type;
      typedef ::std::__timepunct_cache<_CharT> __cache_type;
    protected:
      typename ::std::__timepunct<_CharT>::__cache_type *_M_data;
      ::std::__c_locale _M_c_locale_timepunct;
      const char *_M_name_timepunct;
    public:
      static ::std::locale::id id;
      explicit __timepunct(::std::size_t __refs  = (0));
      explicit __timepunct(typename ::std::__timepunct<_CharT>::__cache_type *__cache, ::std::size_t __refs  = (0));
      explicit __timepunct(::std::__c_locale __cloc, const char *__s, ::std::size_t __refs  = (0));
      void _M_put(_CharT *__s, ::std::size_t __maxlen, const _CharT *__format, const ::tm *__tm) const  throw();
      inline void _M_date_formats(const _CharT **__date) const 
      {
        __date[0] = ::std::__timepunct<_CharT>::_M_data->_M_date_format;
        __date[1] = ::std::__timepunct<_CharT>::_M_data->_M_date_era_format;
      }
      inline void _M_time_formats(const _CharT **__time) const 
      {
        __time[0] = ::std::__timepunct<_CharT>::_M_data->_M_time_format;
        __time[1] = ::std::__timepunct<_CharT>::_M_data->_M_time_era_format;
      }
      inline void _M_date_time_formats(const _CharT **__dt) const 
      {
        __dt[0] = ::std::__timepunct<_CharT>::_M_data->_M_date_time_format;
        __dt[1] = ::std::__timepunct<_CharT>::_M_data->_M_date_time_era_format;
      }
      inline void _M_am_pm_format(const _CharT *__ampm) const 
      {
        __ampm = ::std::__timepunct<_CharT>::_M_data->_M_am_pm_format;
      }
      inline void _M_am_pm(const _CharT **__ampm) const 
      {
        __ampm[0] = ::std::__timepunct<_CharT>::_M_data->_M_am;
        __ampm[1] = ::std::__timepunct<_CharT>::_M_data->_M_pm;
      }
      inline void _M_days(const _CharT **__days) const 
      {
        __days[0] = ::std::__timepunct<_CharT>::_M_data->_M_day1;
        __days[1] = ::std::__timepunct<_CharT>::_M_data->_M_day2;
        __days[2] = ::std::__timepunct<_CharT>::_M_data->_M_day3;
        __days[3] = ::std::__timepunct<_CharT>::_M_data->_M_day4;
        __days[4] = ::std::__timepunct<_CharT>::_M_data->_M_day5;
        __days[5] = ::std::__timepunct<_CharT>::_M_data->_M_day6;
        __days[6] = ::std::__timepunct<_CharT>::_M_data->_M_day7;
      }
      inline void _M_days_abbreviated(const _CharT **__days) const 
      {
        __days[0] = ::std::__timepunct<_CharT>::_M_data->_M_aday1;
        __days[1] = ::std::__timepunct<_CharT>::_M_data->_M_aday2;
        __days[2] = ::std::__timepunct<_CharT>::_M_data->_M_aday3;
        __days[3] = ::std::__timepunct<_CharT>::_M_data->_M_aday4;
        __days[4] = ::std::__timepunct<_CharT>::_M_data->_M_aday5;
        __days[5] = ::std::__timepunct<_CharT>::_M_data->_M_aday6;
        __days[6] = ::std::__timepunct<_CharT>::_M_data->_M_aday7;
      }
      inline void _M_months(const _CharT **__months) const 
      {
        __months[0] = ::std::__timepunct<_CharT>::_M_data->_M_month01;
        __months[1] = ::std::__timepunct<_CharT>::_M_data->_M_month02;
        __months[2] = ::std::__timepunct<_CharT>::_M_data->_M_month03;
        __months[3] = ::std::__timepunct<_CharT>::_M_data->_M_month04;
        __months[4] = ::std::__timepunct<_CharT>::_M_data->_M_month05;
        __months[5] = ::std::__timepunct<_CharT>::_M_data->_M_month06;
        __months[6] = ::std::__timepunct<_CharT>::_M_data->_M_month07;
        __months[7] = ::std::__timepunct<_CharT>::_M_data->_M_month08;
        __months[8] = ::std::__timepunct<_CharT>::_M_data->_M_month09;
        __months[9] = ::std::__timepunct<_CharT>::_M_data->_M_month10;
        __months[10] = ::std::__timepunct<_CharT>::_M_data->_M_month11;
        __months[11] = ::std::__timepunct<_CharT>::_M_data->_M_month12;
      }
      inline void _M_months_abbreviated(const _CharT **__months) const 
      {
        __months[0] = ::std::__timepunct<_CharT>::_M_data->_M_amonth01;
        __months[1] = ::std::__timepunct<_CharT>::_M_data->_M_amonth02;
        __months[2] = ::std::__timepunct<_CharT>::_M_data->_M_amonth03;
        __months[3] = ::std::__timepunct<_CharT>::_M_data->_M_amonth04;
        __months[4] = ::std::__timepunct<_CharT>::_M_data->_M_amonth05;
        __months[5] = ::std::__timepunct<_CharT>::_M_data->_M_amonth06;
        __months[6] = ::std::__timepunct<_CharT>::_M_data->_M_amonth07;
        __months[7] = ::std::__timepunct<_CharT>::_M_data->_M_amonth08;
        __months[8] = ::std::__timepunct<_CharT>::_M_data->_M_amonth09;
        __months[9] = ::std::__timepunct<_CharT>::_M_data->_M_amonth10;
        __months[10] = ::std::__timepunct<_CharT>::_M_data->_M_amonth11;
        __months[11] = ::std::__timepunct<_CharT>::_M_data->_M_amonth12;
      }
    protected:
      virtual ~__timepunct();
      void _M_initialize_timepunct(::std::__c_locale __cloc  = (0));
  };
  template < typename _CharT >
  ::std::locale::id __timepunct<_CharT>::id;
 /* Instantiation of class template '::std::__timepunct<char>' */ 
  template <>
  void __timepunct<char>::_M_initialize_timepunct(::__locale_struct *__cloc);
  template <>
  void __timepunct<char>::_M_put(char *, unsigned long int, const char *, const ::tm *) const  throw();
 /* Instantiation of class template '::std::__timepunct<wchar_t>' */ 
  template <>
  void __timepunct<wchar_t>::_M_initialize_timepunct(::__locale_struct *__cloc);
  template <>
  void __timepunct<wchar_t>::_M_put(wchar_t *, unsigned long int, const wchar_t *, const ::tm *) const  throw();
  template < typename _CharT >
  __timepunct<_CharT>::__timepunct(::std::size_t __refs)
    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0), _M_name_timepunct(_S_get_c_name())
  {
    (*this)._M_initialize_timepunct();
  }
  template < typename _CharT >
  __timepunct<_CharT>::__timepunct(typename ::std::__timepunct<_CharT>::__cache_type *__cache, ::std::size_t __refs)
    : facet(__refs), _M_data(__cache), _M_c_locale_timepunct(0), _M_name_timepunct(_S_get_c_name())
  {
    (*this)._M_initialize_timepunct();
  }
  template < typename _CharT >
  __timepunct<_CharT>::__timepunct(::std::__c_locale __cloc, const char *__s, ::std::size_t __refs)
    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0), _M_name_timepunct(0)
  {
    if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
      {
        const ::std::size_t __len(__builtin_strlen(__s) + 1);
        char *__tmp(new char [__len]);
        __builtin_memcpy(__tmp, __s, __len);
        ::std::__timepunct<_CharT>::_M_name_timepunct = __tmp;
      }
    else
      {
        ::std::__timepunct<_CharT>::_M_name_timepunct = _S_get_c_name();
      }
    try
    {
      (*this)._M_initialize_timepunct(__cloc);
    }
    catch (...)
    {
      if (::std::__timepunct<_CharT>::_M_name_timepunct != _S_get_c_name())
        {
          delete[] ::std::__timepunct<_CharT>::_M_name_timepunct;
        }
      throw;
    }
  }
  template < typename _CharT >
  __timepunct<_CharT>::~__timepunct()
  {
    if (::std::__timepunct<_CharT>::_M_name_timepunct != _S_get_c_name())
      {
        delete[] ::std::__timepunct<_CharT>::_M_name_timepunct;
      }
    delete ::std::__timepunct<_CharT>::_M_data;
    _S_destroy_c_locale(::std::__timepunct<_CharT>::_M_c_locale_timepunct);
  }
  template < typename _CharT, typename _InIter >
  class  time_get : public ::std::locale::facet, public ::std::time_base
  {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef ::std::basic_string<_CharT> __string_type;
      static ::std::locale::id id;
      inline explicit time_get(::std::size_t __refs  = (0))
        : facet(__refs)
      {
      }
      inline ::std::time_base::dateorder date_order() const 
      {
        return this->do_date_order();
      }
      inline typename ::std::time_get<_CharT, _InIter>::iter_type get_time(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const 
      {
        return this->do_get_time(__beg, __end, __io, __err, __tm);
      }
      inline typename ::std::time_get<_CharT, _InIter>::iter_type get_date(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const 
      {
        return this->do_get_date(__beg, __end, __io, __err, __tm);
      }
      inline typename ::std::time_get<_CharT, _InIter>::iter_type get_weekday(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const 
      {
        return this->do_get_weekday(__beg, __end, __io, __err, __tm);
      }
      inline typename ::std::time_get<_CharT, _InIter>::iter_type get_monthname(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const 
      {
        return this->do_get_monthname(__beg, __end, __io, __err, __tm);
      }
      inline typename ::std::time_get<_CharT, _InIter>::iter_type get_year(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const 
      {
        return this->do_get_year(__beg, __end, __io, __err, __tm);
      }
    protected:
      inline virtual ~time_get()
      {
      }
      virtual ::std::time_base::dateorder do_date_order() const ;
      virtual typename ::std::time_get<_CharT, _InIter>::iter_type do_get_time(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const ;
      virtual typename ::std::time_get<_CharT, _InIter>::iter_type do_get_date(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const ;
      virtual typename ::std::time_get<_CharT, _InIter>::iter_type do_get_weekday(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const ;
      virtual typename ::std::time_get<_CharT, _InIter>::iter_type do_get_monthname(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const ;
      virtual typename ::std::time_get<_CharT, _InIter>::iter_type do_get_year(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const ;
      typename ::std::time_get<_CharT, _InIter>::iter_type _M_extract_num(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, int &__member, int __min, int __max, ::std::size_t __len, ::std::ios_base &__io, ::std::ios_base::iostate &__err) const ;
      typename ::std::time_get<_CharT, _InIter>::iter_type _M_extract_name(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, int &__member, const _CharT **__names, ::std::size_t __indexlen, ::std::ios_base &__io, ::std::ios_base::iostate &__err) const ;
      typename ::std::time_get<_CharT, _InIter>::iter_type _M_extract_wday_or_month(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, int &__member, const _CharT **__names, ::std::size_t __indexlen, ::std::ios_base &__io, ::std::ios_base::iostate &__err) const ;
      typename ::std::time_get<_CharT, _InIter>::iter_type _M_extract_via_format(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm, const _CharT *__format) const ;
  };
  template < typename _CharT, typename _InIter >
  ::std::locale::id time_get<_CharT, _InIter>::id;
  template < typename _CharT, typename _InIter >
  class  time_get_byname : public ::std::time_get<_CharT, _InIter>
  {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      inline explicit time_get_byname(const char *, ::std::size_t __refs  = (0))
        : time_get<_CharT, _InIter>(__refs)
      {
      }
    protected:
      inline virtual ~time_get_byname()
      {
      }
  };
  template < typename _CharT, typename _OutIter >
  class  time_put : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      static ::std::locale::id id;
      inline explicit time_put(::std::size_t __refs  = (0))
        : facet(__refs)
      {
      }
      typename ::std::time_put<_CharT, _OutIter>::iter_type put(typename ::std::time_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::time_put<_CharT, _OutIter>::char_type __fill, const ::tm *__tm, const _CharT *__beg, const _CharT *__end) const ;
      inline typename ::std::time_put<_CharT, _OutIter>::iter_type put(typename ::std::time_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::time_put<_CharT, _OutIter>::char_type __fill, const ::tm *__tm, char __format, char __mod  = (0)) const 
      {
        return this->do_put(__s, __io, __fill, __tm, __format, __mod);
      }
    protected:
      inline virtual ~time_put()
      {
      }
      virtual typename ::std::time_put<_CharT, _OutIter>::iter_type do_put(typename ::std::time_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::time_put<_CharT, _OutIter>::char_type, const ::tm *__tm, char __format, char __mod) const ;
  };
  template < typename _CharT, typename _OutIter >
  ::std::locale::id time_put<_CharT, _OutIter>::id;
  template < typename _CharT, typename _OutIter >
  class  time_put_byname : public ::std::time_put<_CharT, _OutIter>
  {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      inline explicit time_put_byname(const char *, ::std::size_t __refs  = (0))
        : time_put<_CharT, _OutIter>(__refs)
      {
      }
    protected:
      inline virtual ~time_put_byname()
      {
      }
  };
  class  money_base
  {
    public:
      enum part
      {
        none = 0,
        space = 1,
        symbol = 2,
        sign = 3,
        value = 4
      };
      struct  pattern
      {
          char field[4L];
      };
      static const ::std::money_base::pattern _S_default_pattern;
      enum mcc_enum_anon_64
      {
        _S_minus = 0,
        _S_zero = 1,
        _S_end = 11
      };
      static const char *_S_atoms;
      static ::std::money_base::pattern _S_construct_pattern(char __precedes, char __space, char __posn) throw() __attribute__((__const__));
  };
  template < typename _CharT, bool _Intl >
  struct  __moneypunct_cache : ::std::locale::facet
  {
      const char *_M_grouping;
      ::std::size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT *_M_curr_symbol;
      ::std::size_t _M_curr_symbol_size;
      const _CharT *_M_positive_sign;
      ::std::size_t _M_positive_sign_size;
      const _CharT *_M_negative_sign;
      ::std::size_t _M_negative_sign_size;
      int _M_frac_digits;
      ::std::money_base::pattern _M_pos_format;
      ::std::money_base::pattern _M_neg_format;
      _CharT _M_atoms[11L];
      bool _M_allocated;
      inline __moneypunct_cache(::std::size_t __refs  = (0))
        : facet(__refs), _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_curr_symbol(0), _M_curr_symbol_size(0), _M_positive_sign(0), _M_positive_sign_size(0), _M_negative_sign(0), _M_negative_sign_size(0), _M_frac_digits(0), _M_pos_format(::std::money_base::pattern()), _M_neg_format(::std::money_base::pattern()), _M_allocated(false)
      {
      }
      virtual ~__moneypunct_cache();
      void _M_cache(const ::std::locale &__loc);
    private:
      ::std::__moneypunct_cache<_CharT, _Intl> &operator =(const ::std::__moneypunct_cache<_CharT, _Intl> &);
      explicit __moneypunct_cache(const ::std::__moneypunct_cache<_CharT, _Intl> &);
  };
  template < typename _CharT, bool _Intl >
  __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
  {
    if (::std::__moneypunct_cache<_CharT, _Intl>::_M_allocated)
      {
        delete[] ::std::__moneypunct_cache<_CharT, _Intl>::_M_grouping;
        delete[] ::std::__moneypunct_cache<_CharT, _Intl>::_M_curr_symbol;
        delete[] ::std::__moneypunct_cache<_CharT, _Intl>::_M_positive_sign;
        delete[] ::std::__moneypunct_cache<_CharT, _Intl>::_M_negative_sign;
      }
  }
  template < typename _CharT, bool _Intl >
  class  moneypunct : public ::std::locale::facet, public ::std::money_base
  {
    public:
      typedef _CharT char_type;
      typedef ::std::basic_string<_CharT> string_type;
      typedef ::std::__moneypunct_cache<_CharT, _Intl> __cache_type;
    private:
      typename ::std::moneypunct<_CharT, _Intl>::__cache_type *_M_data;
    public:
      static const bool intl = _Intl;
      static ::std::locale::id id;
      inline explicit moneypunct(::std::size_t __refs  = (0))
        : facet(__refs), _M_data(0)
      {
        (*this)._M_initialize_moneypunct();
      }
      inline explicit moneypunct(typename ::std::moneypunct<_CharT, _Intl>::__cache_type *__cache, ::std::size_t __refs  = (0))
        : facet(__refs), _M_data(__cache)
      {
        (*this)._M_initialize_moneypunct();
      }
      inline explicit moneypunct(::std::__c_locale __cloc, const char *__s, ::std::size_t __refs  = (0))
        : facet(__refs), _M_data(0)
      {
        (*this)._M_initialize_moneypunct(__cloc, __s);
      }
      inline typename ::std::moneypunct<_CharT, _Intl>::char_type decimal_point() const 
      {
        return this->do_decimal_point();
      }
      inline typename ::std::moneypunct<_CharT, _Intl>::char_type thousands_sep() const 
      {
        return this->do_thousands_sep();
      }
      inline ::std::string grouping() const 
      {
        return this->do_grouping();
      }
      inline typename ::std::moneypunct<_CharT, _Intl>::string_type curr_symbol() const 
      {
        return this->do_curr_symbol();
      }
      inline typename ::std::moneypunct<_CharT, _Intl>::string_type positive_sign() const 
      {
        return this->do_positive_sign();
      }
      inline typename ::std::moneypunct<_CharT, _Intl>::string_type negative_sign() const 
      {
        return this->do_negative_sign();
      }
      inline int frac_digits() const 
      {
        return this->do_frac_digits();
      }
      inline ::std::money_base::pattern pos_format() const 
      {
        return this->do_pos_format();
      }
      inline ::std::money_base::pattern neg_format() const 
      {
        return this->do_neg_format();
      }
    protected:
      virtual ~moneypunct();
      inline virtual typename ::std::moneypunct<_CharT, _Intl>::char_type do_decimal_point() const 
      {
        return ::std::moneypunct<_CharT, _Intl>::_M_data->_M_decimal_point;
      }
      inline virtual typename ::std::moneypunct<_CharT, _Intl>::char_type do_thousands_sep() const 
      {
        return ::std::moneypunct<_CharT, _Intl>::_M_data->_M_thousands_sep;
      }
      inline virtual ::std::string do_grouping() const 
      {
        return ::std::moneypunct<_CharT, _Intl>::_M_data->_M_grouping;
      }
      inline virtual typename ::std::moneypunct<_CharT, _Intl>::string_type do_curr_symbol() const 
      {
        return ::std::moneypunct<_CharT, _Intl>::_M_data->_M_curr_symbol;
      }
      inline virtual typename ::std::moneypunct<_CharT, _Intl>::string_type do_positive_sign() const 
      {
        return ::std::moneypunct<_CharT, _Intl>::_M_data->_M_positive_sign;
      }
      inline virtual typename ::std::moneypunct<_CharT, _Intl>::string_type do_negative_sign() const 
      {
        return ::std::moneypunct<_CharT, _Intl>::_M_data->_M_negative_sign;
      }
      inline virtual int do_frac_digits() const 
      {
        return ::std::moneypunct<_CharT, _Intl>::_M_data->_M_frac_digits;
      }
      inline virtual ::std::money_base::pattern do_pos_format() const 
      {
        return ::std::moneypunct<_CharT, _Intl>::_M_data->_M_pos_format;
      }
      inline virtual ::std::money_base::pattern do_neg_format() const 
      {
        return ::std::moneypunct<_CharT, _Intl>::_M_data->_M_neg_format;
      }
      void _M_initialize_moneypunct(::std::__c_locale __cloc  = (0), const char *__name  = (0));
  };
  template < typename _CharT, bool _Intl >
  ::std::locale::id moneypunct<_CharT, _Intl>::id;
 /* Instantiation of class template '::std::moneypunct<char, true>' */ 
  template <>
  moneypunct<char, true>::~moneypunct();
 /* Instantiation of class template '::std::moneypunct<char, false>' */ 
  template <>
  moneypunct<char, false>::~moneypunct();
  template <>
  void moneypunct<char, true>::_M_initialize_moneypunct(::__locale_struct *, const char *);
  template <>
  void moneypunct<char, false>::_M_initialize_moneypunct(::__locale_struct *, const char *);
 /* Instantiation of class template '::std::moneypunct<wchar_t, true>' */ 
  template <>
  moneypunct<wchar_t, true>::~moneypunct();
 /* Instantiation of class template '::std::moneypunct<wchar_t, false>' */ 
  template <>
  moneypunct<wchar_t, false>::~moneypunct();
  template <>
  void moneypunct<wchar_t, true>::_M_initialize_moneypunct(::__locale_struct *, const char *);
  template <>
  void moneypunct<wchar_t, false>::_M_initialize_moneypunct(::__locale_struct *, const char *);
  template < typename _CharT, bool _Intl >
  class  moneypunct_byname : public ::std::moneypunct<_CharT, _Intl>
  {
    public:
      typedef _CharT char_type;
      typedef ::std::basic_string<_CharT> string_type;
      static const bool intl = _Intl;
      inline explicit moneypunct_byname(const char *__s, ::std::size_t __refs  = (0))
        : moneypunct<_CharT, _Intl>(__refs)
      {
        if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0)
          {
            ::std::__c_locale __tmp;
            this->_S_create_c_locale(__tmp, __s);
            this->_M_initialize_moneypunct(__tmp);
            this->_S_destroy_c_locale(__tmp);
          }
      }
    protected:
      inline virtual ~moneypunct_byname()
      {
      }
  };
  template < typename _CharT, typename _InIter >
  class  money_get : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef ::std::basic_string<_CharT> string_type;
      static ::std::locale::id id;
      inline explicit money_get(::std::size_t __refs  = (0))
        : facet(__refs)
      {
      }
      inline typename ::std::money_get<_CharT, _InIter>::iter_type get(typename ::std::money_get<_CharT, _InIter>::iter_type __s, typename ::std::money_get<_CharT, _InIter>::iter_type __end, bool __intl, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__units) const 
      {
        return this->do_get(__s, __end, __intl, __io, __err, __units);
      }
      inline typename ::std::money_get<_CharT, _InIter>::iter_type get(typename ::std::money_get<_CharT, _InIter>::iter_type __s, typename ::std::money_get<_CharT, _InIter>::iter_type __end, bool __intl, ::std::ios_base &__io, ::std::ios_base::iostate &__err, typename ::std::money_get<_CharT, _InIter>::string_type &__digits) const 
      {
        return this->do_get(__s, __end, __intl, __io, __err, __digits);
      }
    protected:
      inline virtual ~money_get()
      {
      }
      virtual typename ::std::money_get<_CharT, _InIter>::iter_type do_get(typename ::std::money_get<_CharT, _InIter>::iter_type __beg, typename ::std::money_get<_CharT, _InIter>::iter_type __end, bool __intl, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__units) const ;
      virtual typename ::std::money_get<_CharT, _InIter>::iter_type do_get(typename ::std::money_get<_CharT, _InIter>::iter_type __beg, typename ::std::money_get<_CharT, _InIter>::iter_type __end, bool __intl, ::std::ios_base &__io, ::std::ios_base::iostate &__err, typename ::std::money_get<_CharT, _InIter>::string_type &__digits) const ;
      template < bool _Intl >
      typename ::std::money_get<_CharT, _InIter>::iter_type _M_extract(typename ::std::money_get<_CharT, _InIter>::iter_type __beg, typename ::std::money_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::std::string &__units) const ;
  };
  template < typename _CharT, typename _InIter >
  ::std::locale::id money_get<_CharT, _InIter>::id;
  template < typename _CharT, typename _OutIter >
  class  money_put : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef ::std::basic_string<_CharT> string_type;
      static ::std::locale::id id;
      inline explicit money_put(::std::size_t __refs  = (0))
        : facet(__refs)
      {
      }
      inline typename ::std::money_put<_CharT, _OutIter>::iter_type put(typename ::std::money_put<_CharT, _OutIter>::iter_type __s, bool __intl, ::std::ios_base &__io, typename ::std::money_put<_CharT, _OutIter>::char_type __fill, long double __units) const 
      {
        return this->do_put(__s, __intl, __io, __fill, __units);
      }
      inline typename ::std::money_put<_CharT, _OutIter>::iter_type put(typename ::std::money_put<_CharT, _OutIter>::iter_type __s, bool __intl, ::std::ios_base &__io, typename ::std::money_put<_CharT, _OutIter>::char_type __fill, const typename ::std::money_put<_CharT, _OutIter>::string_type &__digits) const 
      {
        return this->do_put(__s, __intl, __io, __fill, __digits);
      }
    protected:
      inline virtual ~money_put()
      {
      }
      virtual typename ::std::money_put<_CharT, _OutIter>::iter_type do_put(typename ::std::money_put<_CharT, _OutIter>::iter_type __s, bool __intl, ::std::ios_base &__io, typename ::std::money_put<_CharT, _OutIter>::char_type __fill, long double __units) const ;
      virtual typename ::std::money_put<_CharT, _OutIter>::iter_type do_put(typename ::std::money_put<_CharT, _OutIter>::iter_type __s, bool __intl, ::std::ios_base &__io, typename ::std::money_put<_CharT, _OutIter>::char_type __fill, const typename ::std::money_put<_CharT, _OutIter>::string_type &__digits) const ;
      template < bool _Intl >
      typename ::std::money_put<_CharT, _OutIter>::iter_type _M_insert(typename ::std::money_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::money_put<_CharT, _OutIter>::char_type __fill, const typename ::std::money_put<_CharT, _OutIter>::string_type &__digits) const ;
  };
  template < typename _CharT, typename _OutIter >
  ::std::locale::id money_put<_CharT, _OutIter>::id;
  struct  messages_base
  {
      typedef int catalog;
  };
  template < typename _CharT >
  class  messages : public ::std::locale::facet, public ::std::messages_base
  {
    public:
      typedef _CharT char_type;
      typedef ::std::basic_string<_CharT> string_type;
    protected:
      ::std::__c_locale _M_c_locale_messages;
      const char *_M_name_messages;
    public:
      static ::std::locale::id id;
      explicit messages(::std::size_t __refs  = (0));
      explicit messages(::std::__c_locale __cloc, const char *__s, ::std::size_t __refs  = (0));
      inline ::std::messages_base::catalog open(const ::std::basic_string<char> &__s, const ::std::locale &__loc) const 
      {
        return this->do_open(__s, __loc);
      }
      ::std::messages_base::catalog open(const ::std::basic_string<char> &__s, const ::std::locale &__loc, const char *__dir) const ;
      inline typename ::std::messages<_CharT>::string_type get(::std::messages_base::catalog __c, int __set, int __msgid, const typename ::std::messages<_CharT>::string_type &__s) const 
      {
        return this->do_get(__c, __set, __msgid, __s);
      }
      inline void close(::std::messages_base::catalog __c) const 
      {
        return this->do_close(__c);
      }
    protected:
      virtual ~messages();
      virtual ::std::messages_base::catalog do_open(const ::std::basic_string<char> &__s, const ::std::locale &) const ;
      virtual typename ::std::messages<_CharT>::string_type do_get(::std::messages_base::catalog, int, int, const typename ::std::messages<_CharT>::string_type &__dfault) const ;
      virtual void do_close(::std::messages_base::catalog) const ;
      inline char *_M_convert_to_char(const typename ::std::messages<_CharT>::string_type &__msg) const 
      {
        return reinterpret_cast<char *>(const_cast<_CharT *>(__msg.c_str()));
      }
      inline typename ::std::messages<_CharT>::string_type _M_convert_from_char(char *) const 
      {
        return ((typename ::std::messages<_CharT>::string_type()));
      }
  };
  template < typename _CharT >
  ::std::locale::id messages<_CharT>::id;
 /* Instantiation of class template '::std::messages<char>' */ 
  template <>
  ::std::basic_string<char> messages<char>::do_get(int, int, int, const ::std::basic_string<char> &) const ;
 /* Instantiation of class template '::std::messages<wchar_t>' */ 
  template <>
  ::std::basic_string<wchar_t> messages<wchar_t>::do_get(int, int, int, const ::std::basic_string<wchar_t> &) const ;
  template < typename _CharT >
  class  messages_byname : public ::std::messages<_CharT>
  {
    public:
      typedef _CharT char_type;
      typedef ::std::basic_string<_CharT> string_type;
      explicit messages_byname(const char *__s, ::std::size_t __refs  = (0));
    protected:
      inline virtual ~messages_byname()
      {
      }
  };
}
extern "C"
{
  extern char *gettext(const char *__msgid) throw() __attribute__((__format_arg__(1)));
}
extern "C"
{
  extern char *dgettext(const char *__domainname, const char *__msgid) throw() __attribute__((__format_arg__(2)));
}
extern "C"
{
  extern char *__dgettext(const char *__domainname, const char *__msgid) throw() __attribute__((__format_arg__(2)));
}
extern "C"
{
  extern char *dcgettext(const char *__domainname, const char *__msgid, int __category) throw() __attribute__((__format_arg__(2)));
}
extern "C"
{
  extern char *__dcgettext(const char *__domainname, const char *__msgid, int __category) throw() __attribute__((__format_arg__(2)));
}
extern "C"
{
  extern char *ngettext(const char *__msgid1, const char *__msgid2, unsigned long int __n) throw() __attribute__((__format_arg__(2)));
}
extern "C"
{
  extern char *dngettext(const char *__domainname, const char *__msgid1, const char *__msgid2, unsigned long int __n) throw() __attribute__((__format_arg__(3)));
}
extern "C"
{
  extern char *dcngettext(const char *__domainname, const char *__msgid1, const char *__msgid2, unsigned long int __n, int __category) throw() __attribute__((__format_arg__(3)));
}
extern "C"
{
  extern char *textdomain(const char *__domainname) throw();
}
extern "C"
{
  extern char *bindtextdomain(const char *__domainname, const char *__dirname) throw();
}
extern "C"
{
  extern char *bind_textdomain_codeset(const char *__domainname, const char *__codeset) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _CharT >
  messages<_CharT>::messages(::std::size_t __refs)
    : facet(__refs), _M_c_locale_messages(_S_get_c_locale()), _M_name_messages(_S_get_c_name())
  {
  }
  template < typename _CharT >
  messages<_CharT>::messages(::std::__c_locale __cloc, const char *__s, ::std::size_t __refs)
    : facet(__refs), _M_c_locale_messages(0), _M_name_messages(0)
  {
    if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
      {
        const ::std::size_t __len(__builtin_strlen(__s) + 1);
        char *__tmp(new char [__len]);
        __builtin_memcpy(__tmp, __s, __len);
        ::std::messages<_CharT>::_M_name_messages = __tmp;
      }
    else
      {
        ::std::messages<_CharT>::_M_name_messages = _S_get_c_name();
      }
    ::std::messages<_CharT>::_M_c_locale_messages = _S_clone_c_locale(__cloc);
  }
  template < typename _CharT >
  ::std::messages_base::catalog messages<_CharT>::open(const ::std::basic_string<char> &__s, const ::std::locale &__loc, const char *__dir) const 
  {
    ::bindtextdomain(__s.::std::basic_string<char>::c_str(), __dir);
    return this->do_open(__s, __loc);
  }
  template < typename _CharT >
  messages<_CharT>::~messages()
  {
    if (::std::messages<_CharT>::_M_name_messages != _S_get_c_name())
      {
        delete[] ::std::messages<_CharT>::_M_name_messages;
      }
    _S_destroy_c_locale(::std::messages<_CharT>::_M_c_locale_messages);
  }
  template < typename _CharT >
  ::std::messages_base::catalog messages<_CharT>::do_open(const ::std::basic_string<char> &__s, const ::std::locale &) const 
  {
    ::textdomain(__s.::std::basic_string<char>::c_str());
    return 0;
  }
  template < typename _CharT >
  void messages<_CharT>::do_close(::std::messages_base::catalog) const 
  {
  }
  template < typename _CharT >
  messages_byname<_CharT>::messages_byname(const char *__s, ::std::size_t __refs)
    : messages<_CharT>(__refs)
  {
    if (this->_M_name_messages != locale::facet::_S_get_c_name())
      {
        delete[] this->_M_name_messages;
        if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0)
          {
            const ::std::size_t __len(__builtin_strlen(__s) + 1);
            char *__tmp(new char [__len]);
            __builtin_memcpy(__tmp, __s, __len);
            this->_M_name_messages = __tmp;
          }
        else
          {
            this->_M_name_messages = locale::facet::_S_get_c_name();
          }
      }
    if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0)
      {
        this->_S_destroy_c_locale(this->_M_c_locale_messages);
        this->_S_create_c_locale(this->_M_c_locale_messages, __s);
      }
  }
  class  codecvt_base
  {
    public:
      enum result
      {
        ok = 0,
        partial = 1,
        error = 2,
        noconv = 3
      };
  };
  template < typename _InternT, typename _ExternT, typename _StateT >
  class  __codecvt_abstract_base : public ::std::locale::facet, public ::std::codecvt_base
  {
    public:
      typedef ::std::codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
      inline typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::result out(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &__state, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__from, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__from_end, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *&__from_next, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to_end, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *&__to_next) const 
      {
        return this->do_out(__state, __from, __from_end, __from_next, __to, __to_end, __to_next);
      }
      inline typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::result unshift(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &__state, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to_end, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *&__to_next) const 
      {
        return this->do_unshift(__state, __to, __to_end, __to_next);
      }
      inline typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::result in(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &__state, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__from, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__from_end, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *&__from_next, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__to, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__to_end, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *&__to_next) const 
      {
        return this->do_in(__state, __from, __from_end, __from_next, __to, __to_end, __to_next);
      }
      inline int encoding() const  throw()
      {
        return this->do_encoding();
      }
      inline bool always_noconv() const  throw()
      {
        return this->do_always_noconv();
      }
      inline int length(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &__state, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__from, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__end, ::std::size_t __max) const 
      {
        return this->do_length(__state, __from, __end, __max);
      }
      inline int max_length() const  throw()
      {
        return this->do_max_length();
      }
    protected:
      inline explicit __codecvt_abstract_base(::std::size_t __refs  = (0))
        : locale::facet(__refs)
      {
      }
      inline virtual ~__codecvt_abstract_base()
      {
      }
      virtual typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::result do_out(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &__state, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__from, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__from_end, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *&__from_next, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to_end, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *&__to_next) const  = 0 ;
      virtual typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::result do_unshift(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &__state, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__to_end, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *&__to_next) const  = 0 ;
      virtual typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::result do_in(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &__state, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__from, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__from_end, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *&__from_next, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__to, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *__to_end, typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::intern_type *&__to_next) const  = 0 ;
      virtual int do_encoding() const  throw() = 0 ;
      virtual bool do_always_noconv() const  throw() = 0 ;
      virtual int do_length(typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::state_type &, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__from, const typename ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>::extern_type *__end, ::std::size_t __max) const  = 0 ;
      virtual int do_max_length() const  throw() = 0 ;
  };
  template < typename _InternT, typename _ExternT, typename _StateT >
  class  codecvt : public ::std::__codecvt_abstract_base<_InternT, _ExternT, _StateT>
  {
    public:
      typedef ::std::codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
    protected:
      ::std::__c_locale _M_c_locale_codecvt;
    public:
      static ::std::locale::id id;
      inline explicit codecvt(::std::size_t __refs  = (0))
        : __codecvt_abstract_base<_InternT, _ExternT, _StateT>(__refs), _M_c_locale_codecvt(0)
      {
      }
      explicit codecvt(::std::__c_locale __cloc, ::std::size_t __refs  = (0));
    protected:
      inline virtual ~codecvt()
      {
      }
      virtual typename ::std::codecvt<_InternT, _ExternT, _StateT>::result do_out(typename ::std::codecvt<_InternT, _ExternT, _StateT>::state_type &__state, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::intern_type *__from, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::intern_type *__from_end, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::intern_type *&__from_next, typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__to, typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__to_end, typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *&__to_next) const ;
      virtual typename ::std::codecvt<_InternT, _ExternT, _StateT>::result do_unshift(typename ::std::codecvt<_InternT, _ExternT, _StateT>::state_type &__state, typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__to, typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__to_end, typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *&__to_next) const ;
      virtual typename ::std::codecvt<_InternT, _ExternT, _StateT>::result do_in(typename ::std::codecvt<_InternT, _ExternT, _StateT>::state_type &__state, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__from, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__from_end, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *&__from_next, typename ::std::codecvt<_InternT, _ExternT, _StateT>::intern_type *__to, typename ::std::codecvt<_InternT, _ExternT, _StateT>::intern_type *__to_end, typename ::std::codecvt<_InternT, _ExternT, _StateT>::intern_type *&__to_next) const ;
      virtual int do_encoding() const  throw();
      virtual bool do_always_noconv() const  throw();
      virtual int do_length(typename ::std::codecvt<_InternT, _ExternT, _StateT>::state_type &, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__from, const typename ::std::codecvt<_InternT, _ExternT, _StateT>::extern_type *__end, ::std::size_t __max) const ;
      virtual int do_max_length() const  throw();
  };
  template < typename _InternT, typename _ExternT, typename _StateT >
  ::std::locale::id codecvt<_InternT, _ExternT, _StateT>::id;
 /* Instantiation of class template '::std::__codecvt_abstract_base<char, char, ::__mbstate_t>' */ 
  template <>
  class  codecvt<char, char, ::__mbstate_t> : public ::std::__codecvt_abstract_base<char, char, ::__mbstate_t>
  {
    public:
      typedef char intern_type;
      typedef char extern_type;
      typedef ::mbstate_t state_type;
    protected:
      ::std::__c_locale _M_c_locale_codecvt;
    public:
      static ::std::locale::id id;
      explicit codecvt(::std::size_t __refs  = (0));
      explicit codecvt(::std::__c_locale __cloc, ::std::size_t __refs  = (0));
    protected:
      virtual ~codecvt();
      virtual ::std::__codecvt_abstract_base<char, char, ::__mbstate_t>::result do_out(::std::codecvt<char, char, ::__mbstate_t>::state_type &__state, const ::std::codecvt<char, char, ::__mbstate_t>::intern_type *__from, const ::std::codecvt<char, char, ::__mbstate_t>::intern_type *__from_end, const ::std::codecvt<char, char, ::__mbstate_t>::intern_type *&__from_next, ::std::codecvt<char, char, ::__mbstate_t>::extern_type *__to, ::std::codecvt<char, char, ::__mbstate_t>::extern_type *__to_end, ::std::codecvt<char, char, ::__mbstate_t>::extern_type *&__to_next) const ;
      virtual ::std::__codecvt_abstract_base<char, char, ::__mbstate_t>::result do_unshift(::std::codecvt<char, char, ::__mbstate_t>::state_type &__state, ::std::codecvt<char, char, ::__mbstate_t>::extern_type *__to, ::std::codecvt<char, char, ::__mbstate_t>::extern_type *__to_end, ::std::codecvt<char, char, ::__mbstate_t>::extern_type *&__to_next) const ;
      virtual ::std::__codecvt_abstract_base<char, char, ::__mbstate_t>::result do_in(::std::codecvt<char, char, ::__mbstate_t>::state_type &__state, const ::std::codecvt<char, char, ::__mbstate_t>::extern_type *__from, const ::std::codecvt<char, char, ::__mbstate_t>::extern_type *__from_end, const ::std::codecvt<char, char, ::__mbstate_t>::extern_type *&__from_next, ::std::codecvt<char, char, ::__mbstate_t>::intern_type *__to, ::std::codecvt<char, char, ::__mbstate_t>::intern_type *__to_end, ::std::codecvt<char, char, ::__mbstate_t>::intern_type *&__to_next) const ;
      virtual int do_encoding() const  throw();
      virtual bool do_always_noconv() const  throw();
      virtual int do_length(::std::codecvt<char, char, ::__mbstate_t>::state_type &, const ::std::codecvt<char, char, ::__mbstate_t>::extern_type *__from, const ::std::codecvt<char, char, ::__mbstate_t>::extern_type *__end, ::std::size_t __max) const ;
      virtual int do_max_length() const  throw();
    public:
  };
 /* Instantiation of class template '::std::__codecvt_abstract_base<wchar_t, char, ::__mbstate_t>' */ 
  template <>
  class  codecvt<wchar_t, char, ::__mbstate_t> : public ::std::__codecvt_abstract_base<wchar_t, char, ::__mbstate_t>
  {
    public:
      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef ::mbstate_t state_type;
    protected:
      ::std::__c_locale _M_c_locale_codecvt;
    public:
      static ::std::locale::id id;
      explicit codecvt(::std::size_t __refs  = (0));
      explicit codecvt(::std::__c_locale __cloc, ::std::size_t __refs  = (0));
    protected:
      virtual ~codecvt();
      virtual ::std::__codecvt_abstract_base<wchar_t, char, ::__mbstate_t>::result do_out(::std::codecvt<wchar_t, char, ::__mbstate_t>::state_type &__state, const ::std::codecvt<wchar_t, char, ::__mbstate_t>::intern_type *__from, const ::std::codecvt<wchar_t, char, ::__mbstate_t>::intern_type *__from_end, const ::std::codecvt<wchar_t, char, ::__mbstate_t>::intern_type *&__from_next, ::std::codecvt<wchar_t, char, ::__mbstate_t>::extern_type *__to, ::std::codecvt<wchar_t, char, ::__mbstate_t>::extern_type *__to_end, ::std::codecvt<wchar_t, char, ::__mbstate_t>::extern_type *&__to_next) const ;
      virtual ::std::__codecvt_abstract_base<wchar_t, char, ::__mbstate_t>::result do_unshift(::std::codecvt<wchar_t, char, ::__mbstate_t>::state_type &__state, ::std::codecvt<wchar_t, char, ::__mbstate_t>::extern_type *__to, ::std::codecvt<wchar_t, char, ::__mbstate_t>::extern_type *__to_end, ::std::codecvt<wchar_t, char, ::__mbstate_t>::extern_type *&__to_next) const ;
      virtual ::std::__codecvt_abstract_base<wchar_t, char, ::__mbstate_t>::result do_in(::std::codecvt<wchar_t, char, ::__mbstate_t>::state_type &__state, const ::std::codecvt<wchar_t, char, ::__mbstate_t>::extern_type *__from, const ::std::codecvt<wchar_t, char, ::__mbstate_t>::extern_type *__from_end, const ::std::codecvt<wchar_t, char, ::__mbstate_t>::extern_type *&__from_next, ::std::codecvt<wchar_t, char, ::__mbstate_t>::intern_type *__to, ::std::codecvt<wchar_t, char, ::__mbstate_t>::intern_type *__to_end, ::std::codecvt<wchar_t, char, ::__mbstate_t>::intern_type *&__to_next) const ;
      virtual int do_encoding() const  throw();
      virtual bool do_always_noconv() const  throw();
      virtual int do_length(::std::codecvt<wchar_t, char, ::__mbstate_t>::state_type &, const ::std::codecvt<wchar_t, char, ::__mbstate_t>::extern_type *__from, const ::std::codecvt<wchar_t, char, ::__mbstate_t>::extern_type *__end, ::std::size_t __max) const ;
      virtual int do_max_length() const  throw();
    public:
  };
  template < typename _InternT, typename _ExternT, typename _StateT >
  class  codecvt_byname : public ::std::codecvt<_InternT, _ExternT, _StateT>
  {
    public:
      inline explicit codecvt_byname(const char *__s, ::std::size_t __refs  = (0))
        : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
        if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0)
          {
            this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
            this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
          }
      }
    protected:
      inline virtual ~codecvt_byname()
      {
      }
  };
  extern template class ::std::codecvt_byname<char, char, ::__mbstate_t>;
  extern template const ::std::codecvt<char, char, ::__mbstate_t> &use_facet< ::std::codecvt<char, char, ::__mbstate_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::codecvt<char, char, ::__mbstate_t> >(const ::std::locale &);
  extern template class ::std::codecvt_byname<wchar_t, char, ::__mbstate_t>;
  extern template const ::std::codecvt<wchar_t, char, ::__mbstate_t> &use_facet< ::std::codecvt<wchar_t, char, ::__mbstate_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::codecvt<wchar_t, char, ::__mbstate_t> >(const ::std::locale &);
  template < typename _CharT, bool _Intl >
  struct  __use_cache< ::std::__moneypunct_cache<_CharT, _Intl> >
  {
      inline const ::std::__moneypunct_cache<_CharT, _Intl> *operator ()(const ::std::locale &__loc) const 
      {
        const ::std::size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
        const ::std::locale::facet **__caches((*__loc._M_impl)._M_caches);
        if (!__caches[__i])
          {
            ::std::__moneypunct_cache<_CharT, _Intl> *__tmp = 0;
            try
            {
              __tmp = (new ::std::__moneypunct_cache<_CharT, _Intl>());
              __tmp->_M_cache(__loc);
            }
            catch (...)
            {
              delete __tmp;
              throw;
            }
            (*__loc._M_impl)._M_install_cache(__tmp, __i);
          }
        return static_cast<const ::std::__moneypunct_cache<_CharT, _Intl> *>(__caches[__i]);
      }
  };
  template < typename _CharT, bool _Intl >
  void __moneypunct_cache<_CharT, _Intl>::_M_cache(const ::std::locale &__loc)
  {
    ::std::__moneypunct_cache<_CharT, _Intl>::_M_allocated = true;
    const ::std::moneypunct<_CharT, _Intl> &__mp = use_facet< ::std::moneypunct<_CharT, _Intl> >(__loc);
    ::std::__moneypunct_cache<_CharT, _Intl>::_M_decimal_point = __mp.decimal_point();
    ::std::__moneypunct_cache<_CharT, _Intl>::_M_thousands_sep = __mp.thousands_sep();
    ::std::__moneypunct_cache<_CharT, _Intl>::_M_frac_digits = __mp.frac_digits();
    char *__grouping(0);
    _CharT *__curr_symbol = 0;
    _CharT *__positive_sign = 0;
    _CharT *__negative_sign = 0;
    try
    {
      ::std::__moneypunct_cache<_CharT, _Intl>::_M_grouping_size = __mp.grouping().size();
      __grouping = (new char [::std::__moneypunct_cache<_CharT, _Intl>::_M_grouping_size]);
      __mp.grouping().copy(__grouping, ::std::__moneypunct_cache<_CharT, _Intl>::_M_grouping_size);
      ::std::__moneypunct_cache<_CharT, _Intl>::_M_grouping = __grouping;
      ::std::__moneypunct_cache<_CharT, _Intl>::_M_use_grouping = (::std::__moneypunct_cache<_CharT, _Intl>::_M_grouping_size && static_cast<signed char>(::std::__moneypunct_cache<_CharT, _Intl>::_M_grouping[0]) > 0) && ::std::__moneypunct_cache<_CharT, _Intl>::_M_grouping[0] != ::__gnu_cxx::__numeric_traits_integer<char>::__max;
      ::std::__moneypunct_cache<_CharT, _Intl>::_M_curr_symbol_size = __mp.curr_symbol().size();
      __curr_symbol = (new _CharT [::std::__moneypunct_cache<_CharT, _Intl>::_M_curr_symbol_size]);
      __mp.curr_symbol().copy(__curr_symbol, ::std::__moneypunct_cache<_CharT, _Intl>::_M_curr_symbol_size);
      ::std::__moneypunct_cache<_CharT, _Intl>::_M_curr_symbol = __curr_symbol;
      ::std::__moneypunct_cache<_CharT, _Intl>::_M_positive_sign_size = __mp.positive_sign().size();
      __positive_sign = (new _CharT [::std::__moneypunct_cache<_CharT, _Intl>::_M_positive_sign_size]);
      __mp.positive_sign().copy(__positive_sign, ::std::__moneypunct_cache<_CharT, _Intl>::_M_positive_sign_size);
      ::std::__moneypunct_cache<_CharT, _Intl>::_M_positive_sign = __positive_sign;
      ::std::__moneypunct_cache<_CharT, _Intl>::_M_negative_sign_size = __mp.negative_sign().size();
      __negative_sign = (new _CharT [::std::__moneypunct_cache<_CharT, _Intl>::_M_negative_sign_size]);
      __mp.negative_sign().copy(__negative_sign, ::std::__moneypunct_cache<_CharT, _Intl>::_M_negative_sign_size);
      ::std::__moneypunct_cache<_CharT, _Intl>::_M_negative_sign = __negative_sign;
      ::std::__moneypunct_cache<_CharT, _Intl>::_M_pos_format = __mp.pos_format();
      ::std::__moneypunct_cache<_CharT, _Intl>::_M_neg_format = __mp.neg_format();
      const ::std::ctype<_CharT> &__ct = use_facet< ::std::ctype<_CharT> >(__loc);
      __ct.widen(::std::money_base::_S_atoms, ::std::money_base::_S_atoms + ::std::money_base::_S_end, ::std::__moneypunct_cache<_CharT, _Intl>::_M_atoms);
    }
    catch (...)
    {
      delete[] __grouping;
      delete[] __curr_symbol;
      delete[] __positive_sign;
      delete[] __negative_sign;
      throw;
    }
  }
 /* Instantiation of class template '::std::iterator_traits<char *>' */ 
 /* Instantiation of class template '::__gnu_cxx::__normal_iterator<char *, ::std::basic_string<char> >' */ 
 /* Instantiation of class template '::std::__are_same<char *, char *>' */ 
 /* Instantiation of class template '::__gnu_cxx::__enable_if<true, ::std::basic_string<char> >' */ 
  template < typename _CharT, typename _InIter >
  template < bool _Intl >
  typename ::std::money_get<_CharT, _InIter>::iter_type money_get<_CharT, _InIter>::_M_extract(typename ::std::money_get<_CharT, _InIter>::iter_type __beg, typename ::std::money_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::std::string &__units) const 
  {
    typedef ::std::char_traits<_CharT> __traits_type;
    typedef typename ::std::basic_string<_CharT>::size_type size_type;
    typedef ::std::money_base::part part;
    typedef ::std::__moneypunct_cache<_CharT, _Intl> __cache_type;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    ::std::__use_cache<__cache_type> __uc;
    const __cache_type *__lc = __uc(__loc);
    const typename ::std::money_get<_CharT, _InIter>::char_type *__lit = __lc->_M_atoms;
    bool __negative(false);
    size_type __sign_size = 0;
    const bool __mandatory_sign = __lc->_M_positive_sign_size && __lc->_M_negative_sign_size;
    ::std::string __grouping_tmp /* () */ ;
    if (__lc->_M_use_grouping)
      {
        __grouping_tmp.::std::basic_string<char>::reserve(32);
      }
    int __last_pos(0);
    int __n(0);
    bool __testvalid(true);
    bool __testdecfound(false);
    ::std::string __res /* () */ ;
    __res.::std::basic_string<char>::reserve(32);
    const typename ::std::money_get<_CharT, _InIter>::char_type *__lit_zero = __lit + ::std::money_base::_S_zero;
    const ::std::money_base::pattern __p = __lc->_M_neg_format;
    for (int __i(0); __i < 4 && __testvalid;  ++__i)
      {
        const part __which(static_cast<part>(__p.field[__i]));
        switch (__which)
            {
              case ::std::money_base::symbol :
              if ((((__io.::std::ios_base::flags() & ::std::ios_base::showbase || __sign_size > 1) || __i == 0) || (__i == 1 && ((__mandatory_sign || static_cast<part>(__p.field[0]) == ::std::money_base::sign) || static_cast<part>(__p.field[2]) == ::std::money_base::space))) || (__i == 2 && (static_cast<part>(__p.field[3]) == ::std::money_base::value || (__mandatory_sign && static_cast<part>(__p.field[3]) == ::std::money_base::sign))))
                {
                  const size_type __len = __lc->_M_curr_symbol_size;
                  size_type __j = 0;
                  for (; (__beg != __end && __j < __len) && *__beg == __lc->_M_curr_symbol[__j]; ( ++__beg,  ++__j))
                    {
                      ;
                    }
                  if (__j != __len && (__j || __io.::std::ios_base::flags() & ::std::ios_base::showbase))
                    {
                      __testvalid = false;
                    }
                }
              break;
              case ::std::money_base::sign :
              if ((__lc->_M_positive_sign_size && __beg != __end) && *__beg == __lc->_M_positive_sign[0])
                {
                  __sign_size = __lc->_M_positive_sign_size;
                   ++__beg;
                }
              else
                {
                  if ((__lc->_M_negative_sign_size && __beg != __end) && *__beg == __lc->_M_negative_sign[0])
                    {
                      __negative = true;
                      __sign_size = __lc->_M_negative_sign_size;
                       ++__beg;
                    }
                  else
                    {
                      if (__lc->_M_positive_sign_size && !__lc->_M_negative_sign_size)
                        {
                          __negative = true;
                        }
                      else
                        {
                          if (__mandatory_sign)
                            {
                              __testvalid = false;
                            }
                        }
                    }
                }
              break;
              case ::std::money_base::value :
              for (; __beg != __end;  ++__beg)
                {
                  const typename ::std::money_get<_CharT, _InIter>::char_type __c = *__beg;
                  const typename ::std::money_get<_CharT, _InIter>::char_type *__q = __traits_type::find(__lit_zero, 10, __c);
                  if (__q != 0)
                    {
                      __res += ::std::money_base::_S_atoms[__q - __lit];
                       ++__n;
                    }
                  else
                    {
                      if (__c == __lc->_M_decimal_point && !__testdecfound)
                        {
                          if (__lc->_M_frac_digits <= 0)
                            {
                              break;
                            }
                          __last_pos = __n;
                          __n = 0;
                          __testdecfound = true;
                        }
                      else
                        {
                          if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !__testdecfound)
                            {
                              if (__n)
                                {
                                  __grouping_tmp += static_cast<char>(__n);
                                  __n = 0;
                                }
                              else
                                {
                                  __testvalid = false;
                                  break;
                                }
                            }
                          else
                            {
                              break;
                            }
                        }
                    }
                }
              if (__res.::std::basic_string<char>::empty())
                {
                  __testvalid = false;
                }
              break;
              case ::std::money_base::space :
              if (__beg != __end && __ctype.is(::std::ctype_base::space, *__beg))
                {
                   ++__beg;
                }
              else
                {
                  __testvalid = false;
                }
              case ::std::money_base::none :
              if (__i != 3)
                {
                  for (; __beg != __end && __ctype.is(::std::ctype_base::space, *__beg);  ++__beg)
                    {
                      ;
                    }
                }
              break;
            }
      }
    if (__sign_size > 1 && __testvalid)
      {
        const typename ::std::money_get<_CharT, _InIter>::char_type *__sign = __negative ? __lc->_M_negative_sign : __lc->_M_positive_sign;
        size_type __i = 1;
        for (; (__beg != __end && __i < __sign_size) && *__beg == __sign[__i]; ( ++__beg,  ++__i))
          {
            ;
          }
        if (__i != __sign_size)
          {
            __testvalid = false;
          }
      }
    if (__testvalid)
      {
        if (__res.::std::basic_string<char>::size() > 1)
          {
            const size_type __first = __res.::std::basic_string<char>::find_first_not_of('0' /* , 0 */ );
            const bool __only_zeros = __first == ::std::basic_string<char>::npos;
            if (__first)
              {
                __res.erase(0, __only_zeros ? __res.::std::basic_string<char>::size() - 1 : __first);
              }
          }
        if (__negative && __res.::std::basic_string<char>::operator [](0) != '0')
          {
            __res.::std::basic_string<char>::insert(__res.::std::basic_string<char>::begin(), '-');
          }
        if (__grouping_tmp.::std::basic_string<char>::size())
          {
            __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos : __n);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __grouping_tmp))
              {
                __err |= ::std::ios_base::failbit;
              }
          }
        if (__testdecfound && __n != __lc->_M_frac_digits)
          {
            __testvalid = false;
          }
      }
    if (!__testvalid)
      {
        __err |= ::std::ios_base::failbit;
      }
    else
      {
        __units.::std::basic_string<char>::swap(__res);
      }
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::money_get<_CharT, _InIter>::iter_type money_get<_CharT, _InIter>::do_get(typename ::std::money_get<_CharT, _InIter>::iter_type __beg, typename ::std::money_get<_CharT, _InIter>::iter_type __end, bool __intl, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__units) const 
  {
    ::std::string __str /* () */ ;
    __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str) : _M_extract<false>(__beg, __end, __io, __err, __str);
    std::__convert_to_v(__str.::std::basic_string<char>::c_str(), __units, __err, _S_get_c_locale());
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::money_get<_CharT, _InIter>::iter_type money_get<_CharT, _InIter>::do_get(typename ::std::money_get<_CharT, _InIter>::iter_type __beg, typename ::std::money_get<_CharT, _InIter>::iter_type __end, bool __intl, ::std::ios_base &__io, ::std::ios_base::iostate &__err, typename ::std::money_get<_CharT, _InIter>::string_type &__digits) const 
  {
    typedef ::std::basic_string<char>::size_type size_type;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    ::std::string __str /* () */ ;
    __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str) : _M_extract<false>(__beg, __end, __io, __err, __str);
    const size_type __len(__str.::std::basic_string<char>::size());
    if (__len)
      {
        __digits.resize(__len);
        __ctype.widen(__str.::std::basic_string<char>::data(), __str.::std::basic_string<char>::data() + __len, &__digits[0]);
      }
    return __beg;
  }
  template < typename _CharT, typename _OutIter >
  template < bool _Intl >
  typename ::std::money_put<_CharT, _OutIter>::iter_type money_put<_CharT, _OutIter>::_M_insert(typename ::std::money_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::money_put<_CharT, _OutIter>::char_type __fill, const typename ::std::money_put<_CharT, _OutIter>::string_type &__digits) const 
  {
    typedef typename ::std::basic_string<_CharT>::size_type size_type;
    typedef ::std::money_base::part part;
    typedef ::std::__moneypunct_cache<_CharT, _Intl> __cache_type;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    ::std::__use_cache<__cache_type> __uc;
    const __cache_type *__lc = __uc(__loc);
    const typename ::std::money_put<_CharT, _OutIter>::char_type *__lit = __lc->_M_atoms;
    const typename ::std::money_put<_CharT, _OutIter>::char_type *__beg = __digits.data();
    ::std::money_base::pattern __p /* () */ ;
    const typename ::std::money_put<_CharT, _OutIter>::char_type *__sign;
    size_type __sign_size;
    if (!(*__beg == __lit[::std::money_base::_S_minus]))
      {
        __p = __lc->_M_pos_format;
        __sign = __lc->_M_positive_sign;
        __sign_size = __lc->_M_positive_sign_size;
      }
    else
      {
        __p = __lc->_M_neg_format;
        __sign = __lc->_M_negative_sign;
        __sign_size = __lc->_M_negative_sign_size;
        if (__digits.size())
          {
             ++__beg;
          }
      }
    size_type __len = __ctype.scan_not(::std::ctype_base::digit, __beg, __beg + __digits.size()) - __beg;
    if (__len)
      {
        typename ::std::money_put<_CharT, _OutIter>::string_type __value;
        __value.reserve(2 * __len);
        long int __paddec = __len - __lc->_M_frac_digits;
        if (__paddec > 0)
          {
            if (__lc->_M_frac_digits < 0)
              {
                __paddec = __len;
              }
            if (__lc->_M_grouping_size)
              {
                __value.assign(2 * __paddec, ((typename ::std::money_put<_CharT, _OutIter>::char_type())));
                _CharT *__vend = std::__add_grouping(&__value[0], __lc->_M_thousands_sep, __lc->_M_grouping, __lc->_M_grouping_size, __beg, __beg + __paddec);
                __value.erase(__vend - &__value[0]);
              }
            else
              {
                __value.assign(__beg, __paddec);
              }
          }
        if (__lc->_M_frac_digits > 0)
          {
            __value += __lc->_M_decimal_point;
            if (__paddec >= 0)
              {
                __value.append(__beg + __paddec, __lc->_M_frac_digits);
              }
            else
              {
                __value.append( -__paddec, __lit[::std::money_base::_S_zero]);
                __value.append(__beg, __len);
              }
          }
        const ::std::ios_base::fmtflags __f(__io.::std::ios_base::flags() & ::std::ios_base::adjustfield);
        __len = __value.size() + __sign_size;
        __len += __io.::std::ios_base::flags() & ::std::ios_base::showbase ? __lc->_M_curr_symbol_size : 0;
        typename ::std::money_put<_CharT, _OutIter>::string_type __res;
        __res.reserve(2 * __len);
        const size_type __width = static_cast<size_type>(__io.::std::ios_base::width());
        const bool __testipad = __f == ::std::ios_base::internal && __len < __width;
        for (int __i(0); __i < 4;  ++__i)
          {
            const part __which(static_cast<part>(__p.field[__i]));
            switch (__which)
                {
                  case ::std::money_base::symbol :
                  if (__io.::std::ios_base::flags() & ::std::ios_base::showbase)
                    {
                      __res.append(__lc->_M_curr_symbol, __lc->_M_curr_symbol_size);
                    }
                  break;
                  case ::std::money_base::sign :
                  if (__sign_size)
                    {
                      __res += __sign[0];
                    }
                  break;
                  case ::std::money_base::value :
                  __res += __value;
                  break;
                  case ::std::money_base::space :
                  if (__testipad)
                    {
                      __res.append(__width - __len, __fill);
                    }
                  else
                    {
                      __res += __fill;
                    }
                  break;
                  case ::std::money_base::none :
                  if (__testipad)
                    {
                      __res.append(__width - __len, __fill);
                    }
                  break;
                }
          }
        if (__sign_size > 1)
          {
            __res.append(__sign + 1, __sign_size - 1);
          }
        __len = __res.size();
        if (__width > __len)
          {
            if (__f == ::std::ios_base::left)
              {
                __res.append(__width - __len, __fill);
              }
            else
              {
                __res.insert(0, __width - __len, __fill);
              }
            __len = __width;
          }
        __s = std::__write(__s, __res.data(), __len);
      }
    __io.::std::ios_base::width(0);
    return __s;
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::money_put<_CharT, _OutIter>::iter_type money_put<_CharT, _OutIter>::do_put(typename ::std::money_put<_CharT, _OutIter>::iter_type __s, bool __intl, ::std::ios_base &__io, typename ::std::money_put<_CharT, _OutIter>::char_type __fill, long double __units) const 
  {
    const ::std::locale __loc((__io.::std::ios_base::getloc()));
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    int __cs_size(64);
    char *__cs(static_cast<char *>(__builtin_alloca(__cs_size)));
    int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, "%.*Lf", 0, __units);
    if (__len >= __cs_size)
      {
        __cs_size = __len + 1;
        __cs = static_cast<char *>(__builtin_alloca(__cs_size));
        __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, "%.*Lf", 0, __units);
      }
    typename ::std::money_put<_CharT, _OutIter>::string_type __digits(__len, ((typename ::std::money_put<_CharT, _OutIter>::char_type())));
    __ctype.widen(__cs, __cs + __len, &__digits[0]);
    return __intl ? _M_insert<true>(__s, __io, __fill, __digits) : _M_insert<false>(__s, __io, __fill, __digits);
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::money_put<_CharT, _OutIter>::iter_type money_put<_CharT, _OutIter>::do_put(typename ::std::money_put<_CharT, _OutIter>::iter_type __s, bool __intl, ::std::ios_base &__io, typename ::std::money_put<_CharT, _OutIter>::char_type __fill, const typename ::std::money_put<_CharT, _OutIter>::string_type &__digits) const 
  {
    return __intl ? _M_insert<true>(__s, __io, __fill, __digits) : _M_insert<false>(__s, __io, __fill, __digits);
  }
  template < typename _CharT, typename _InIter >
  ::std::time_base::dateorder time_get<_CharT, _InIter>::do_date_order() const 
  {
    return ::std::time_base::no_order;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::time_get<_CharT, _InIter>::iter_type time_get<_CharT, _InIter>::_M_extract_via_format(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm, const _CharT *__format) const 
  {
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const ::std::__timepunct<_CharT> &__tp = use_facet< ::std::__timepunct<_CharT> >(__loc);
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    const ::std::size_t __len = char_traits<_CharT>::length(__format);
    ::std::ios_base::iostate __tmperr(::std::ios_base::goodbit);
    ::std::size_t __i(0);
    for (; (__beg != __end && __i < __len) && !__tmperr;  ++__i)
      {
        if (__ctype.narrow(__format[__i], 0) == '%')
          {
            char __c = __ctype.narrow(__format[ ++__i], 0);
            int __mem(0);
            if (__c == 'E' || __c == 'O')
              {
                __c = __ctype.narrow(__format[ ++__i], 0);
              }
            switch (__c)
                {
                  const char *__cs;
                  _CharT __wcs[10L];
                  case 'a' :
                  const typename ::std::time_get<_CharT, _InIter>::char_type *__days1[7L];
                  __tp._M_days_abbreviated(__days1);
                  __beg = (*this)._M_extract_name(__beg, __end, (*__tm).tm_wday, __days1, 7, __io, __tmperr);
                  break;
                  case 'A' :
                  const typename ::std::time_get<_CharT, _InIter>::char_type *__days2[7L];
                  __tp._M_days(__days2);
                  __beg = (*this)._M_extract_name(__beg, __end, (*__tm).tm_wday, __days2, 7, __io, __tmperr);
                  break;
                  case 'h' :
                  ;
                  case 'b' :
                  const typename ::std::time_get<_CharT, _InIter>::char_type *__months1[12L];
                  __tp._M_months_abbreviated(__months1);
                  __beg = (*this)._M_extract_name(__beg, __end, (*__tm).tm_mon, __months1, 12, __io, __tmperr);
                  break;
                  case 'B' :
                  const typename ::std::time_get<_CharT, _InIter>::char_type *__months2[12L];
                  __tp._M_months(__months2);
                  __beg = (*this)._M_extract_name(__beg, __end, (*__tm).tm_mon, __months2, 12, __io, __tmperr);
                  break;
                  case 'c' :
                  const typename ::std::time_get<_CharT, _InIter>::char_type *__dt[2L];
                  __tp._M_date_time_formats(__dt);
                  __beg = (*this)._M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __dt[0]);
                  break;
                  case 'd' :
                  __beg = (*this)._M_extract_num(__beg, __end, (*__tm).tm_mday, 1, 31, 2, __io, __tmperr);
                  break;
                  case 'e' :
                  if (__ctype.is(::std::ctype_base::space, *__beg))
                    {
                      __beg = (*this)._M_extract_num( ++__beg, __end, (*__tm).tm_mday, 1, 9, 1, __io, __tmperr);
                    }
                  else
                    {
                      __beg = (*this)._M_extract_num(__beg, __end, (*__tm).tm_mday, 10, 31, 2, __io, __tmperr);
                    }
                  break;
                  case 'D' :
                  __cs = "%m/%d/%y";
                  __ctype.widen(__cs, __cs + 9, __wcs);
                  __beg = (*this)._M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __wcs);
                  break;
                  case 'H' :
                  __beg = (*this)._M_extract_num(__beg, __end, (*__tm).tm_hour, 0, 23, 2, __io, __tmperr);
                  break;
                  case 'I' :
                  __beg = (*this)._M_extract_num(__beg, __end, (*__tm).tm_hour, 1, 12, 2, __io, __tmperr);
                  break;
                  case 'm' :
                  __beg = (*this)._M_extract_num(__beg, __end, __mem, 1, 12, 2, __io, __tmperr);
                  if (!__tmperr)
                    {
                      (*__tm).tm_mon = __mem - 1;
                    }
                  break;
                  case 'M' :
                  __beg = (*this)._M_extract_num(__beg, __end, (*__tm).tm_min, 0, 59, 2, __io, __tmperr);
                  break;
                  case 'n' :
                  if (__ctype.narrow(*__beg, 0) == '\n')
                    {
                       ++__beg;
                    }
                  else
                    {
                      __tmperr |= ::std::ios_base::failbit;
                    }
                  break;
                  case 'R' :
                  __cs = "%H:%M";
                  __ctype.widen(__cs, __cs + 6, __wcs);
                  __beg = (*this)._M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __wcs);
                  break;
                  case 'S' :
                  __beg = (*this)._M_extract_num(__beg, __end, (*__tm).tm_sec, 0, 60, 2, __io, __tmperr);
                  break;
                  case 't' :
                  if (__ctype.narrow(*__beg, 0) == '\t')
                    {
                       ++__beg;
                    }
                  else
                    {
                      __tmperr |= ::std::ios_base::failbit;
                    }
                  break;
                  case 'T' :
                  __cs = "%H:%M:%S";
                  __ctype.widen(__cs, __cs + 9, __wcs);
                  __beg = (*this)._M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __wcs);
                  break;
                  case 'x' :
                  const typename ::std::time_get<_CharT, _InIter>::char_type *__dates[2L];
                  __tp._M_date_formats(__dates);
                  __beg = (*this)._M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __dates[0]);
                  break;
                  case 'X' :
                  const typename ::std::time_get<_CharT, _InIter>::char_type *__times[2L];
                  __tp._M_time_formats(__times);
                  __beg = (*this)._M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __times[0]);
                  break;
                  case 'y' :
                  ;
                  case 'C' :
                  ;
                  case 'Y' :
                  __beg = (*this)._M_extract_num(__beg, __end, __mem, 0, 9999, 4, __io, __tmperr);
                  if (!__tmperr)
                    {
                      (*__tm).tm_year = __mem < 0 ? __mem + 100 : __mem - 1900;
                    }
                  break;
                  case 'Z' :
                  if (__ctype.is(::std::ctype_base::upper, *__beg))
                    {
                      int __tmp;
                      __beg = (*this)._M_extract_name(__beg, __end, __tmp, __timepunct_cache<_CharT>::_S_timezones, 14, __io, __tmperr);
                      if (((__beg != __end && !__tmperr) && __tmp == 0) && (*__beg == __ctype.widen('-') || *__beg == __ctype.widen('+')))
                        {
                          __beg = (*this)._M_extract_num(__beg, __end, __tmp, 0, 23, 2, __io, __tmperr);
                          __beg = (*this)._M_extract_num(__beg, __end, __tmp, 0, 59, 2, __io, __tmperr);
                        }
                    }
                  else
                    {
                      __tmperr |= ::std::ios_base::failbit;
                    }
                  break;
                  default :
                  __tmperr |= ::std::ios_base::failbit;
                }
          }
        else
          {
            if (__format[__i] == *__beg)
              {
                 ++__beg;
              }
            else
              {
                __tmperr |= ::std::ios_base::failbit;
              }
          }
      }
    if (__tmperr || __i != __len)
      {
        __err |= ::std::ios_base::failbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::time_get<_CharT, _InIter>::iter_type time_get<_CharT, _InIter>::_M_extract_num(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, int &__member, int __min, int __max, ::std::size_t __len, ::std::ios_base &__io, ::std::ios_base::iostate &__err) const 
  {
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    int __mult(__len == 2 ? 10 : __len == 4 ? 1000 : 1);
     ++__min;
    ::std::size_t __i(0);
    int __value(0);
    for (; __beg != __end && __i < __len; ( ++__beg,  ++__i))
      {
        const char __c = __ctype.narrow(*__beg, '*');
        if (__c >= '0' && __c <= '9')
          {
            __value = __value * 10 + (__c - '0');
            const int __valuec(__value * __mult);
            if (__valuec > __max || __valuec + __mult < __min)
              {
                break;
              }
            __mult /= 10;
          }
        else
          {
            break;
          }
      }
    if (__i == __len)
      {
        __member = __value;
      }
    else
      {
        if (__len == 4 && __i == 2)
          {
            __member = __value - 100;
          }
        else
          {
            __err |= ::std::ios_base::failbit;
          }
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::time_get<_CharT, _InIter>::iter_type time_get<_CharT, _InIter>::_M_extract_name(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, int &__member, const _CharT **__names, ::std::size_t __indexlen, ::std::ios_base &__io, ::std::ios_base::iostate &__err) const 
  {
    typedef ::std::char_traits<_CharT> __traits_type;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    int *__matches(static_cast<int *>(__builtin_alloca(sizeof(int) * __indexlen)));
    ::std::size_t __nmatches(0);
    ::std::size_t __pos(0);
    bool __testvalid(true);
    const typename ::std::time_get<_CharT, _InIter>::char_type *__name;
    if (__beg != __end)
      {
        const typename ::std::time_get<_CharT, _InIter>::char_type __c = *__beg;
        for (::std::size_t __i1(0); __i1 < __indexlen;  ++__i1)
          {
            if (__c == __names[__i1][0] || __c == __ctype.toupper(__names[__i1][0]))
              {
                __matches[__nmatches++] = __i1;
              }
          }
      }
    while (__nmatches > 1)
      {
        ::std::size_t __minlen = __traits_type::length(__names[__matches[0]]);
        for (::std::size_t __i2(1); __i2 < __nmatches;  ++__i2)
          {
            __minlen = std::min(__minlen, __traits_type::length(__names[__matches[__i2]]));
          }
        ( ++__beg,  ++__pos);
        if (__pos < __minlen && __beg != __end)
          {
            for (::std::size_t __i3(0); __i3 < __nmatches; )
              {
                __name = __names[__matches[__i3]];
                if (!(__name[__pos] == *__beg))
                  {
                    __matches[__i3] = __matches[ --__nmatches];
                  }
                else
                  {
                     ++__i3;
                  }
              }
          }
        else
          {
            break;
          }
      }
    if (__nmatches == 1)
      {
        ( ++__beg,  ++__pos);
        __name = __names[__matches[0]];
        const ::std::size_t __len = __traits_type::length(__name);
        while ((__pos < __len && __beg != __end) && __name[__pos] == *__beg)
          {
            ( ++__beg,  ++__pos);
          }
        if (__len == __pos)
          {
            __member = __matches[0];
          }
        else
          {
            __testvalid = false;
          }
      }
    else
      {
        __testvalid = false;
      }
    if (!__testvalid)
      {
        __err |= ::std::ios_base::failbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::time_get<_CharT, _InIter>::iter_type time_get<_CharT, _InIter>::_M_extract_wday_or_month(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, int &__member, const _CharT **__names, ::std::size_t __indexlen, ::std::ios_base &__io, ::std::ios_base::iostate &__err) const 
  {
    typedef ::std::char_traits<_CharT> __traits_type;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    int *__matches(static_cast<int *>(__builtin_alloca(2 * sizeof(int) * __indexlen)));
    ::std::size_t __nmatches(0);
    ::std::size_t *__matches_lengths(0);
    ::std::size_t __pos(0);
    if (__beg != __end)
      {
        const typename ::std::time_get<_CharT, _InIter>::char_type __c = *__beg;
        for (::std::size_t __i(0); __i < 2 * __indexlen;  ++__i)
          {
            if (__c == __names[__i][0] || __c == __ctype.toupper(__names[__i][0]))
              {
                __matches[__nmatches++] = __i;
              }
          }
      }
    if (__nmatches)
      {
        ( ++__beg,  ++__pos);
        __matches_lengths = static_cast< ::std::size_t *>(__builtin_alloca(sizeof(::std::size_t) * __nmatches));
        for (::std::size_t __i(0); __i < __nmatches;  ++__i)
          {
            __matches_lengths[__i] = __traits_type::length(__names[__matches[__i]]);
          }
      }
    for (; __beg != __end; ( ++__beg,  ++__pos))
      {
        ::std::size_t __nskipped(0);
        const typename ::std::time_get<_CharT, _InIter>::char_type __c = *__beg;
        for (::std::size_t __i(0); __i < __nmatches; )
          {
            const typename ::std::time_get<_CharT, _InIter>::char_type *__name = __names[__matches[__i]];
            if (__pos >= __matches_lengths[__i])
              {
                ( ++__nskipped,  ++__i);
              }
            else
              {
                if (!(__name[__pos] == __c))
                  {
                     --__nmatches;
                    __matches[__i] = __matches[__nmatches];
                    __matches_lengths[__i] = __matches_lengths[__nmatches];
                  }
                else
                  {
                     ++__i;
                  }
              }
          }
        if (__nskipped == __nmatches)
          {
            break;
          }
      }
    if ((__nmatches == 1 && __matches_lengths[0] == __pos) || (__nmatches == 2 && (__matches_lengths[0] == __pos || __matches_lengths[1] == __pos)))
      {
        __member = __matches[0] >= __indexlen ? __matches[0] - __indexlen : __matches[0];
      }
    else
      {
        __err |= ::std::ios_base::failbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::time_get<_CharT, _InIter>::iter_type time_get<_CharT, _InIter>::do_get_time(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const 
  {
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const ::std::__timepunct<_CharT> &__tp = use_facet< ::std::__timepunct<_CharT> >(__loc);
    const typename ::std::time_get<_CharT, _InIter>::char_type *__times[2L];
    __tp._M_time_formats(__times);
    __beg = (*this)._M_extract_via_format(__beg, __end, __io, __err, __tm, __times[0]);
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::time_get<_CharT, _InIter>::iter_type time_get<_CharT, _InIter>::do_get_date(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const 
  {
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const ::std::__timepunct<_CharT> &__tp = use_facet< ::std::__timepunct<_CharT> >(__loc);
    const typename ::std::time_get<_CharT, _InIter>::char_type *__dates[2L];
    __tp._M_date_formats(__dates);
    __beg = (*this)._M_extract_via_format(__beg, __end, __io, __err, __tm, __dates[0]);
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::time_get<_CharT, _InIter>::iter_type time_get<_CharT, _InIter>::do_get_weekday(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const 
  {
    typedef ::std::char_traits<_CharT> __traits_type;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const ::std::__timepunct<_CharT> &__tp = use_facet< ::std::__timepunct<_CharT> >(__loc);
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    const typename ::std::time_get<_CharT, _InIter>::char_type *__days[14L];
    __tp._M_days_abbreviated(__days);
    __tp._M_days(__days + 7);
    int __tmpwday;
    ::std::ios_base::iostate __tmperr(::std::ios_base::goodbit);
    __beg = (*this)._M_extract_wday_or_month(__beg, __end, __tmpwday, __days, 7, __io, __tmperr);
    if (!__tmperr)
      {
        (*__tm).tm_wday = __tmpwday;
      }
    else
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::time_get<_CharT, _InIter>::iter_type time_get<_CharT, _InIter>::do_get_monthname(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const 
  {
    typedef ::std::char_traits<_CharT> __traits_type;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const ::std::__timepunct<_CharT> &__tp = use_facet< ::std::__timepunct<_CharT> >(__loc);
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    const typename ::std::time_get<_CharT, _InIter>::char_type *__months[24L];
    __tp._M_months_abbreviated(__months);
    __tp._M_months(__months + 12);
    int __tmpmon;
    ::std::ios_base::iostate __tmperr(::std::ios_base::goodbit);
    __beg = (*this)._M_extract_wday_or_month(__beg, __end, __tmpmon, __months, 12, __io, __tmperr);
    if (!__tmperr)
      {
        (*__tm).tm_mon = __tmpmon;
      }
    else
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::time_get<_CharT, _InIter>::iter_type time_get<_CharT, _InIter>::do_get_year(typename ::std::time_get<_CharT, _InIter>::iter_type __beg, typename ::std::time_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::tm *__tm) const 
  {
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    int __tmpyear;
    ::std::ios_base::iostate __tmperr(::std::ios_base::goodbit);
    __beg = (*this)._M_extract_num(__beg, __end, __tmpyear, 0, 9999, 4, __io, __tmperr);
    if (!__tmperr)
      {
        (*__tm).tm_year = __tmpyear < 0 ? __tmpyear + 100 : __tmpyear - 1900;
      }
    else
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::time_put<_CharT, _OutIter>::iter_type time_put<_CharT, _OutIter>::put(typename ::std::time_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::time_put<_CharT, _OutIter>::char_type __fill, const ::tm *__tm, const _CharT *__beg, const _CharT *__end) const 
  {
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    for (; __beg != __end;  ++__beg)
      {
        if (__ctype.narrow(*__beg, 0) != '%')
          {
            *__s = *__beg;
             ++__s;
          }
        else
          {
            if ( ++__beg != __end)
              {
                char __format;
                char __mod(0);
                const char __c = __ctype.narrow(*__beg, 0);
                if (__c != 'E' && __c != 'O')
                  {
                    __format = __c;
                  }
                else
                  {
                    if ( ++__beg != __end)
                      {
                        __mod = __c;
                        __format = __ctype.narrow(*__beg, 0);
                      }
                    else
                      {
                        break;
                      }
                  }
                __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
              }
            else
              {
                break;
              }
          }
      }
    return __s;
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::time_put<_CharT, _OutIter>::iter_type time_put<_CharT, _OutIter>::do_put(typename ::std::time_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::time_put<_CharT, _OutIter>::char_type, const ::tm *__tm, char __format, char __mod) const 
  {
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    const ::std::__timepunct<_CharT> &__tp = use_facet< ::std::__timepunct<_CharT> >(__loc);
    const ::std::size_t __maxlen(128);
    typename ::std::time_put<_CharT, _OutIter>::char_type __res[128L];
    typename ::std::time_put<_CharT, _OutIter>::char_type __fmt[4L];
    __fmt[0] = __ctype.widen('%');
    if (!__mod)
      {
        __fmt[1] = __format;
        __fmt[2] = ((typename ::std::time_put<_CharT, _OutIter>::char_type()));
      }
    else
      {
        __fmt[1] = __mod;
        __fmt[2] = __format;
        __fmt[3] = ((typename ::std::time_put<_CharT, _OutIter>::char_type()));
      }
    __tp._M_put(__res, __maxlen, __fmt, __tm);
    return std::__write(__s, __res, char_traits<typename ::std::time_put<_CharT, _OutIter>::char_type>::length(__res));
  }
  extern template class ::std::moneypunct<char, false>;
  extern template class ::std::moneypunct<char, true>;
  extern template class ::std::moneypunct_byname<char, false>;
  extern template class ::std::moneypunct_byname<char, true>;
  extern template class ::std::money_get<char>;
  extern template class ::std::money_put<char>;
  extern template class ::std::__timepunct<char>;
  extern template class ::std::time_put<char>;
  extern template class ::std::time_put_byname<char>;
  extern template class ::std::time_get<char>;
  extern template class ::std::time_get_byname<char>;
  extern template class ::std::messages<char>;
  extern template class ::std::messages_byname<char>;
  extern template const ::std::moneypunct<char, true> &use_facet< ::std::moneypunct<char, true> >(const ::std::locale &);
  extern template const ::std::moneypunct<char, false> &use_facet< ::std::moneypunct<char, false> >(const ::std::locale &);
  extern template const ::std::money_put<char> &use_facet< ::std::money_put<char> >(const ::std::locale &);
  extern template const ::std::money_get<char> &use_facet< ::std::money_get<char> >(const ::std::locale &);
  extern template const ::std::__timepunct<char> &use_facet< ::std::__timepunct<char> >(const ::std::locale &);
  extern template const ::std::time_put<char> &use_facet< ::std::time_put<char> >(const ::std::locale &);
  extern template const ::std::time_get<char> &use_facet< ::std::time_get<char> >(const ::std::locale &);
  extern template const ::std::messages<char> &use_facet< ::std::messages<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::moneypunct<char, false> >(const ::std::locale &);
  extern template bool has_facet< ::std::money_put<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::money_get<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::__timepunct<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::time_put<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::time_get<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::messages<char> >(const ::std::locale &);
  extern template class ::std::moneypunct<wchar_t, false>;
  extern template class ::std::moneypunct<wchar_t, true>;
  extern template class ::std::moneypunct_byname<wchar_t, false>;
  extern template class ::std::moneypunct_byname<wchar_t, true>;
  extern template class ::std::money_get<wchar_t>;
  extern template class ::std::money_put<wchar_t>;
  extern template class ::std::__timepunct<wchar_t>;
  extern template class ::std::time_put<wchar_t>;
  extern template class ::std::time_put_byname<wchar_t>;
  extern template class ::std::time_get<wchar_t>;
  extern template class ::std::time_get_byname<wchar_t>;
  extern template class ::std::messages<wchar_t>;
  extern template class ::std::messages_byname<wchar_t>;
  extern template const ::std::moneypunct<wchar_t, true> &use_facet< ::std::moneypunct<wchar_t, true> >(const ::std::locale &);
  extern template const ::std::moneypunct<wchar_t, false> &use_facet< ::std::moneypunct<wchar_t, false> >(const ::std::locale &);
  extern template const ::std::money_put<wchar_t> &use_facet< ::std::money_put<wchar_t> >(const ::std::locale &);
  extern template const ::std::money_get<wchar_t> &use_facet< ::std::money_get<wchar_t> >(const ::std::locale &);
  extern template const ::std::__timepunct<wchar_t> &use_facet< ::std::__timepunct<wchar_t> >(const ::std::locale &);
  extern template const ::std::time_put<wchar_t> &use_facet< ::std::time_put<wchar_t> >(const ::std::locale &);
  extern template const ::std::time_get<wchar_t> &use_facet< ::std::time_get<wchar_t> >(const ::std::locale &);
  extern template const ::std::messages<wchar_t> &use_facet< ::std::messages<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::moneypunct<wchar_t, false> >(const ::std::locale &);
  extern template bool has_facet< ::std::money_put<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::money_get<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::__timepunct<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::time_put<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::time_get<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::messages<wchar_t> >(const ::std::locale &);
  enum float_round_style
  {
    round_indeterminate =  -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };
  enum float_denorm_style
  {
    denorm_indeterminate =  -1,
    denorm_absent = 0,
    denorm_present = 1
  };
  struct  __numeric_limits_base
  {
      static constexpr const bool is_specialized = false;
      static constexpr const int digits = 0;
      static constexpr const int digits10 = 0;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = false;
      static constexpr const bool is_integer = false;
      static constexpr const bool is_exact = false;
      static constexpr const int radix = 0;
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = false;
      static constexpr const bool is_modulo = false;
      static constexpr const bool traps = false;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template < typename _Tp >
  struct  numeric_limits : ::std::__numeric_limits_base
  {
      static inline constexpr _Tp min() noexcept(true)
      {
        return _Tp();
      }
      static inline constexpr _Tp max() noexcept(true)
      {
        return _Tp();
      }
      static inline constexpr _Tp lowest() noexcept(true)
      {
        return _Tp();
      }
      static inline constexpr _Tp epsilon() noexcept(true)
      {
        return _Tp();
      }
      static inline constexpr _Tp round_error() noexcept(true)
      {
        return _Tp();
      }
      static inline constexpr _Tp infinity() noexcept(true)
      {
        return _Tp();
      }
      static inline constexpr _Tp quiet_NaN() noexcept(true)
      {
        return _Tp();
      }
      static inline constexpr _Tp signaling_NaN() noexcept(true)
      {
        return _Tp();
      }
      static inline constexpr _Tp denorm_min() noexcept(true)
      {
        return _Tp();
      }
  };
  template < typename _Tp >
  struct  numeric_limits<const _Tp> : ::std::numeric_limits<_Tp>
  {
  };
  template < typename _Tp >
  struct  numeric_limits<volatile _Tp> : ::std::numeric_limits<_Tp>
  {
  };
  template < typename _Tp >
  struct  numeric_limits<const volatile _Tp> : ::std::numeric_limits<_Tp>
  {
  };
  template <>
  struct  numeric_limits<bool>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr bool min() noexcept(true)
      {
        return false;
      }
      static inline constexpr bool max() noexcept(true)
      {
        return true;
      }
      static inline constexpr bool lowest() noexcept(true)
      {
        return ::std::numeric_limits<bool>::min();
      }
      static constexpr const int digits = 1;
      static constexpr const int digits10 = 0;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = false;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr bool epsilon() noexcept(true)
      {
        return false;
      }
      static inline constexpr bool round_error() noexcept(true)
      {
        return false;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr bool infinity() noexcept(true)
      {
        return false;
      }
      static inline constexpr bool quiet_NaN() noexcept(true)
      {
        return false;
      }
      static inline constexpr bool signaling_NaN() noexcept(true)
      {
        return false;
      }
      static inline constexpr bool denorm_min() noexcept(true)
      {
        return false;
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = false;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<char>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr char min() noexcept(true)
      {
        return (char) -1 < 0 ?  -((char) -1 < 0 ? ((((char)1 << (sizeof(char) * 8 - ((char) -1 < 0) - 1)) - 1) << 1) + 1 : ~((char)0)) - 1 : (char)0;
      }
      static inline constexpr char max() noexcept(true)
      {
        return (char) -1 < 0 ? ((((char)1 << (sizeof(char) * 8 - ((char) -1 < 0) - 1)) - 1) << 1) + 1 : ~((char)0);
      }
      static inline constexpr char lowest() noexcept(true)
      {
        return ::std::numeric_limits<char>::min();
      }
      static constexpr const int digits = sizeof(char) * 8 - ((char) -1 < 0);
      static constexpr const int digits10 = (sizeof(char) * 8 - ((char) -1 < 0)) * 643L / 2136;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = (char) -1 < 0;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr char epsilon() noexcept(true)
      {
        return 0;
      }
      static inline constexpr char round_error() noexcept(true)
      {
        return 0;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr char infinity() noexcept(true)
      {
        return char();
      }
      static inline constexpr char quiet_NaN() noexcept(true)
      {
        return char();
      }
      static inline constexpr char signaling_NaN() noexcept(true)
      {
        return char();
      }
      static inline constexpr char denorm_min() noexcept(true)
      {
        return static_cast<char>(0);
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = !::std::numeric_limits<char>::is_signed;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<signed char>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr signed char min() noexcept(true)
      {
        return  -127 - 1;
      }
      static inline constexpr signed char max() noexcept(true)
      {
        return 127;
      }
      static inline constexpr signed char lowest() noexcept(true)
      {
        return ::std::numeric_limits<signed char>::min();
      }
      static constexpr const int digits = sizeof(signed char) * 8 - ((signed char) -1 < 0);
      static constexpr const int digits10 = (sizeof(signed char) * 8 - ((signed char) -1 < 0)) * 643L / 2136;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = true;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr signed char epsilon() noexcept(true)
      {
        return 0;
      }
      static inline constexpr signed char round_error() noexcept(true)
      {
        return 0;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr signed char infinity() noexcept(true)
      {
        return static_cast<signed char>(0);
      }
      static inline constexpr signed char quiet_NaN() noexcept(true)
      {
        return static_cast<signed char>(0);
      }
      static inline constexpr signed char signaling_NaN() noexcept(true)
      {
        return static_cast<signed char>(0);
      }
      static inline constexpr signed char denorm_min() noexcept(true)
      {
        return static_cast<signed char>(0);
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = false;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<unsigned char>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr unsigned char min() noexcept(true)
      {
        return 0;
      }
      static inline constexpr unsigned char max() noexcept(true)
      {
        return 127 * 2U + 1;
      }
      static inline constexpr unsigned char lowest() noexcept(true)
      {
        return ::std::numeric_limits<unsigned char>::min();
      }
      static constexpr const int digits = sizeof(unsigned char) * 8 - ((unsigned char) -1 < 0);
      static constexpr const int digits10 = (sizeof(unsigned char) * 8 - ((unsigned char) -1 < 0)) * 643L / 2136;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = false;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr unsigned char epsilon() noexcept(true)
      {
        return 0;
      }
      static inline constexpr unsigned char round_error() noexcept(true)
      {
        return 0;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr unsigned char infinity() noexcept(true)
      {
        return static_cast<unsigned char>(0);
      }
      static inline constexpr unsigned char quiet_NaN() noexcept(true)
      {
        return static_cast<unsigned char>(0);
      }
      static inline constexpr unsigned char signaling_NaN() noexcept(true)
      {
        return static_cast<unsigned char>(0);
      }
      static inline constexpr unsigned char denorm_min() noexcept(true)
      {
        return static_cast<unsigned char>(0);
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = true;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<wchar_t>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr wchar_t min() noexcept(true)
      {
        return (wchar_t) -1 < 0 ?  -((wchar_t) -1 < 0 ? ((((wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t) -1 < 0) - 1)) - 1) << 1) + 1 : ~((wchar_t)0)) - 1 : (wchar_t)0;
      }
      static inline constexpr wchar_t max() noexcept(true)
      {
        return (wchar_t) -1 < 0 ? ((((wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t) -1 < 0) - 1)) - 1) << 1) + 1 : ~((wchar_t)0);
      }
      static inline constexpr wchar_t lowest() noexcept(true)
      {
        return ::std::numeric_limits<wchar_t>::min();
      }
      static constexpr const int digits = sizeof(wchar_t) * 8 - ((wchar_t) -1 < 0);
      static constexpr const int digits10 = (sizeof(wchar_t) * 8 - ((wchar_t) -1 < 0)) * 643L / 2136;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = (wchar_t) -1 < 0;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr wchar_t epsilon() noexcept(true)
      {
        return 0;
      }
      static inline constexpr wchar_t round_error() noexcept(true)
      {
        return 0;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr wchar_t infinity() noexcept(true)
      {
        return wchar_t();
      }
      static inline constexpr wchar_t quiet_NaN() noexcept(true)
      {
        return wchar_t();
      }
      static inline constexpr wchar_t signaling_NaN() noexcept(true)
      {
        return wchar_t();
      }
      static inline constexpr wchar_t denorm_min() noexcept(true)
      {
        return wchar_t();
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = !::std::numeric_limits<wchar_t>::is_signed;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<char16_t>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr char16_t min() noexcept(true)
      {
        return (char16_t) -1 < 0 ?  -((char16_t) -1 < 0 ? ((((char16_t)1 << (sizeof(char16_t) * 8 - ((char16_t) -1 < 0) - 1)) - 1) << 1) + 1 : ~((char16_t)0)) - 1 : (char16_t)0;
      }
      static inline constexpr char16_t max() noexcept(true)
      {
        return (char16_t) -1 < 0 ? ((((char16_t)1 << (sizeof(char16_t) * 8 - ((char16_t) -1 < 0) - 1)) - 1) << 1) + 1 : ~((char16_t)0);
      }
      static inline constexpr char16_t lowest() noexcept(true)
      {
        return ::std::numeric_limits<char16_t>::min();
      }
      static constexpr const int digits = sizeof(char16_t) * 8 - ((char16_t) -1 < 0);
      static constexpr const int digits10 = (sizeof(char16_t) * 8 - ((char16_t) -1 < 0)) * 643L / 2136;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = (char16_t) -1 < 0;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr char16_t epsilon() noexcept(true)
      {
        return 0;
      }
      static inline constexpr char16_t round_error() noexcept(true)
      {
        return 0;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr char16_t infinity() noexcept(true)
      {
        return char16_t();
      }
      static inline constexpr char16_t quiet_NaN() noexcept(true)
      {
        return char16_t();
      }
      static inline constexpr char16_t signaling_NaN() noexcept(true)
      {
        return char16_t();
      }
      static inline constexpr char16_t denorm_min() noexcept(true)
      {
        return char16_t();
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = !::std::numeric_limits<char16_t>::is_signed;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<char32_t>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr char32_t min() noexcept(true)
      {
        return (char32_t) -1 < 0 ?  -((char32_t) -1 < 0 ? ((((char32_t)1 << (sizeof(char32_t) * 8 - ((char32_t) -1 < 0) - 1)) - 1) << 1) + 1 : ~((char32_t)0)) - 1 : (char32_t)0;
      }
      static inline constexpr char32_t max() noexcept(true)
      {
        return (char32_t) -1 < 0 ? ((((char32_t)1 << (sizeof(char32_t) * 8 - ((char32_t) -1 < 0) - 1)) - 1) << 1) + 1 : ~((char32_t)0);
      }
      static inline constexpr char32_t lowest() noexcept(true)
      {
        return ::std::numeric_limits<char32_t>::min();
      }
      static constexpr const int digits = sizeof(char32_t) * 8 - ((char32_t) -1 < 0);
      static constexpr const int digits10 = (sizeof(char32_t) * 8 - ((char32_t) -1 < 0)) * 643L / 2136;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = (char32_t) -1 < 0;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr char32_t epsilon() noexcept(true)
      {
        return 0;
      }
      static inline constexpr char32_t round_error() noexcept(true)
      {
        return 0;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr char32_t infinity() noexcept(true)
      {
        return char32_t();
      }
      static inline constexpr char32_t quiet_NaN() noexcept(true)
      {
        return char32_t();
      }
      static inline constexpr char32_t signaling_NaN() noexcept(true)
      {
        return char32_t();
      }
      static inline constexpr char32_t denorm_min() noexcept(true)
      {
        return char32_t();
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = !::std::numeric_limits<char32_t>::is_signed;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<short int>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr short int min() noexcept(true)
      {
        return  -32767 - 1;
      }
      static inline constexpr short int max() noexcept(true)
      {
        return 32767;
      }
      static inline constexpr short int lowest() noexcept(true)
      {
        return ::std::numeric_limits<short int>::min();
      }
      static constexpr const int digits = sizeof(short int) * 8 - ((short int) -1 < 0);
      static constexpr const int digits10 = (sizeof(short int) * 8 - ((short int) -1 < 0)) * 643L / 2136;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = true;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr short int epsilon() noexcept(true)
      {
        return 0;
      }
      static inline constexpr short int round_error() noexcept(true)
      {
        return 0;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr short int infinity() noexcept(true)
      {
        return short();
      }
      static inline constexpr short int quiet_NaN() noexcept(true)
      {
        return short();
      }
      static inline constexpr short int signaling_NaN() noexcept(true)
      {
        return short();
      }
      static inline constexpr short int denorm_min() noexcept(true)
      {
        return short();
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = false;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<unsigned short int>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr unsigned short int min() noexcept(true)
      {
        return 0;
      }
      static inline constexpr unsigned short int max() noexcept(true)
      {
        return 32767 * 2U + 1;
      }
      static inline constexpr unsigned short int lowest() noexcept(true)
      {
        return ::std::numeric_limits<unsigned short int>::min();
      }
      static constexpr const int digits = sizeof(unsigned short int) * 8 - ((unsigned short int) -1 < 0);
      static constexpr const int digits10 = (sizeof(unsigned short int) * 8 - ((unsigned short int) -1 < 0)) * 643L / 2136;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = false;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr unsigned short int epsilon() noexcept(true)
      {
        return 0;
      }
      static inline constexpr unsigned short int round_error() noexcept(true)
      {
        return 0;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr unsigned short int infinity() noexcept(true)
      {
        return static_cast<unsigned short int>(0);
      }
      static inline constexpr unsigned short int quiet_NaN() noexcept(true)
      {
        return static_cast<unsigned short int>(0);
      }
      static inline constexpr unsigned short int signaling_NaN() noexcept(true)
      {
        return static_cast<unsigned short int>(0);
      }
      static inline constexpr unsigned short int denorm_min() noexcept(true)
      {
        return static_cast<unsigned short int>(0);
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = true;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<int>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr int min() noexcept(true)
      {
        return  -2147483647 - 1;
      }
      static inline constexpr int max() noexcept(true)
      {
        return 2147483647;
      }
      static inline constexpr int lowest() noexcept(true)
      {
        return ::std::numeric_limits<int>::min();
      }
      static constexpr const int digits = sizeof(int) * 8 - ((int) -1 < 0);
      static constexpr const int digits10 = (sizeof(int) * 8 - ((int) -1 < 0)) * 643L / 2136;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = true;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr int epsilon() noexcept(true)
      {
        return 0;
      }
      static inline constexpr int round_error() noexcept(true)
      {
        return 0;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr int infinity() noexcept(true)
      {
        return static_cast<int>(0);
      }
      static inline constexpr int quiet_NaN() noexcept(true)
      {
        return static_cast<int>(0);
      }
      static inline constexpr int signaling_NaN() noexcept(true)
      {
        return static_cast<int>(0);
      }
      static inline constexpr int denorm_min() noexcept(true)
      {
        return static_cast<int>(0);
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = false;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<unsigned int>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr unsigned int min() noexcept(true)
      {
        return 0;
      }
      static inline constexpr unsigned int max() noexcept(true)
      {
        return 2147483647 * 2U + 1;
      }
      static inline constexpr unsigned int lowest() noexcept(true)
      {
        return ::std::numeric_limits<unsigned int>::min();
      }
      static constexpr const int digits = sizeof(unsigned int) * 8 - ((unsigned int) -1 < 0);
      static constexpr const int digits10 = (sizeof(unsigned int) * 8 - ((unsigned int) -1 < 0)) * 643L / 2136;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = false;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr unsigned int epsilon() noexcept(true)
      {
        return 0;
      }
      static inline constexpr unsigned int round_error() noexcept(true)
      {
        return 0;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr unsigned int infinity() noexcept(true)
      {
        return static_cast<unsigned int>(0);
      }
      static inline constexpr unsigned int quiet_NaN() noexcept(true)
      {
        return static_cast<unsigned int>(0);
      }
      static inline constexpr unsigned int signaling_NaN() noexcept(true)
      {
        return static_cast<unsigned int>(0);
      }
      static inline constexpr unsigned int denorm_min() noexcept(true)
      {
        return static_cast<unsigned int>(0);
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = true;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<long int>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr long int min() noexcept(true)
      {
        return  -9223372036854775807L - 1;
      }
      static inline constexpr long int max() noexcept(true)
      {
        return 9223372036854775807L;
      }
      static inline constexpr long int lowest() noexcept(true)
      {
        return ::std::numeric_limits<long int>::min();
      }
      static constexpr const int digits = sizeof(long int) * 8 - ((long int) -1 < 0);
      static constexpr const int digits10 = (sizeof(long int) * 8 - ((long int) -1 < 0)) * 643L / 2136;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = true;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr long int epsilon() noexcept(true)
      {
        return 0;
      }
      static inline constexpr long int round_error() noexcept(true)
      {
        return 0;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr long int infinity() noexcept(true)
      {
        return static_cast<long int>(0);
      }
      static inline constexpr long int quiet_NaN() noexcept(true)
      {
        return static_cast<long int>(0);
      }
      static inline constexpr long int signaling_NaN() noexcept(true)
      {
        return static_cast<long int>(0);
      }
      static inline constexpr long int denorm_min() noexcept(true)
      {
        return static_cast<long int>(0);
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = false;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<unsigned long int>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr unsigned long int min() noexcept(true)
      {
        return 0;
      }
      static inline constexpr unsigned long int max() noexcept(true)
      {
        return 9223372036854775807L * 2LU + 1;
      }
      static inline constexpr unsigned long int lowest() noexcept(true)
      {
        return ::std::numeric_limits<unsigned long int>::min();
      }
      static constexpr const int digits = sizeof(unsigned long int) * 8 - ((unsigned long int) -1 < 0);
      static constexpr const int digits10 = (sizeof(unsigned long int) * 8 - ((unsigned long int) -1 < 0)) * 643L / 2136;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = false;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr unsigned long int epsilon() noexcept(true)
      {
        return 0;
      }
      static inline constexpr unsigned long int round_error() noexcept(true)
      {
        return 0;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr unsigned long int infinity() noexcept(true)
      {
        return static_cast<unsigned long int>(0);
      }
      static inline constexpr unsigned long int quiet_NaN() noexcept(true)
      {
        return static_cast<unsigned long int>(0);
      }
      static inline constexpr unsigned long int signaling_NaN() noexcept(true)
      {
        return static_cast<unsigned long int>(0);
      }
      static inline constexpr unsigned long int denorm_min() noexcept(true)
      {
        return static_cast<unsigned long int>(0);
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = true;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<long long int>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr long long int min() noexcept(true)
      {
        return  -9223372036854775807LL - 1;
      }
      static inline constexpr long long int max() noexcept(true)
      {
        return 9223372036854775807LL;
      }
      static inline constexpr long long int lowest() noexcept(true)
      {
        return ::std::numeric_limits<long long int>::min();
      }
      static constexpr const int digits = sizeof(long long int) * 8 - ((long long int) -1 < 0);
      static constexpr const int digits10 = (sizeof(long long int) * 8 - ((long long int) -1 < 0)) * 643L / 2136;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = true;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr long long int epsilon() noexcept(true)
      {
        return 0;
      }
      static inline constexpr long long int round_error() noexcept(true)
      {
        return 0;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr long long int infinity() noexcept(true)
      {
        return static_cast<long long int>(0);
      }
      static inline constexpr long long int quiet_NaN() noexcept(true)
      {
        return static_cast<long long int>(0);
      }
      static inline constexpr long long int signaling_NaN() noexcept(true)
      {
        return static_cast<long long int>(0);
      }
      static inline constexpr long long int denorm_min() noexcept(true)
      {
        return static_cast<long long int>(0);
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = false;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<unsigned long long int>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr unsigned long long int min() noexcept(true)
      {
        return 0;
      }
      static inline constexpr unsigned long long int max() noexcept(true)
      {
        return 9223372036854775807LL * 2LLU + 1;
      }
      static inline constexpr unsigned long long int lowest() noexcept(true)
      {
        return ::std::numeric_limits<unsigned long long int>::min();
      }
      static constexpr const int digits = sizeof(unsigned long long int) * 8 - ((unsigned long long int) -1 < 0);
      static constexpr const int digits10 = (sizeof(unsigned long long int) * 8 - ((unsigned long long int) -1 < 0)) * 643L / 2136;
      static constexpr const int max_digits10 = 0;
      static constexpr const bool is_signed = false;
      static constexpr const bool is_integer = true;
      static constexpr const bool is_exact = true;
      static constexpr const int radix = 2;
      static inline constexpr unsigned long long int epsilon() noexcept(true)
      {
        return 0;
      }
      static inline constexpr unsigned long long int round_error() noexcept(true)
      {
        return 0;
      }
      static constexpr const int min_exponent = 0;
      static constexpr const int min_exponent10 = 0;
      static constexpr const int max_exponent = 0;
      static constexpr const int max_exponent10 = 0;
      static constexpr const bool has_infinity = false;
      static constexpr const bool has_quiet_NaN = false;
      static constexpr const bool has_signaling_NaN = false;
      static constexpr const ::std::float_denorm_style has_denorm = ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr unsigned long long int infinity() noexcept(true)
      {
        return static_cast<unsigned long long int>(0);
      }
      static inline constexpr unsigned long long int quiet_NaN() noexcept(true)
      {
        return static_cast<unsigned long long int>(0);
      }
      static inline constexpr unsigned long long int signaling_NaN() noexcept(true)
      {
        return static_cast<unsigned long long int>(0);
      }
      static inline constexpr unsigned long long int denorm_min() noexcept(true)
      {
        return static_cast<unsigned long long int>(0);
      }
      static constexpr const bool is_iec559 = false;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = true;
      static constexpr const bool traps = true;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_toward_zero;
  };
  template <>
  struct  numeric_limits<float>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr float min() noexcept(true)
      {
        return 1.175494350822287507968737e-38f;
      }
      static inline constexpr float max() noexcept(true)
      {
        return 3.402823466385288598117042e+38f;
      }
      static inline constexpr float lowest() noexcept(true)
      {
        return  -3.402823466385288598117042e+38f;
      }
      static constexpr const int digits = 24;
      static constexpr const int digits10 = 6;
      static constexpr const int max_digits10 = 2 + 24 * 643L / 2136;
      static constexpr const bool is_signed = true;
      static constexpr const bool is_integer = false;
      static constexpr const bool is_exact = false;
      static constexpr const int radix = 2;
      static inline constexpr float epsilon() noexcept(true)
      {
        return 1.192092895507812500000000e-07f;
      }
      static inline constexpr float round_error() noexcept(true)
      {
        return 5.000000000000000000000000e-01f;
      }
      static constexpr const int min_exponent =  -125;
      static constexpr const int min_exponent10 =  -37;
      static constexpr const int max_exponent = 128;
      static constexpr const int max_exponent10 = 38;
      static constexpr const bool has_infinity = 1;
      static constexpr const bool has_quiet_NaN = 1;
      static constexpr const bool has_signaling_NaN = ::std::numeric_limits<float>::has_quiet_NaN;
      static constexpr const ::std::float_denorm_style has_denorm = (bool)1 ? ::std::denorm_present : ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr float infinity() noexcept(true)
      {
        return __builtin_huge_valf();
      }
      static inline constexpr float quiet_NaN() noexcept(true)
      {
        return __builtin_nanf("");
      }
      static inline constexpr float signaling_NaN() noexcept(true)
      {
        return __builtin_nansf("");
      }
      static inline constexpr float denorm_min() noexcept(true)
      {
        return 1.401298464324817070923730e-45f;
      }
      static constexpr const bool is_iec559 = (::std::numeric_limits<float>::has_infinity && ::std::numeric_limits<float>::has_quiet_NaN) && ::std::numeric_limits<float>::has_denorm == ::std::denorm_present;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = false;
      static constexpr const bool traps = false;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_to_nearest;
  };
  template <>
  struct  numeric_limits<double>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr double min() noexcept(true)
      {
        return (double)2.2250738585072013830902327173324040642192159804623318305533274169e-308L;
      }
      static inline constexpr double max() noexcept(true)
      {
        return (double)1.7976931348623157081452742373170435679807056752584499659891747680e+308L;
      }
      static inline constexpr double lowest() noexcept(true)
      {
        return  -((double)1.7976931348623157081452742373170435679807056752584499659891747680e+308L);
      }
      static constexpr const int digits = 53;
      static constexpr const int digits10 = 15;
      static constexpr const int max_digits10 = 2 + 53 * 643L / 2136;
      static constexpr const bool is_signed = true;
      static constexpr const bool is_integer = false;
      static constexpr const bool is_exact = false;
      static constexpr const int radix = 2;
      static inline constexpr double epsilon() noexcept(true)
      {
        return (double)2.2204460492503130808472633361816406250000000000000000000000000000e-16L;
      }
      static inline constexpr double round_error() noexcept(true)
      {
        return 5.00000000000000000000000000000000000000000000000000000e-01;
      }
      static constexpr const int min_exponent =  -1021;
      static constexpr const int min_exponent10 =  -307;
      static constexpr const int max_exponent = 1024;
      static constexpr const int max_exponent10 = 308;
      static constexpr const bool has_infinity = 1;
      static constexpr const bool has_quiet_NaN = 1;
      static constexpr const bool has_signaling_NaN = ::std::numeric_limits<double>::has_quiet_NaN;
      static constexpr const ::std::float_denorm_style has_denorm = (bool)1 ? ::std::denorm_present : ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr double infinity() noexcept(true)
      {
        return __builtin_huge_val();
      }
      static inline constexpr double quiet_NaN() noexcept(true)
      {
        return __builtin_nan("");
      }
      static inline constexpr double signaling_NaN() noexcept(true)
      {
        return __builtin_nans("");
      }
      static inline constexpr double denorm_min() noexcept(true)
      {
        return (double)4.9406564584124654417656879286822137236505980261432476442558568250e-324L;
      }
      static constexpr const bool is_iec559 = (::std::numeric_limits<double>::has_infinity && ::std::numeric_limits<double>::has_quiet_NaN) && ::std::numeric_limits<double>::has_denorm == ::std::denorm_present;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = false;
      static constexpr const bool traps = false;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_to_nearest;
  };
  template <>
  struct  numeric_limits<long double>
  {
      static constexpr const bool is_specialized = true;
      static inline constexpr long double min() noexcept(true)
      {
        return 3.3621031431120935062626778173217526025980793448464712401088272298e-4932L;
      }
      static inline constexpr long double max() noexcept(true)
      {
        return 1.1897314953572317650212638530309702051690633222946242004403237339e+4932L;
      }
      static inline constexpr long double lowest() noexcept(true)
      {
        return  -1.1897314953572317650212638530309702051690633222946242004403237339e+4932L;
      }
      static constexpr const int digits = 64;
      static constexpr const int digits10 = 18;
      static constexpr const int max_digits10 = 2 + 64 * 643L / 2136;
      static constexpr const bool is_signed = true;
      static constexpr const bool is_integer = false;
      static constexpr const bool is_exact = false;
      static constexpr const int radix = 2;
      static inline constexpr long double epsilon() noexcept(true)
      {
        return 1.0842021724855044340074528008699417114257812500000000000000000000e-19L;
      }
      static inline constexpr long double round_error() noexcept(true)
      {
        return 5.0000000000000000000000000000000000000000000000000000000000000000e-01L;
      }
      static constexpr const int min_exponent =  -16381;
      static constexpr const int min_exponent10 =  -4931;
      static constexpr const int max_exponent = 16384;
      static constexpr const int max_exponent10 = 4932;
      static constexpr const bool has_infinity = 1;
      static constexpr const bool has_quiet_NaN = 1;
      static constexpr const bool has_signaling_NaN = ::std::numeric_limits<long double>::has_quiet_NaN;
      static constexpr const ::std::float_denorm_style has_denorm = (bool)1 ? ::std::denorm_present : ::std::denorm_absent;
      static constexpr const bool has_denorm_loss = false;
      static inline constexpr long double infinity() noexcept(true)
      {
        return __builtin_huge_vall();
      }
      static inline constexpr long double quiet_NaN() noexcept(true)
      {
        return __builtin_nanl("");
      }
      static inline constexpr long double signaling_NaN() noexcept(true)
      {
        return __builtin_nansl("");
      }
      static inline constexpr long double denorm_min() noexcept(true)
      {
        return 3.6451995318824746025284059336194198163990508156935633437209804870e-4951L;
      }
      static constexpr const bool is_iec559 = (::std::numeric_limits<long double>::has_infinity && ::std::numeric_limits<long double>::has_quiet_NaN) && ::std::numeric_limits<long double>::has_denorm == ::std::denorm_present;
      static constexpr const bool is_bounded = true;
      static constexpr const bool is_modulo = false;
      static constexpr const bool traps = false;
      static constexpr const bool tinyness_before = false;
      static constexpr const ::std::float_round_style round_style = ::std::round_to_nearest;
  };
}
namespace boost {
  namespace io {
    class ios_flags_saver;
    class ios_precision_saver;
    class ios_width_saver;
    class ios_base_all_saver;
    template < typename Ch, typename Tr = ::std::char_traits<Ch> >
    class basic_ios_iostate_saver;
    template < typename Ch, typename Tr = ::std::char_traits<Ch> >
    class basic_ios_exception_saver;
    template < typename Ch, typename Tr = ::std::char_traits<Ch> >
    class basic_ios_tie_saver;
    template < typename Ch, typename Tr = ::std::char_traits<Ch> >
    class basic_ios_rdbuf_saver;
    template < typename Ch, typename Tr = ::std::char_traits<Ch> >
    class basic_ios_fill_saver;
    template < typename Ch, typename Tr = ::std::char_traits<Ch> >
    class basic_ios_locale_saver;
    template < typename Ch, typename Tr = ::std::char_traits<Ch> >
    class basic_ios_all_saver;
    typedef ::boost::io::basic_ios_iostate_saver<char> ios_iostate_saver;
    typedef ::boost::io::basic_ios_iostate_saver<wchar_t> wios_iostate_saver;
    typedef ::boost::io::basic_ios_exception_saver<char> ios_exception_saver;
    typedef ::boost::io::basic_ios_exception_saver<wchar_t> wios_exception_saver;
    typedef ::boost::io::basic_ios_tie_saver<char> ios_tie_saver;
    typedef ::boost::io::basic_ios_tie_saver<wchar_t> wios_tie_saver;
    typedef ::boost::io::basic_ios_rdbuf_saver<char> ios_rdbuf_saver;
    typedef ::boost::io::basic_ios_rdbuf_saver<wchar_t> wios_rdbuf_saver;
    typedef ::boost::io::basic_ios_fill_saver<char> ios_fill_saver;
    typedef ::boost::io::basic_ios_fill_saver<wchar_t> wios_fill_saver;
    typedef ::boost::io::basic_ios_locale_saver<char> ios_locale_saver;
    typedef ::boost::io::basic_ios_locale_saver<wchar_t> wios_locale_saver;
    typedef ::boost::io::basic_ios_all_saver<char> ios_all_saver;
    typedef ::boost::io::basic_ios_all_saver<wchar_t> wios_all_saver;
    class ios_iword_saver;
    class ios_pword_saver;
    class ios_all_word_saver;
    class  ios_flags_saver
    {
      public:
        typedef ::std::ios_base state_type;
        typedef ::std::ios_base::fmtflags aspect_type;
        inline explicit ios_flags_saver(::boost::io::ios_flags_saver::state_type &s)
          : s_save_(s), a_save_(s.::std::ios_base::flags())
        {
        }
        inline ios_flags_saver(::boost::io::ios_flags_saver::state_type &s, const ::boost::io::ios_flags_saver::aspect_type &a)
          : s_save_(s), a_save_(s.::std::ios_base::flags(a))
        {
        }
        inline ~ios_flags_saver()
        {
          (*this).::boost::io::ios_flags_saver::restore();
        }
        inline void restore()
        {
          (*this).s_save_.::std::ios_base::flags((*this).a_save_);
        }
      private:
        ::boost::io::ios_flags_saver::state_type &s_save_;
        const ::boost::io::ios_flags_saver::aspect_type a_save_;
        ::boost::io::ios_flags_saver &operator =(const ::boost::io::ios_flags_saver &);
      public:
    };
    class  ios_precision_saver
    {
      public:
        typedef ::std::ios_base state_type;
        typedef ::std::streamsize aspect_type;
        inline explicit ios_precision_saver(::boost::io::ios_precision_saver::state_type &s)
          : s_save_(s), a_save_(s.::std::ios_base::precision())
        {
        }
        inline ios_precision_saver(::boost::io::ios_precision_saver::state_type &s, const ::boost::io::ios_precision_saver::aspect_type &a)
          : s_save_(s), a_save_(s.::std::ios_base::precision(a))
        {
        }
        inline ~ios_precision_saver()
        {
          (*this).::boost::io::ios_precision_saver::restore();
        }
        inline void restore()
        {
          (*this).s_save_.::std::ios_base::precision((*this).a_save_);
        }
      private:
        ::boost::io::ios_precision_saver::state_type &s_save_;
        const ::boost::io::ios_precision_saver::aspect_type a_save_;
        ::boost::io::ios_precision_saver &operator =(const ::boost::io::ios_precision_saver &);
      public:
    };
    class  ios_width_saver
    {
      public:
        typedef ::std::ios_base state_type;
        typedef ::std::streamsize aspect_type;
        inline explicit ios_width_saver(::boost::io::ios_width_saver::state_type &s)
          : s_save_(s), a_save_(s.::std::ios_base::width())
        {
        }
        inline ios_width_saver(::boost::io::ios_width_saver::state_type &s, const ::boost::io::ios_width_saver::aspect_type &a)
          : s_save_(s), a_save_(s.::std::ios_base::width(a))
        {
        }
        inline ~ios_width_saver()
        {
          (*this).::boost::io::ios_width_saver::restore();
        }
        inline void restore()
        {
          (*this).s_save_.::std::ios_base::width((*this).a_save_);
        }
      private:
        ::boost::io::ios_width_saver::state_type &s_save_;
        const ::boost::io::ios_width_saver::aspect_type a_save_;
        ::boost::io::ios_width_saver &operator =(const ::boost::io::ios_width_saver &);
      public:
    };
    template < typename Ch, typename Tr >
    class  basic_ios_iostate_saver
    {
      public:
        typedef ::std::basic_ios<Ch, Tr> state_type;
        typedef ::std::ios_base::iostate aspect_type;
        inline explicit basic_ios_iostate_saver(typename ::boost::io::basic_ios_iostate_saver<Ch, Tr>::state_type &s)
          : s_save_(s), a_save_(s.rdstate())
        {
        }
        inline basic_ios_iostate_saver(typename ::boost::io::basic_ios_iostate_saver<Ch, Tr>::state_type &s, const typename ::boost::io::basic_ios_iostate_saver<Ch, Tr>::aspect_type &a)
          : s_save_(s), a_save_(s.rdstate())
        {
          s.clear(a);
        }
        inline ~basic_ios_iostate_saver()
        {
          this->restore();
        }
        inline void restore()
        {
          ::boost::io::basic_ios_iostate_saver<Ch, Tr>::s_save_.clear(::boost::io::basic_ios_iostate_saver<Ch, Tr>::a_save_);
        }
      private:
        typename ::boost::io::basic_ios_iostate_saver<Ch, Tr>::state_type &s_save_;
        const typename ::boost::io::basic_ios_iostate_saver<Ch, Tr>::aspect_type a_save_;
        ::boost::io::basic_ios_iostate_saver<Ch, Tr> &operator =(const ::boost::io::basic_ios_iostate_saver<Ch, Tr> &);
    };
    template < typename Ch, typename Tr >
    class  basic_ios_exception_saver
    {
      public:
        typedef ::std::basic_ios<Ch, Tr> state_type;
        typedef ::std::ios_base::iostate aspect_type;
        inline explicit basic_ios_exception_saver(typename ::boost::io::basic_ios_exception_saver<Ch, Tr>::state_type &s)
          : s_save_(s), a_save_(s.exceptions())
        {
        }
        inline basic_ios_exception_saver(typename ::boost::io::basic_ios_exception_saver<Ch, Tr>::state_type &s, const typename ::boost::io::basic_ios_exception_saver<Ch, Tr>::aspect_type &a)
          : s_save_(s), a_save_(s.exceptions())
        {
          s.exceptions(a);
        }
        inline ~basic_ios_exception_saver()
        {
          this->restore();
        }
        inline void restore()
        {
          ::boost::io::basic_ios_exception_saver<Ch, Tr>::s_save_.exceptions(::boost::io::basic_ios_exception_saver<Ch, Tr>::a_save_);
        }
      private:
        typename ::boost::io::basic_ios_exception_saver<Ch, Tr>::state_type &s_save_;
        const typename ::boost::io::basic_ios_exception_saver<Ch, Tr>::aspect_type a_save_;
        ::boost::io::basic_ios_exception_saver<Ch, Tr> &operator =(const ::boost::io::basic_ios_exception_saver<Ch, Tr> &);
    };
    template < typename Ch, typename Tr >
    class  basic_ios_tie_saver
    {
      public:
        typedef ::std::basic_ios<Ch, Tr> state_type;
        typedef ::std::basic_ostream<Ch, Tr> *aspect_type;
        inline explicit basic_ios_tie_saver(typename ::boost::io::basic_ios_tie_saver<Ch, Tr>::state_type &s)
          : s_save_(s), a_save_(s.tie())
        {
        }
        inline basic_ios_tie_saver(typename ::boost::io::basic_ios_tie_saver<Ch, Tr>::state_type &s, const typename ::boost::io::basic_ios_tie_saver<Ch, Tr>::aspect_type &a)
          : s_save_(s), a_save_(s.tie(a))
        {
        }
        inline ~basic_ios_tie_saver()
        {
          this->restore();
        }
        inline void restore()
        {
          ::boost::io::basic_ios_tie_saver<Ch, Tr>::s_save_.tie(::boost::io::basic_ios_tie_saver<Ch, Tr>::a_save_);
        }
      private:
        typename ::boost::io::basic_ios_tie_saver<Ch, Tr>::state_type &s_save_;
        const typename ::boost::io::basic_ios_tie_saver<Ch, Tr>::aspect_type a_save_;
        ::boost::io::basic_ios_tie_saver<Ch, Tr> &operator =(const ::boost::io::basic_ios_tie_saver<Ch, Tr> &);
    };
    template < typename Ch, typename Tr >
    class  basic_ios_rdbuf_saver
    {
      public:
        typedef ::std::basic_ios<Ch, Tr> state_type;
        typedef ::std::basic_streambuf<Ch, Tr> *aspect_type;
        inline explicit basic_ios_rdbuf_saver(typename ::boost::io::basic_ios_rdbuf_saver<Ch, Tr>::state_type &s)
          : s_save_(s), a_save_(s.rdbuf())
        {
        }
        inline basic_ios_rdbuf_saver(typename ::boost::io::basic_ios_rdbuf_saver<Ch, Tr>::state_type &s, const typename ::boost::io::basic_ios_rdbuf_saver<Ch, Tr>::aspect_type &a)
          : s_save_(s), a_save_(s.rdbuf(a))
        {
        }
        inline ~basic_ios_rdbuf_saver()
        {
          this->restore();
        }
        inline void restore()
        {
          ::boost::io::basic_ios_rdbuf_saver<Ch, Tr>::s_save_.rdbuf(::boost::io::basic_ios_rdbuf_saver<Ch, Tr>::a_save_);
        }
      private:
        typename ::boost::io::basic_ios_rdbuf_saver<Ch, Tr>::state_type &s_save_;
        const typename ::boost::io::basic_ios_rdbuf_saver<Ch, Tr>::aspect_type a_save_;
        ::boost::io::basic_ios_rdbuf_saver<Ch, Tr> &operator =(const ::boost::io::basic_ios_rdbuf_saver<Ch, Tr> &);
    };
    template < typename Ch, typename Tr >
    class  basic_ios_fill_saver
    {
      public:
        typedef ::std::basic_ios<Ch, Tr> state_type;
        typedef typename ::std::basic_ios<Ch, Tr>::char_type aspect_type;
        inline explicit basic_ios_fill_saver(typename ::boost::io::basic_ios_fill_saver<Ch, Tr>::state_type &s)
          : s_save_(s), a_save_(s.fill())
        {
        }
        inline basic_ios_fill_saver(typename ::boost::io::basic_ios_fill_saver<Ch, Tr>::state_type &s, const typename ::boost::io::basic_ios_fill_saver<Ch, Tr>::aspect_type &a)
          : s_save_(s), a_save_(s.fill(a))
        {
        }
        inline ~basic_ios_fill_saver()
        {
          this->restore();
        }
        inline void restore()
        {
          ::boost::io::basic_ios_fill_saver<Ch, Tr>::s_save_.fill(::boost::io::basic_ios_fill_saver<Ch, Tr>::a_save_);
        }
      private:
        typename ::boost::io::basic_ios_fill_saver<Ch, Tr>::state_type &s_save_;
        const typename ::boost::io::basic_ios_fill_saver<Ch, Tr>::aspect_type a_save_;
        ::boost::io::basic_ios_fill_saver<Ch, Tr> &operator =(const ::boost::io::basic_ios_fill_saver<Ch, Tr> &);
    };
    template < typename Ch, typename Tr >
    class  basic_ios_locale_saver
    {
      public:
        typedef ::std::basic_ios<Ch, Tr> state_type;
        typedef ::std::locale aspect_type;
        inline explicit basic_ios_locale_saver(typename ::boost::io::basic_ios_locale_saver<Ch, Tr>::state_type &s)
          : s_save_(s), a_save_(s.getloc())
        {
        }
        inline basic_ios_locale_saver(typename ::boost::io::basic_ios_locale_saver<Ch, Tr>::state_type &s, const typename ::boost::io::basic_ios_locale_saver<Ch, Tr>::aspect_type &a)
          : s_save_(s), a_save_(s.imbue(a))
        {
        }
        inline ~basic_ios_locale_saver()
        {
          this->restore();
        }
        inline void restore()
        {
          ::boost::io::basic_ios_locale_saver<Ch, Tr>::s_save_.imbue(::boost::io::basic_ios_locale_saver<Ch, Tr>::a_save_);
        }
      private:
        typename ::boost::io::basic_ios_locale_saver<Ch, Tr>::state_type &s_save_;
        const typename ::boost::io::basic_ios_locale_saver<Ch, Tr>::aspect_type a_save_;
        ::boost::io::basic_ios_locale_saver<Ch, Tr> &operator =(const ::boost::io::basic_ios_locale_saver<Ch, Tr> &);
    };
    class  ios_iword_saver
    {
      public:
        typedef ::std::ios_base state_type;
        typedef int index_type;
        typedef long int aspect_type;
        inline explicit ios_iword_saver(::boost::io::ios_iword_saver::state_type &s, ::boost::io::ios_iword_saver::index_type i)
          : s_save_(s), a_save_(s.::std::ios_base::iword(i)), i_save_(i)
        {
        }
        inline ios_iword_saver(::boost::io::ios_iword_saver::state_type &s, ::boost::io::ios_iword_saver::index_type i, const ::boost::io::ios_iword_saver::aspect_type &a)
          : s_save_(s), a_save_(s.::std::ios_base::iword(i)), i_save_(i)
        {
          s.::std::ios_base::iword(i) = a;
        }
        inline ~ios_iword_saver()
        {
          (*this).::boost::io::ios_iword_saver::restore();
        }
        inline void restore()
        {
          (*this).s_save_.::std::ios_base::iword((*this).i_save_) = (*this).a_save_;
        }
      private:
        ::boost::io::ios_iword_saver::state_type &s_save_;
        const ::boost::io::ios_iword_saver::aspect_type a_save_;
        const ::boost::io::ios_iword_saver::index_type i_save_;
        ::boost::io::ios_iword_saver &operator =(const ::boost::io::ios_iword_saver &);
      public:
    };
    class  ios_pword_saver
    {
      public:
        typedef ::std::ios_base state_type;
        typedef int index_type;
        typedef void *aspect_type;
        inline explicit ios_pword_saver(::boost::io::ios_pword_saver::state_type &s, ::boost::io::ios_pword_saver::index_type i)
          : s_save_(s), a_save_(s.::std::ios_base::pword(i)), i_save_(i)
        {
        }
        inline ios_pword_saver(::boost::io::ios_pword_saver::state_type &s, ::boost::io::ios_pword_saver::index_type i, const ::boost::io::ios_pword_saver::aspect_type &a)
          : s_save_(s), a_save_(s.::std::ios_base::pword(i)), i_save_(i)
        {
          s.::std::ios_base::pword(i) = a;
        }
        inline ~ios_pword_saver()
        {
          (*this).::boost::io::ios_pword_saver::restore();
        }
        inline void restore()
        {
          (*this).s_save_.::std::ios_base::pword((*this).i_save_) = (*this).a_save_;
        }
      private:
        ::boost::io::ios_pword_saver::state_type &s_save_;
        const ::boost::io::ios_pword_saver::aspect_type a_save_;
        const ::boost::io::ios_pword_saver::index_type i_save_;
        ::boost::io::ios_pword_saver operator =(const ::boost::io::ios_pword_saver &);
      public:
    };
    class  ios_base_all_saver
    {
      public:
        typedef ::std::ios_base state_type;
        inline explicit ios_base_all_saver(::boost::io::ios_base_all_saver::state_type &s)
          : s_save_(s), a1_save_(s.::std::ios_base::flags()), a2_save_(s.::std::ios_base::precision()), a3_save_(s.::std::ios_base::width())
        {
        }
        inline ~ios_base_all_saver()
        {
          (*this).::boost::io::ios_base_all_saver::restore();
        }
        inline void restore()
        {
          (*this).s_save_.::std::ios_base::width((*this).a3_save_);
          (*this).s_save_.::std::ios_base::precision((*this).a2_save_);
          (*this).s_save_.::std::ios_base::flags((*this).a1_save_);
        }
      private:
        ::boost::io::ios_base_all_saver::state_type &s_save_;
        const ::std::ios_base::fmtflags a1_save_;
        const ::std::streamsize a2_save_;
        const ::std::streamsize a3_save_;
        ::boost::io::ios_base_all_saver &operator =(const ::boost::io::ios_base_all_saver &);
      public:
    };
    template < typename Ch, typename Tr >
    class  basic_ios_all_saver
    {
      public:
        typedef ::std::basic_ios<Ch, Tr> state_type;
        inline explicit basic_ios_all_saver(typename ::boost::io::basic_ios_all_saver<Ch, Tr>::state_type &s)
          : s_save_(s), a1_save_(s.flags()), a2_save_(s.precision()), a3_save_(s.width()), a4_save_(s.rdstate()), a5_save_(s.exceptions()), a6_save_(s.tie()), a7_save_(s.rdbuf()), a8_save_(s.fill()), a9_save_(s.getloc())
        {
        }
        inline ~basic_ios_all_saver()
        {
          this->restore();
        }
        inline void restore()
        {
          ::boost::io::basic_ios_all_saver<Ch, Tr>::s_save_.imbue(::boost::io::basic_ios_all_saver<Ch, Tr>::a9_save_);
          ::boost::io::basic_ios_all_saver<Ch, Tr>::s_save_.fill(::boost::io::basic_ios_all_saver<Ch, Tr>::a8_save_);
          ::boost::io::basic_ios_all_saver<Ch, Tr>::s_save_.rdbuf(::boost::io::basic_ios_all_saver<Ch, Tr>::a7_save_);
          ::boost::io::basic_ios_all_saver<Ch, Tr>::s_save_.tie(::boost::io::basic_ios_all_saver<Ch, Tr>::a6_save_);
          ::boost::io::basic_ios_all_saver<Ch, Tr>::s_save_.exceptions(::boost::io::basic_ios_all_saver<Ch, Tr>::a5_save_);
          ::boost::io::basic_ios_all_saver<Ch, Tr>::s_save_.clear(::boost::io::basic_ios_all_saver<Ch, Tr>::a4_save_);
          ::boost::io::basic_ios_all_saver<Ch, Tr>::s_save_.width(::boost::io::basic_ios_all_saver<Ch, Tr>::a3_save_);
          ::boost::io::basic_ios_all_saver<Ch, Tr>::s_save_.precision(::boost::io::basic_ios_all_saver<Ch, Tr>::a2_save_);
          ::boost::io::basic_ios_all_saver<Ch, Tr>::s_save_.flags(::boost::io::basic_ios_all_saver<Ch, Tr>::a1_save_);
        }
      private:
        typename ::boost::io::basic_ios_all_saver<Ch, Tr>::state_type &s_save_;
        const typename ::std::basic_ios<Ch, Tr>::fmtflags a1_save_;
        const ::std::streamsize a2_save_;
        const ::std::streamsize a3_save_;
        const typename ::std::basic_ios<Ch, Tr>::iostate a4_save_;
        const typename ::std::basic_ios<Ch, Tr>::iostate a5_save_;
        ::std::basic_ostream<Ch, Tr> *const a6_save_;
        ::std::basic_streambuf<Ch, Tr> *const a7_save_;
        const typename ::std::basic_ios<Ch, Tr>::char_type a8_save_;
        const ::std::locale a9_save_;
        ::boost::io::basic_ios_all_saver<Ch, Tr> &operator =(const ::boost::io::basic_ios_all_saver<Ch, Tr> &);
    };
    class  ios_all_word_saver
    {
      public:
        typedef ::std::ios_base state_type;
        typedef int index_type;
        inline ios_all_word_saver(::boost::io::ios_all_word_saver::state_type &s, ::boost::io::ios_all_word_saver::index_type i)
          : s_save_(s), i_save_(i), a1_save_(s.::std::ios_base::iword(i)), a2_save_(s.::std::ios_base::pword(i))
        {
        }
        inline ~ios_all_word_saver()
        {
          (*this).::boost::io::ios_all_word_saver::restore();
        }
        inline void restore()
        {
          (*this).s_save_.::std::ios_base::pword((*this).i_save_) = (*this).a2_save_;
          (*this).s_save_.::std::ios_base::iword((*this).i_save_) = (*this).a1_save_;
        }
      private:
        ::boost::io::ios_all_word_saver::state_type &s_save_;
        const ::boost::io::ios_all_word_saver::index_type i_save_;
        const long int a1_save_;
        void *const a2_save_;
        ::boost::io::ios_all_word_saver &operator =(const ::boost::io::ios_all_word_saver &);
      public:
    };
  }
  template < typename T >
  inline void checked_delete(T *x);
  template < typename T >
  inline void checked_delete(T *x)
  {
    typedef char type_must_be_complete[sizeof(T) ? 1 :  -1];
    (void)sizeof(type_must_be_complete);
    delete x;
  }
  template < typename T >
  inline void checked_array_delete(T *x);
  template < typename T >
  inline void checked_array_delete(T *x)
  {
    typedef char type_must_be_complete[sizeof(T) ? 1 :  -1];
    (void)sizeof(type_must_be_complete);
    delete[] x;
  }
  template < typename T >
  struct  checked_deleter
  {
      typedef void result_type;
      typedef T *argument_type;
      inline void operator ()(T *x) const 
      {
        boost::checked_delete(x);
      }
  };
  template < typename T >
  struct  checked_array_deleter
  {
      typedef void result_type;
      typedef T *argument_type;
      inline void operator ()(T *x) const 
      {
        boost::checked_array_delete(x);
      }
  };
  namespace detail {
    typedef ::std::nullptr_t sp_nullptr_t;
  }
}
namespace std __attribute__((__visibility__("default"))) {
   template < typename _Tp >
  ::std::pair<_Tp *, long int> get_temporary_buffer(::std::ptrdiff_t __len) noexcept(true);
  template < typename _Tp >
  ::std::pair<_Tp *, long int> get_temporary_buffer(::std::ptrdiff_t __len) noexcept(true)
  {
    const ::std::ptrdiff_t __max = ::__gnu_cxx::__numeric_traits_integer<long int>::__max / sizeof(_Tp);
    if (__len > __max)
      {
        __len = __max;
      }
    while (__len > 0)
      {
        _Tp *__tmp = static_cast<_Tp *>(::operator new(__len * sizeof(_Tp), ::std::nothrow));
        if (__tmp != 0)
          {
            return ::std::pair<_Tp *, long int>(__tmp, __len);
          }
        __len /= 2;
      }
    return ::std::pair<_Tp *, long int>(static_cast<_Tp *>(0), 0);
  }
  template < typename _Tp >
  inline void return_temporary_buffer(_Tp *__p);
  template < typename _Tp >
  inline void return_temporary_buffer(_Tp *__p)
  {
    ::operator delete(__p, ::std::nothrow);
  }
  template < typename _ForwardIterator, typename _Tp >
  class  _Temporary_buffer
  {
    public:
      typedef _Tp value_type;
      typedef typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::value_type *pointer;
      typedef typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::pointer iterator;
      typedef ::std::ptrdiff_t size_type;
    protected:
      typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::size_type _M_original_len;
      typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::size_type _M_len;
      typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::pointer _M_buffer;
    public:
      inline typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::size_type size() const 
      {
        return ::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_len;
      }
      inline typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::size_type requested_size() const 
      {
        return ::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_original_len;
      }
      inline typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::iterator begin()
      {
        return ::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_buffer;
      }
      inline typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::iterator end()
      {
        return ::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_buffer + ::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_len;
      }
      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);
      inline ~_Temporary_buffer()
      {
        std::_Destroy(::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_buffer, ::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_buffer + ::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_len);
        std::return_temporary_buffer(::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_buffer);
      }
    private:
      _Temporary_buffer(const ::std::_Temporary_buffer<_ForwardIterator, _Tp> &);
      void operator =(const ::std::_Temporary_buffer<_ForwardIterator, _Tp> &);
  };
  template < bool __nontype_tpl_param_1_0__ >
  struct  __uninitialized_construct_buf_dispatch
  {
      template < typename _Pointer, typename _ForwardIterator >
      static inline void __ucr(_Pointer __first, _Pointer __last, _ForwardIterator __seed)
      {
        if (__first == __last)
          {
            return ;
          }
        _Pointer __cur = __first;
        try
        {
          std::_Construct(std::__addressof(*__first), std::move(*__seed));
          _Pointer __prev = __cur;
           ++__cur;
          for (; __cur != __last; ( ++__cur,  ++__prev))
            {
              std::_Construct(std::__addressof(*__cur), std::move(*__prev));
            }
          *__seed = std::move(*__prev);
        }
        catch (...)
        {
          std::_Destroy(__first, __cur);
          throw;
        }
      }
  };
  template <>
  struct  __uninitialized_construct_buf_dispatch<true>
  {
      template < typename _Pointer, typename _ForwardIterator >
      static inline void __ucr(_Pointer, _Pointer, _ForwardIterator)
      {
      }
  };
  template < typename _Pointer, typename _ForwardIterator >
  inline void __uninitialized_construct_buf(_Pointer __first, _Pointer __last, _ForwardIterator __seed);
  template < typename _Pointer, typename _ForwardIterator >
  inline void __uninitialized_construct_buf(_Pointer __first, _Pointer __last, _ForwardIterator __seed)
  {
    typedef typename ::std::iterator_traits<_Pointer>::value_type _ValueType;
    std::__uninitialized_construct_buf_dispatch<__has_trivial_constructor(_ValueType)>::__ucr(__first, __last, __seed);
  }
  template < typename _ForwardIterator, typename _Tp >
  _Temporary_buffer<_ForwardIterator, _Tp>::_Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)), _M_len(0), _M_buffer(0)
  {
    try
    {
      ::std::pair<typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::pointer, long int> __p(std::get_temporary_buffer<typename ::std::_Temporary_buffer<_ForwardIterator, _Tp>::value_type>(::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_original_len));
      ::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_buffer = __p.first;
      ::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_len = __p.second;
      if (::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_buffer)
        {
          std::__uninitialized_construct_buf(::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_buffer, ::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_buffer + ::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_len, __first);
        }
    }
    catch (...)
    {
      std::return_temporary_buffer(::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_buffer);
      ::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_buffer = 0;
      ::std::_Temporary_buffer<_ForwardIterator, _Tp>::_M_len = 0;
      throw;
    }
  }
  template < typename _OutputIterator, typename _Tp >
  class  raw_storage_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    protected:
      _OutputIterator _M_iter;
    public:
      inline explicit raw_storage_iterator(_OutputIterator __x)
        : _M_iter(__x)
      {
      }
      inline ::std::raw_storage_iterator<_OutputIterator, _Tp> &operator *()
      {
        return *this;
      }
      inline ::std::raw_storage_iterator<_OutputIterator, _Tp> &operator =(const _Tp &__element)
      {
        std::_Construct(std::__addressof(*::std::raw_storage_iterator<_OutputIterator, _Tp>::_M_iter), __element);
        return *this;
      }
      inline ::std::raw_storage_iterator<_OutputIterator, _Tp> &operator ++()
      {
         ++::std::raw_storage_iterator<_OutputIterator, _Tp>::_M_iter;
        return *this;
      }
      inline ::std::raw_storage_iterator<_OutputIterator, _Tp> operator ++(int)
      {
        ::std::raw_storage_iterator<_OutputIterator, _Tp> __tmp = *this;
         ++::std::raw_storage_iterator<_OutputIterator, _Tp>::_M_iter;
        return __tmp;
      }
  };
}
#pragma GCC visibility push(default)
namespace __cxxabiv1 {
  class __class_type_info;
}
namespace std __attribute__((__visibility__("default"))) {
  class  type_info
  {
    public:
      virtual ~type_info();
      inline const char *name() const  noexcept(true)
      {
        return (*this).__name[0] == '*' ? (*this).__name + 1 : (*this).__name;
      }
      inline bool before(const ::std::type_info &__arg) const  noexcept(true)
      {
        return (*this).__name[0] == '*' && __arg.__name[0] == '*' ? (*this).__name < __arg.__name : __builtin_strcmp((*this).__name, __arg.__name) < 0;
      }
      inline bool operator ==(const ::std::type_info &__arg) const  noexcept(true)
      {
        return (*this).__name == __arg.__name || ((*this).__name[0] != '*' && __builtin_strcmp((*this).__name, __arg.__name) == 0);
      }
      inline bool operator !=(const ::std::type_info &__arg) const  noexcept(true)
      {
        return !(*this).::std::type_info::operator ==(__arg);
      }
      inline ::std::size_t hash_code() const  noexcept(true)
      {
        return ::std::_Hash_bytes((*this).::std::type_info::name(), __builtin_strlen((*this).::std::type_info::name()), static_cast< ::std::size_t>(3339675911LU));
      }
      virtual bool __is_pointer_p() const ;
      virtual bool __is_function_p() const ;
      virtual bool __do_catch(const ::std::type_info *__thr_type, void **__thr_obj, unsigned int __outer) const ;
      virtual bool __do_upcast(const ::__cxxabiv1::__class_type_info *__target, void **__obj_ptr) const ;
    protected:
      const char *__name;
      inline explicit type_info(const char *__n)
        : __name(__n)
      {
      }
    private:
      ::std::type_info &operator =(const ::std::type_info &);
      type_info(const ::std::type_info &);
  };
  class  bad_cast : public ::std::exception
  {
    public:
      inline bad_cast() noexcept(true)
      {
      }
      virtual ~bad_cast() noexcept(true);
      virtual const char *what() const  noexcept(true);
  };
  class  bad_typeid : public ::std::exception
  {
    public:
      inline bad_typeid() noexcept(true)
      {
      }
      virtual ~bad_typeid() noexcept(true);
      virtual const char *what() const  noexcept(true);
  };
}
#pragma GCC visibility pop
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  enum _Lock_policy
  {
    _S_single = 0,
    _S_mutex = 1,
    _S_atomic = 2
  };
  static const ::__gnu_cxx::_Lock_policy __default_lock_policy(::__gnu_cxx::_S_atomic);
  class  __concurrence_lock_error : public ::std::exception
  {
    public:
      virtual inline const char *what() const  throw()
      {
        return "__gnu_cxx::__concurrence_lock_error";
      }
  };
  class  __concurrence_unlock_error : public ::std::exception
  {
    public:
      virtual inline const char *what() const  throw()
      {
        return "__gnu_cxx::__concurrence_unlock_error";
      }
  };
  class  __concurrence_broadcast_error : public ::std::exception
  {
    public:
      virtual inline const char *what() const  throw()
      {
        return "__gnu_cxx::__concurrence_broadcast_error";
      }
  };
  class  __concurrence_wait_error : public ::std::exception
  {
    public:
      virtual inline const char *what() const  throw()
      {
        return "__gnu_cxx::__concurrence_wait_error";
      }
  };
  inline void __throw_concurrence_lock_error()
  {
    throw ::__gnu_cxx::__concurrence_lock_error();
  }
  inline void __throw_concurrence_unlock_error()
  {
    throw ::__gnu_cxx::__concurrence_unlock_error();
  }
  inline void __throw_concurrence_broadcast_error()
  {
    throw ::__gnu_cxx::__concurrence_broadcast_error();
  }
  inline void __throw_concurrence_wait_error()
  {
    throw ::__gnu_cxx::__concurrence_wait_error();
  }
  class  __mutex
  {
      ::__gthread_mutex_t _M_mutex = { /* .::pthread_mutex_t::__data =  */ { /* .::pthread_mutex_t::__pthread_mutex_s::__lock =  */ 0,  /* .::pthread_mutex_t::__pthread_mutex_s::__count =  */ 0,  /* .::pthread_mutex_t::__pthread_mutex_s::__owner =  */ 0,  /* .::pthread_mutex_t::__pthread_mutex_s::__nusers =  */ 0,  /* .::pthread_mutex_t::__pthread_mutex_s::__kind =  */ 0,  /* .::pthread_mutex_t::__pthread_mutex_s::__spins =  */ 0,  /* .::pthread_mutex_t::__pthread_mutex_s::__elision =  */ 0,  /* .::pthread_mutex_t::__pthread_mutex_s::__list =  */ { /* .::__pthread_internal_list::__prev =  */ 0,  /* .::__pthread_internal_list::__next =  */ 0}}};
      __mutex(const ::__gnu_cxx::__mutex &);
      ::__gnu_cxx::__mutex &operator =(const ::__gnu_cxx::__mutex &);
    public:
      inline __mutex()
      {
      }
      inline void lock()
      {
        if (::__gthread_active_p())
          {
            if (::__gthread_mutex_lock(&(*this)._M_mutex) != 0)
              {
                ::__gnu_cxx::__throw_concurrence_lock_error();
              }
          }
      }
      inline void unlock()
      {
        if (::__gthread_active_p())
          {
            if (::__gthread_mutex_unlock(&(*this)._M_mutex) != 0)
              {
                ::__gnu_cxx::__throw_concurrence_unlock_error();
              }
          }
      }
      inline ::__gthread_mutex_t *gthread_mutex()
      {
        return &(*this)._M_mutex;
      }
  };
  class  __recursive_mutex
  {
      ::__gthread_recursive_mutex_t _M_mutex = { /* .::pthread_mutex_t::__data =  */ { /* .::pthread_mutex_t::__pthread_mutex_s::__lock =  */ 0,  /* .::pthread_mutex_t::__pthread_mutex_s::__count =  */ 0,  /* .::pthread_mutex_t::__pthread_mutex_s::__owner =  */ 0,  /* .::pthread_mutex_t::__pthread_mutex_s::__nusers =  */ 0,  /* .::pthread_mutex_t::__pthread_mutex_s::__kind =  */ ::PTHREAD_MUTEX_RECURSIVE_NP,  /* .::pthread_mutex_t::__pthread_mutex_s::__spins =  */ 0,  /* .::pthread_mutex_t::__pthread_mutex_s::__elision =  */ 0,  /* .::pthread_mutex_t::__pthread_mutex_s::__list =  */ { /* .::__pthread_internal_list::__prev =  */ 0,  /* .::__pthread_internal_list::__next =  */ 0}}};
      __recursive_mutex(const ::__gnu_cxx::__recursive_mutex &);
      ::__gnu_cxx::__recursive_mutex &operator =(const ::__gnu_cxx::__recursive_mutex &);
    public:
      inline __recursive_mutex()
      {
      }
      inline void lock()
      {
        if (::__gthread_active_p())
          {
            if (::__gthread_recursive_mutex_lock(&(*this)._M_mutex) != 0)
              {
                ::__gnu_cxx::__throw_concurrence_lock_error();
              }
          }
      }
      inline void unlock()
      {
        if (::__gthread_active_p())
          {
            if (::__gthread_recursive_mutex_unlock(&(*this)._M_mutex) != 0)
              {
                ::__gnu_cxx::__throw_concurrence_unlock_error();
              }
          }
      }
      inline ::__gthread_recursive_mutex_t *gthread_recursive_mutex()
      {
        return &(*this)._M_mutex;
      }
  };
  class  __scoped_lock
  {
    public:
      typedef ::__gnu_cxx::__mutex __mutex_type;
    private:
      ::__gnu_cxx::__scoped_lock::__mutex_type &_M_device;
      __scoped_lock(const ::__gnu_cxx::__scoped_lock &);
      ::__gnu_cxx::__scoped_lock &operator =(const ::__gnu_cxx::__scoped_lock &);
    public:
      inline explicit __scoped_lock(::__gnu_cxx::__scoped_lock::__mutex_type &__name)
        : _M_device(__name)
      {
        (*this)._M_device.::__gnu_cxx::__mutex::lock();
      }
      inline ~__scoped_lock() throw()
      {
        (*this)._M_device.::__gnu_cxx::__mutex::unlock();
      }
  };
  class  __cond
  {
      ::__gthread_cond_t _M_cond = { /* .::pthread_cond_t::__data =  */ { /* .::pthread_cond_t::mcc_struct_anon_31::__lock =  */ 0,  /* .::pthread_cond_t::mcc_struct_anon_31::__futex =  */ 0,  /* .::pthread_cond_t::mcc_struct_anon_31::__total_seq =  */ 0,  /* .::pthread_cond_t::mcc_struct_anon_31::__wakeup_seq =  */ 0,  /* .::pthread_cond_t::mcc_struct_anon_31::__woken_seq =  */ 0,  /* .::pthread_cond_t::mcc_struct_anon_31::__mutex =  */ (void *)0,  /* .::pthread_cond_t::mcc_struct_anon_31::__nwaiters =  */ 0,  /* .::pthread_cond_t::mcc_struct_anon_31::__broadcast_seq =  */ 0}};
      __cond(const ::__gnu_cxx::__cond &);
      ::__gnu_cxx::__cond &operator =(const ::__gnu_cxx::__cond &);
    public:
      inline __cond()
      {
      }
      inline void broadcast()
      {
        if (::__gthread_active_p())
          {
            if (::__gthread_cond_broadcast(&(*this)._M_cond) != 0)
              {
                ::__gnu_cxx::__throw_concurrence_broadcast_error();
              }
          }
      }
      inline void wait(::__gnu_cxx::__mutex *mutex)
      {
        {
          if (::__gthread_cond_wait(&(*this)._M_cond, (*mutex).::__gnu_cxx::__mutex::gthread_mutex()) != 0)
            {
              ::__gnu_cxx::__throw_concurrence_wait_error();
            }
        }
      }
      inline void wait_recursive(::__gnu_cxx::__recursive_mutex *mutex)
      {
        {
          if (::__gthread_cond_wait_recursive(&(*this)._M_cond, (*mutex).::__gnu_cxx::__recursive_mutex::gthread_recursive_mutex()) != 0)
            {
              ::__gnu_cxx::__throw_concurrence_wait_error();
            }
        }
      }
  };
}
namespace std __attribute__((__visibility__("default"))) {
  struct  allocator_arg_t
  {
  };
  constexpr const ::std::allocator_arg_t allocator_arg((::std::allocator_arg_t()));
  template < typename _Tp >
  class  __has_allocator_type_helper : ::std::__sfinae_types
  {
      template < typename _Up >
      struct  _Wrap_type
      {
      };
      template < typename _Up >
      static ::std::__sfinae_types::__one __test(typename ::std::__has_allocator_type_helper<_Tp>::template _Wrap_type<typename _Up::allocator_type> *);
      template < typename _Up >
      static ::std::__sfinae_types::__two __test(...);
    public:
      static constexpr const bool value = sizeof(__test<_Tp>(0)) == 1;
  };
  template < typename _Tp >
  struct  __has_allocator_type : ::std::integral_constant<bool, __has_allocator_type_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename _Tp, typename _Alloc, bool __nontype_tpl_param_1_2__ = __has_allocator_type<_Tp>::value >
  struct  __uses_allocator_helper : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp, typename _Alloc >
  struct  __uses_allocator_helper<_Tp, _Alloc, true> : ::std::integral_constant<bool, is_convertible<_Alloc, typename _Tp::allocator_type>::value>
  {
  };
  template < typename _Tp, typename _Alloc >
  struct  uses_allocator : ::std::integral_constant<bool, __uses_allocator_helper<_Tp, _Alloc>::value>
  {
  };
  template < typename _Tp, typename _Alloc, typename ..._Args >
  struct  __uses_allocator_arg : ::std::is_constructible<_Tp, _Alloc, _Args ...>
  {
      static_assert(uses_allocator<_Tp, _Alloc>::value, "uses allocator");
  };
  struct  __uses_alloc_base
  {
  };
  struct  __uses_alloc0 : ::std::__uses_alloc_base
  {
      struct  _Anything
      {
          inline _Anything(...)
          {
          }
      };
      ::std::__uses_alloc0::_Anything _M_a;
  };
  template < typename _Alloc >
  struct  __uses_alloc1 : ::std::__uses_alloc_base
  {
      const _Alloc *_M_a;
  };
  template < typename _Alloc >
  struct  __uses_alloc2 : ::std::__uses_alloc_base
  {
      const _Alloc *_M_a;
  };
  template < bool __nontype_tpl_param_1_0__, typename _Alloc, typename ..._Args >
  struct __uses_alloc;
  template < typename _Tp, typename _Alloc, typename ..._Args >
  struct  __uses_alloc<true, _Tp, _Alloc, _Args ...> : ::std::conditional<is_constructible<_Tp, ::std::allocator_arg_t, _Alloc, _Args ...>::value, ::std::__uses_alloc1<_Alloc>, ::std::__uses_alloc2<_Alloc> >::type
  {
  };
  template < typename _Tp, typename _Alloc, typename ..._Args >
  struct  __uses_alloc<false, _Tp, _Alloc, _Args ...> : ::std::__uses_alloc0
  {
  };
  template < typename _Tp, typename _Alloc, typename ..._Args >
  struct  __uses_alloc_impl : ::std::__uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args ...>
  {
  };
  template < typename _Tp, typename _Alloc, typename ..._Args >
  ::std::__uses_alloc_impl<_Tp, _Alloc, _Args ...> __use_alloc(const _Alloc &__a);
  template < typename _Tp, typename _Alloc, typename ..._Args >
  ::std::__uses_alloc_impl<_Tp, _Alloc, _Args ...> __use_alloc(const _Alloc &__a)
  {
    ::std::__uses_alloc_impl<_Tp, _Alloc, _Args ...> __ret;
    __ret._M_a = &__a;
    return __ret;
  }
  class  logic_error : public ::std::exception
  {
      ::std::string _M_msg;
    public:
      explicit logic_error(const ::std::string &__arg);
      virtual ~logic_error() noexcept(true);
      virtual const char *what() const  noexcept(true);
  };
  class  domain_error : public ::std::logic_error
  {
    public:
      explicit domain_error(const ::std::string &__arg);
      virtual ~domain_error() noexcept(true);
  };
  class  invalid_argument : public ::std::logic_error
  {
    public:
      explicit invalid_argument(const ::std::string &__arg);
      virtual ~invalid_argument() noexcept(true);
  };
  class  length_error : public ::std::logic_error
  {
    public:
      explicit length_error(const ::std::string &__arg);
      virtual ~length_error() noexcept(true);
  };
  class  out_of_range : public ::std::logic_error
  {
    public:
      explicit out_of_range(const ::std::string &__arg);
      virtual ~out_of_range() noexcept(true);
  };
  class  runtime_error : public ::std::exception
  {
      ::std::string _M_msg;
    public:
      explicit runtime_error(const ::std::string &__arg);
      virtual ~runtime_error() noexcept(true);
      virtual const char *what() const  noexcept(true);
  };
  class  range_error : public ::std::runtime_error
  {
    public:
      explicit range_error(const ::std::string &__arg);
      virtual ~range_error() noexcept(true);
  };
  class  overflow_error : public ::std::runtime_error
  {
    public:
      explicit overflow_error(const ::std::string &__arg);
      virtual ~overflow_error() noexcept(true);
  };
  class  underflow_error : public ::std::runtime_error
  {
    public:
      explicit underflow_error(const ::std::string &__arg);
      virtual ~underflow_error() noexcept(true);
  };
  template < typename _Tp, ::std::size_t _Nm >
  struct  __array_traits
  {
      typedef _Tp _Type[_Nm];
      static inline constexpr _Tp &_S_ref(const _Tp (&__t)[_Nm], ::std::size_t __n) noexcept(true)
      {
        return const_cast<_Tp &>(__t[__n]);
      }
  };
  template < typename _Tp >
  struct  __array_traits<_Tp, 0LU>
  {
      struct  _Type
      {
      };
      static inline constexpr _Tp &_S_ref(const typename ::std::__array_traits<_Tp, 0LU>::_Type &, ::std::size_t) noexcept(true)
      {
        return *static_cast<_Tp *>(nullptr);
      }
  };
  template < typename _Tp, ::std::size_t _Nm >
  struct  array
  {
      typedef _Tp value_type;
      typedef typename ::std::array<_Tp, _Nm>::value_type *pointer;
      typedef const typename ::std::array<_Tp, _Nm>::value_type *const_pointer;
      typedef typename ::std::array<_Tp, _Nm>::value_type &reference;
      typedef const typename ::std::array<_Tp, _Nm>::value_type &const_reference;
      typedef typename ::std::array<_Tp, _Nm>::value_type *iterator;
      typedef const typename ::std::array<_Tp, _Nm>::value_type *const_iterator;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef ::std::reverse_iterator<typename ::std::array<_Tp, _Nm>::iterator> reverse_iterator;
      typedef ::std::reverse_iterator<typename ::std::array<_Tp, _Nm>::const_iterator> const_reverse_iterator;
      typedef ::std::__array_traits<_Tp, _Nm> _AT_Type;
      typename ::std::__array_traits<_Tp, _Nm>::_Type _M_elems;
      inline void fill(const typename ::std::array<_Tp, _Nm>::value_type &__u)
      {
        std::fill_n((*this).begin(), (*this).size(), __u);
      }
      inline void swap(::std::array<_Tp, _Nm> &__other) noexcept(noexcept(swap(std::declval<_Tp &>(), std::declval<_Tp &>())))
      {
        std::swap_ranges((*this).begin(), (*this).end(), __other.begin());
      }
      inline typename ::std::array<_Tp, _Nm>::iterator begin() noexcept(true)
      {
        return ((typename ::std::array<_Tp, _Nm>::iterator((*this).data())));
      }
      inline typename ::std::array<_Tp, _Nm>::const_iterator begin() const  noexcept(true)
      {
        return ((typename ::std::array<_Tp, _Nm>::const_iterator((*this).data())));
      }
      inline typename ::std::array<_Tp, _Nm>::iterator end() noexcept(true)
      {
        return ((typename ::std::array<_Tp, _Nm>::iterator((*this).data() + _Nm)));
      }
      inline typename ::std::array<_Tp, _Nm>::const_iterator end() const  noexcept(true)
      {
        return ((typename ::std::array<_Tp, _Nm>::const_iterator((*this).data() + _Nm)));
      }
      inline typename ::std::array<_Tp, _Nm>::reverse_iterator rbegin() noexcept(true)
      {
        return ((typename ::std::array<_Tp, _Nm>::reverse_iterator((*this).end())));
      }
      inline typename ::std::array<_Tp, _Nm>::const_reverse_iterator rbegin() const  noexcept(true)
      {
        return ((typename ::std::array<_Tp, _Nm>::const_reverse_iterator((*this).end())));
      }
      inline typename ::std::array<_Tp, _Nm>::reverse_iterator rend() noexcept(true)
      {
        return ((typename ::std::array<_Tp, _Nm>::reverse_iterator((*this).begin())));
      }
      inline typename ::std::array<_Tp, _Nm>::const_reverse_iterator rend() const  noexcept(true)
      {
        return ((typename ::std::array<_Tp, _Nm>::const_reverse_iterator((*this).begin())));
      }
      inline typename ::std::array<_Tp, _Nm>::const_iterator cbegin() const  noexcept(true)
      {
        return ((typename ::std::array<_Tp, _Nm>::const_iterator((*this).data())));
      }
      inline typename ::std::array<_Tp, _Nm>::const_iterator cend() const  noexcept(true)
      {
        return ((typename ::std::array<_Tp, _Nm>::const_iterator((*this).data() + _Nm)));
      }
      inline typename ::std::array<_Tp, _Nm>::const_reverse_iterator crbegin() const  noexcept(true)
      {
        return ((typename ::std::array<_Tp, _Nm>::const_reverse_iterator((*this).end())));
      }
      inline typename ::std::array<_Tp, _Nm>::const_reverse_iterator crend() const  noexcept(true)
      {
        return ((typename ::std::array<_Tp, _Nm>::const_reverse_iterator((*this).begin())));
      }
      inline constexpr typename ::std::array<_Tp, _Nm>::size_type size() const  noexcept(true)
      {
        return _Nm;
      }
      inline constexpr typename ::std::array<_Tp, _Nm>::size_type max_size() const  noexcept(true)
      {
        return _Nm;
      }
      inline constexpr bool empty() const  noexcept(true)
      {
        return (*this).size() == 0;
      }
      inline typename ::std::array<_Tp, _Nm>::reference operator [](typename ::std::array<_Tp, _Nm>::size_type __n)
      {
        return _AT_Type::_S_ref(::std::array<_Tp, _Nm>::_M_elems, __n);
      }
      inline constexpr typename ::std::array<_Tp, _Nm>::const_reference operator [](typename ::std::array<_Tp, _Nm>::size_type __n) const  noexcept(true)
      {
        return _AT_Type::_S_ref(::std::array<_Tp, _Nm>::_M_elems, __n);
      }
      inline typename ::std::array<_Tp, _Nm>::reference at(typename ::std::array<_Tp, _Nm>::size_type __n)
      {
        if (__n >= _Nm)
          {
            std::__throw_out_of_range("array::at");
          }
        return _AT_Type::_S_ref(::std::array<_Tp, _Nm>::_M_elems, __n);
      }
      inline constexpr typename ::std::array<_Tp, _Nm>::const_reference at(typename ::std::array<_Tp, _Nm>::size_type __n) const 
      {
        return __n < _Nm ? _AT_Type::_S_ref(::std::array<_Tp, _Nm>::_M_elems, __n) : ((std::__throw_out_of_range("array::at"), _AT_Type::_S_ref(::std::array<_Tp, _Nm>::_M_elems, 0)));
      }
      inline typename ::std::array<_Tp, _Nm>::reference front()
      {
        return *(*this).begin();
      }
      inline constexpr typename ::std::array<_Tp, _Nm>::const_reference front() const 
      {
        return _AT_Type::_S_ref(::std::array<_Tp, _Nm>::_M_elems, 0);
      }
      inline typename ::std::array<_Tp, _Nm>::reference back()
      {
        return _Nm ? *((*this).end() - 1) : *(*this).end();
      }
      inline constexpr typename ::std::array<_Tp, _Nm>::const_reference back() const 
      {
        return _Nm ? _AT_Type::_S_ref(::std::array<_Tp, _Nm>::_M_elems, _Nm - 1) : _AT_Type::_S_ref(::std::array<_Tp, _Nm>::_M_elems, 0);
      }
      inline typename ::std::array<_Tp, _Nm>::pointer data() noexcept(true)
      {
        return std::__addressof(_AT_Type::_S_ref(::std::array<_Tp, _Nm>::_M_elems, 0));
      }
      inline typename ::std::array<_Tp, _Nm>::const_pointer data() const  noexcept(true)
      {
        return std::__addressof(_AT_Type::_S_ref(::std::array<_Tp, _Nm>::_M_elems, 0));
      }
  };
  template < typename _Tp, ::std::size_t _Nm >
  inline bool operator ==(const ::std::array<_Tp, _Nm> &__one, const ::std::array<_Tp, _Nm> &__two);
  template < typename _Tp, ::std::size_t _Nm >
  inline bool operator ==(const ::std::array<_Tp, _Nm> &__one, const ::std::array<_Tp, _Nm> &__two)
  {
    return std::equal(__one.begin(), __one.end(), __two.begin());
  }
  template < typename _Tp, ::std::size_t _Nm >
  inline bool operator !=(const ::std::array<_Tp, _Nm> &__one, const ::std::array<_Tp, _Nm> &__two);
  template < typename _Tp, ::std::size_t _Nm >
  inline bool operator !=(const ::std::array<_Tp, _Nm> &__one, const ::std::array<_Tp, _Nm> &__two)
  {
    return !(__one == __two);
  }
  template < typename _Tp, ::std::size_t _Nm >
  inline bool operator <(const ::std::array<_Tp, _Nm> &__a, const ::std::array<_Tp, _Nm> &__b);
  template < typename _Tp, ::std::size_t _Nm >
  inline bool operator <(const ::std::array<_Tp, _Nm> &__a, const ::std::array<_Tp, _Nm> &__b)
  {
    return std::lexicographical_compare(__a.begin(), __a.end(), __b.begin(), __b.end());
  }
  template < typename _Tp, ::std::size_t _Nm >
  inline bool operator >(const ::std::array<_Tp, _Nm> &__one, const ::std::array<_Tp, _Nm> &__two);
  template < typename _Tp, ::std::size_t _Nm >
  inline bool operator >(const ::std::array<_Tp, _Nm> &__one, const ::std::array<_Tp, _Nm> &__two)
  {
    return __two < __one;
  }
  template < typename _Tp, ::std::size_t _Nm >
  inline bool operator <=(const ::std::array<_Tp, _Nm> &__one, const ::std::array<_Tp, _Nm> &__two);
  template < typename _Tp, ::std::size_t _Nm >
  inline bool operator <=(const ::std::array<_Tp, _Nm> &__one, const ::std::array<_Tp, _Nm> &__two)
  {
    return !(__one > __two);
  }
  template < typename _Tp, ::std::size_t _Nm >
  inline bool operator >=(const ::std::array<_Tp, _Nm> &__one, const ::std::array<_Tp, _Nm> &__two);
  template < typename _Tp, ::std::size_t _Nm >
  inline bool operator >=(const ::std::array<_Tp, _Nm> &__one, const ::std::array<_Tp, _Nm> &__two)
  {
    return !(__one < __two);
  }
  template < typename _Tp, ::std::size_t _Nm >
  inline void swap(::std::array<_Tp, _Nm> &__one, ::std::array<_Tp, _Nm> &__two) noexcept(noexcept(__one.swap(__two)));
  template < typename _Tp, ::std::size_t _Nm >
  inline void swap(::std::array<_Tp, _Nm> &__one, ::std::array<_Tp, _Nm> &__two) noexcept(noexcept(__one.swap(__two)))
  {
    __one.swap(__two);
  }
  template < ::std::size_t _Int, typename _Tp, ::std::size_t _Nm >
  inline constexpr _Tp &get(::std::array<_Tp, _Nm> &__arr) noexcept(true);
  template < ::std::size_t _Int, typename _Tp, ::std::size_t _Nm >
  inline constexpr _Tp &get(::std::array<_Tp, _Nm> &__arr) noexcept(true)
  {
    static_assert(_Int < _Nm, "index is out of bounds");
    return std::__array_traits<_Tp, _Nm>::_S_ref(__arr._M_elems, _Int);
  }
  template < ::std::size_t _Int, typename _Tp, ::std::size_t _Nm >
  inline constexpr _Tp &&get(::std::array<_Tp, _Nm> &&__arr) noexcept(true);
  template < ::std::size_t _Int, typename _Tp, ::std::size_t _Nm >
  inline constexpr _Tp &&get(::std::array<_Tp, _Nm> &&__arr) noexcept(true)
  {
    static_assert(_Int < _Nm, "index is out of bounds");
    return std::move(get<_Int>(__arr));
  }
  template < ::std::size_t _Int, typename _Tp, ::std::size_t _Nm >
  inline constexpr const _Tp &get(const ::std::array<_Tp, _Nm> &__arr) noexcept(true);
  template < ::std::size_t _Int, typename _Tp, ::std::size_t _Nm >
  inline constexpr const _Tp &get(const ::std::array<_Tp, _Nm> &__arr) noexcept(true)
  {
    static_assert(_Int < _Nm, "index is out of bounds");
    return std::__array_traits<_Tp, _Nm>::_S_ref(__arr._M_elems, _Int);
  }
  template < typename _Tp >
  class tuple_size;
  template < typename _Tp, ::std::size_t _Nm >
  struct  tuple_size< ::std::array<_Tp, _Nm> > : ::std::integral_constant<unsigned long int, _Nm>
  {
  };
  template < ::std::size_t _Int, typename _Tp >
  class tuple_element;
  template < ::std::size_t _Int, typename _Tp, ::std::size_t _Nm >
  struct  tuple_element<_Int, ::std::array<_Tp, _Nm> >
  {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  __add_c_ref
  {
      typedef const _Tp &type;
  };
  template < typename _Tp >
  struct  __add_c_ref<_Tp &>
  {
      typedef _Tp &type;
  };
  template < typename _Tp >
  struct  __add_ref
  {
      typedef _Tp &type;
  };
  template < typename _Tp >
  struct  __add_ref<_Tp &>
  {
      typedef _Tp &type;
  };
  template < typename _Tp >
  struct  __add_r_ref
  {
      typedef _Tp &&type;
  };
  template < typename _Tp >
  struct  __add_r_ref<_Tp &>
  {
      typedef _Tp &type;
  };
  template < ::std::size_t _Idx, typename _Head, bool _IsEmptyNotFinal >
  struct _Head_base;
  template < ::std::size_t _Idx, typename _Head >
  struct  _Head_base<_Idx, _Head, true> : _Head
  {
      inline constexpr _Head_base()
        : _Head()
      {
      }
      inline constexpr _Head_base(const _Head &__h)
        : _Head(__h)
      {
      }
      inline constexpr _Head_base(const ::std::_Head_base<_Idx, _Head, true> &) = default ;
      inline constexpr _Head_base(::std::_Head_base<_Idx, _Head, true> &&) = default ;
      template < typename _UHead >
      inline constexpr _Head_base(_UHead &&__h)
        : _Head(std::forward<_UHead>(__h))
      {
      }
      inline _Head_base(::std::allocator_arg_t, ::std::__uses_alloc0)
        : _Head()
      {
      }
      template < typename _Alloc >
      inline _Head_base(::std::allocator_arg_t, ::std::__uses_alloc1<_Alloc> __a)
        : _Head(::std::allocator_arg, *__a._M_a)
      {
      }
      template < typename _Alloc >
      inline _Head_base(::std::allocator_arg_t, ::std::__uses_alloc2<_Alloc> __a)
        : _Head(*__a._M_a)
      {
      }
      template < typename _UHead >
      inline _Head_base(::std::__uses_alloc0, _UHead &&__uhead)
        : _Head(std::forward<_UHead>(__uhead))
      {
      }
      template < typename _Alloc, typename _UHead >
      inline _Head_base(::std::__uses_alloc1<_Alloc> __a, _UHead &&__uhead)
        : _Head(::std::allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
      {
      }
      template < typename _Alloc, typename _UHead >
      inline _Head_base(::std::__uses_alloc2<_Alloc> __a, _UHead &&__uhead)
        : _Head(std::forward<_UHead>(__uhead), *__a._M_a)
      {
      }
      static inline constexpr _Head &_M_head(::std::_Head_base<_Idx, _Head, true> &__b) noexcept(true)
      {
        return __b;
      }
      static inline constexpr const _Head &_M_head(const ::std::_Head_base<_Idx, _Head, true> &__b) noexcept(true)
      {
        return __b;
      }
  };
  template < ::std::size_t _Idx, typename _Head >
  struct  _Head_base<_Idx, _Head, false>
  {
      inline constexpr _Head_base()
        : _M_head_impl()
      {
      }
      inline constexpr _Head_base(const _Head &__h)
        : _M_head_impl(__h)
      {
      }
      inline constexpr _Head_base(const ::std::_Head_base<_Idx, _Head, false> &) = default ;
      inline constexpr _Head_base(::std::_Head_base<_Idx, _Head, false> &&) = default ;
      template < typename _UHead >
      inline constexpr _Head_base(_UHead &&__h)
        : _M_head_impl(std::forward<_UHead>(__h))
      {
      }
      inline _Head_base(::std::allocator_arg_t, ::std::__uses_alloc0)
        : _M_head_impl()
      {
      }
      template < typename _Alloc >
      inline _Head_base(::std::allocator_arg_t, ::std::__uses_alloc1<_Alloc> __a)
        : _M_head_impl(::std::allocator_arg, *__a._M_a)
      {
      }
      template < typename _Alloc >
      inline _Head_base(::std::allocator_arg_t, ::std::__uses_alloc2<_Alloc> __a)
        : _M_head_impl(*__a._M_a)
      {
      }
      template < typename _UHead >
      inline _Head_base(::std::__uses_alloc0, _UHead &&__uhead)
        : _M_head_impl(std::forward<_UHead>(__uhead))
      {
      }
      template < typename _Alloc, typename _UHead >
      inline _Head_base(::std::__uses_alloc1<_Alloc> __a, _UHead &&__uhead)
        : _M_head_impl(::std::allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
      {
      }
      template < typename _Alloc, typename _UHead >
      inline _Head_base(::std::__uses_alloc2<_Alloc> __a, _UHead &&__uhead)
        : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a)
      {
      }
      static inline constexpr _Head &_M_head(::std::_Head_base<_Idx, _Head, false> &__b) noexcept(true)
      {
        return __b._M_head_impl;
      }
      static inline constexpr const _Head &_M_head(const ::std::_Head_base<_Idx, _Head, false> &__b) noexcept(true)
      {
        return __b._M_head_impl;
      }
      _Head _M_head_impl;
  };
  template < ::std::size_t _Idx, typename ..._Elements >
  struct _Tuple_impl;
  template < ::std::size_t _Idx >
  struct  _Tuple_impl<_Idx>
  {
      _Tuple_impl() = default ;
      template < typename _Alloc >
      inline _Tuple_impl(::std::allocator_arg_t, const _Alloc &)
      {
      }
      template < typename _Alloc >
      inline _Tuple_impl(::std::allocator_arg_t, const _Alloc &, const ::std::_Tuple_impl<_Idx> &)
      {
      }
      template < typename _Alloc >
      inline _Tuple_impl(::std::allocator_arg_t, const _Alloc &, ::std::_Tuple_impl<_Idx> &&)
      {
      }
    protected:
      inline void _M_swap(::std::_Tuple_impl<_Idx> &) noexcept(true)
      {
      }
    template < ::std::size_t __nontype_tpl_param_2_0__, typename ...__type_tpl__param_2_1__ >
    friend class _Tuple_impl;
  };
  template < typename _Tp >
  struct  __is_empty_non_tuple : ::std::is_empty<_Tp>
  {
  };
  template < typename _El0, typename ..._El >
  struct  __is_empty_non_tuple< ::std::tuple<_El0, _El ...> > : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  using __empty_not_final = typename ::std::conditional<__is_final(_Tp), ::std::integral_constant<bool, false>, ::std::__is_empty_non_tuple<_Tp> >::type;
  template < ::std::size_t _Idx, typename _Head, typename ..._Tail >
  struct  _Tuple_impl<_Idx, _Head, _Tail ...> : ::std::_Tuple_impl<_Idx + 1, _Tail ...>, private ::std::_Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
  {
      typedef ::std::_Tuple_impl<_Idx + 1, _Tail ...> _Inherited;
      typedef ::std::_Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;
      static inline constexpr _Head &_M_head(::std::_Tuple_impl<_Idx, _Head, _Tail ...> &__t) noexcept(true)
      {
        return _Base::_M_head(__t);
      }
      static inline constexpr const _Head &_M_head(const ::std::_Tuple_impl<_Idx, _Head, _Tail ...> &__t) noexcept(true)
      {
        return _Base::_M_head(__t);
      }
      static inline constexpr typename ::std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited &_M_tail(::std::_Tuple_impl<_Idx, _Head, _Tail ...> &__t) noexcept(true)
      {
        return __t;
      }
      static inline constexpr const typename ::std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited &_M_tail(const ::std::_Tuple_impl<_Idx, _Head, _Tail ...> &__t) noexcept(true)
      {
        return __t;
      }
      inline constexpr _Tuple_impl()
        : _Inherited(), _Base()
      {
      }
      inline constexpr explicit _Tuple_impl(const _Head &__head, const _Tail &...__tail)
        : _Inherited(__tail ...), _Base(__head)
      {
      }
      template < typename _UHead, typename ..._UTail, typename __type_tpl__param_2_2__ = typename ::std::enable_if<(sizeof...(_Tail)) == (sizeof...(_UTail))>::type >
      inline constexpr explicit _Tuple_impl(_UHead &&__head, _UTail &&...__tail)
        : _Inherited(std::forward<_UTail>(__tail) ...), _Base(std::forward<_UHead>(__head))
      {
      }
      inline constexpr _Tuple_impl(const ::std::_Tuple_impl<_Idx, _Head, _Tail ...> &) = default ;
      inline constexpr _Tuple_impl(::std::_Tuple_impl<_Idx, _Head, _Tail ...> &&__in) noexcept(__and_< ::std::is_nothrow_move_constructible<_Head>, ::std::is_nothrow_move_constructible<typename ::std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited> >::value)
        : _Inherited(std::move(_M_tail(__in))), _Base(std::forward<_Head>(_M_head(__in)))
      {
      }
      template < typename ..._UElements >
      inline constexpr _Tuple_impl(const ::std::_Tuple_impl<_Idx, _UElements ...> &__in)
        : _Inherited(_Tuple_impl<_Idx, _UElements ...>::_M_tail(__in)), _Base(_Tuple_impl<_Idx, _UElements ...>::_M_head(__in))
      {
      }
      template < typename _UHead, typename ..._UTails >
      inline constexpr _Tuple_impl(::std::_Tuple_impl<_Idx, _UHead, _UTails ...> &&__in)
        : _Inherited(std::move(_Tuple_impl<_Idx, _UHead, _UTails ...>::_M_tail(__in))), _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead, _UTails ...>::_M_head(__in)))
      {
      }
      template < typename _Alloc >
      inline _Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a)
        : _Inherited(__tag, __a), _Base(__tag, __use_alloc<_Head>(__a))
      {
      }
      template < typename _Alloc >
      inline _Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, const _Head &__head, const _Tail &...__tail)
        : _Inherited(__tag, __a, __tail ...), _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head)
      {
      }
      template < typename _Alloc, typename _UHead, typename ..._UTail, typename __type_tpl__param_2_3__ = typename ::std::enable_if<(sizeof...(_Tail)) == (sizeof...(_UTail))>::type >
      inline _Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, _UHead &&__head, _UTail &&...__tail)
        : _Inherited(__tag, __a, std::forward<_UTail>(__tail) ...), _Base(__use_alloc<_Head, _Alloc, _UHead>(__a), std::forward<_UHead>(__head))
      {
      }
      template < typename _Alloc >
      inline _Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, const ::std::_Tuple_impl<_Idx, _Head, _Tail ...> &__in)
        : _Inherited(__tag, __a, _M_tail(__in)), _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in))
      {
      }
      template < typename _Alloc >
      inline _Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, ::std::_Tuple_impl<_Idx, _Head, _Tail ...> &&__in)
        : _Inherited(__tag, __a, std::move(_M_tail(__in))), _Base(__use_alloc<_Head, _Alloc, _Head>(__a), std::forward<_Head>(_M_head(__in)))
      {
      }
      template < typename _Alloc, typename ..._UElements >
      inline _Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, const ::std::_Tuple_impl<_Idx, _UElements ...> &__in)
        : _Inherited(__tag, __a, _Tuple_impl<_Idx, _UElements ...>::_M_tail(__in)), _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _Tuple_impl<_Idx, _UElements ...>::_M_head(__in))
      {
      }
      template < typename _Alloc, typename _UHead, typename ..._UTails >
      inline _Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, ::std::_Tuple_impl<_Idx, _UHead, _UTails ...> &&__in)
        : _Inherited(__tag, __a, std::move(_Tuple_impl<_Idx, _UHead, _UTails ...>::_M_tail(__in))), _Base(__use_alloc<_Head, _Alloc, _UHead>(__a), std::forward<_UHead>(_Tuple_impl<_Idx, _UHead, _UTails ...>::_M_head(__in)))
      {
      }
      inline ::std::_Tuple_impl<_Idx, _Head, _Tail ...> &operator =(const ::std::_Tuple_impl<_Idx, _Head, _Tail ...> &__in)
      {
        _M_head(*this) = _M_head(__in);
        _M_tail(*this) = _M_tail(__in);
        return *this;
      }
      inline ::std::_Tuple_impl<_Idx, _Head, _Tail ...> &operator =(::std::_Tuple_impl<_Idx, _Head, _Tail ...> &&__in) noexcept(__and_< ::std::is_nothrow_move_assignable<_Head>, ::std::is_nothrow_move_assignable<typename ::std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited> >::value)
      {
        _M_head(*this) = std::forward<_Head>(_M_head(__in));
        _M_tail(*this) = std::move(_M_tail(__in));
        return *this;
      }
      template < typename ..._UElements >
      inline ::std::_Tuple_impl<_Idx, _Head, _Tail ...> &operator =(const ::std::_Tuple_impl<_Idx, _UElements ...> &__in)
      {
        _M_head(*this) = _Tuple_impl<_Idx, _UElements ...>::_M_head(__in);
        _M_tail(*this) = _Tuple_impl<_Idx, _UElements ...>::_M_tail(__in);
        return *this;
      }
      template < typename _UHead, typename ..._UTails >
      inline ::std::_Tuple_impl<_Idx, _Head, _Tail ...> &operator =(::std::_Tuple_impl<_Idx, _UHead, _UTails ...> &&__in)
      {
        _M_head(*this) = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead, _UTails ...>::_M_head(__in));
        _M_tail(*this) = std::move(_Tuple_impl<_Idx, _UHead, _UTails ...>::_M_tail(__in));
        return *this;
      }
    protected:
      inline void _M_swap(::std::_Tuple_impl<_Idx, _Head, _Tail ...> &__in) noexcept((noexcept(swap(std::declval<_Head &>(), std::declval<_Head &>()))) && (noexcept(_M_tail(__in)._M_swap(_M_tail(__in)))))
      {
        using ::std::swap;
        swap(_M_head(*this), _M_head(__in));
        _Inherited::_M_swap(_M_tail(__in));
      }
    template < ::std::size_t __nontype_tpl_param_2_0__, typename ...__type_tpl__param_2_1__ >
    friend class _Tuple_impl;
  };
  template < typename ..._Elements >
  class  tuple : public ::std::_Tuple_impl<0, _Elements ...>
  {
      typedef ::std::_Tuple_impl<0, _Elements ...> _Inherited;
    public:
      inline constexpr tuple()
        : _Inherited()
      {
      }
      inline constexpr explicit tuple(const _Elements &...__elements)
        : _Inherited(__elements ...)
      {
      }
      template < typename ..._UElements, typename __type_tpl__param_2_1__ = typename ::std::enable_if<__and_< ::std::is_convertible<_UElements, _Elements> ...>::value>::type >
      inline constexpr explicit tuple(_UElements &&...__elements)
        : _Inherited(std::forward<_UElements>(__elements) ...)
      {
      }
      inline constexpr tuple(const ::std::tuple<_Elements ...> &) = default ;
      inline constexpr tuple(::std::tuple<_Elements ...> &&) = default ;
      template < typename ..._UElements, typename __type_tpl__param_2_1__ = typename ::std::enable_if<__and_< ::std::is_convertible<const _UElements &, _Elements> ...>::value>::type >
      inline constexpr tuple(const ::std::tuple<_UElements ...> &__in)
        : _Inherited(static_cast<const ::std::_Tuple_impl<0, _UElements ...> &>(__in))
      {
      }
      template < typename ..._UElements, typename __type_tpl__param_2_1__ = typename ::std::enable_if<__and_< ::std::is_convertible<_UElements, _Elements> ...>::value>::type >
      inline constexpr tuple(::std::tuple<_UElements ...> &&__in)
        : _Inherited(static_cast< ::std::_Tuple_impl<0, _UElements ...> &&>(__in))
      {
      }
      template < typename _Alloc >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a)
        : _Inherited(__tag, __a)
      {
      }
      template < typename _Alloc >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a, const _Elements &...__elements)
        : _Inherited(__tag, __a, __elements ...)
      {
      }
      template < typename _Alloc, typename ..._UElements, typename __type_tpl__param_2_2__ = typename ::std::enable_if<(sizeof...(_UElements)) == (sizeof...(_Elements))>::type >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a, _UElements &&...__elements)
        : _Inherited(__tag, __a, std::forward<_UElements>(__elements) ...)
      {
      }
      template < typename _Alloc >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a, const ::std::tuple<_Elements ...> &__in)
        : _Inherited(__tag, __a, static_cast<const typename ::std::tuple<_Elements ...>::_Inherited &>(__in))
      {
      }
      template < typename _Alloc >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a, ::std::tuple<_Elements ...> &&__in)
        : _Inherited(__tag, __a, static_cast<typename ::std::tuple<_Elements ...>::_Inherited &&>(__in))
      {
      }
      template < typename _Alloc, typename ..._UElements, typename __type_tpl__param_2_2__ = typename ::std::enable_if<(sizeof...(_UElements)) == (sizeof...(_Elements))>::type >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a, const ::std::tuple<_UElements ...> &__in)
        : _Inherited(__tag, __a, static_cast<const ::std::_Tuple_impl<0, _UElements ...> &>(__in))
      {
      }
      template < typename _Alloc, typename ..._UElements, typename __type_tpl__param_2_2__ = typename ::std::enable_if<(sizeof...(_UElements)) == (sizeof...(_Elements))>::type >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a, ::std::tuple<_UElements ...> &&__in)
        : _Inherited(__tag, __a, static_cast< ::std::_Tuple_impl<0, _UElements ...> &&>(__in))
      {
      }
      inline ::std::tuple<_Elements ...> &operator =(const ::std::tuple<_Elements ...> &__in)
      {
        static_cast<typename ::std::tuple<_Elements ...>::_Inherited &>(*this) = __in;
        return *this;
      }
      inline ::std::tuple<_Elements ...> &operator =(::std::tuple<_Elements ...> &&__in) noexcept(is_nothrow_move_assignable<typename ::std::tuple<_Elements ...>::_Inherited>::value)
      {
        static_cast<typename ::std::tuple<_Elements ...>::_Inherited &>(*this) = std::move(__in);
        return *this;
      }
      template < typename ..._UElements, typename __type_tpl__param_2_1__ = typename ::std::enable_if<(sizeof...(_UElements)) == (sizeof...(_Elements))>::type >
      inline ::std::tuple<_Elements ...> &operator =(const ::std::tuple<_UElements ...> &__in)
      {
        static_cast<typename ::std::tuple<_Elements ...>::_Inherited &>(*this) = __in;
        return *this;
      }
      template < typename ..._UElements, typename __type_tpl__param_2_1__ = typename ::std::enable_if<(sizeof...(_UElements)) == (sizeof...(_Elements))>::type >
      inline ::std::tuple<_Elements ...> &operator =(::std::tuple<_UElements ...> &&__in)
      {
        static_cast<typename ::std::tuple<_Elements ...>::_Inherited &>(*this) = std::move(__in);
        return *this;
      }
      inline void swap(::std::tuple<_Elements ...> &__in) noexcept(noexcept(__in._M_swap(__in)))
      {
        _Inherited::_M_swap(__in);
      }
  };
  template <>
  class  tuple<>
  {
    public:
      inline void swap(::std::tuple<> &) noexcept(true)
      {
      }
  };
  template < typename _T1, typename _T2 >
  class  tuple<_T1, _T2> : public ::std::_Tuple_impl<0LU, _T1, _T2>
  {
      typedef ::std::_Tuple_impl<0LU, _T1, _T2> _Inherited;
    public:
      inline constexpr tuple()
        : _Inherited()
      {
      }
      inline constexpr explicit tuple(const _T1 &__a1, const _T2 &__a2)
        : _Inherited(__a1, __a2)
      {
      }
      template < typename _U1, typename _U2, typename __type_tpl__param_2_2__ = typename ::std::enable_if<__and_< ::std::is_convertible<_U1, _T1>, ::std::is_convertible<_U2, _T2> >::value>::type >
      inline constexpr explicit tuple(_U1 &&__a1, _U2 &&__a2)
        : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2))
      {
      }
      inline constexpr tuple(const ::std::tuple<_T1, _T2> &) = default ;
      inline constexpr tuple(::std::tuple<_T1, _T2> &&) = default ;
      template < typename _U1, typename _U2, typename __type_tpl__param_2_2__ = typename ::std::enable_if<__and_< ::std::is_convertible<const _U1 &, _T1>, ::std::is_convertible<const _U2 &, _T2> >::value>::type >
      inline constexpr tuple(const ::std::tuple<_U1, _U2> &__in)
        : _Inherited(static_cast<const ::std::_Tuple_impl<0LU, _U1, _U2> &>(__in))
      {
      }
      template < typename _U1, typename _U2, typename __type_tpl__param_2_2__ = typename ::std::enable_if<__and_< ::std::is_convertible<_U1, _T1>, ::std::is_convertible<_U2, _T2> >::value>::type >
      inline constexpr tuple(::std::tuple<_U1, _U2> &&__in)
        : _Inherited(static_cast< ::std::_Tuple_impl<0LU, _U1, _U2> &&>(__in))
      {
      }
      template < typename _U1, typename _U2, typename __type_tpl__param_2_2__ = typename ::std::enable_if<__and_< ::std::is_convertible<const _U1 &, _T1>, ::std::is_convertible<const _U2 &, _T2> >::value>::type >
      inline constexpr tuple(const ::std::pair<_U1, _U2> &__in)
        : _Inherited(__in.first, __in.second)
      {
      }
      template < typename _U1, typename _U2, typename __type_tpl__param_2_2__ = typename ::std::enable_if<__and_< ::std::is_convertible<_U1, _T1>, ::std::is_convertible<_U2, _T2> >::value>::type >
      inline constexpr tuple(::std::pair<_U1, _U2> &&__in)
        : _Inherited(std::forward<_U1>(__in.first), std::forward<_U2>(__in.second))
      {
      }
      template < typename _Alloc >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a)
        : _Inherited(__tag, __a)
      {
      }
      template < typename _Alloc >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a, const _T1 &__a1, const _T2 &__a2)
        : _Inherited(__tag, __a, __a1, __a2)
      {
      }
      template < typename _Alloc, typename _U1, typename _U2 >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a, _U1 &&__a1, _U2 &&__a2)
        : _Inherited(__tag, __a, std::forward<_U1>(__a1), std::forward<_U2>(__a2))
      {
      }
      template < typename _Alloc >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a, const ::std::tuple<_T1, _T2> &__in)
        : _Inherited(__tag, __a, static_cast<const typename ::std::tuple<_T1, _T2>::_Inherited &>(__in))
      {
      }
      template < typename _Alloc >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a, ::std::tuple<_T1, _T2> &&__in)
        : _Inherited(__tag, __a, static_cast<typename ::std::tuple<_T1, _T2>::_Inherited &&>(__in))
      {
      }
      template < typename _Alloc, typename _U1, typename _U2 >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a, const ::std::tuple<_U1, _U2> &__in)
        : _Inherited(__tag, __a, static_cast<const ::std::_Tuple_impl<0LU, _U1, _U2> &>(__in))
      {
      }
      template < typename _Alloc, typename _U1, typename _U2 >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a, ::std::tuple<_U1, _U2> &&__in)
        : _Inherited(__tag, __a, static_cast< ::std::_Tuple_impl<0LU, _U1, _U2> &&>(__in))
      {
      }
      template < typename _Alloc, typename _U1, typename _U2 >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a, const ::std::pair<_U1, _U2> &__in)
        : _Inherited(__tag, __a, __in.first, __in.second)
      {
      }
      template < typename _Alloc, typename _U1, typename _U2 >
      inline tuple(::std::allocator_arg_t __tag, const _Alloc &__a, ::std::pair<_U1, _U2> &&__in)
        : _Inherited(__tag, __a, std::forward<_U1>(__in.first), std::forward<_U2>(__in.second))
      {
      }
      inline ::std::tuple<_T1, _T2> &operator =(const ::std::tuple<_T1, _T2> &__in)
      {
        static_cast<typename ::std::tuple<_T1, _T2>::_Inherited &>(*this) = __in;
        return *this;
      }
      inline ::std::tuple<_T1, _T2> &operator =(::std::tuple<_T1, _T2> &&__in) noexcept(is_nothrow_move_assignable<typename ::std::tuple<_T1, _T2>::_Inherited>::value)
      {
        static_cast<typename ::std::tuple<_T1, _T2>::_Inherited &>(*this) = std::move(__in);
        return *this;
      }
      template < typename _U1, typename _U2 >
      inline ::std::tuple<_T1, _T2> &operator =(const ::std::tuple<_U1, _U2> &__in)
      {
        static_cast<typename ::std::tuple<_T1, _T2>::_Inherited &>(*this) = __in;
        return *this;
      }
      template < typename _U1, typename _U2 >
      inline ::std::tuple<_T1, _T2> &operator =(::std::tuple<_U1, _U2> &&__in)
      {
        static_cast<typename ::std::tuple<_T1, _T2>::_Inherited &>(*this) = std::move(__in);
        return *this;
      }
      template < typename _U1, typename _U2 >
      inline ::std::tuple<_T1, _T2> &operator =(const ::std::pair<_U1, _U2> &__in)
      {
        this->_M_head(*this) = __in.first;
        this->_M_tail(*this)._M_head(*this) = __in.second;
        return *this;
      }
      template < typename _U1, typename _U2 >
      inline ::std::tuple<_T1, _T2> &operator =(::std::pair<_U1, _U2> &&__in)
      {
        this->_M_head(*this) = std::forward<_U1>(__in.first);
        this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
        return *this;
      }
      inline void swap(::std::tuple<_T1, _T2> &__in) noexcept(noexcept(__in._M_swap(__in)))
      {
        _Inherited::_M_swap(__in);
      }
  };
  template < ::std::size_t __i, typename _Tp >
  class tuple_element;
  template < ::std::size_t __i, typename _Head, typename ..._Tail >
  struct  tuple_element<__i, ::std::tuple<_Head, _Tail ...> > : ::std::tuple_element<__i - 1, ::std::tuple<_Tail ...> >
  {
  };
  template < typename _Head, typename ..._Tail >
  struct  tuple_element<0LU, ::std::tuple<_Head, _Tail ...> >
  {
      typedef _Head type;
  };
  template < ::std::size_t __i, typename _Tp >
  struct  tuple_element<__i, const _Tp>
  {
      typedef typename ::std::add_const<typename ::std::tuple_element<__i, _Tp>::type>::type type;
  };
  template < ::std::size_t __i, typename _Tp >
  struct  tuple_element<__i, volatile _Tp>
  {
      typedef typename ::std::add_volatile<typename ::std::tuple_element<__i, _Tp>::type>::type type;
  };
  template < ::std::size_t __i, typename _Tp >
  struct  tuple_element<__i, const volatile _Tp>
  {
      typedef typename ::std::add_cv<typename ::std::tuple_element<__i, _Tp>::type>::type type;
  };
  template < typename _Tp >
  class tuple_size;
  template < typename _Tp >
  struct  tuple_size<const _Tp> : ::std::integral_constant<typename ::std::remove_cv<decltype(tuple_size<_Tp>::value)>::type, tuple_size<_Tp>::value>
  {
  };
  template < typename _Tp >
  struct  tuple_size<volatile _Tp> : ::std::integral_constant<typename ::std::remove_cv<decltype(tuple_size<_Tp>::value)>::type, tuple_size<_Tp>::value>
  {
  };
  template < typename _Tp >
  struct  tuple_size<const volatile _Tp> : ::std::integral_constant<typename ::std::remove_cv<decltype(tuple_size<_Tp>::value)>::type, tuple_size<_Tp>::value>
  {
  };
  template < typename ..._Elements >
  struct  tuple_size< ::std::tuple<_Elements ...> > : ::std::integral_constant<unsigned long int, sizeof...(_Elements)>
  {
  };
  template < ::std::size_t __i, typename _Head, typename ..._Tail >
  inline constexpr typename ::std::__add_ref<_Head>::type __get_helper(::std::_Tuple_impl<__i, _Head, _Tail ...> &__t) noexcept(true);
  template < ::std::size_t __i, typename _Head, typename ..._Tail >
  inline constexpr typename ::std::__add_ref<_Head>::type __get_helper(::std::_Tuple_impl<__i, _Head, _Tail ...> &__t) noexcept(true)
  {
    return _Tuple_impl<__i, _Head, _Tail ...>::_M_head(__t);
  }
  template < ::std::size_t __i, typename _Head, typename ..._Tail >
  inline constexpr typename ::std::__add_c_ref<_Head>::type __get_helper(const ::std::_Tuple_impl<__i, _Head, _Tail ...> &__t) noexcept(true);
  template < ::std::size_t __i, typename _Head, typename ..._Tail >
  inline constexpr typename ::std::__add_c_ref<_Head>::type __get_helper(const ::std::_Tuple_impl<__i, _Head, _Tail ...> &__t) noexcept(true)
  {
    return _Tuple_impl<__i, _Head, _Tail ...>::_M_head(__t);
  }
  template < ::std::size_t __i, typename ..._Elements >
  inline constexpr typename ::std::__add_ref<typename ::std::tuple_element<__i, ::std::tuple<_Elements ...> >::type>::type get(::std::tuple<_Elements ...> &__t) noexcept(true);
  template < ::std::size_t __i, typename ..._Elements >
  inline constexpr typename ::std::__add_ref<typename ::std::tuple_element<__i, ::std::tuple<_Elements ...> >::type>::type get(::std::tuple<_Elements ...> &__t) noexcept(true)
  {
    return std::__get_helper<__i>(__t);
  }
  template < ::std::size_t __i, typename ..._Elements >
  inline constexpr typename ::std::__add_c_ref<typename ::std::tuple_element<__i, ::std::tuple<_Elements ...> >::type>::type get(const ::std::tuple<_Elements ...> &__t) noexcept(true);
  template < ::std::size_t __i, typename ..._Elements >
  inline constexpr typename ::std::__add_c_ref<typename ::std::tuple_element<__i, ::std::tuple<_Elements ...> >::type>::type get(const ::std::tuple<_Elements ...> &__t) noexcept(true)
  {
    return std::__get_helper<__i>(__t);
  }
  template < ::std::size_t __i, typename ..._Elements >
  inline constexpr typename ::std::__add_r_ref<typename ::std::tuple_element<__i, ::std::tuple<_Elements ...> >::type>::type get(::std::tuple<_Elements ...> &&__t) noexcept(true);
  template < ::std::size_t __i, typename ..._Elements >
  inline constexpr typename ::std::__add_r_ref<typename ::std::tuple_element<__i, ::std::tuple<_Elements ...> >::type>::type get(::std::tuple<_Elements ...> &&__t) noexcept(true)
  {
    return std::forward<typename ::std::tuple_element<__i, ::std::tuple<_Elements ...> >::type &&>(get<__i>(__t));
  }
  template < ::std::size_t __check_equal_size, ::std::size_t __i, ::std::size_t __j, typename _Tp, typename _Up >
  struct __tuple_compare;
  template < ::std::size_t __i, ::std::size_t __j, typename _Tp, typename _Up >
  struct  __tuple_compare<0LU, __i, __j, _Tp, _Up>
  {
      static inline constexpr bool __eq(const _Tp &__t, const _Up &__u)
      {
        return get<__i>(__t) == get<__i>(__u) && __tuple_compare<0, __i + 1, __j, _Tp, _Up>::__eq(__t, __u);
      }
      static inline constexpr bool __less(const _Tp &__t, const _Up &__u)
      {
        return get<__i>(__t) < get<__i>(__u) || (!(get<__i>(__u) < get<__i>(__t)) && __tuple_compare<0, __i + 1, __j, _Tp, _Up>::__less(__t, __u));
      }
  };
  template < ::std::size_t __i, typename _Tp, typename _Up >
  struct  __tuple_compare<0LU, __i, __i, _Tp, _Up>
  {
      static inline constexpr bool __eq(const _Tp &, const _Up &)
      {
        return true;
      }
      static inline constexpr bool __less(const _Tp &, const _Up &)
      {
        return false;
      }
  };
  template < typename ..._TElements, typename ..._UElements >
  inline constexpr bool operator ==(const ::std::tuple<_TElements ...> &__t, const ::std::tuple<_UElements ...> &__u);
  template < typename ..._TElements, typename ..._UElements >
  inline constexpr bool operator ==(const ::std::tuple<_TElements ...> &__t, const ::std::tuple<_UElements ...> &__u)
  {
    typedef ::std::tuple<_TElements ...> _Tp;
    typedef ::std::tuple<_UElements ...> _Up;
    return bool(__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value, 0, tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u));
  }
  template < typename ..._TElements, typename ..._UElements >
  inline constexpr bool operator <(const ::std::tuple<_TElements ...> &__t, const ::std::tuple<_UElements ...> &__u);
  template < typename ..._TElements, typename ..._UElements >
  inline constexpr bool operator <(const ::std::tuple<_TElements ...> &__t, const ::std::tuple<_UElements ...> &__u)
  {
    typedef ::std::tuple<_TElements ...> _Tp;
    typedef ::std::tuple<_UElements ...> _Up;
    return bool(__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value, 0, tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u));
  }
  template < typename ..._TElements, typename ..._UElements >
  inline constexpr bool operator !=(const ::std::tuple<_TElements ...> &__t, const ::std::tuple<_UElements ...> &__u);
  template < typename ..._TElements, typename ..._UElements >
  inline constexpr bool operator !=(const ::std::tuple<_TElements ...> &__t, const ::std::tuple<_UElements ...> &__u)
  {
    return !(__t == __u);
  }
  template < typename ..._TElements, typename ..._UElements >
  inline constexpr bool operator >(const ::std::tuple<_TElements ...> &__t, const ::std::tuple<_UElements ...> &__u);
  template < typename ..._TElements, typename ..._UElements >
  inline constexpr bool operator >(const ::std::tuple<_TElements ...> &__t, const ::std::tuple<_UElements ...> &__u)
  {
    return __u < __t;
  }
  template < typename ..._TElements, typename ..._UElements >
  inline constexpr bool operator <=(const ::std::tuple<_TElements ...> &__t, const ::std::tuple<_UElements ...> &__u);
  template < typename ..._TElements, typename ..._UElements >
  inline constexpr bool operator <=(const ::std::tuple<_TElements ...> &__t, const ::std::tuple<_UElements ...> &__u)
  {
    return !(__u < __t);
  }
  template < typename ..._TElements, typename ..._UElements >
  inline constexpr bool operator >=(const ::std::tuple<_TElements ...> &__t, const ::std::tuple<_UElements ...> &__u);
  template < typename ..._TElements, typename ..._UElements >
  inline constexpr bool operator >=(const ::std::tuple<_TElements ...> &__t, const ::std::tuple<_UElements ...> &__u)
  {
    return !(__t < __u);
  }
  template < typename ..._Elements >
  inline constexpr ::std::tuple<typename ::std::__decay_and_strip<_Elements>::__type ...> make_tuple(_Elements &&...__args);
  template < typename ..._Elements >
  inline constexpr ::std::tuple<typename ::std::__decay_and_strip<_Elements>::__type ...> make_tuple(_Elements &&...__args)
  {
    typedef ::std::tuple<typename ::std::__decay_and_strip<_Elements>::__type ...> __result_type;
    return __result_type(std::forward<_Elements>(__args) ...);
  }
  template < typename ..._Elements >
  ::std::tuple<_Elements &&...> forward_as_tuple(_Elements &&...__args) noexcept(true);
  template < typename ..._Elements >
  ::std::tuple<_Elements &&...> forward_as_tuple(_Elements &&...__args) noexcept(true)
  {
    return ::std::tuple<_Elements &&...>(std::forward<_Elements>(__args) ...);
  }
  template < typename __type_tpl__param_1_0__ >
  struct  __is_tuple_like_impl : ::std::integral_constant<bool, false>
  {
  };
  template < typename ..._Tps >
  struct  __is_tuple_like_impl< ::std::tuple<_Tps ...> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _T1, typename _T2 >
  struct  __is_tuple_like_impl< ::std::pair<_T1, _T2> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp, ::std::size_t _Nm >
  struct  __is_tuple_like_impl< ::std::array<_Tp, _Nm> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  __is_tuple_like : ::std::__is_tuple_like_impl<typename ::std::remove_cv<typename ::std::remove_reference<_Tp>::type>::type>::type
  {
  };
  template < ::std::size_t ... _Indexes >
  struct  _Index_tuple
  {
      typedef ::std::_Index_tuple<_Indexes ..., sizeof...(_Indexes)> __next;
  };
  template < ::std::size_t _Num >
  struct  _Build_index_tuple
  {
      typedef typename ::std::_Build_index_tuple<_Num - 1>::__type::__next __type;
  };
  template <>
  struct  _Build_index_tuple<0LU>
  {
      typedef ::std::_Index_tuple<> __type;
  };
  template < ::std::size_t __nontype_tpl_param_1_0__, typename __type_tpl__param_1_1__, typename __type_tpl__param_1_2__, ::std::size_t __nontype_tpl_param_1_3__ >
  struct __make_tuple_impl;
  template < ::std::size_t _Idx, typename _Tuple, typename ..._Tp, ::std::size_t _Nm >
  struct  __make_tuple_impl<_Idx, ::std::tuple<_Tp ...>, _Tuple, _Nm>
  {
      typedef typename ::std::__make_tuple_impl<_Idx + 1, ::std::tuple<_Tp ..., typename ::std::tuple_element<_Idx, _Tuple>::type>, _Tuple, _Nm>::__type __type;
  };
  template < ::std::size_t _Nm, typename _Tuple, typename ..._Tp >
  struct  __make_tuple_impl<_Nm, ::std::tuple<_Tp ...>, _Tuple, _Nm>
  {
      typedef ::std::tuple<_Tp ...> __type;
  };
  template < typename _Tuple >
  struct  __do_make_tuple : ::std::__make_tuple_impl<0LU, ::std::tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
  {
  };
  template < typename _Tuple >
  struct  __make_tuple : ::std::__do_make_tuple<typename ::std::remove_cv<typename ::std::remove_reference<_Tuple>::type>::type>
  {
  };
  template < typename ...__type_tpl__param_1_0__ >
  struct __combine_tuples;
  template <>
  struct  __combine_tuples<>
  {
      typedef ::std::tuple<> __type;
  };
  template < typename ..._Ts >
  struct  __combine_tuples< ::std::tuple<_Ts ...> >
  {
      typedef ::std::tuple<_Ts ...> __type;
  };
  template < typename ..._T1s, typename ..._T2s, typename ..._Rem >
  struct  __combine_tuples< ::std::tuple<_T1s ...>, ::std::tuple<_T2s ...>, _Rem ...>
  {
      typedef typename ::std::__combine_tuples< ::std::tuple<_T1s ..., _T2s ...>, _Rem ...>::__type __type;
  };
  template < typename ..._Tpls >
  struct  __tuple_cat_result
  {
      typedef typename ::std::__combine_tuples<typename ::std::__make_tuple<_Tpls>::__type ...>::__type __type;
  };
  template < typename ...__type_tpl__param_1_0__ >
  struct __make_1st_indices;
  template <>
  struct  __make_1st_indices<>
  {
      typedef ::std::_Index_tuple<> __type;
  };
  template < typename _Tp, typename ..._Tpls >
  struct  __make_1st_indices<_Tp, _Tpls ...>
  {
      typedef typename ::std::_Build_index_tuple<std::tuple_size<typename ::std::remove_reference<_Tp>::type>::value>::__type __type;
  };
  template < typename _Ret, typename _Indices, typename ..._Tpls >
  struct __tuple_concater;
  template < typename _Ret, ::std::size_t ... _Is, typename _Tp, typename ..._Tpls >
  struct  __tuple_concater<_Ret, ::std::_Index_tuple<_Is ...>, _Tp, _Tpls ...>
  {
      template < typename ..._Us >
      static inline constexpr _Ret _S_do(_Tp &&__tp, _Tpls &&...__tps, _Us &&...__us)
      {
        typedef typename ::std::__make_1st_indices<_Tpls ...>::__type __idx;
        typedef ::std::__tuple_concater<_Ret, __idx, _Tpls ...> __next;
        return __next::_S_do(std::forward<_Tpls>(__tps) ..., std::forward<_Us>(__us) ..., std::get<_Is>(std::forward<_Tp>(__tp)) ...);
      }
  };
  template < typename _Ret >
  struct  __tuple_concater<_Ret, ::std::_Index_tuple<> >
  {
      template < typename ..._Us >
      static inline constexpr _Ret _S_do(_Us &&...__us)
      {
        return _Ret(std::forward<_Us>(__us) ...);
      }
  };
  template < typename ..._Tpls, typename __type_tpl__param_1_1__ = typename ::std::enable_if<__and_< ::std::__is_tuple_like<_Tpls> ...>::value>::type >
  inline constexpr auto tuple_cat(_Tpls &&...__tpls) -> typename ::std::__tuple_cat_result<_Tpls ...>::__type;
  template < typename ..._Tpls, typename __type_tpl__param_1_1__ >
  inline constexpr auto tuple_cat(_Tpls &&...__tpls) -> typename ::std::__tuple_cat_result<_Tpls ...>::__type
  {
    typedef typename ::std::__tuple_cat_result<_Tpls ...>::__type __ret;
    typedef typename ::std::__make_1st_indices<_Tpls ...>::__type __idx;
    typedef ::std::__tuple_concater<__ret, __idx, _Tpls ...> __concater;
    return __concater::_S_do(std::forward<_Tpls>(__tpls) ...);
  }
  template < typename ..._Elements >
  inline ::std::tuple<_Elements &...> tie(_Elements &...__args) noexcept(true);
  template < typename ..._Elements >
  inline ::std::tuple<_Elements &...> tie(_Elements &...__args) noexcept(true)
  {
    return ::std::tuple<_Elements &...>(__args ...);
  }
  template < typename ..._Elements >
  inline void swap(::std::tuple<_Elements ...> &__x, ::std::tuple<_Elements ...> &__y) noexcept(noexcept(__x.swap(__y)));
  template < typename ..._Elements >
  inline void swap(::std::tuple<_Elements ...> &__x, ::std::tuple<_Elements ...> &__y) noexcept(noexcept(__x.swap(__y)))
  {
    __x.swap(__y);
  }
  struct  _Swallow_assign
  {
      template < typename _Tp >
      inline const ::std::_Swallow_assign &operator =(const _Tp &) const 
      {
        return *this;
      }
  };
  const ::std::_Swallow_assign ignore{};
  template < typename ..._Types, typename _Alloc >
  struct  uses_allocator< ::std::tuple<_Types ...>, _Alloc> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _T1, typename _T2 >
  template < typename ..._Args1, typename ..._Args2 >
  inline pair<_T1, _T2>::pair(::std::piecewise_construct_t, ::std::tuple<_Args1 ...> __first, ::std::tuple<_Args2 ...> __second)
    : pair(__first, __second, typename ::std::_Build_index_tuple<sizeof...(_Args1)>::__type(), typename ::std::_Build_index_tuple<sizeof...(_Args2)>::__type())
  {
  }
  template < typename _T1, typename _T2 >
  template < typename ..._Args1, ::std::size_t ... _Indexes1, typename ..._Args2, ::std::size_t ... _Indexes2 >
  inline pair<_T1, _T2>::pair(::std::tuple<_Args1 ...> &__tuple1, ::std::tuple<_Args2 ...> &__tuple2, ::std::_Index_tuple<_Indexes1 ...>, ::std::_Index_tuple<_Indexes2 ...>)
    : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1)) ...), second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2)) ...)
  {
  }
  template < typename _MemberPointer >
  class _Mem_fn;
  template < typename _Tp, typename _Class >
  inline ::std::_Mem_fn<_Tp _Class::*> mem_fn(_Tp _Class::*__pm) noexcept(true);
  template < typename _Tp >
  class  __has_result_type_helper : ::std::__sfinae_types
  {
      template < typename _Up >
      struct  _Wrap_type
      {
      };
      template < typename _Up >
      static ::std::__sfinae_types::__one __test(typename ::std::__has_result_type_helper<_Tp>::template _Wrap_type<typename _Up::result_type> *);
      template < typename _Up >
      static ::std::__sfinae_types::__two __test(...);
    public:
      static constexpr const bool value = sizeof(__test<_Tp>(0)) == 1;
  };
  template < typename _Tp >
  struct  __has_result_type : ::std::integral_constant<bool, __has_result_type_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < bool _Has_result_type, typename _Functor >
  struct  _Maybe_get_result_type
  {
  };
  template < typename _Functor >
  struct  _Maybe_get_result_type<true, _Functor>
  {
      typedef typename _Functor::result_type result_type;
  };
  template < typename _Functor >
  struct  _Weak_result_type_impl : ::std::_Maybe_get_result_type<__has_result_type<_Functor>::value, _Functor>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_ArgTypes ...)>
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_ArgTypes ..., ...)>
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_ArgTypes ...) const >
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_ArgTypes ..., ...) const >
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_ArgTypes ...) volatile >
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_ArgTypes ..., ...) volatile >
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_ArgTypes ...) const volatile >
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_ArgTypes ..., ...) const volatile >
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (&)(_ArgTypes ...)>
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (&)(_ArgTypes ..., ...)>
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (*)(_ArgTypes ...)>
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (*)(_ArgTypes ..., ...)>
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename _Class, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes ...)>
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename _Class, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes ..., ...)>
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename _Class, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes ...) const >
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename _Class, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes ..., ...) const >
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename _Class, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes ...) volatile >
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename _Class, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes ..., ...) volatile >
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename _Class, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes ...) const volatile >
  {
      typedef _Res result_type;
  };
  template < typename _Res, typename _Class, typename ..._ArgTypes >
  struct  _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes ..., ...) const volatile >
  {
      typedef _Res result_type;
  };
  template < typename _Functor >
  struct  _Weak_result_type : ::std::_Weak_result_type_impl<typename ::std::remove_cv<_Functor>::type>
  {
  };
  template < typename _Tp >
  struct  _Derives_from_unary_function : ::std::__sfinae_types
  {
    private:
      template < typename _T1, typename _Res >
      static ::std::__sfinae_types::__one __test(const volatile ::std::unary_function<_T1, _Res> *);
      static ::std::__sfinae_types::__two __test(...);
    public:
      static const bool value = sizeof(__test((_Tp *)0)) == 1;
  };
  template < typename _Tp >
  struct  _Derives_from_binary_function : ::std::__sfinae_types
  {
    private:
      template < typename _T1, typename _T2, typename _Res >
      static ::std::__sfinae_types::__one __test(const volatile ::std::binary_function<_T1, _T2, _Res> *);
      static ::std::__sfinae_types::__two __test(...);
    public:
      static const bool value = sizeof(__test((_Tp *)0)) == 1;
  };
  template < typename _Functor, typename ..._Args >
  inline typename ::std::enable_if<(!is_member_pointer<_Functor>::value && !is_function<_Functor>::value) && !is_function<typename ::std::remove_pointer<_Functor>::type>::value, typename ::std::result_of<_Functor &(_Args &&...)>::type>::type __invoke(_Functor &__f, _Args &&...__args);
  template < typename _Functor, typename ..._Args >
  inline typename ::std::enable_if<(!is_member_pointer<_Functor>::value && !is_function<_Functor>::value) && !is_function<typename ::std::remove_pointer<_Functor>::type>::value, typename ::std::result_of<_Functor &(_Args &&...)>::type>::type __invoke(_Functor &__f, _Args &&...__args)
  {
    return __f(std::forward<_Args>(__args) ...);
  }
  template < typename _Functor, typename ..._Args >
  inline typename ::std::enable_if<(is_member_pointer<_Functor>::value && !is_function<_Functor>::value) && !is_function<typename ::std::remove_pointer<_Functor>::type>::value, typename ::std::result_of<_Functor (_Args &&...)>::type>::type __invoke(_Functor &__f, _Args &&...__args);
  template < typename _Functor, typename ..._Args >
  inline typename ::std::enable_if<(is_member_pointer<_Functor>::value && !is_function<_Functor>::value) && !is_function<typename ::std::remove_pointer<_Functor>::type>::value, typename ::std::result_of<_Functor (_Args &&...)>::type>::type __invoke(_Functor &__f, _Args &&...__args)
  {
    return std::mem_fn(__f)(std::forward<_Args>(__args) ...);
  }
  template < typename _Functor, typename ..._Args >
  inline typename ::std::enable_if<is_pointer<_Functor>::value && is_function<typename ::std::remove_pointer<_Functor>::type>::value, typename ::std::result_of<_Functor (_Args &&...)>::type>::type __invoke(_Functor __f, _Args &&...__args);
  template < typename _Functor, typename ..._Args >
  inline typename ::std::enable_if<is_pointer<_Functor>::value && is_function<typename ::std::remove_pointer<_Functor>::type>::value, typename ::std::result_of<_Functor (_Args &&...)>::type>::type __invoke(_Functor __f, _Args &&...__args)
  {
    return __f(std::forward<_Args>(__args) ...);
  }
  template < bool _Unary, bool _Binary, typename _Tp >
  struct _Reference_wrapper_base_impl;
  template < typename _Tp >
  struct  _Reference_wrapper_base_impl<false, false, _Tp> : ::std::_Weak_result_type<_Tp>
  {
  };
  template < typename _Tp >
  struct  _Reference_wrapper_base_impl<true, false, _Tp> : ::std::_Weak_result_type<_Tp>
  {
      typedef typename _Tp::argument_type argument_type;
  };
  template < typename _Tp >
  struct  _Reference_wrapper_base_impl<false, true, _Tp> : ::std::_Weak_result_type<_Tp>
  {
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
  };
  template < typename _Tp >
  struct  _Reference_wrapper_base_impl<true, true, _Tp> : ::std::_Weak_result_type<_Tp>
  {
      typedef typename _Tp::argument_type argument_type;
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
  };
  template < typename _Tp >
  class  __has_argument_type_helper : ::std::__sfinae_types
  {
      template < typename _Up >
      struct  _Wrap_type
      {
      };
      template < typename _Up >
      static ::std::__sfinae_types::__one __test(typename ::std::__has_argument_type_helper<_Tp>::template _Wrap_type<typename _Up::argument_type> *);
      template < typename _Up >
      static ::std::__sfinae_types::__two __test(...);
    public:
      static constexpr const bool value = sizeof(__test<_Tp>(0)) == 1;
  };
  template < typename _Tp >
  struct  __has_argument_type : ::std::integral_constant<bool, __has_argument_type_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename _Tp >
  class  __has_first_argument_type_helper : ::std::__sfinae_types
  {
      template < typename _Up >
      struct  _Wrap_type
      {
      };
      template < typename _Up >
      static ::std::__sfinae_types::__one __test(typename ::std::__has_first_argument_type_helper<_Tp>::template _Wrap_type<typename _Up::first_argument_type> *);
      template < typename _Up >
      static ::std::__sfinae_types::__two __test(...);
    public:
      static constexpr const bool value = sizeof(__test<_Tp>(0)) == 1;
  };
  template < typename _Tp >
  struct  __has_first_argument_type : ::std::integral_constant<bool, __has_first_argument_type_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename _Tp >
  class  __has_second_argument_type_helper : ::std::__sfinae_types
  {
      template < typename _Up >
      struct  _Wrap_type
      {
      };
      template < typename _Up >
      static ::std::__sfinae_types::__one __test(typename ::std::__has_second_argument_type_helper<_Tp>::template _Wrap_type<typename _Up::second_argument_type> *);
      template < typename _Up >
      static ::std::__sfinae_types::__two __test(...);
    public:
      static constexpr const bool value = sizeof(__test<_Tp>(0)) == 1;
  };
  template < typename _Tp >
  struct  __has_second_argument_type : ::std::integral_constant<bool, __has_second_argument_type_helper<typename ::std::remove_cv<_Tp>::type>::value>
  {
  };
  template < typename _Tp >
  struct  _Reference_wrapper_base : ::std::_Reference_wrapper_base_impl<__has_argument_type<_Tp>::value, __has_first_argument_type<_Tp>::value && __has_second_argument_type<_Tp>::value, _Tp>
  {
  };
  template < typename _Res, typename _T1 >
  struct  _Reference_wrapper_base<_Res (_T1)> : ::std::unary_function<_T1, _Res>
  {
  };
  template < typename _Res, typename _T1 >
  struct  _Reference_wrapper_base<_Res (_T1) const > : ::std::unary_function<_T1, _Res>
  {
  };
  template < typename _Res, typename _T1 >
  struct  _Reference_wrapper_base<_Res (_T1) volatile > : ::std::unary_function<_T1, _Res>
  {
  };
  template < typename _Res, typename _T1 >
  struct  _Reference_wrapper_base<_Res (_T1) const volatile > : ::std::unary_function<_T1, _Res>
  {
  };
  template < typename _Res, typename _T1, typename _T2 >
  struct  _Reference_wrapper_base<_Res (_T1, _T2)> : ::std::binary_function<_T1, _T2, _Res>
  {
  };
  template < typename _Res, typename _T1, typename _T2 >
  struct  _Reference_wrapper_base<_Res (_T1, _T2) const > : ::std::binary_function<_T1, _T2, _Res>
  {
  };
  template < typename _Res, typename _T1, typename _T2 >
  struct  _Reference_wrapper_base<_Res (_T1, _T2) volatile > : ::std::binary_function<_T1, _T2, _Res>
  {
  };
  template < typename _Res, typename _T1, typename _T2 >
  struct  _Reference_wrapper_base<_Res (_T1, _T2) const volatile > : ::std::binary_function<_T1, _T2, _Res>
  {
  };
  template < typename _Res, typename _T1 >
  struct  _Reference_wrapper_base<_Res (*)(_T1)> : ::std::unary_function<_T1, _Res>
  {
  };
  template < typename _Res, typename _T1, typename _T2 >
  struct  _Reference_wrapper_base<_Res (*)(_T1, _T2)> : ::std::binary_function<_T1, _T2, _Res>
  {
  };
  template < typename _Res, typename _T1 >
  struct  _Reference_wrapper_base<_Res (_T1::*)()> : ::std::unary_function<_T1 *, _Res>
  {
  };
  template < typename _Res, typename _T1, typename _T2 >
  struct  _Reference_wrapper_base<_Res (_T1::*)(_T2)> : ::std::binary_function<_T1 *, _T2, _Res>
  {
  };
  template < typename _Res, typename _T1 >
  struct  _Reference_wrapper_base<_Res (_T1::*)() const > : ::std::unary_function<const _T1 *, _Res>
  {
  };
  template < typename _Res, typename _T1, typename _T2 >
  struct  _Reference_wrapper_base<_Res (_T1::*)(_T2) const > : ::std::binary_function<const _T1 *, _T2, _Res>
  {
  };
  template < typename _Res, typename _T1 >
  struct  _Reference_wrapper_base<_Res (_T1::*)() volatile > : ::std::unary_function<volatile _T1 *, _Res>
  {
  };
  template < typename _Res, typename _T1, typename _T2 >
  struct  _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile > : ::std::binary_function<volatile _T1 *, _T2, _Res>
  {
  };
  template < typename _Res, typename _T1 >
  struct  _Reference_wrapper_base<_Res (_T1::*)() const volatile > : ::std::unary_function<const volatile _T1 *, _Res>
  {
  };
  template < typename _Res, typename _T1, typename _T2 >
  struct  _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile > : ::std::binary_function<const volatile _T1 *, _T2, _Res>
  {
  };
  template < typename _Tp >
  class  reference_wrapper : public ::std::_Reference_wrapper_base<typename ::std::remove_cv<_Tp>::type>
  {
      _Tp *_M_data;
    public:
      typedef _Tp type;
      inline reference_wrapper(_Tp &__indata) noexcept(true)
        : _M_data(std::__addressof(__indata))
      {
      }
      reference_wrapper(_Tp &&) = delete ;
      inline reference_wrapper(const ::std::reference_wrapper<_Tp> &__inref) noexcept(true)
        : _M_data(__inref._M_data)
      {
      }
      inline ::std::reference_wrapper<_Tp> &operator =(const ::std::reference_wrapper<_Tp> &__inref) noexcept(true)
      {
        ::std::reference_wrapper<_Tp>::_M_data = __inref._M_data;
        return *this;
      }
      inline operator _Tp &() const  noexcept(true)
      {
        return this->get();
      }
      inline _Tp &get() const  noexcept(true)
      {
        return *::std::reference_wrapper<_Tp>::_M_data;
      }
      template < typename ..._Args >
      inline typename ::std::result_of<_Tp &(_Args &&...)>::type operator ()(_Args &&...__args) const 
      {
        return __invoke((*this).get(), std::forward<_Args>(__args) ...);
      }
  };
  template < typename _Tp >
  inline ::std::reference_wrapper<_Tp> ref(_Tp &__t) noexcept(true);
  template < typename _Tp >
  inline ::std::reference_wrapper<_Tp> ref(_Tp &__t) noexcept(true)
  {
    return ::std::reference_wrapper<_Tp>(__t);
  }
  template < typename _Tp >
  inline ::std::reference_wrapper<const _Tp> cref(const _Tp &__t) noexcept(true);
  template < typename _Tp >
  inline ::std::reference_wrapper<const _Tp> cref(const _Tp &__t) noexcept(true)
  {
    return ::std::reference_wrapper<const _Tp>(__t);
  }
  template < typename _Tp >
  void ref(const _Tp &&) = delete ;
  template < typename _Tp >
  void cref(const _Tp &&) = delete ;
  template < typename _Tp >
  inline ::std::reference_wrapper<_Tp> ref(::std::reference_wrapper<_Tp> __t) noexcept(true);
  template < typename _Tp >
  inline ::std::reference_wrapper<_Tp> ref(::std::reference_wrapper<_Tp> __t) noexcept(true)
  {
    return ref(__t.get());
  }
  template < typename _Tp >
  inline ::std::reference_wrapper<const _Tp> cref(::std::reference_wrapper<_Tp> __t) noexcept(true);
  template < typename _Tp >
  inline ::std::reference_wrapper<const _Tp> cref(::std::reference_wrapper<_Tp> __t) noexcept(true)
  {
    return cref(__t.get());
  }
  template < typename ..._Types >
  struct  _Pack : ::std::integral_constant<unsigned long int, sizeof...(_Types)>
  {
  };
  template < typename _From, typename _To, bool __nontype_tpl_param_1_2__ = _From::value == _To::value >
  struct  _AllConvertible : ::std::integral_constant<bool, false>
  {
  };
  template < typename ..._From, typename ..._To >
  struct  _AllConvertible< ::std::_Pack<_From ...>, ::std::_Pack<_To ...>, true> : ::std::__and_< ::std::is_convertible<_From, _To> ...>
  {
  };
  template < typename _Tp1, typename _Tp2 >
  using _NotSame = ::std::__not_< ::std::is_same<typename ::std::decay<_Tp1>::type, typename ::std::decay<_Tp2>::type> >;
  template < typename _Res, typename ..._ArgTypes >
  struct  _Maybe_unary_or_binary_function
  {
  };
  template < typename _Res, typename _T1 >
  struct  _Maybe_unary_or_binary_function<_Res, _T1> : ::std::unary_function<_T1, _Res>
  {
  };
  template < typename _Res, typename _T1, typename _T2 >
  struct  _Maybe_unary_or_binary_function<_Res, _T1, _T2> : ::std::binary_function<_T1, _T2, _Res>
  {
  };
  template < typename _Res, typename _Class, typename ..._ArgTypes >
  class  _Mem_fn<_Res (_Class::*)(_ArgTypes ...)> : public ::std::_Maybe_unary_or_binary_function<_Res, _Class *, _ArgTypes ...>
  {
      typedef _Res (_Class::*_Functor)(_ArgTypes ...);
      template < typename _Tp, typename ..._Args >
      inline _Res _M_call(_Tp &&__object, const volatile _Class *, _Args &&...__args) const 
      {
        return (std::forward<_Tp>(__object).*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename _Tp, typename ..._Args >
      inline _Res _M_call(_Tp &&__ptr, const volatile void *, _Args &&...__args) const 
      {
        return (*__ptr.*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename ..._Args >
      using _RequireValidArgs = ::std::_Require< ::std::_AllConvertible< ::std::_Pack<_Args ...>, ::std::_Pack<_ArgTypes ...> > >;
      template < typename _Tp, typename ..._Args >
      using _RequireValidArgs2 = ::std::_Require< ::std::_NotSame<_Class, _Tp>, ::std::_NotSame<_Class *, _Tp>, ::std::_AllConvertible< ::std::_Pack<_Args ...>, ::std::_Pack<_ArgTypes ...> > >;
      template < typename _Tp, typename ..._Args >
      using _RequireValidArgs3 = ::std::_Require< ::std::is_base_of<_Class, _Tp>, ::std::_AllConvertible< ::std::_Pack<_Args ...>, ::std::_Pack<_ArgTypes ...> > >;
    public:
      typedef _Res result_type;
      inline explicit _Mem_fn(typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::_Functor __pmf)
        : __pmf(__pmf)
      {
      }
      template < typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::template _RequireValidArgs<_Args ...> >
      inline _Res operator ()(_Class &__object, _Args &&...__args) const 
      {
        return (__object.*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::template _RequireValidArgs<_Args ...> >
      inline _Res operator ()(_Class &&__object, _Args &&...__args) const 
      {
        return (std::move(__object).*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::template _RequireValidArgs<_Args ...> >
      inline _Res operator ()(_Class *__object, _Args &&...__args) const 
      {
        return (__object->*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename _Tp, typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::template _RequireValidArgs2<_Tp, _Args ...> >
      inline _Res operator ()(_Tp &&__object, _Args &&...__args) const 
      {
        return (*this)._M_call(std::forward<_Tp>(__object), &__object, std::forward<_Args>(__args) ...);
      }
      template < typename _Tp, typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::template _RequireValidArgs3<_Tp, _Args ...> >
      inline _Res operator ()(::std::reference_wrapper<_Tp> __ref, _Args &&...__args) const 
      {
        return (*this).operator ()(__ref.get(), std::forward<_Args>(__args) ...);
      }
    private:
      typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::_Functor __pmf;
  };
  template < typename _Res, typename _Class, typename ..._ArgTypes >
  class  _Mem_fn<_Res (_Class::*)(_ArgTypes ...) const > : public ::std::_Maybe_unary_or_binary_function<_Res, const _Class *, _ArgTypes ...>
  {
      typedef _Res (_Class::*_Functor)(_ArgTypes ...) const ;
      template < typename _Tp, typename ..._Args >
      inline _Res _M_call(_Tp &&__object, const volatile _Class *, _Args &&...__args) const 
      {
        return (std::forward<_Tp>(__object).*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename _Tp, typename ..._Args >
      inline _Res _M_call(_Tp &&__ptr, const volatile void *, _Args &&...__args) const 
      {
        return (*__ptr.*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename ..._Args >
      using _RequireValidArgs = ::std::_Require< ::std::_AllConvertible< ::std::_Pack<_Args ...>, ::std::_Pack<_ArgTypes ...> > >;
      template < typename _Tp, typename ..._Args >
      using _RequireValidArgs2 = ::std::_Require< ::std::_NotSame<_Class, _Tp>, ::std::_NotSame<const _Class *, _Tp>, ::std::_AllConvertible< ::std::_Pack<_Args ...>, ::std::_Pack<_ArgTypes ...> > >;
      template < typename _Tp, typename ..._Args >
      using _RequireValidArgs3 = ::std::_Require< ::std::is_base_of<_Class, _Tp>, ::std::_AllConvertible< ::std::_Pack<_Args ...>, ::std::_Pack<_ArgTypes ...> > >;
    public:
      typedef _Res result_type;
      inline explicit _Mem_fn(typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const >::_Functor __pmf)
        : __pmf(__pmf)
      {
      }
      template < typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const >::template _RequireValidArgs<_Args ...> >
      inline _Res operator ()(const _Class &__object, _Args &&...__args) const 
      {
        return (__object.*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const >::template _RequireValidArgs<_Args ...> >
      inline _Res operator ()(const _Class &&__object, _Args &&...__args) const 
      {
        return (std::move(__object).*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const >::template _RequireValidArgs<_Args ...> >
      inline _Res operator ()(const _Class *__object, _Args &&...__args) const 
      {
        return (__object->*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename _Tp, typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const >::template _RequireValidArgs2<_Tp, _Args ...> >
      inline _Res operator ()(_Tp &&__object, _Args &&...__args) const 
      {
        return (*this)._M_call(std::forward<_Tp>(__object), &__object, std::forward<_Args>(__args) ...);
      }
      template < typename _Tp, typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const >::template _RequireValidArgs3<_Tp, _Args ...> >
      inline _Res operator ()(::std::reference_wrapper<_Tp> __ref, _Args &&...__args) const 
      {
        return (*this).operator ()(__ref.get(), std::forward<_Args>(__args) ...);
      }
    private:
      typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const >::_Functor __pmf;
  };
  template < typename _Res, typename _Class, typename ..._ArgTypes >
  class  _Mem_fn<_Res (_Class::*)(_ArgTypes ...) volatile > : public ::std::_Maybe_unary_or_binary_function<_Res, volatile _Class *, _ArgTypes ...>
  {
      typedef _Res (_Class::*_Functor)(_ArgTypes ...) volatile ;
      template < typename _Tp, typename ..._Args >
      inline _Res _M_call(_Tp &&__object, const volatile _Class *, _Args &&...__args) const 
      {
        return (std::forward<_Tp>(__object).*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) volatile >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename _Tp, typename ..._Args >
      inline _Res _M_call(_Tp &&__ptr, const volatile void *, _Args &&...__args) const 
      {
        return (*__ptr.*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) volatile >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename ..._Args >
      using _RequireValidArgs = ::std::_Require< ::std::_AllConvertible< ::std::_Pack<_Args ...>, ::std::_Pack<_ArgTypes ...> > >;
      template < typename _Tp, typename ..._Args >
      using _RequireValidArgs2 = ::std::_Require< ::std::_NotSame<_Class, _Tp>, ::std::_NotSame<volatile _Class *, _Tp>, ::std::_AllConvertible< ::std::_Pack<_Args ...>, ::std::_Pack<_ArgTypes ...> > >;
      template < typename _Tp, typename ..._Args >
      using _RequireValidArgs3 = ::std::_Require< ::std::is_base_of<_Class, _Tp>, ::std::_AllConvertible< ::std::_Pack<_Args ...>, ::std::_Pack<_ArgTypes ...> > >;
    public:
      typedef _Res result_type;
      inline explicit _Mem_fn(typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) volatile >::_Functor __pmf)
        : __pmf(__pmf)
      {
      }
      template < typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) volatile >::template _RequireValidArgs<_Args ...> >
      inline _Res operator ()(volatile _Class &__object, _Args &&...__args) const 
      {
        return (__object.*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) volatile >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) volatile >::template _RequireValidArgs<_Args ...> >
      inline _Res operator ()(volatile _Class &&__object, _Args &&...__args) const 
      {
        return (std::move(__object).*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) volatile >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) volatile >::template _RequireValidArgs<_Args ...> >
      inline _Res operator ()(volatile _Class *__object, _Args &&...__args) const 
      {
        return (__object->*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) volatile >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename _Tp, typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) volatile >::template _RequireValidArgs2<_Tp, _Args ...> >
      inline _Res operator ()(_Tp &&__object, _Args &&...__args) const 
      {
        return (*this)._M_call(std::forward<_Tp>(__object), &__object, std::forward<_Args>(__args) ...);
      }
      template < typename _Tp, typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) volatile >::template _RequireValidArgs3<_Tp, _Args ...> >
      inline _Res operator ()(::std::reference_wrapper<_Tp> __ref, _Args &&...__args) const 
      {
        return (*this).operator ()(__ref.get(), std::forward<_Args>(__args) ...);
      }
    private:
      typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) volatile >::_Functor __pmf;
  };
  template < typename _Res, typename _Class, typename ..._ArgTypes >
  class  _Mem_fn<_Res (_Class::*)(_ArgTypes ...) const volatile > : public ::std::_Maybe_unary_or_binary_function<_Res, const volatile _Class *, _ArgTypes ...>
  {
      typedef _Res (_Class::*_Functor)(_ArgTypes ...) const volatile ;
      template < typename _Tp, typename ..._Args >
      inline _Res _M_call(_Tp &&__object, const volatile _Class *, _Args &&...__args) const 
      {
        return (std::forward<_Tp>(__object).*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const volatile >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename _Tp, typename ..._Args >
      inline _Res _M_call(_Tp &&__ptr, const volatile void *, _Args &&...__args) const 
      {
        return (*__ptr.*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const volatile >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename ..._Args >
      using _RequireValidArgs = ::std::_Require< ::std::_AllConvertible< ::std::_Pack<_Args ...>, ::std::_Pack<_ArgTypes ...> > >;
      template < typename _Tp, typename ..._Args >
      using _RequireValidArgs2 = ::std::_Require< ::std::_NotSame<_Class, _Tp>, ::std::_NotSame<const volatile _Class *, _Tp>, ::std::_AllConvertible< ::std::_Pack<_Args ...>, ::std::_Pack<_ArgTypes ...> > >;
      template < typename _Tp, typename ..._Args >
      using _RequireValidArgs3 = ::std::_Require< ::std::is_base_of<_Class, _Tp>, ::std::_AllConvertible< ::std::_Pack<_Args ...>, ::std::_Pack<_ArgTypes ...> > >;
    public:
      typedef _Res result_type;
      inline explicit _Mem_fn(typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const volatile >::_Functor __pmf)
        : __pmf(__pmf)
      {
      }
      template < typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const volatile >::template _RequireValidArgs<_Args ...> >
      inline _Res operator ()(const volatile _Class &__object, _Args &&...__args) const 
      {
        return (__object.*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const volatile >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const volatile >::template _RequireValidArgs<_Args ...> >
      inline _Res operator ()(const volatile _Class &&__object, _Args &&...__args) const 
      {
        return (std::move(__object).*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const volatile >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const volatile >::template _RequireValidArgs<_Args ...> >
      inline _Res operator ()(const volatile _Class *__object, _Args &&...__args) const 
      {
        return (__object->*::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const volatile >::__pmf)(std::forward<_Args>(__args) ...);
      }
      template < typename _Tp, typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const volatile >::template _RequireValidArgs2<_Tp, _Args ...> >
      inline _Res operator ()(_Tp &&__object, _Args &&...__args) const 
      {
        return (*this)._M_call(std::forward<_Tp>(__object), &__object, std::forward<_Args>(__args) ...);
      }
      template < typename _Tp, typename ..._Args, typename _Req = typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const volatile >::template _RequireValidArgs3<_Tp, _Args ...> >
      inline _Res operator ()(::std::reference_wrapper<_Tp> __ref, _Args &&...__args) const 
      {
        return (*this).operator ()(__ref.get(), std::forward<_Args>(__args) ...);
      }
    private:
      typename ::std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...) const volatile >::_Functor __pmf;
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ >
  struct  _Mem_fn_const_or_non
  {
      typedef const _Tp &type;
  };
  template < typename _Tp >
  struct  _Mem_fn_const_or_non<_Tp, false>
  {
      typedef _Tp &type;
  };
  template < typename _Res, typename _Class >
  class  _Mem_fn<_Res _Class::*>
  {
      typedef _Res _Class::*__pm_type;
      template < typename _Tp >
      inline auto _M_call(_Tp &&__object, const _Class *) const  noexcept(true) -> decltype(std::forward<_Tp>(__object).*std::declval<typename ::std::_Mem_fn<_Res _Class::*>::__pm_type &>())
      {
        return std::forward<_Tp>(__object).*::std::_Mem_fn<_Res _Class::*>::__pm;
      }
      template < typename _Tp, typename _Up >
      inline auto _M_call(_Tp &&__object, _Up *const *) const  noexcept(true) -> decltype(*std::forward<_Tp>(__object).*std::declval<typename ::std::_Mem_fn<_Res _Class::*>::__pm_type &>())
      {
        return *std::forward<_Tp>(__object).*::std::_Mem_fn<_Res _Class::*>::__pm;
      }
      template < typename _Tp >
      inline auto _M_call(_Tp &&__ptr, const volatile void *) const  noexcept(noexcept(*__ptr.*std::declval<typename ::std::_Mem_fn<_Res _Class::*>::__pm_type &>())) -> decltype(*__ptr.*std::declval<typename ::std::_Mem_fn<_Res _Class::*>::__pm_type &>())
      {
        return *__ptr.*::std::_Mem_fn<_Res _Class::*>::__pm;
      }
    public:
      inline explicit _Mem_fn(_Res _Class::*__pm) noexcept(true)
        : __pm(__pm)
      {
      }
      inline _Res &operator ()(_Class &__object) const  noexcept(true)
      {
        return __object.*::std::_Mem_fn<_Res _Class::*>::__pm;
      }
      inline const _Res &operator ()(const _Class &__object) const  noexcept(true)
      {
        return __object.*::std::_Mem_fn<_Res _Class::*>::__pm;
      }
      inline _Res &&operator ()(_Class &&__object) const  noexcept(true)
      {
        return std::forward<_Class>(__object).*::std::_Mem_fn<_Res _Class::*>::__pm;
      }
      inline const _Res &&operator ()(const _Class &&__object) const  noexcept(true)
      {
        return std::forward<const _Class>(__object).*::std::_Mem_fn<_Res _Class::*>::__pm;
      }
      inline _Res &operator ()(_Class *__object) const  noexcept(true)
      {
        return __object->*::std::_Mem_fn<_Res _Class::*>::__pm;
      }
      inline const _Res &operator ()(const _Class *__object) const  noexcept(true)
      {
        return __object->*::std::_Mem_fn<_Res _Class::*>::__pm;
      }
      template < typename _Tp, typename _Req = ::std::_Require< ::std::_NotSame<_Class *, _Tp> > >
      inline auto operator ()(_Tp &&__unknown) const  noexcept(noexcept(std::declval< ::std::_Mem_fn<_Res _Class::*> *>()->_M_call(std::forward<_Tp>(__unknown), &__unknown))) -> decltype(this->_M_call(std::forward<_Tp>(__unknown), &__unknown))
      {
        return (*this)._M_call(std::forward<_Tp>(__unknown), &__unknown);
      }
      template < typename _Tp, typename _Req = ::std::_Require< ::std::is_base_of<_Class, _Tp> > >
      inline auto operator ()(::std::reference_wrapper<_Tp> __ref) const  noexcept(noexcept(std::declval< ::std::_Mem_fn<_Res _Class::*> &>()(__ref.get()))) -> decltype((*this)(__ref.get()))
      {
        return (*this)(__ref.get());
      }
    private:
      _Res _Class::*__pm;
  };
  template < typename _Tp, typename _Class >
  inline ::std::_Mem_fn<_Tp _Class::*> mem_fn(_Tp _Class::*__pm) noexcept(true)
  {
    return ::std::_Mem_fn<_Tp _Class::*>(__pm);
  }
  template < typename _Tp >
  struct  is_bind_expression : ::std::integral_constant<bool, false>
  {
  };
 /* Instantiation of class template '::std::integral_constant<int, 0>' */ 
  template < typename _Tp >
  struct  is_placeholder : ::std::integral_constant<int, 0>
  {
  };
  template < int _Num >
  struct  _Placeholder
  {
  };
  namespace placeholders {
    extern const ::std::_Placeholder<1> _1;
    extern const ::std::_Placeholder<2> _2;
    extern const ::std::_Placeholder<3> _3;
    extern const ::std::_Placeholder<4> _4;
    extern const ::std::_Placeholder<5> _5;
    extern const ::std::_Placeholder<6> _6;
    extern const ::std::_Placeholder<7> _7;
    extern const ::std::_Placeholder<8> _8;
    extern const ::std::_Placeholder<9> _9;
    extern const ::std::_Placeholder<10> _10;
    extern const ::std::_Placeholder<11> _11;
    extern const ::std::_Placeholder<12> _12;
    extern const ::std::_Placeholder<13> _13;
    extern const ::std::_Placeholder<14> _14;
    extern const ::std::_Placeholder<15> _15;
    extern const ::std::_Placeholder<16> _16;
    extern const ::std::_Placeholder<17> _17;
    extern const ::std::_Placeholder<18> _18;
    extern const ::std::_Placeholder<19> _19;
    extern const ::std::_Placeholder<20> _20;
    extern const ::std::_Placeholder<21> _21;
    extern const ::std::_Placeholder<22> _22;
    extern const ::std::_Placeholder<23> _23;
    extern const ::std::_Placeholder<24> _24;
    extern const ::std::_Placeholder<25> _25;
    extern const ::std::_Placeholder<26> _26;
    extern const ::std::_Placeholder<27> _27;
    extern const ::std::_Placeholder<28> _28;
    extern const ::std::_Placeholder<29> _29;
  }
  template < int _Num >
  struct  is_placeholder< ::std::_Placeholder<_Num> > : ::std::integral_constant<int, _Num>
  {
  };
  template < int _Num >
  struct  is_placeholder<const ::std::_Placeholder<_Num> > : ::std::integral_constant<int, _Num>
  {
  };
  struct _No_tuple_element;
  template < ::std::size_t __i, typename _Tuple, bool _IsSafe >
  struct  _Safe_tuple_element_impl : ::std::tuple_element<__i, _Tuple>
  {
  };
  template < ::std::size_t __i, typename _Tuple >
  struct  _Safe_tuple_element_impl<__i, _Tuple, false>
  {
      typedef ::std::_No_tuple_element type;
  };
  template < ::std::size_t __i, typename _Tuple >
  struct  _Safe_tuple_element : ::std::_Safe_tuple_element_impl<__i, _Tuple, __i < tuple_size<_Tuple>::value>
  {
  };
  template < typename _Arg, bool _IsBindExp = is_bind_expression<_Arg>::value, bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0) >
  class _Mu;
  template < typename _Tp >
  class  _Mu< ::std::reference_wrapper<_Tp>, false, false>
  {
    public:
      typedef _Tp &result_type;
      template < typename _CVRef, typename _Tuple >
      inline typename ::std::_Mu< ::std::reference_wrapper<_Tp>, false, false>::result_type operator ()(_CVRef &__arg, _Tuple &) const volatile 
      {
        return __arg.get();
      }
  };
  template < typename _Arg >
  class  _Mu<_Arg, true, false>
  {
    public:
      template < typename _CVArg, typename ..._Args >
      inline auto operator ()(_CVArg &__arg, ::std::tuple<_Args ...> &__tuple) const volatile  -> decltype(__arg(declval<_Args>() ...))
      {
        typedef typename ::std::_Build_index_tuple<sizeof...(_Args)>::__type _Indexes;
        return this->__call(__arg, __tuple, _Indexes());
      }
    private:
      template < typename _CVArg, typename ..._Args, ::std::size_t ... _Indexes >
      inline auto __call(_CVArg &__arg, ::std::tuple<_Args ...> &__tuple, const ::std::_Index_tuple<_Indexes ...> &) const volatile  -> decltype(__arg(declval<_Args>() ...))
      {
        return __arg(std::forward<_Args>(get<_Indexes>(__tuple)) ...);
      }
  };
  template < typename _Arg >
  class  _Mu<_Arg, false, true>
  {
    public:
      template < typename _Signature >
      class result;
      template < typename _CVMu, typename _CVArg, typename _Tuple >
      class  result<_CVMu (_CVArg, _Tuple)>
      {
          typedef typename ::std::_Safe_tuple_element<is_placeholder<_Arg>::value - 1, _Tuple>::type __base_type;
        public:
          typedef typename ::std::add_rvalue_reference<typename ::std::_Mu<_Arg, false, true>::template result<_CVMu (_CVArg, _Tuple)>::__base_type>::type type;
      };
      template < typename _Tuple >
      inline typename ::std::_Mu<_Arg, false, true>::template result< ::std::_Mu<_Arg, false, true> (_Arg, _Tuple)>::type operator ()(const volatile _Arg &, _Tuple &__tuple) const volatile 
      {
        return std::forward<typename ::std::_Mu<_Arg, false, true>::template result< ::std::_Mu<_Arg, false, true> (_Arg, _Tuple)>::type>(::std::get<is_placeholder<_Arg>::value - 1>(__tuple));
      }
  };
  template < typename _Arg >
  class  _Mu<_Arg, false, false>
  {
    public:
      template < typename _Signature >
      struct result;
      template < typename _CVMu, typename _CVArg, typename _Tuple >
      struct  result<_CVMu (_CVArg, _Tuple)>
      {
          typedef typename ::std::add_lvalue_reference<_CVArg>::type type;
      };
      template < typename _CVArg, typename _Tuple >
      inline _CVArg &&operator ()(_CVArg &&__arg, _Tuple &) const volatile 
      {
        return std::forward<_CVArg>(__arg);
      }
  };
  template < typename _Tp >
  struct  _Maybe_wrap_member_pointer
  {
      typedef _Tp type;
      static inline const _Tp &__do_wrap(const _Tp &__x)
      {
        return __x;
      }
      static inline _Tp &&__do_wrap(_Tp &&__x)
      {
        return static_cast<_Tp &&>(__x);
      }
  };
  template < typename _Tp, typename _Class >
  struct  _Maybe_wrap_member_pointer<_Tp _Class::*>
  {
      typedef ::std::_Mem_fn<_Tp _Class::*> type;
      static inline typename ::std::_Maybe_wrap_member_pointer<_Tp _Class::*>::type __do_wrap(_Tp _Class::*__pm)
      {
        return ((typename ::std::_Maybe_wrap_member_pointer<_Tp _Class::*>::type(__pm)));
      }
  };
  template <>
  struct  _Maybe_wrap_member_pointer<void>
  {
      typedef void type;
  };
  template < ::std::size_t _Ind, typename ..._Tp >
  inline auto __volget(volatile ::std::tuple<_Tp ...> &__tuple) -> volatile typename ::std::tuple_element<_Ind, ::std::tuple<_Tp ...> >::type &;
  template < ::std::size_t _Ind, typename ..._Tp >
  inline auto __volget(volatile ::std::tuple<_Tp ...> &__tuple) -> volatile typename ::std::tuple_element<_Ind, ::std::tuple<_Tp ...> >::type &
  {
    return std::get<_Ind>(const_cast< ::std::tuple<_Tp ...> &>(__tuple));
  }
  template < ::std::size_t _Ind, typename ..._Tp >
  inline auto __volget(const volatile ::std::tuple<_Tp ...> &__tuple) -> const volatile typename ::std::tuple_element<_Ind, ::std::tuple<_Tp ...> >::type &;
  template < ::std::size_t _Ind, typename ..._Tp >
  inline auto __volget(const volatile ::std::tuple<_Tp ...> &__tuple) -> const volatile typename ::std::tuple_element<_Ind, ::std::tuple<_Tp ...> >::type &
  {
    return std::get<_Ind>(const_cast<const ::std::tuple<_Tp ...> &>(__tuple));
  }
  template < typename _Signature >
  struct _Bind;
  template < typename _Functor, typename ..._Bound_args >
  class  _Bind<_Functor (_Bound_args ...)> : public ::std::_Weak_result_type<_Functor>
  {
      typedef ::std::_Bind<_Functor (_Bound_args ...)> __self_type;
      typedef typename ::std::_Build_index_tuple<sizeof...(_Bound_args)>::__type _Bound_indexes;
      _Functor _M_f;
      ::std::tuple<_Bound_args ...> _M_bound_args;
      template < typename _Result, typename ..._Args, ::std::size_t ... _Indexes >
      inline _Result __call(::std::tuple<_Args ...> &&__args, ::std::_Index_tuple<_Indexes ...>)
      {
        return ::std::_Bind<_Functor (_Bound_args ...)>::_M_f(::std::_Mu<_Bound_args>()(get<_Indexes>(::std::_Bind<_Functor (_Bound_args ...)>::_M_bound_args), __args) ...);
      }
      template < typename _Result, typename ..._Args, ::std::size_t ... _Indexes >
      inline _Result __call_c(::std::tuple<_Args ...> &&__args, ::std::_Index_tuple<_Indexes ...>) const 
      {
        return ::std::_Bind<_Functor (_Bound_args ...)>::_M_f(::std::_Mu<_Bound_args>()(get<_Indexes>(::std::_Bind<_Functor (_Bound_args ...)>::_M_bound_args), __args) ...);
      }
      template < typename _Result, typename ..._Args, ::std::size_t ... _Indexes >
      inline _Result __call_v(::std::tuple<_Args ...> &&__args, ::std::_Index_tuple<_Indexes ...>) volatile 
      {
        return ::std::_Bind<_Functor (_Bound_args ...)>::_M_f(::std::_Mu<_Bound_args>()(__volget<_Indexes>(::std::_Bind<_Functor (_Bound_args ...)>::_M_bound_args), __args) ...);
      }
      template < typename _Result, typename ..._Args, ::std::size_t ... _Indexes >
      inline _Result __call_c_v(::std::tuple<_Args ...> &&__args, ::std::_Index_tuple<_Indexes ...>) const volatile 
      {
        return ::std::_Bind<_Functor (_Bound_args ...)>::_M_f(::std::_Mu<_Bound_args>()(__volget<_Indexes>(::std::_Bind<_Functor (_Bound_args ...)>::_M_bound_args), __args) ...);
      }
    public:
      template < typename ..._Args >
      inline explicit _Bind(const _Functor &__f, _Args &&...__args)
        : _M_f(__f), _M_bound_args(std::forward<_Args>(__args) ...)
      {
      }
      template < typename ..._Args >
      inline explicit _Bind(_Functor &&__f, _Args &&...__args)
        : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args) ...)
      {
      }
      _Bind(const ::std::_Bind<_Functor (_Bound_args ...)> &) = default ;
      inline _Bind(::std::_Bind<_Functor (_Bound_args ...)> &&__b)
        : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      {
      }
      template < typename ..._Args, typename _Result = decltype(std::declval<_Functor>()(::std::_Mu<_Bound_args>()(std::declval<_Bound_args &>(), std::declval< ::std::tuple<_Args ...> &>()) ...)) >
      inline _Result operator ()(_Args &&...__args)
      {
        return this->__call<_Result>(std::forward_as_tuple(std::forward<_Args>(__args) ...), ((typename ::std::_Bind<_Functor (_Bound_args ...)>::_Bound_indexes())));
      }
      template < typename ..._Args, typename _Result = decltype(std::declval<typename ::std::enable_if<((sizeof...(_Args)) >= 0), typename ::std::add_const<_Functor>::type>::type>()(::std::_Mu<_Bound_args>()(std::declval<const _Bound_args &>(), std::declval< ::std::tuple<_Args ...> &>()) ...)) >
      inline _Result operator ()(_Args &&...__args) const 
      {
        return this->__call_c<_Result>(std::forward_as_tuple(std::forward<_Args>(__args) ...), ((typename ::std::_Bind<_Functor (_Bound_args ...)>::_Bound_indexes())));
      }
      template < typename ..._Args, typename _Result = decltype(std::declval<typename ::std::enable_if<((sizeof...(_Args)) >= 0), typename ::std::add_volatile<_Functor>::type>::type>()(::std::_Mu<_Bound_args>()(std::declval<volatile _Bound_args &>(), std::declval< ::std::tuple<_Args ...> &>()) ...)) >
      inline _Result operator ()(_Args &&...__args) volatile 
      {
        return this->__call_v<_Result>(std::forward_as_tuple(std::forward<_Args>(__args) ...), ((typename ::std::_Bind<_Functor (_Bound_args ...)>::_Bound_indexes())));
      }
      template < typename ..._Args, typename _Result = decltype(std::declval<typename ::std::enable_if<((sizeof...(_Args)) >= 0), typename ::std::add_cv<_Functor>::type>::type>()(::std::_Mu<_Bound_args>()(std::declval<const volatile _Bound_args &>(), std::declval< ::std::tuple<_Args ...> &>()) ...)) >
      inline _Result operator ()(_Args &&...__args) const volatile 
      {
        return this->__call_c_v<_Result>(std::forward_as_tuple(std::forward<_Args>(__args) ...), ((typename ::std::_Bind<_Functor (_Bound_args ...)>::_Bound_indexes())));
      }
  };
  template < typename _Result, typename _Signature >
  struct _Bind_result;
  template < typename _Result, typename _Functor, typename ..._Bound_args >
  class  _Bind_result<_Result, _Functor (_Bound_args ...)>
  {
      typedef ::std::_Bind_result<_Result, _Functor (_Bound_args ...)> __self_type;
      typedef typename ::std::_Build_index_tuple<sizeof...(_Bound_args)>::__type _Bound_indexes;
      _Functor _M_f;
      ::std::tuple<_Bound_args ...> _M_bound_args;
      template < typename _Res >
      struct  __enable_if_void : ::std::enable_if<is_void<_Res>::value, int>
      {
      };
      template < typename _Res >
      struct  __disable_if_void : ::std::enable_if<!is_void<_Res>::value, int>
      {
      };
      template < typename _Res, typename ..._Args, ::std::size_t ... _Indexes >
      inline _Result __call(::std::tuple<_Args ...> &&__args, ::std::_Index_tuple<_Indexes ...>, typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::template __disable_if_void< _Res>::type  = (0))
      {
        return ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_f(::std::_Mu<_Bound_args>()(get<_Indexes>(::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_bound_args), __args) ...);
      }
      template < typename _Res, typename ..._Args, ::std::size_t ... _Indexes >
      inline void __call(::std::tuple<_Args ...> &&__args, ::std::_Index_tuple<_Indexes ...>, typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::template __enable_if_void< _Res>::type  = (0))
      {
        ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_f(::std::_Mu<_Bound_args>()(get<_Indexes>(::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_bound_args), __args) ...);
      }
      template < typename _Res, typename ..._Args, ::std::size_t ... _Indexes >
      inline _Result __call(::std::tuple<_Args ...> &&__args, ::std::_Index_tuple<_Indexes ...>, typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::template __disable_if_void< _Res>::type  = (0)) const 
      {
        return ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_f(::std::_Mu<_Bound_args>()(get<_Indexes>(::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_bound_args), __args) ...);
      }
      template < typename _Res, typename ..._Args, ::std::size_t ... _Indexes >
      inline void __call(::std::tuple<_Args ...> &&__args, ::std::_Index_tuple<_Indexes ...>, typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::template __enable_if_void< _Res>::type  = (0)) const 
      {
        ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_f(::std::_Mu<_Bound_args>()(get<_Indexes>(::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_bound_args), __args) ...);
      }
      template < typename _Res, typename ..._Args, ::std::size_t ... _Indexes >
      inline _Result __call(::std::tuple<_Args ...> &&__args, ::std::_Index_tuple<_Indexes ...>, typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::template __disable_if_void< _Res>::type  = (0)) volatile 
      {
        return ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_f(::std::_Mu<_Bound_args>()(__volget<_Indexes>(::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_bound_args), __args) ...);
      }
      template < typename _Res, typename ..._Args, ::std::size_t ... _Indexes >
      inline void __call(::std::tuple<_Args ...> &&__args, ::std::_Index_tuple<_Indexes ...>, typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::template __enable_if_void< _Res>::type  = (0)) volatile 
      {
        ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_f(::std::_Mu<_Bound_args>()(__volget<_Indexes>(::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_bound_args), __args) ...);
      }
      template < typename _Res, typename ..._Args, ::std::size_t ... _Indexes >
      inline _Result __call(::std::tuple<_Args ...> &&__args, ::std::_Index_tuple<_Indexes ...>, typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::template __disable_if_void< _Res>::type  = (0)) const volatile 
      {
        return ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_f(::std::_Mu<_Bound_args>()(__volget<_Indexes>(::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_bound_args), __args) ...);
      }
      template < typename _Res, typename ..._Args, ::std::size_t ... _Indexes >
      inline void __call(::std::tuple<_Args ...> &&__args, ::std::_Index_tuple<_Indexes ...>, typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::template __enable_if_void< _Res>::type  = (0)) const volatile 
      {
        ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_f(::std::_Mu<_Bound_args>()(__volget<_Indexes>(::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_M_bound_args), __args) ...);
      }
    public:
      typedef _Result result_type;
      template < typename ..._Args >
      inline explicit _Bind_result(const _Functor &__f, _Args &&...__args)
        : _M_f(__f), _M_bound_args(std::forward<_Args>(__args) ...)
      {
      }
      template < typename ..._Args >
      inline explicit _Bind_result(_Functor &&__f, _Args &&...__args)
        : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args) ...)
      {
      }
      _Bind_result(const ::std::_Bind_result<_Result, _Functor (_Bound_args ...)> &) = default ;
      inline _Bind_result(::std::_Bind_result<_Result, _Functor (_Bound_args ...)> &&__b)
        : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      {
      }
      template < typename ..._Args >
      inline typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::result_type operator ()(_Args &&...__args)
      {
        return this->__call<_Result>(std::forward_as_tuple(std::forward<_Args>(__args) ...), ((typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_Bound_indexes())));
      }
      template < typename ..._Args >
      inline typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::result_type operator ()(_Args &&...__args) const 
      {
        return this->__call<_Result>(std::forward_as_tuple(std::forward<_Args>(__args) ...), ((typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_Bound_indexes())));
      }
      template < typename ..._Args >
      inline typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::result_type operator ()(_Args &&...__args) volatile 
      {
        return this->__call<_Result>(std::forward_as_tuple(std::forward<_Args>(__args) ...), ((typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_Bound_indexes())));
      }
      template < typename ..._Args >
      inline typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::result_type operator ()(_Args &&...__args) const volatile 
      {
        return this->__call<_Result>(std::forward_as_tuple(std::forward<_Args>(__args) ...), ((typename ::std::_Bind_result<_Result, _Functor (_Bound_args ...)>::_Bound_indexes())));
      }
  };
  template < typename _Signature >
  struct  is_bind_expression< ::std::_Bind<_Signature> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Signature >
  struct  is_bind_expression<const ::std::_Bind<_Signature> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Signature >
  struct  is_bind_expression<volatile ::std::_Bind<_Signature> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Signature >
  struct  is_bind_expression<const volatile ::std::_Bind<_Signature> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Result, typename _Signature >
  struct  is_bind_expression< ::std::_Bind_result<_Result, _Signature> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Result, typename _Signature >
  struct  is_bind_expression<const ::std::_Bind_result<_Result, _Signature> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Result, typename _Signature >
  struct  is_bind_expression<volatile ::std::_Bind_result<_Result, _Signature> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Result, typename _Signature >
  struct  is_bind_expression<const volatile ::std::_Bind_result<_Result, _Signature> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp, typename _Tp2 = typename ::std::decay<_Tp>::type >
  using __is_socketlike = ::std::__or_< ::std::is_integral<_Tp2>, ::std::is_enum<_Tp2> >;
  template < bool _SocketLike, typename _Func, typename ..._BoundArgs >
  struct  _Bind_helper
  {
      typedef ::std::_Maybe_wrap_member_pointer<typename ::std::decay<_Func>::type> __maybe_type;
      typedef typename ::std::_Maybe_wrap_member_pointer<typename ::std::decay<_Func>::type>::type __func_type;
      typedef ::std::_Bind<typename ::std::_Bind_helper<_SocketLike, _Func, _BoundArgs ...>::__func_type (typename ::std::decay<_BoundArgs>::type ...)> type;
  };
  template < typename _Func, typename ..._BoundArgs >
  struct  _Bind_helper<true, _Func, _BoundArgs ...>
  {
  };
  template < typename _Func, typename ..._BoundArgs >
  inline typename ::std::_Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs ...>::type bind(_Func &&__f, _BoundArgs &&...__args);
  template < typename _Func, typename ..._BoundArgs >
  inline typename ::std::_Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs ...>::type bind(_Func &&__f, _BoundArgs &&...__args)
  {
    typedef ::std::_Bind_helper<false, _Func, _BoundArgs ...> __helper_type;
    typedef typename ::std::_Bind_helper<false, _Func, _BoundArgs ...>::__maybe_type __maybe_type;
    typedef typename ::std::_Bind_helper<false, _Func, _BoundArgs ...>::type __result_type;
    return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)), std::forward<_BoundArgs>(__args) ...);
  }
  template < typename _Result, typename _Func, typename ..._BoundArgs >
  struct  _Bindres_helper
  {
      typedef ::std::_Maybe_wrap_member_pointer<typename ::std::decay<_Func>::type> __maybe_type;
      typedef typename ::std::_Maybe_wrap_member_pointer<typename ::std::decay<_Func>::type>::type __functor_type;
      typedef ::std::_Bind_result<_Result, typename ::std::_Bindres_helper<_Result, _Func, _BoundArgs ...>::__functor_type (typename ::std::decay<_BoundArgs>::type ...)> type;
  };
  template < typename _Result, typename _Func, typename ..._BoundArgs >
  inline typename ::std::_Bindres_helper<_Result, _Func, _BoundArgs ...>::type bind(_Func &&__f, _BoundArgs &&...__args);
  template < typename _Result, typename _Func, typename ..._BoundArgs >
  inline typename ::std::_Bindres_helper<_Result, _Func, _BoundArgs ...>::type bind(_Func &&__f, _BoundArgs &&...__args)
  {
    typedef ::std::_Bindres_helper<_Result, _Func, _BoundArgs ...> __helper_type;
    typedef typename ::std::_Bindres_helper<_Result, _Func, _BoundArgs ...>::__maybe_type __maybe_type;
    typedef typename ::std::_Bindres_helper<_Result, _Func, _BoundArgs ...>::type __result_type;
    return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)), std::forward<_BoundArgs>(__args) ...);
  }
  template < typename _Signature >
  struct _Bind_simple;
  template < typename _Callable, typename ..._Args >
  struct  _Bind_simple<_Callable (_Args ...)>
  {
      typedef typename ::std::result_of<_Callable (_Args ...)>::type result_type;
      template < typename ..._Args2, typename __type_tpl__param_2_1__ = typename ::std::enable_if<(sizeof...(_Args)) == (sizeof...(_Args2))>::type >
      inline explicit _Bind_simple(const _Callable &__callable, _Args2 &&...__args)
        : _M_bound(__callable, std::forward<_Args2>(__args) ...)
      {
      }
      template < typename ..._Args2, typename __type_tpl__param_2_1__ = typename ::std::enable_if<(sizeof...(_Args)) == (sizeof...(_Args2))>::type >
      inline explicit _Bind_simple(_Callable &&__callable, _Args2 &&...__args)
        : _M_bound(std::move(__callable), std::forward<_Args2>(__args) ...)
      {
      }
      _Bind_simple(const ::std::_Bind_simple<_Callable (_Args ...)> &) = default ;
      _Bind_simple(::std::_Bind_simple<_Callable (_Args ...)> &&) = default ;
      inline typename ::std::_Bind_simple<_Callable (_Args ...)>::result_type operator ()()
      {
        typedef typename ::std::_Build_index_tuple<sizeof...(_Args)>::__type _Indices;
        return (*this)._M_invoke(_Indices());
      }
    private:
      template < ::std::size_t ... _Indices >
      inline typename ::std::result_of<_Callable (_Args ...)>::type _M_invoke(::std::_Index_tuple<_Indices ...>)
      {
        return std::forward<_Callable>(std::get<0>(::std::_Bind_simple<_Callable (_Args ...)>::_M_bound))(std::forward<_Args>(std::get<_Indices + 1>(::std::_Bind_simple<_Callable (_Args ...)>::_M_bound)) ...);
      }
      ::std::tuple<_Callable, _Args ...> _M_bound;
  };
  template < typename _Func, typename ..._BoundArgs >
  struct  _Bind_simple_helper
  {
      typedef ::std::_Maybe_wrap_member_pointer<typename ::std::decay<_Func>::type> __maybe_type;
      typedef typename ::std::_Maybe_wrap_member_pointer<typename ::std::decay<_Func>::type>::type __func_type;
      typedef ::std::_Bind_simple<typename ::std::_Bind_simple_helper<_Func, _BoundArgs ...>::__func_type (typename ::std::decay<_BoundArgs>::type ...)> __type;
  };
  template < typename _Callable, typename ..._Args >
  typename ::std::_Bind_simple_helper<_Callable, _Args ...>::__type __bind_simple(_Callable &&__callable, _Args &&...__args);
  template < typename _Callable, typename ..._Args >
  typename ::std::_Bind_simple_helper<_Callable, _Args ...>::__type __bind_simple(_Callable &&__callable, _Args &&...__args)
  {
    typedef ::std::_Bind_simple_helper<_Callable, _Args ...> __helper_type;
    typedef typename ::std::_Bind_simple_helper<_Callable, _Args ...>::__maybe_type __maybe_type;
    typedef typename ::std::_Bind_simple_helper<_Callable, _Args ...>::__type __result_type;
    return __result_type(__maybe_type::__do_wrap(std::forward<_Callable>(__callable)), std::forward<_Args>(__args) ...);
  }
  class  bad_function_call : public ::std::exception
  {
    public:
      virtual ~bad_function_call() noexcept(true);
      virtual const char *what() const  noexcept(true);
  };
  template < typename _Tp >
  struct  __is_location_invariant : ::std::integral_constant<bool, is_pointer<_Tp>::value || is_member_pointer<_Tp>::value>
  {
  };
  class _Undefined_class;
  union  _Nocopy_types
  {
      void *_M_object;
      const void *_M_const_object;
      void (*_M_function_pointer)();
      void (::std::_Undefined_class::*_M_member_pointer)();
  };
  union  _Any_data
  {
      inline void *_M_access()
      {
        return &(*this)._M_pod_data[0];
      }
      inline const void *_M_access() const 
      {
        return &(*this)._M_pod_data[0];
      }
      template < typename _Tp >
      inline _Tp &_M_access()
      {
        return *static_cast<_Tp *>((*this).::std::_Any_data::_M_access());
      }
      template < typename _Tp >
      inline const _Tp &_M_access() const 
      {
        return *static_cast<const _Tp *>((*this).::std::_Any_data::_M_access());
      }
      ::std::_Nocopy_types _M_unused;
      char _M_pod_data[16L];
  };
  enum _Manager_operation
  {
    __get_type_info = 0,
    __get_functor_ptr = 1,
    __clone_functor = 2,
    __destroy_functor = 3
  };
  template < typename _Tp >
  struct  _Simple_type_wrapper
  {
      inline _Simple_type_wrapper(_Tp __value)
        : __value(__value)
      {
      }
      _Tp __value;
  };
  template < typename _Tp >
  struct  __is_location_invariant< ::std::_Simple_type_wrapper<_Tp> > : ::std::__is_location_invariant<_Tp>
  {
  };
  template < typename _Functor >
  inline _Functor &__callable_functor(_Functor &__f);
  template < typename _Functor >
  inline _Functor &__callable_functor(_Functor &__f)
  {
    return __f;
  }
  template < typename _Member, typename _Class >
  inline ::std::_Mem_fn<_Member _Class::*> __callable_functor(_Member _Class::*&__p);
  template < typename _Member, typename _Class >
  inline ::std::_Mem_fn<_Member _Class::*> __callable_functor(_Member _Class::*&__p)
  {
    return std::mem_fn(__p);
  }
  template < typename _Member, typename _Class >
  inline ::std::_Mem_fn<_Member _Class::*> __callable_functor(_Member _Class::*const &__p);
  template < typename _Member, typename _Class >
  inline ::std::_Mem_fn<_Member _Class::*> __callable_functor(_Member _Class::*const &__p)
  {
    return std::mem_fn(__p);
  }
  template < typename _Member, typename _Class >
  inline ::std::_Mem_fn<_Member _Class::*> __callable_functor(_Member _Class::*volatile &__p);
  template < typename _Member, typename _Class >
  inline ::std::_Mem_fn<_Member _Class::*> __callable_functor(_Member _Class::*volatile &__p)
  {
    return std::mem_fn(__p);
  }
  template < typename _Member, typename _Class >
  inline ::std::_Mem_fn<_Member _Class::*> __callable_functor(_Member _Class::*const volatile &__p);
  template < typename _Member, typename _Class >
  inline ::std::_Mem_fn<_Member _Class::*> __callable_functor(_Member _Class::*const volatile &__p)
  {
    return std::mem_fn(__p);
  }
  template < typename _Signature >
  class function;
  class  _Function_base
  {
    public:
      static const ::std::size_t _M_max_size = sizeof(::std::_Nocopy_types);
      static const ::std::size_t _M_max_align = alignof(::std::_Nocopy_types);
      template < typename _Functor >
      class  _Base_manager
      {
        protected:
          static const bool __stored_locally = ((__is_location_invariant<_Functor>::value && sizeof(_Functor) <= ::std::_Function_base::_M_max_size) && (alignof(_Functor)) <= ::std::_Function_base::_M_max_align) && ::std::_Function_base::_M_max_align % (alignof(_Functor)) == 0;
          typedef ::std::integral_constant<bool, ::std::_Function_base::_Base_manager<_Functor>::__stored_locally> _Local_storage;
          static inline _Functor *_M_get_pointer(const ::std::_Any_data &__source)
          {
            const _Functor *__ptr = ::std::_Function_base::_Base_manager<_Functor>::__stored_locally ? std::__addressof(__source._M_access<_Functor>()) : __source._M_access<_Functor *>();
            return const_cast<_Functor *>(__ptr);
          }
          static inline void _M_clone(::std::_Any_data &__dest, const ::std::_Any_data &__source, ::std::true_type)
          {
            new (__dest.::std::_Any_data::_M_access())_Functor(__source._M_access<_Functor>());
          }
          static inline void _M_clone(::std::_Any_data &__dest, const ::std::_Any_data &__source, ::std::false_type)
          {
            __dest._M_access<_Functor *>() = (new _Functor(*__source._M_access<_Functor *>()));
          }
          static inline void _M_destroy(::std::_Any_data &__victim, ::std::true_type)
          {
            __victim._M_access<_Functor>().~_Functor();
          }
          static inline void _M_destroy(::std::_Any_data &__victim, ::std::false_type)
          {
            delete __victim._M_access<_Functor *>();
          }
        public:
          static inline bool _M_manager(::std::_Any_data &__dest, const ::std::_Any_data &__source, ::std::_Manager_operation __op)
          {
            switch (__op)
                {
                  case ::std::__get_type_info :
                  __dest.::std::_Any_data::_M_access<const ::std::type_info *>() = &typeid(_Functor);
                  break;
                  case ::std::__get_functor_ptr :
                  __dest._M_access<_Functor *>() = _M_get_pointer(__source);
                  break;
                  case ::std::__clone_functor :
                  _M_clone(__dest, __source, ((typename ::std::_Function_base::_Base_manager<_Functor>::_Local_storage())));
                  break;
                  case ::std::__destroy_functor :
                  _M_destroy(__dest, ((typename ::std::_Function_base::_Base_manager<_Functor>::_Local_storage())));
                  break;
                }
            return false;
          }
          static inline void _M_init_functor(::std::_Any_data &__functor, _Functor &&__f)
          {
            _M_init_functor(__functor, std::move(__f), ((typename ::std::_Function_base::_Base_manager<_Functor>::_Local_storage())));
          }
          template < typename _Signature >
          static inline bool _M_not_empty_function(const ::std::function<_Signature> &__f)
          {
            return static_cast<bool>(__f);
          }
          template < typename _Tp >
          static inline bool _M_not_empty_function(_Tp *const &__fp)
          {
            return __fp;
          }
          template < typename _Class, typename _Tp >
          static inline bool _M_not_empty_function(_Tp _Class::*const &__mp)
          {
            return __mp;
          }
          template < typename _Tp >
          static inline bool _M_not_empty_function(const _Tp &)
          {
            return true;
          }
        private:
          static inline void _M_init_functor(::std::_Any_data &__functor, _Functor &&__f, ::std::true_type)
          {
            new (__functor.::std::_Any_data::_M_access())_Functor(std::move(__f));
          }
          static inline void _M_init_functor(::std::_Any_data &__functor, _Functor &&__f, ::std::false_type)
          {
            __functor._M_access<_Functor *>() = (new _Functor(std::move(__f)));
          }
      };
      template < typename _Functor >
      class  _Ref_manager : public ::std::_Function_base::_Base_manager<_Functor *>
      {
          typedef typename ::std::_Function_base::_Base_manager<_Functor *> _Base;
        public:
          static inline bool _M_manager(::std::_Any_data &__dest, const ::std::_Any_data &__source, ::std::_Manager_operation __op)
          {
            switch (__op)
                {
                  case ::std::__get_type_info :
                  __dest.::std::_Any_data::_M_access<const ::std::type_info *>() = &typeid(_Functor);
                  break;
                  case ::std::__get_functor_ptr :
                  __dest._M_access<_Functor *>() = *_Base::_M_get_pointer(__source);
                  return is_const<_Functor>::value;
                  break;
                  default :
                  _Base::_M_manager(__dest, __source, __op);
                }
            return false;
          }
          static inline void _M_init_functor(::std::_Any_data &__functor, ::std::reference_wrapper<_Functor> __f)
          {
            _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
          }
      };
      inline _Function_base()
        : _M_manager(0)
      {
      }
      inline ~_Function_base()
      {
        if ((*this)._M_manager)
          {
            (*this)._M_manager((*this)._M_functor, (*this)._M_functor, ::std::__destroy_functor);
          }
      }
      inline bool _M_empty() const 
      {
        return !(*this)._M_manager;
      }
      typedef bool (*_Manager_type)(::std::_Any_data &, const ::std::_Any_data &, ::std::_Manager_operation);
      ::std::_Any_data _M_functor;
      ::std::_Function_base::_Manager_type _M_manager;
  };
  template < typename _Signature, typename _Functor >
  class _Function_handler;
  template < typename _Res, typename _Functor, typename ..._ArgTypes >
  class  _Function_handler<_Res (_ArgTypes ...), _Functor> : public ::std::_Function_base::_Base_manager<_Functor>
  {
      typedef typename ::std::_Function_base::_Base_manager<_Functor> _Base;
    public:
      static inline _Res _M_invoke(const ::std::_Any_data &__functor, _ArgTypes ...__args)
      {
        return (*_Base::_M_get_pointer(__functor))(std::forward<_ArgTypes>(__args) ...);
      }
  };
  template < typename _Functor, typename ..._ArgTypes >
  class  _Function_handler<void (_ArgTypes ...), _Functor> : public ::std::_Function_base::_Base_manager<_Functor>
  {
      typedef typename ::std::_Function_base::_Base_manager<_Functor> _Base;
    public:
      static inline void _M_invoke(const ::std::_Any_data &__functor, _ArgTypes ...__args)
      {
        (*_Base::_M_get_pointer(__functor))(std::forward<_ArgTypes>(__args) ...);
      }
  };
  template < typename _Res, typename _Functor, typename ..._ArgTypes >
  class  _Function_handler<_Res (_ArgTypes ...), ::std::reference_wrapper<_Functor> > : public ::std::_Function_base::_Ref_manager<_Functor>
  {
      typedef typename ::std::_Function_base::_Ref_manager<_Functor> _Base;
    public:
      static inline _Res _M_invoke(const ::std::_Any_data &__functor, _ArgTypes ...__args)
      {
        return __callable_functor(**_Base::_M_get_pointer(__functor))(std::forward<_ArgTypes>(__args) ...);
      }
  };
  template < typename _Functor, typename ..._ArgTypes >
  class  _Function_handler<void (_ArgTypes ...), ::std::reference_wrapper<_Functor> > : public ::std::_Function_base::_Ref_manager<_Functor>
  {
      typedef typename ::std::_Function_base::_Ref_manager<_Functor> _Base;
    public:
      static inline void _M_invoke(const ::std::_Any_data &__functor, _ArgTypes ...__args)
      {
        __callable_functor(**_Base::_M_get_pointer(__functor))(std::forward<_ArgTypes>(__args) ...);
      }
  };
  template < typename _Class, typename _Member, typename _Res, typename ..._ArgTypes >
  class  _Function_handler<_Res (_ArgTypes ...), _Member _Class::*> : public ::std::_Function_handler<void (_ArgTypes ...), _Member _Class::*>
  {
      typedef ::std::_Function_handler<void (_ArgTypes ...), _Member _Class::*> _Base;
    public:
      static inline _Res _M_invoke(const ::std::_Any_data &__functor, _ArgTypes ...__args)
      {
        return std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(std::forward<_ArgTypes>(__args) ...);
      }
  };
  template < typename _Class, typename _Member, typename ..._ArgTypes >
  class  _Function_handler<void (_ArgTypes ...), _Member _Class::*> : public ::std::_Function_base::_Base_manager< ::std::_Simple_type_wrapper<_Member _Class::*> >
  {
      typedef _Member _Class::*_Functor;
      typedef ::std::_Simple_type_wrapper<typename ::std::_Function_handler<void (_ArgTypes ...), _Member _Class::*>::_Functor> _Wrapper;
      typedef typename ::std::_Function_base::_Base_manager<typename ::std::_Function_handler<void (_ArgTypes ...), _Member _Class::*>::_Wrapper> _Base;
    public:
      static inline bool _M_manager(::std::_Any_data &__dest, const ::std::_Any_data &__source, ::std::_Manager_operation __op)
      {
        switch (__op)
            {
              case ::std::__get_type_info :
              __dest.::std::_Any_data::_M_access<const ::std::type_info *>() = &typeid(typename ::std::_Function_handler<void (_ArgTypes ...), _Member _Class::*>::_Functor);
              break;
              case ::std::__get_functor_ptr :
              __dest._M_access<typename ::std::_Function_handler<void (_ArgTypes ...), _Member _Class::*>::_Functor *>() = &_Base::_M_get_pointer(__source)->__value;
              break;
              default :
              _Base::_M_manager(__dest, __source, __op);
            }
        return false;
      }
      static inline void _M_invoke(const ::std::_Any_data &__functor, _ArgTypes ...__args)
      {
        std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(std::forward<_ArgTypes>(__args) ...);
      }
  };
  template < typename _From, typename _To >
  using __check_func_return_type = ::std::__or_< ::std::is_void<_To>, ::std::is_convertible<_From, _To> >;
  template < typename _Res, typename ..._ArgTypes >
  class  function<_Res (_ArgTypes ...)> : public ::std::_Maybe_unary_or_binary_function<_Res, _ArgTypes ...>, ::std::_Function_base
  {
      typedef _Res _Signature_type(_ArgTypes ...);
      template < typename _Functor >
      using _Invoke = decltype(__callable_functor(std::declval<_Functor &>())(std::declval<_ArgTypes>() ...));
      template < typename _Tp >
      using _NotSelf = ::std::__not_< ::std::is_same<_Tp, ::std::function<_Res (_ArgTypes ...)> > >;
      template < typename _Functor >
      using _Callable = ::std::__and_<typename ::std::function<_Res (_ArgTypes ...)>::template _NotSelf<_Functor>, ::std::__check_func_return_type<typename ::std::function<_Res (_ArgTypes ...)>::template _Invoke<_Functor>, _Res> >;
      template < typename _Cond, typename _Tp >
      using _Requires = typename ::std::enable_if<_Cond::value, _Tp>::type;
    public:
      typedef _Res result_type;
      inline function() noexcept(true)
        : _Function_base()
      {
      }
      inline function(::std::nullptr_t) noexcept(true)
        : _Function_base()
      {
      }
      function(const ::std::function<_Res (_ArgTypes ...)> &__x);
      inline function(::std::function<_Res (_ArgTypes ...)> &&__x)
        : _Function_base()
      {
        __x.swap(*this);
      }
      template < typename _Functor, typename __type_tpl__param_2_1__ = typename ::std::function<_Res (_ArgTypes ...)>::template _Requires<typename ::std::function<_Res (_ArgTypes ...)>::template _Callable<_Functor>, void> >
      function(_Functor __f);
      inline ::std::function<_Res (_ArgTypes ...)> &operator =(const ::std::function<_Res (_ArgTypes ...)> &__x)
      {
        ::std::function<_Res (_ArgTypes ...)>(__x).swap(*this);
        return *this;
      }
      inline ::std::function<_Res (_ArgTypes ...)> &operator =(::std::function<_Res (_ArgTypes ...)> &&__x)
      {
        ::std::function<_Res (_ArgTypes ...)>(std::move(__x)).swap(*this);
        return *this;
      }
      inline ::std::function<_Res (_ArgTypes ...)> &operator =(::std::nullptr_t)
      {
        if ((*this)._M_manager)
          {
            (*this)._M_manager((*this)._M_functor, (*this)._M_functor, ::std::__destroy_functor);
            (*this)._M_manager = 0;
            ::std::function<_Res (_ArgTypes ...)>::_M_invoker = 0;
          }
        return *this;
      }
      template < typename _Functor >
      inline typename ::std::function<_Res (_ArgTypes ...)>::template _Requires<typename ::std::function<_Res (_ArgTypes ...)>::template _Callable<typename ::std::decay<_Functor>::type>, ::std::function<_Res (_ArgTypes ...)> &> operator =(_Functor &&__f)
      {
        ::std::function<_Res (_ArgTypes ...)>(std::forward<_Functor>(__f)).swap(*this);
        return *this;
      }
      template < typename _Functor >
      inline ::std::function<_Res (_ArgTypes ...)> &operator =(::std::reference_wrapper<_Functor> __f) noexcept(true)
      {
        ::std::function<_Res (_ArgTypes ...)>(__f).swap(*this);
        return *this;
      }
      inline void swap(::std::function<_Res (_ArgTypes ...)> &__x)
      {
        std::swap((*this)._M_functor, __x._M_functor);
        std::swap((*this)._M_manager, __x._M_manager);
        std::swap(::std::function<_Res (_ArgTypes ...)>::_M_invoker, __x._M_invoker);
      }
      inline explicit operator bool() const  noexcept(true)
      {
        return !(*this)._M_empty();
      }
      _Res operator ()(_ArgTypes ...__args) const ;
      const ::std::type_info &target_type() const  noexcept(true);
      template < typename _Functor >
      _Functor *target() noexcept(true);
      template < typename _Functor >
      const _Functor *target() const  noexcept(true);
    private:
      typedef _Res (*_Invoker_type)(const ::std::_Any_data &, _ArgTypes ...);
      typename ::std::function<_Res (_ArgTypes ...)>::_Invoker_type _M_invoker;
  };
  template < typename _Res, typename ..._ArgTypes >
  function<_Res (_ArgTypes ...)>::function(const ::std::function<_Res (_ArgTypes ...)> &__x)
    : _Function_base()
  {
    if (static_cast<bool>(__x))
      {
        __x._M_manager((*this)._M_functor, __x._M_functor, ::std::__clone_functor);
        ::std::function<_Res (_ArgTypes ...)>::_M_invoker = __x._M_invoker;
        (*this)._M_manager = __x._M_manager;
      }
  }
  template < typename _Res, typename ..._ArgTypes >
  template < typename _Functor, typename __type_tpl__param_2_1__ >
  function<_Res (_ArgTypes ...)>::function(_Functor __f)
    : _Function_base()
  {
    typedef ::std::_Function_handler<typename ::std::function<_Res (_ArgTypes ...)>::_Signature_type, _Functor> _My_handler;
    if (_My_handler::_M_not_empty_function(__f))
      {
        _My_handler::_M_init_functor((*this)._M_functor, std::move(__f));
        ::std::function<_Res (_ArgTypes ...)>::_M_invoker = &_My_handler::_M_invoke;
        (*this)._M_manager = &_My_handler::_M_manager;
      }
  }
  template < typename _Res, typename ..._ArgTypes >
  _Res function<_Res (_ArgTypes ...)>::operator ()(_ArgTypes ...__args) const 
  {
    if ((*this)._M_empty())
      {
        ::std::__throw_bad_function_call();
      }
    return ::std::function<_Res (_ArgTypes ...)>::_M_invoker((*this)._M_functor, std::forward<_ArgTypes>(__args) ...);
  }
  template < typename _Res, typename ..._ArgTypes >
  const ::std::type_info &function<_Res (_ArgTypes ...)>::target_type() const  noexcept(true)
  {
    if ((*this)._M_manager)
      {
        ::std::_Any_data __typeinfo_result /* () */ ;
        (*this)._M_manager(__typeinfo_result, (*this)._M_functor, ::std::__get_type_info);
        return *__typeinfo_result.::std::_Any_data::_M_access<const ::std::type_info *>();
      }
    else
      {
        return typeid(void);
      }
  }
  template < typename _Res, typename ..._ArgTypes >
  template < typename _Functor >
  _Functor *function<_Res (_ArgTypes ...)>::target() noexcept(true)
  {
    if (typeid(_Functor) == (*this).target_type() && (*this)._M_manager)
      {
        ::std::_Any_data __ptr /* () */ ;
        if ((*this)._M_manager(__ptr, (*this)._M_functor, ::std::__get_functor_ptr) && !is_const<_Functor>::value)
          {
            return 0;
          }
        else
          {
            return __ptr._M_access<_Functor *>();
          }
      }
    else
      {
        return 0;
      }
  }
  template < typename _Res, typename ..._ArgTypes >
  template < typename _Functor >
  const _Functor *function<_Res (_ArgTypes ...)>::target() const  noexcept(true)
  {
    if (typeid(_Functor) == (*this).target_type() && (*this)._M_manager)
      {
        ::std::_Any_data __ptr /* () */ ;
        (*this)._M_manager(__ptr, (*this)._M_functor, ::std::__get_functor_ptr);
        return __ptr._M_access<const _Functor *>();
      }
    else
      {
        return 0;
      }
  }
  template < typename _Res, typename ..._Args >
  inline bool operator ==(const ::std::function<_Res (_Args ...)> &__f, ::std::nullptr_t) noexcept(true);
  template < typename _Res, typename ..._Args >
  inline bool operator ==(const ::std::function<_Res (_Args ...)> &__f, ::std::nullptr_t) noexcept(true)
  {
    return !static_cast<bool>(__f);
  }
  template < typename _Res, typename ..._Args >
  inline bool operator ==(::std::nullptr_t, const ::std::function<_Res (_Args ...)> &__f) noexcept(true);
  template < typename _Res, typename ..._Args >
  inline bool operator ==(::std::nullptr_t, const ::std::function<_Res (_Args ...)> &__f) noexcept(true)
  {
    return !static_cast<bool>(__f);
  }
  template < typename _Res, typename ..._Args >
  inline bool operator !=(const ::std::function<_Res (_Args ...)> &__f, ::std::nullptr_t) noexcept(true);
  template < typename _Res, typename ..._Args >
  inline bool operator !=(const ::std::function<_Res (_Args ...)> &__f, ::std::nullptr_t) noexcept(true)
  {
    return static_cast<bool>(__f);
  }
  template < typename _Res, typename ..._Args >
  inline bool operator !=(::std::nullptr_t, const ::std::function<_Res (_Args ...)> &__f) noexcept(true);
  template < typename _Res, typename ..._Args >
  inline bool operator !=(::std::nullptr_t, const ::std::function<_Res (_Args ...)> &__f) noexcept(true)
  {
    return static_cast<bool>(__f);
  }
  template < typename _Res, typename ..._Args >
  inline void swap(::std::function<_Res (_Args ...)> &__x, ::std::function<_Res (_Args ...)> &__y);
  template < typename _Res, typename ..._Args >
  inline void swap(::std::function<_Res (_Args ...)> &__x, ::std::function<_Res (_Args ...)> &__y)
  {
    __x.swap(__y);
  }
  template < typename __type_tpl__param_1_0__ >
  class __attribute__((__deprecated__)) auto_ptr;
  template < typename _Tp >
  struct  default_delete
  {
      inline constexpr default_delete() noexcept(true) = default ;
      template < typename _Up, typename __type_tpl__param_2_1__ = typename ::std::enable_if<is_convertible<_Up *, _Tp *>::value>::type >
      inline default_delete(const ::std::default_delete<_Up> &) noexcept(true)
      {
      }
      inline void operator ()(_Tp *__ptr) const 
      {
        static_assert(sizeof(_Tp) > 0, "can\'t delete pointer to incomplete type");
        delete __ptr;
      }
  };
  template < typename _Tp >
  struct  default_delete<_Tp []>
  {
    private:
      template < typename _Up >
      using __remove_cv = typename ::std::remove_cv<_Up>::type;
      template < typename _Up >
      using __is_derived_Tp = ::std::__and_< ::std::is_base_of<_Tp, _Up>, ::std::__not_< ::std::is_same<typename ::std::default_delete<_Tp []>::template __remove_cv<_Tp>, typename ::std::default_delete<_Tp []>::template __remove_cv<_Up> > > >;
    public:
      inline constexpr default_delete() noexcept(true) = default ;
      template < typename _Up, typename __type_tpl__param_2_1__ = typename ::std::enable_if<!__is_derived_Tp<_Up>::value>::type >
      inline default_delete(const ::std::default_delete<_Up []> &) noexcept(true)
      {
      }
      inline void operator ()(_Tp *__ptr) const 
      {
        static_assert(sizeof(_Tp) > 0, "can\'t delete pointer to incomplete type");
        delete[] __ptr;
      }
      template < typename _Up >
      typename ::std::enable_if<__is_derived_Tp<_Up>::value>::type operator ()(_Up *) const  = delete ;
  };
  template < typename _Tp, typename _Dp = ::std::default_delete<_Tp> >
  class  unique_ptr
  {
      class  _Pointer
      {
          template < typename _Up >
          static typename _Up::pointer __test(typename _Up::pointer *);
          template < typename _Up >
          static _Tp *__test(...);
          typedef typename ::std::remove_reference<_Dp>::type _Del;
        public:
          typedef decltype(__test<typename ::std::unique_ptr<_Tp, _Dp>::_Pointer::_Del>(0)) type;
      };
      typedef ::std::tuple<typename ::std::unique_ptr<_Tp, _Dp>::_Pointer::type, _Dp> __tuple_type;
      typename ::std::unique_ptr<_Tp, _Dp>::__tuple_type _M_t;
    public:
      typedef typename ::std::unique_ptr<_Tp, _Dp>::_Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;
      inline constexpr unique_ptr() noexcept(true)
        : _M_t()
      {
        static_assert(!is_pointer<typename ::std::unique_ptr<_Tp, _Dp>::deleter_type>::value, "constructed with null function pointer deleter");
      }
      inline explicit unique_ptr(typename ::std::unique_ptr<_Tp, _Dp>::pointer __p) noexcept(true)
        : _M_t(__p, ((typename ::std::unique_ptr<_Tp, _Dp>::deleter_type())))
      {
        static_assert(!is_pointer<typename ::std::unique_ptr<_Tp, _Dp>::deleter_type>::value, "constructed with null function pointer deleter");
      }
      inline unique_ptr(typename ::std::unique_ptr<_Tp, _Dp>::pointer __p, typename ::std::conditional<is_reference<typename ::std::unique_ptr<_Tp, _Dp>::deleter_type>::value, typename ::std::unique_ptr<_Tp, _Dp>::deleter_type, const typename ::std::unique_ptr<_Tp, _Dp>::deleter_type &>::type __d) noexcept(true)
        : _M_t(__p, __d)
      {
      }
      inline unique_ptr(typename ::std::unique_ptr<_Tp, _Dp>::pointer __p, typename ::std::remove_reference<typename ::std::unique_ptr<_Tp, _Dp>::deleter_type>::type &&__d) noexcept(true)
        : _M_t(std::move(__p), std::move(__d))
      {
        static_assert(!std::is_reference<typename ::std::unique_ptr<_Tp, _Dp>::deleter_type>::value, "rvalue deleter bound to reference");
      }
      inline constexpr unique_ptr(::std::nullptr_t) noexcept(true)
        : unique_ptr()
      {
      }
      inline unique_ptr(::std::unique_ptr<_Tp, _Dp> &&__u) noexcept(true)
        : _M_t(__u.release(), std::forward<typename ::std::unique_ptr<_Tp, _Dp>::deleter_type>(__u.get_deleter()))
      {
      }
      template < typename _Up, typename _Ep, typename __type_tpl__param_2_2__ = ::std::_Require< ::std::is_convertible<typename ::std::unique_ptr<_Up, _Ep>::pointer, typename ::std::unique_ptr<_Tp, _Dp>::pointer>, ::std::__not_< ::std::is_array<_Up> >, typename ::std::conditional<is_reference<_Dp>::value, ::std::is_same<_Ep, _Dp>, ::std::is_convertible<_Ep, _Dp> >::type> >
      inline unique_ptr(::std::unique_ptr<_Up, _Ep> &&__u) noexcept(true)
        : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
      {
      }
      template < typename _Up, typename __type_tpl__param_2_1__ = ::std::_Require< ::std::is_convertible<_Up *, _Tp *>, ::std::is_same<_Dp, ::std::default_delete<_Tp> > > >
      inline unique_ptr(::std::auto_ptr<_Up> &&__u) noexcept(true);
      inline ~unique_ptr() noexcept(true)
      {
        auto (&__ptr) = std::get<0>(::std::unique_ptr<_Tp, _Dp>::_M_t);
        if (__ptr != nullptr)
          {
            (*this).get_deleter()(__ptr);
          }
        __ptr = ((typename ::std::unique_ptr<_Tp, _Dp>::pointer()));
      }
      inline ::std::unique_ptr<_Tp, _Dp> &operator =(::std::unique_ptr<_Tp, _Dp> &&__u) noexcept(true)
      {
        (*this).reset(__u.release());
        (*this).get_deleter() = std::forward<typename ::std::unique_ptr<_Tp, _Dp>::deleter_type>(__u.get_deleter());
        return *this;
      }
      template < typename _Up, typename _Ep >
      inline typename ::std::enable_if<__and_< ::std::is_convertible<typename ::std::unique_ptr<_Up, _Ep>::pointer, typename ::std::unique_ptr<_Tp, _Dp>::pointer>, ::std::__not_< ::std::is_array<_Up> > >::value, ::std::unique_ptr<_Tp, _Dp> &>::type operator =(::std::unique_ptr<_Up, _Ep> &&__u) noexcept(true)
      {
        (*this).reset(__u.release());
        (*this).get_deleter() = std::forward<_Ep>(__u.get_deleter());
        return *this;
      }
      inline ::std::unique_ptr<_Tp, _Dp> &operator =(::std::nullptr_t) noexcept(true)
      {
        (*this).reset();
        return *this;
      }
      inline typename ::std::add_lvalue_reference<typename ::std::unique_ptr<_Tp, _Dp>::element_type>::type operator *() const 
      {
        ;
        return *(*this).get();
      }
      inline typename ::std::unique_ptr<_Tp, _Dp>::pointer operator ->() const  noexcept(true)
      {
        ;
        return (*this).get();
      }
      inline typename ::std::unique_ptr<_Tp, _Dp>::pointer get() const  noexcept(true)
      {
        return std::get<0>(::std::unique_ptr<_Tp, _Dp>::_M_t);
      }
      inline typename ::std::unique_ptr<_Tp, _Dp>::deleter_type &get_deleter() noexcept(true)
      {
        return std::get<1>(::std::unique_ptr<_Tp, _Dp>::_M_t);
      }
      inline const typename ::std::unique_ptr<_Tp, _Dp>::deleter_type &get_deleter() const  noexcept(true)
      {
        return std::get<1>(::std::unique_ptr<_Tp, _Dp>::_M_t);
      }
      inline explicit operator bool() const  noexcept(true)
      {
        return (*this).get() == ((typename ::std::unique_ptr<_Tp, _Dp>::pointer())) ? false : true;
      }
      inline typename ::std::unique_ptr<_Tp, _Dp>::pointer release() noexcept(true)
      {
        typename ::std::unique_ptr<_Tp, _Dp>::pointer __p = (*this).get();
        std::get<0>(::std::unique_ptr<_Tp, _Dp>::_M_t) = ((typename ::std::unique_ptr<_Tp, _Dp>::pointer()));
        return __p;
      }
      inline void reset(typename ::std::unique_ptr<_Tp, _Dp>::pointer __p  = (((typename ::std::unique_ptr<_Tp, _Dp>::pointer())))) noexcept(true)
      {
        using ::std::swap;
        swap(std::get<0>(::std::unique_ptr<_Tp, _Dp>::_M_t), __p);
        if (__p != ((typename ::std::unique_ptr<_Tp, _Dp>::pointer())))
          {
            (*this).get_deleter()(__p);
          }
      }
      inline void swap(::std::unique_ptr<_Tp, _Dp> &__u) noexcept(true)
      {
        using ::std::swap;
        swap(::std::unique_ptr<_Tp, _Dp>::_M_t, __u._M_t);
      }
      unique_ptr(const ::std::unique_ptr<_Tp, _Dp> &) = delete ;
      ::std::unique_ptr<_Tp, _Dp> &operator =(const ::std::unique_ptr<_Tp, _Dp> &) = delete ;
  };
  template < typename _Tp, typename _Dp >
  class  unique_ptr<_Tp [], _Dp>
  {
      class  _Pointer
      {
          template < typename _Up >
          static typename _Up::pointer __test(typename _Up::pointer *);
          template < typename _Up >
          static _Tp *__test(...);
          typedef typename ::std::remove_reference<_Dp>::type _Del;
        public:
          typedef decltype(__test<typename ::std::unique_ptr<_Tp [], _Dp>::_Pointer::_Del>(0)) type;
      };
      typedef ::std::tuple<typename ::std::unique_ptr<_Tp [], _Dp>::_Pointer::type, _Dp> __tuple_type;
      typename ::std::unique_ptr<_Tp [], _Dp>::__tuple_type _M_t;
      template < typename _Up >
      using __remove_cv = typename ::std::remove_cv<_Up>::type;
      template < typename _Up >
      using __is_derived_Tp = ::std::__and_< ::std::is_base_of<_Tp, _Up>, ::std::__not_< ::std::is_same<typename ::std::unique_ptr<_Tp [], _Dp>::template __remove_cv<_Tp>, typename ::std::unique_ptr<_Tp [], _Dp>::template __remove_cv<_Up> > > >;
      template < typename _Up, typename _Ep, typename _Tp_pointer = typename ::std::unique_ptr<_Tp [], _Dp>::_Pointer::type, typename _Up_pointer = typename ::std::unique_ptr<_Up, _Ep>::pointer >
      using __safe_conversion = ::std::__and_< ::std::is_convertible<_Up_pointer, _Tp_pointer>, ::std::is_array<_Up>, ::std::__or_< ::std::__not_< ::std::is_pointer<_Up_pointer> >, ::std::__not_< ::std::is_pointer<_Tp_pointer> >, ::std::__not_<typename ::std::unique_ptr<_Tp [], _Dp>::template __is_derived_Tp<typename ::std::remove_extent<_Up>::type> > > >;
    public:
      typedef typename ::std::unique_ptr<_Tp [], _Dp>::_Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;
      inline constexpr unique_ptr() noexcept(true)
        : _M_t()
      {
        static_assert(!std::is_pointer<typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type>::value, "constructed with null function pointer deleter");
      }
      inline explicit unique_ptr(typename ::std::unique_ptr<_Tp [], _Dp>::pointer __p) noexcept(true)
        : _M_t(__p, ((typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type())))
      {
        static_assert(!is_pointer<typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type>::value, "constructed with null function pointer deleter");
      }
      template < typename _Up, typename __type_tpl__param_2_1__ = ::std::_Require< ::std::is_pointer<typename ::std::unique_ptr<_Tp [], _Dp>::pointer>, ::std::is_convertible<_Up *, typename ::std::unique_ptr<_Tp [], _Dp>::pointer>, typename ::std::unique_ptr<_Tp [], _Dp>::template __is_derived_Tp<_Up> > >
      explicit unique_ptr(_Up *__p) = delete ;
      inline unique_ptr(typename ::std::unique_ptr<_Tp [], _Dp>::pointer __p, typename ::std::conditional<is_reference<typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type>::value, typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type, const typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type &>::type __d) noexcept(true)
        : _M_t(__p, __d)
      {
      }
      inline unique_ptr(typename ::std::unique_ptr<_Tp [], _Dp>::pointer __p, typename ::std::remove_reference<typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type>::type &&__d) noexcept(true)
        : _M_t(std::move(__p), std::move(__d))
      {
        static_assert(!is_reference<typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type>::value, "rvalue deleter bound to reference");
      }
      inline unique_ptr(::std::unique_ptr<_Tp [], _Dp> &&__u) noexcept(true)
        : _M_t(__u.release(), std::forward<typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type>(__u.get_deleter()))
      {
      }
      inline constexpr unique_ptr(::std::nullptr_t) noexcept(true)
        : unique_ptr()
      {
      }
      template < typename _Up, typename _Ep, typename __type_tpl__param_2_2__ = ::std::_Require<typename ::std::unique_ptr<_Tp [], _Dp>::template __safe_conversion<_Up, _Ep>, typename ::std::conditional<is_reference<_Dp>::value, ::std::is_same<_Ep, _Dp>, ::std::is_convertible<_Ep, _Dp> >::type> >
      inline unique_ptr(::std::unique_ptr<_Up, _Ep> &&__u) noexcept(true)
        : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
      {
      }
      inline ~unique_ptr()
      {
        auto (&__ptr) = std::get<0>(::std::unique_ptr<_Tp [], _Dp>::_M_t);
        if (__ptr != nullptr)
          {
            (*this).get_deleter()(__ptr);
          }
        __ptr = ((typename ::std::unique_ptr<_Tp [], _Dp>::pointer()));
      }
      inline ::std::unique_ptr<_Tp [], _Dp> &operator =(::std::unique_ptr<_Tp [], _Dp> &&__u) noexcept(true)
      {
        (*this).reset(__u.release());
        (*this).get_deleter() = std::forward<typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type>(__u.get_deleter());
        return *this;
      }
      template < typename _Up, typename _Ep >
      inline typename ::std::enable_if<__safe_conversion<_Up, _Ep>::value, ::std::unique_ptr<_Tp [], _Dp> &>::type operator =(::std::unique_ptr<_Up, _Ep> &&__u) noexcept(true)
      {
        (*this).reset(__u.release());
        (*this).get_deleter() = std::forward<_Ep>(__u.get_deleter());
        return *this;
      }
      inline ::std::unique_ptr<_Tp [], _Dp> &operator =(::std::nullptr_t) noexcept(true)
      {
        (*this).reset();
        return *this;
      }
      inline typename ::std::add_lvalue_reference<typename ::std::unique_ptr<_Tp [], _Dp>::element_type>::type operator [](::std::size_t __i) const 
      {
        ;
        return (*this).get()[__i];
      }
      inline typename ::std::unique_ptr<_Tp [], _Dp>::pointer get() const  noexcept(true)
      {
        return std::get<0>(::std::unique_ptr<_Tp [], _Dp>::_M_t);
      }
      inline typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type &get_deleter() noexcept(true)
      {
        return std::get<1>(::std::unique_ptr<_Tp [], _Dp>::_M_t);
      }
      inline const typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type &get_deleter() const  noexcept(true)
      {
        return std::get<1>(::std::unique_ptr<_Tp [], _Dp>::_M_t);
      }
      inline explicit operator bool() const  noexcept(true)
      {
        return (*this).get() == ((typename ::std::unique_ptr<_Tp [], _Dp>::pointer())) ? false : true;
      }
      inline typename ::std::unique_ptr<_Tp [], _Dp>::pointer release() noexcept(true)
      {
        typename ::std::unique_ptr<_Tp [], _Dp>::pointer __p = (*this).get();
        std::get<0>(::std::unique_ptr<_Tp [], _Dp>::_M_t) = ((typename ::std::unique_ptr<_Tp [], _Dp>::pointer()));
        return __p;
      }
      inline void reset() noexcept(true)
      {
        (*this).reset(((typename ::std::unique_ptr<_Tp [], _Dp>::pointer())));
      }
      inline void reset(typename ::std::unique_ptr<_Tp [], _Dp>::pointer __p) noexcept(true)
      {
        using ::std::swap;
        swap(std::get<0>(::std::unique_ptr<_Tp [], _Dp>::_M_t), __p);
        if (__p != nullptr)
          {
            (*this).get_deleter()(__p);
          }
      }
      template < typename _Up, typename __type_tpl__param_2_1__ = ::std::_Require< ::std::is_pointer<typename ::std::unique_ptr<_Tp [], _Dp>::pointer>, ::std::is_convertible<_Up *, typename ::std::unique_ptr<_Tp [], _Dp>::pointer>, typename ::std::unique_ptr<_Tp [], _Dp>::template __is_derived_Tp<_Up> > >
      void reset(_Up *) = delete ;
      inline void swap(::std::unique_ptr<_Tp [], _Dp> &__u) noexcept(true)
      {
        using ::std::swap;
        swap(::std::unique_ptr<_Tp [], _Dp>::_M_t, __u._M_t);
      }
      unique_ptr(const ::std::unique_ptr<_Tp [], _Dp> &) = delete ;
      ::std::unique_ptr<_Tp [], _Dp> &operator =(const ::std::unique_ptr<_Tp [], _Dp> &) = delete ;
      template < typename _Up, typename __type_tpl__param_2_1__ = ::std::_Require< ::std::is_pointer<typename ::std::unique_ptr<_Tp [], _Dp>::pointer>, ::std::is_convertible<_Up *, typename ::std::unique_ptr<_Tp [], _Dp>::pointer>, typename ::std::unique_ptr<_Tp [], _Dp>::template __is_derived_Tp<_Up> > >
      unique_ptr(_Up *, typename ::std::conditional<is_reference<typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type>::value, typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type, const typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type &>::type) = delete ;
      template < typename _Up, typename __type_tpl__param_2_1__ = ::std::_Require< ::std::is_pointer<typename ::std::unique_ptr<_Tp [], _Dp>::pointer>, ::std::is_convertible<_Up *, typename ::std::unique_ptr<_Tp [], _Dp>::pointer>, typename ::std::unique_ptr<_Tp [], _Dp>::template __is_derived_Tp<_Up> > >
      unique_ptr(_Up *, typename ::std::remove_reference<typename ::std::unique_ptr<_Tp [], _Dp>::deleter_type>::type &&) = delete ;
  };
  template < typename _Tp, typename _Dp >
  inline void swap(::std::unique_ptr<_Tp, _Dp> &__x, ::std::unique_ptr<_Tp, _Dp> &__y) noexcept(true);
  template < typename _Tp, typename _Dp >
  inline void swap(::std::unique_ptr<_Tp, _Dp> &__x, ::std::unique_ptr<_Tp, _Dp> &__y) noexcept(true)
  {
    __x.swap(__y);
  }
  template < typename _Tp, typename _Dp, typename _Up, typename _Ep >
  inline bool operator ==(const ::std::unique_ptr<_Tp, _Dp> &__x, const ::std::unique_ptr<_Up, _Ep> &__y);
  template < typename _Tp, typename _Dp, typename _Up, typename _Ep >
  inline bool operator ==(const ::std::unique_ptr<_Tp, _Dp> &__x, const ::std::unique_ptr<_Up, _Ep> &__y)
  {
    return __x.get() == __y.get();
  }
  template < typename _Tp, typename _Dp >
  inline bool operator ==(const ::std::unique_ptr<_Tp, _Dp> &__x, ::std::nullptr_t) noexcept(true);
  template < typename _Tp, typename _Dp >
  inline bool operator ==(const ::std::unique_ptr<_Tp, _Dp> &__x, ::std::nullptr_t) noexcept(true)
  {
    return !__x;
  }
  template < typename _Tp, typename _Dp >
  inline bool operator ==(::std::nullptr_t, const ::std::unique_ptr<_Tp, _Dp> &__x) noexcept(true);
  template < typename _Tp, typename _Dp >
  inline bool operator ==(::std::nullptr_t, const ::std::unique_ptr<_Tp, _Dp> &__x) noexcept(true)
  {
    return !__x;
  }
  template < typename _Tp, typename _Dp, typename _Up, typename _Ep >
  inline bool operator !=(const ::std::unique_ptr<_Tp, _Dp> &__x, const ::std::unique_ptr<_Up, _Ep> &__y);
  template < typename _Tp, typename _Dp, typename _Up, typename _Ep >
  inline bool operator !=(const ::std::unique_ptr<_Tp, _Dp> &__x, const ::std::unique_ptr<_Up, _Ep> &__y)
  {
    return __x.get() != __y.get();
  }
  template < typename _Tp, typename _Dp >
  inline bool operator !=(const ::std::unique_ptr<_Tp, _Dp> &__x, ::std::nullptr_t) noexcept(true);
  template < typename _Tp, typename _Dp >
  inline bool operator !=(const ::std::unique_ptr<_Tp, _Dp> &__x, ::std::nullptr_t) noexcept(true)
  {
    return (bool)__x;
  }
  template < typename _Tp, typename _Dp >
  inline bool operator !=(::std::nullptr_t, const ::std::unique_ptr<_Tp, _Dp> &__x) noexcept(true);
  template < typename _Tp, typename _Dp >
  inline bool operator !=(::std::nullptr_t, const ::std::unique_ptr<_Tp, _Dp> &__x) noexcept(true)
  {
    return (bool)__x;
  }
  template < typename _Tp, typename _Dp, typename _Up, typename _Ep >
  inline bool operator <(const ::std::unique_ptr<_Tp, _Dp> &__x, const ::std::unique_ptr<_Up, _Ep> &__y);
  template < typename _Tp, typename _Dp, typename _Up, typename _Ep >
  inline bool operator <(const ::std::unique_ptr<_Tp, _Dp> &__x, const ::std::unique_ptr<_Up, _Ep> &__y)
  {
    typedef typename ::std::common_type<typename ::std::unique_ptr<_Tp, _Dp>::pointer, typename ::std::unique_ptr<_Up, _Ep>::pointer>::type _CT;
    return ::std::less<_CT>()(__x.get(), __y.get());
  }
  template < typename _Tp, typename _Dp >
  inline bool operator <(const ::std::unique_ptr<_Tp, _Dp> &__x, ::std::nullptr_t);
  template < typename _Tp, typename _Dp >
  inline bool operator <(const ::std::unique_ptr<_Tp, _Dp> &__x, ::std::nullptr_t)
  {
    return ::std::less<typename ::std::unique_ptr<_Tp, _Dp>::pointer>()(__x.get(), nullptr);
  }
  template < typename _Tp, typename _Dp >
  inline bool operator <(::std::nullptr_t, const ::std::unique_ptr<_Tp, _Dp> &__x);
  template < typename _Tp, typename _Dp >
  inline bool operator <(::std::nullptr_t, const ::std::unique_ptr<_Tp, _Dp> &__x)
  {
    return ::std::less<typename ::std::unique_ptr<_Tp, _Dp>::pointer>()(nullptr, __x.get());
  }
  template < typename _Tp, typename _Dp, typename _Up, typename _Ep >
  inline bool operator <=(const ::std::unique_ptr<_Tp, _Dp> &__x, const ::std::unique_ptr<_Up, _Ep> &__y);
  template < typename _Tp, typename _Dp, typename _Up, typename _Ep >
  inline bool operator <=(const ::std::unique_ptr<_Tp, _Dp> &__x, const ::std::unique_ptr<_Up, _Ep> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Tp, typename _Dp >
  inline bool operator <=(const ::std::unique_ptr<_Tp, _Dp> &__x, ::std::nullptr_t);
  template < typename _Tp, typename _Dp >
  inline bool operator <=(const ::std::unique_ptr<_Tp, _Dp> &__x, ::std::nullptr_t)
  {
    return !(nullptr < __x);
  }
  template < typename _Tp, typename _Dp >
  inline bool operator <=(::std::nullptr_t, const ::std::unique_ptr<_Tp, _Dp> &__x);
  template < typename _Tp, typename _Dp >
  inline bool operator <=(::std::nullptr_t, const ::std::unique_ptr<_Tp, _Dp> &__x)
  {
    return !(__x < nullptr);
  }
  template < typename _Tp, typename _Dp, typename _Up, typename _Ep >
  inline bool operator >(const ::std::unique_ptr<_Tp, _Dp> &__x, const ::std::unique_ptr<_Up, _Ep> &__y);
  template < typename _Tp, typename _Dp, typename _Up, typename _Ep >
  inline bool operator >(const ::std::unique_ptr<_Tp, _Dp> &__x, const ::std::unique_ptr<_Up, _Ep> &__y)
  {
    return __y < __x;
  }
  template < typename _Tp, typename _Dp >
  inline bool operator >(const ::std::unique_ptr<_Tp, _Dp> &__x, ::std::nullptr_t);
  template < typename _Tp, typename _Dp >
  inline bool operator >(const ::std::unique_ptr<_Tp, _Dp> &__x, ::std::nullptr_t)
  {
    return ::std::less<typename ::std::unique_ptr<_Tp, _Dp>::pointer>()(nullptr, __x.get());
  }
  template < typename _Tp, typename _Dp >
  inline bool operator >(::std::nullptr_t, const ::std::unique_ptr<_Tp, _Dp> &__x);
  template < typename _Tp, typename _Dp >
  inline bool operator >(::std::nullptr_t, const ::std::unique_ptr<_Tp, _Dp> &__x)
  {
    return ::std::less<typename ::std::unique_ptr<_Tp, _Dp>::pointer>()(__x.get(), nullptr);
  }
  template < typename _Tp, typename _Dp, typename _Up, typename _Ep >
  inline bool operator >=(const ::std::unique_ptr<_Tp, _Dp> &__x, const ::std::unique_ptr<_Up, _Ep> &__y);
  template < typename _Tp, typename _Dp, typename _Up, typename _Ep >
  inline bool operator >=(const ::std::unique_ptr<_Tp, _Dp> &__x, const ::std::unique_ptr<_Up, _Ep> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Tp, typename _Dp >
  inline bool operator >=(const ::std::unique_ptr<_Tp, _Dp> &__x, ::std::nullptr_t);
  template < typename _Tp, typename _Dp >
  inline bool operator >=(const ::std::unique_ptr<_Tp, _Dp> &__x, ::std::nullptr_t)
  {
    return !(__x < nullptr);
  }
  template < typename _Tp, typename _Dp >
  inline bool operator >=(::std::nullptr_t, const ::std::unique_ptr<_Tp, _Dp> &__x);
  template < typename _Tp, typename _Dp >
  inline bool operator >=(::std::nullptr_t, const ::std::unique_ptr<_Tp, _Dp> &__x)
  {
    return !(nullptr < __x);
  }
  template < typename _Tp, typename _Dp >
  struct  hash< ::std::unique_ptr<_Tp, _Dp> > : ::std::__hash_base<unsigned long int, ::std::unique_ptr<_Tp, _Dp> >
  {
      inline ::std::size_t operator ()(const ::std::unique_ptr<_Tp, _Dp> &__u) const  noexcept(true)
      {
        typedef ::std::unique_ptr<_Tp, _Dp> _UP;
        return ::std::hash<typename ::std::unique_ptr<_Tp, _Dp>::pointer>()(__u.get());
      }
  };
  template < typename __type_tpl__param_1_0__ >
  class __attribute__((__deprecated__)) auto_ptr;
  class  bad_weak_ptr : public ::std::exception
  {
    public:
      virtual const char *what() const  noexcept(true);
      virtual ~bad_weak_ptr() noexcept(true);
  };
  inline void __throw_bad_weak_ptr()
  {
    throw ::std::bad_weak_ptr();
  }
  using ::__gnu_cxx::_Lock_policy;
  using ::__gnu_cxx::__default_lock_policy;
  using ::__gnu_cxx::_S_single;
  using ::__gnu_cxx::_S_mutex;
  using ::__gnu_cxx::_S_atomic;
  template < ::__gnu_cxx::_Lock_policy _Lp >
  class  _Mutex_base
  {
    protected:
      enum mcc_enum_anon_65
      {
        _S_need_barriers = 0
      };
  };
  template <>
  class  _Mutex_base< ::__gnu_cxx::_S_mutex> : public ::__gnu_cxx::__mutex
  {
    protected:
      enum mcc_enum_anon_66
      {
        _S_need_barriers = 1
      };
    public:
  };
  template < ::__gnu_cxx::_Lock_policy _Lp = ::__gnu_cxx::__default_lock_policy >
  class  _Sp_counted_base : public ::std::_Mutex_base<_Lp>
  {
    public:
      inline _Sp_counted_base() noexcept(true)
        : _M_use_count(1), _M_weak_count(1)
      {
      }
      inline virtual ~_Sp_counted_base() noexcept(true)
      {
      }
      virtual void _M_dispose() noexcept(true) = 0 ;
      inline virtual void _M_destroy() noexcept(true)
      {
        delete this;
      }
      virtual void *_M_get_deleter(const ::std::type_info &) = 0 ;
      inline void _M_add_ref_copy()
      {
        __gnu_cxx::__atomic_add_dispatch(&(*this).::std::_Sp_counted_base<_Lp>::_M_use_count, 1);
      }
      void _M_add_ref_lock();
      inline void _M_release() noexcept(true)
      {
        ;
        if (__gnu_cxx::__exchange_and_add_dispatch(&(*this).::std::_Sp_counted_base<_Lp>::_M_use_count,  -1) == 1)
          {
            ;
            (*this)._M_dispose();
            if (_Mutex_base<_Lp>::_S_need_barriers)
              {
                __asm__ __volatile("" :  :  : "memory");
                __asm__ __volatile("" :  :  : "memory");
              }
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&(*this).::std::_Sp_counted_base<_Lp>::_M_weak_count,  -1) == 1)
              {
                ;
                (*this)._M_destroy();
              }
          }
      }
      inline void _M_weak_add_ref() noexcept(true)
      {
        __gnu_cxx::__atomic_add_dispatch(&(*this).::std::_Sp_counted_base<_Lp>::_M_weak_count, 1);
      }
      inline void _M_weak_release() noexcept(true)
      {
        ;
        if (__gnu_cxx::__exchange_and_add_dispatch(&(*this).::std::_Sp_counted_base<_Lp>::_M_weak_count,  -1) == 1)
          {
            ;
            if (_Mutex_base<_Lp>::_S_need_barriers)
              {
                __asm__ __volatile("" :  :  : "memory");
                __asm__ __volatile("" :  :  : "memory");
              }
            (*this)._M_destroy();
          }
      }
      inline long int _M_get_use_count() const  noexcept(true)
      {
        return __atomic_load_n(&(*this).::std::_Sp_counted_base<_Lp>::_M_use_count, 0);
      }
    private:
      _Sp_counted_base(const ::std::_Sp_counted_base<_Lp> &) = delete ;
      ::std::_Sp_counted_base<_Lp> &operator =(const ::std::_Sp_counted_base<_Lp> &) = delete ;
      ::_Atomic_word _M_use_count;
      ::_Atomic_word _M_weak_count;
  };
 /* Instantiation of class template '::std::_Mutex_base< ::__gnu_cxx::_S_single>' */ 
 /* Instantiation of class template '::std::_Sp_counted_base< ::__gnu_cxx::_S_single>' */ 
  template <>
  inline void _Sp_counted_base< ::__gnu_cxx::_S_single>::_M_add_ref_lock()
  {
    if (__gnu_cxx::__exchange_and_add_dispatch(&(*this)._M_use_count, 1) == 0)
      {
        (*this)._M_use_count = 0;
        ::std::__throw_bad_weak_ptr();
      }
  }
 /* Instantiation of class template '::std::_Sp_counted_base< ::__gnu_cxx::_S_mutex>' */ 
  template <>
  inline void _Sp_counted_base< ::__gnu_cxx::_S_mutex>::_M_add_ref_lock()
  {
    ::__gnu_cxx::__scoped_lock sentry((*this));
    if (__gnu_cxx::__exchange_and_add_dispatch(&(*this)._M_use_count, 1) == 0)
      {
        (*this)._M_use_count = 0;
        ::std::__throw_bad_weak_ptr();
      }
  }
 /* Instantiation of class template '::std::_Mutex_base< ::__gnu_cxx::_S_atomic>' */ 
 /* Instantiation of class template '::std::_Sp_counted_base< ::__gnu_cxx::_S_atomic>' */ 
 /* Instantiation of template function 'long int ::std::_Sp_counted_base< ::__gnu_cxx::_S_atomic>::_M_get_use_count() const ' */ 
  template <>
  inline void _Sp_counted_base< ::__gnu_cxx::_S_atomic>::_M_add_ref_lock()
  {
    ::_Atomic_word __count((*this).::std::_Sp_counted_base< ::__gnu_cxx::_S_atomic>::_M_get_use_count());
    do
      {
        if (__count == 0)
          {
            ::std::__throw_bad_weak_ptr();
          }
      }
    while (!__atomic_compare_exchange_n(&(*this)._M_use_count, &__count, __count + 1, true, 4, 0));
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp = ::__gnu_cxx::__default_lock_policy >
  class __shared_ptr;
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp = ::__gnu_cxx::__default_lock_policy >
  class __weak_ptr;
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp = ::__gnu_cxx::__default_lock_policy >
  class __enable_shared_from_this;
  template < typename _Tp >
  class shared_ptr;
  template < typename _Tp >
  class weak_ptr;
  template < typename _Tp >
  struct owner_less;
  template < typename _Tp >
  class enable_shared_from_this;
  template < ::__gnu_cxx::_Lock_policy _Lp = ::__gnu_cxx::__default_lock_policy >
  class __weak_count;
  template < ::__gnu_cxx::_Lock_policy _Lp = ::__gnu_cxx::__default_lock_policy >
  class __shared_count;
  template < typename _Ptr, ::__gnu_cxx::_Lock_policy _Lp >
  class  _Sp_counted_ptr final : public ::std::_Sp_counted_base<_Lp>
  {
    public:
      inline explicit _Sp_counted_ptr(_Ptr __p)
        : _M_ptr(__p)
      {
      }
      inline virtual void _M_dispose() noexcept(true)
      {
        delete ::std::_Sp_counted_ptr<_Ptr, _Lp>::_M_ptr;
      }
      inline virtual void _M_destroy() noexcept(true)
      {
        delete this;
      }
      inline virtual void *_M_get_deleter(const ::std::type_info &)
      {
        return 0;
      }
      _Sp_counted_ptr(const ::std::_Sp_counted_ptr<_Ptr, _Lp> &) = delete ;
      ::std::_Sp_counted_ptr<_Ptr, _Lp> &operator =(const ::std::_Sp_counted_ptr<_Ptr, _Lp> &) = delete ;
    protected:
      _Ptr _M_ptr;
  };
 /* Instantiation of class template '::std::_Sp_counted_ptr<decltype(nullptr), ::__gnu_cxx::_S_single>' */ 
  template <>
  inline void _Sp_counted_ptr<decltype(nullptr), ::__gnu_cxx::_S_single>::_M_dispose() noexcept(true)
  {
  }
 /* Instantiation of class template '::std::_Sp_counted_ptr<decltype(nullptr), ::__gnu_cxx::_S_mutex>' */ 
  template <>
  inline void _Sp_counted_ptr<decltype(nullptr), ::__gnu_cxx::_S_mutex>::_M_dispose() noexcept(true)
  {
  }
 /* Instantiation of class template '::std::_Sp_counted_ptr<decltype(nullptr), ::__gnu_cxx::_S_atomic>' */ 
  template <>
  inline void _Sp_counted_ptr<decltype(nullptr), ::__gnu_cxx::_S_atomic>::_M_dispose() noexcept(true)
  {
  }
  template < typename _Ptr, typename _Deleter, typename _Alloc, ::__gnu_cxx::_Lock_policy _Lp >
  class  _Sp_counted_deleter final : public ::std::_Sp_counted_base<_Lp>
  {
      struct  _My_Deleter : _Alloc
      {
          _Deleter _M_del;
          inline _My_Deleter(_Deleter __d, const _Alloc &__a)
            : _Alloc(__a), _M_del(__d)
          {
          }
      };
    public:
      inline _Sp_counted_deleter(_Ptr __p, _Deleter __d)
        : _M_ptr(__p), _M_del(__d, _Alloc())
      {
      }
      inline _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc &__a)
        : _M_ptr(__p), _M_del(__d, __a)
      {
      }
      inline ~_Sp_counted_deleter() noexcept(true)
      {
      }
      inline virtual void _M_dispose() noexcept(true)
      {
        ::std::_Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp>::_M_del._M_del(::std::_Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp>::_M_ptr);
      }
      inline virtual void _M_destroy() noexcept(true)
      {
        typedef typename ::std::allocator_traits<_Alloc>::template rebind_traits< ::std::_Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> > _Alloc_traits;
        typename ::std::allocator_traits<_Alloc>::template rebind_traits< ::std::_Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> >::allocator_type __a(::std::_Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp>::_M_del);
        _Alloc_traits::destroy(__a, this);
        _Alloc_traits::deallocate(__a, this, 1);
      }
      inline virtual void *_M_get_deleter(const ::std::type_info &__ti)
      {
        return __ti == typeid(_Deleter) ? &::std::_Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp>::_M_del._M_del : 0;
      }
    protected:
      _Ptr _M_ptr;
      typename ::std::_Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp>::_My_Deleter _M_del;
  };
  struct  _Sp_make_shared_tag
  {
  };
  template < typename _Tp, typename _Alloc, ::__gnu_cxx::_Lock_policy _Lp >
  class  _Sp_counted_ptr_inplace final : public ::std::_Sp_counted_base<_Lp>
  {
      struct  _Impl : _Alloc
      {
          inline _Impl(_Alloc __a)
            : _Alloc(__a), _M_ptr()
          {
          }
          _Tp *_M_ptr;
      };
    public:
      template < typename ..._Args >
      inline _Sp_counted_ptr_inplace(_Alloc __a, _Args &&...__args)
        : _M_impl(__a)
      {
        ::std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_impl._M_ptr = static_cast<_Tp *>(static_cast<void *>(&(*this).::std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_storage));
        allocator_traits<_Alloc>::construct(__a, ::std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_impl._M_ptr, std::forward<_Args>(__args) ...);
      }
      inline ~_Sp_counted_ptr_inplace() noexcept(true)
      {
      }
      inline virtual void _M_dispose() noexcept(true)
      {
        allocator_traits<_Alloc>::destroy(::std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_impl, ::std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_impl._M_ptr);
      }
      inline virtual void _M_destroy() noexcept(true)
      {
        typedef typename ::std::allocator_traits<_Alloc>::template rebind_traits< ::std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> > _Alloc_traits;
        typename ::std::allocator_traits<_Alloc>::template rebind_traits< ::std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> >::allocator_type __a(::std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_impl);
        _Alloc_traits::destroy(__a, this);
        _Alloc_traits::deallocate(__a, this, 1);
      }
      inline virtual void *_M_get_deleter(const ::std::type_info &__ti) noexcept(true)
      {
        return __ti == typeid(::std::_Sp_make_shared_tag) ? static_cast<void *>(&(*this).::std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_storage) : 0;
      }
    private:
      typename ::std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Impl _M_impl;
      typename ::std::aligned_storage<sizeof(_Tp), alignment_of<_Tp>::value>::type _M_storage;
  };
 /* Instantiation of class template '::__gnu_cxx::new_allocator<int>' */ 
 /* Instantiation of class template '::std::allocator<int>' */ 
  template < ::__gnu_cxx::_Lock_policy _Lp >
  class  __shared_count
  {
    public:
      inline constexpr __shared_count() noexcept(true)
        : _M_pi(0)
      {
      }
      template < typename _Ptr >
      inline explicit __shared_count(_Ptr __p)
        : _M_pi(0)
      {
        try
        {
          ::std::__shared_count<_Lp>::_M_pi = (new ::std::_Sp_counted_ptr<_Ptr, _Lp>(__p));
        }
        catch (...)
        {
          delete __p;
          throw;
        }
      }
      template < typename _Ptr, typename _Deleter >
      inline __shared_count(_Ptr __p, _Deleter __d)
        : __shared_count(__p, std::move(__d), ::std::allocator<int>())
      {
      }
      template < typename _Ptr, typename _Deleter, typename _Alloc >
      inline __shared_count(_Ptr __p, _Deleter __d, _Alloc __a)
        : _M_pi(0)
      {
        typedef ::std::_Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
        typedef typename ::std::allocator_traits<_Alloc>::template rebind_traits< _Sp_cd_type> _Alloc_traits;
        typename ::std::allocator_traits<_Alloc>::template rebind_traits< _Sp_cd_type>::allocator_type __a2(__a);
        _Sp_cd_type *__mem = 0;
        try
        {
          __mem = _Alloc_traits::allocate(__a2, 1);
          _Alloc_traits::construct(__a2, __mem, __p, std::move(__d), std::move(__a));
          ::std::__shared_count<_Lp>::_M_pi = __mem;
        }
        catch (...)
        {
          __d(__p);
          if (__mem)
            {
              _Alloc_traits::deallocate(__a2, __mem, 1);
            }
          throw;
        }
      }
      template < typename _Tp, typename _Alloc, typename ..._Args >
      inline __shared_count(::std::_Sp_make_shared_tag, _Tp *, const _Alloc &__a, _Args &&...__args)
        : _M_pi(0)
      {
        typedef ::std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
        typedef typename ::std::allocator_traits<_Alloc>::template rebind_traits< _Sp_cp_type> _Alloc_traits;
        typename ::std::allocator_traits<_Alloc>::template rebind_traits< _Sp_cp_type>::allocator_type __a2(__a);
        _Sp_cp_type *__mem = _Alloc_traits::allocate(__a2, 1);
        try
        {
          _Alloc_traits::construct(__a2, __mem, std::move(__a), std::forward<_Args>(__args) ...);
          ::std::__shared_count<_Lp>::_M_pi = __mem;
        }
        catch (...)
        {
          _Alloc_traits::deallocate(__a2, __mem, 1);
          throw;
        }
      }
      template < typename _Tp >
      inline explicit __shared_count(::std::auto_ptr<_Tp> &&__r);
      template < typename _Tp, typename _Del >
      inline explicit __shared_count(::std::unique_ptr<_Tp, _Del> &&__r)
        : _M_pi(0)
      {
        typedef typename ::std::unique_ptr<_Tp, _Del>::pointer _Ptr;
        typedef typename ::std::conditional<is_reference<_Del>::value, ::std::reference_wrapper<typename ::std::remove_reference<_Del>::type>, _Del>::type _Del2;
        typedef ::std::_Sp_counted_deleter<_Ptr, _Del2, ::std::allocator<void>, _Lp> _Sp_cd_type;
        typedef ::std::allocator<_Sp_cd_type> _Alloc;
        typedef ::std::allocator_traits<_Alloc> _Alloc_traits;
        _Alloc __a;
        _Sp_cd_type *__mem = _Alloc_traits::allocate(__a, 1);
        _Alloc_traits::construct(__a, __mem, __r.release(), __r.get_deleter());
        ::std::__shared_count<_Lp>::_M_pi = __mem;
      }
      inline explicit __shared_count(const ::std::__weak_count<_Lp> &__r);
      inline ~__shared_count() noexcept(true)
      {
        if (::std::__shared_count<_Lp>::_M_pi != nullptr)
          {
            ::std::__shared_count<_Lp>::_M_pi->_M_release();
          }
      }
      inline __shared_count(const ::std::__shared_count<_Lp> &__r) noexcept(true)
        : _M_pi(__r._M_pi)
      {
        if (::std::__shared_count<_Lp>::_M_pi != 0)
          {
            ::std::__shared_count<_Lp>::_M_pi->_M_add_ref_copy();
          }
      }
      inline ::std::__shared_count<_Lp> &operator =(const ::std::__shared_count<_Lp> &__r) noexcept(true)
      {
        ::std::_Sp_counted_base<_Lp> *__tmp = __r._M_pi;
        if (__tmp != ::std::__shared_count<_Lp>::_M_pi)
          {
            if (__tmp != 0)
              {
                __tmp->_M_add_ref_copy();
              }
            if (::std::__shared_count<_Lp>::_M_pi != 0)
              {
                ::std::__shared_count<_Lp>::_M_pi->_M_release();
              }
            ::std::__shared_count<_Lp>::_M_pi = __tmp;
          }
        return *this;
      }
      inline void _M_swap(::std::__shared_count<_Lp> &__r) noexcept(true)
      {
        ::std::_Sp_counted_base<_Lp> *__tmp = __r._M_pi;
        __r._M_pi = ::std::__shared_count<_Lp>::_M_pi;
        ::std::__shared_count<_Lp>::_M_pi = __tmp;
      }
      inline long int _M_get_use_count() const  noexcept(true)
      {
        return ::std::__shared_count<_Lp>::_M_pi != 0 ? ::std::__shared_count<_Lp>::_M_pi->_M_get_use_count() : 0;
      }
      inline bool _M_unique() const  noexcept(true)
      {
        return this->_M_get_use_count() == 1;
      }
      inline void *_M_get_deleter(const ::std::type_info &__ti) const  noexcept(true)
      {
        return ::std::__shared_count<_Lp>::_M_pi ? ::std::__shared_count<_Lp>::_M_pi->_M_get_deleter(__ti) : 0;
      }
      inline bool _M_less(const ::std::__shared_count<_Lp> &__rhs) const  noexcept(true)
      {
        return ::std::less< ::std::_Sp_counted_base<_Lp> *>()(this->_M_pi, __rhs._M_pi);
      }
      inline bool _M_less(const ::std::__weak_count<_Lp> &__rhs) const  noexcept(true)
      {
        return ::std::less< ::std::_Sp_counted_base<_Lp> *>()(this->_M_pi, __rhs._M_pi);
      }
    private:
      ::std::_Sp_counted_base<_Lp> *_M_pi;
    friend inline bool operator ==(const ::std::__shared_count<_Lp> &__a, const ::std::__shared_count<_Lp> &__b) throw()
    {
      return __a._M_pi == __b._M_pi;
    }
    friend class ::std::__weak_count<_Lp>;
  };
  template < ::__gnu_cxx::_Lock_policy _Lp >
  class  __weak_count
  {
    public:
      inline constexpr __weak_count() noexcept(true)
        : _M_pi(0)
      {
      }
      inline __weak_count(const ::std::__shared_count<_Lp> &__r) noexcept(true)
        : _M_pi(__r._M_pi)
      {
        if (::std::__weak_count<_Lp>::_M_pi != 0)
          {
            ::std::__weak_count<_Lp>::_M_pi->_M_weak_add_ref();
          }
      }
      inline __weak_count(const ::std::__weak_count<_Lp> &__r) noexcept(true)
        : _M_pi(__r._M_pi)
      {
        if (::std::__weak_count<_Lp>::_M_pi != 0)
          {
            ::std::__weak_count<_Lp>::_M_pi->_M_weak_add_ref();
          }
      }
      inline ~__weak_count() noexcept(true)
      {
        if (::std::__weak_count<_Lp>::_M_pi != 0)
          {
            ::std::__weak_count<_Lp>::_M_pi->_M_weak_release();
          }
      }
      inline ::std::__weak_count<_Lp> &operator =(const ::std::__shared_count<_Lp> &__r) noexcept(true)
      {
        ::std::_Sp_counted_base<_Lp> *__tmp = __r._M_pi;
        if (__tmp != 0)
          {
            __tmp->_M_weak_add_ref();
          }
        if (::std::__weak_count<_Lp>::_M_pi != 0)
          {
            ::std::__weak_count<_Lp>::_M_pi->_M_weak_release();
          }
        ::std::__weak_count<_Lp>::_M_pi = __tmp;
        return *this;
      }
      inline ::std::__weak_count<_Lp> &operator =(const ::std::__weak_count<_Lp> &__r) noexcept(true)
      {
        ::std::_Sp_counted_base<_Lp> *__tmp = __r._M_pi;
        if (__tmp != 0)
          {
            __tmp->_M_weak_add_ref();
          }
        if (::std::__weak_count<_Lp>::_M_pi != 0)
          {
            ::std::__weak_count<_Lp>::_M_pi->_M_weak_release();
          }
        ::std::__weak_count<_Lp>::_M_pi = __tmp;
        return *this;
      }
      inline void _M_swap(::std::__weak_count<_Lp> &__r) noexcept(true)
      {
        ::std::_Sp_counted_base<_Lp> *__tmp = __r._M_pi;
        __r._M_pi = ::std::__weak_count<_Lp>::_M_pi;
        ::std::__weak_count<_Lp>::_M_pi = __tmp;
      }
      inline long int _M_get_use_count() const  noexcept(true)
      {
        return ::std::__weak_count<_Lp>::_M_pi != 0 ? ::std::__weak_count<_Lp>::_M_pi->_M_get_use_count() : 0;
      }
      inline bool _M_less(const ::std::__weak_count<_Lp> &__rhs) const  noexcept(true)
      {
        return ::std::less< ::std::_Sp_counted_base<_Lp> *>()(this->_M_pi, __rhs._M_pi);
      }
      inline bool _M_less(const ::std::__shared_count<_Lp> &__rhs) const  noexcept(true)
      {
        return ::std::less< ::std::_Sp_counted_base<_Lp> *>()(this->_M_pi, __rhs._M_pi);
      }
    private:
      ::std::_Sp_counted_base<_Lp> *_M_pi;
    friend inline bool operator ==(const ::std::__weak_count<_Lp> &__a, const ::std::__weak_count<_Lp> &__b) throw()
    {
      return __a._M_pi == __b._M_pi;
    }
    friend class ::std::__shared_count<_Lp>;
  };
  template < ::__gnu_cxx::_Lock_policy _Lp >
  inline __shared_count<_Lp>::__shared_count(const ::std::__weak_count<_Lp> &__r)
    : _M_pi(__r._M_pi)
  {
    if (::std::__shared_count<_Lp>::_M_pi != 0)
      {
        ::std::__shared_count<_Lp>::_M_pi->_M_add_ref_lock();
      }
    else
      {
        ::std::__throw_bad_weak_ptr();
      }
  }
  template < ::__gnu_cxx::_Lock_policy _Lp, typename _Tp1, typename _Tp2 >
  void __enable_shared_from_this_helper(const ::std::__shared_count<_Lp> &, const ::std::__enable_shared_from_this<_Tp1, _Lp> *, const _Tp2 *) noexcept(true);
  template < typename _Tp1, typename _Tp2 >
  void __enable_shared_from_this_helper(const ::std::__shared_count<> &, const ::std::enable_shared_from_this<_Tp1> *, const _Tp2 *) noexcept(true);
  template < ::__gnu_cxx::_Lock_policy _Lp >
  inline void __enable_shared_from_this_helper(const ::std::__shared_count<_Lp> &, ...) noexcept(true);
  template < ::__gnu_cxx::_Lock_policy _Lp >
  inline void __enable_shared_from_this_helper(const ::std::__shared_count<_Lp> &, ...) noexcept(true)
  {
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  class  __shared_ptr
  {
    public:
      typedef _Tp element_type;
      inline constexpr __shared_ptr() noexcept(true)
        : _M_ptr(0), _M_refcount()
      {
      }
      template < typename _Tp1 >
      inline explicit __shared_ptr(_Tp1 *__p)
        : _M_ptr(__p), _M_refcount(__p)
      {
        static_assert(sizeof(_Tp1) > 0, "incomplete type");
        __enable_shared_from_this_helper(::std::__shared_ptr<_Tp, _Lp>::_M_refcount, __p, __p);
      }
      template < typename _Tp1, typename _Deleter >
      inline __shared_ptr(_Tp1 *__p, _Deleter __d)
        : _M_ptr(__p), _M_refcount(__p, __d)
      {
        __enable_shared_from_this_helper(::std::__shared_ptr<_Tp, _Lp>::_M_refcount, __p, __p);
      }
      template < typename _Tp1, typename _Deleter, typename _Alloc >
      inline __shared_ptr(_Tp1 *__p, _Deleter __d, _Alloc __a)
        : _M_ptr(__p), _M_refcount(__p, __d, std::move(__a))
      {
        __enable_shared_from_this_helper(::std::__shared_ptr<_Tp, _Lp>::_M_refcount, __p, __p);
      }
      template < typename _Deleter >
      inline __shared_ptr(::std::nullptr_t __p, _Deleter __d)
        : _M_ptr(0), _M_refcount(__p, __d)
      {
      }
      template < typename _Deleter, typename _Alloc >
      inline __shared_ptr(::std::nullptr_t __p, _Deleter __d, _Alloc __a)
        : _M_ptr(0), _M_refcount(__p, __d, std::move(__a))
      {
      }
      template < typename _Tp1 >
      inline __shared_ptr(const ::std::__shared_ptr<_Tp1, _Lp> &__r, _Tp *__p) noexcept(true)
        : _M_ptr(__p), _M_refcount(__r._M_refcount)
      {
      }
      __shared_ptr(const ::std::__shared_ptr<_Tp, _Lp> &) noexcept(true) = default ;
      ::std::__shared_ptr<_Tp, _Lp> &operator =(const ::std::__shared_ptr<_Tp, _Lp> &) noexcept(true) = default ;
      ~__shared_ptr() = default ;
      template < typename _Tp1, typename __type_tpl__param_2_1__ = typename ::std::enable_if<std::is_convertible<_Tp1 *, _Tp *>::value>::type >
      inline __shared_ptr(const ::std::__shared_ptr<_Tp1, _Lp> &__r) noexcept(true)
        : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
      {
      }
      inline __shared_ptr(::std::__shared_ptr<_Tp, _Lp> &&__r) noexcept(true)
        : _M_ptr(__r._M_ptr), _M_refcount()
      {
        ::std::__shared_ptr<_Tp, _Lp>::_M_refcount._M_swap(__r._M_refcount);
        __r._M_ptr = 0;
      }
      template < typename _Tp1, typename __type_tpl__param_2_1__ = typename ::std::enable_if<std::is_convertible<_Tp1 *, _Tp *>::value>::type >
      inline __shared_ptr(::std::__shared_ptr<_Tp1, _Lp> &&__r) noexcept(true)
        : _M_ptr(__r._M_ptr), _M_refcount()
      {
        ::std::__shared_ptr<_Tp, _Lp>::_M_refcount._M_swap(__r._M_refcount);
        __r._M_ptr = 0;
      }
      template < typename _Tp1 >
      inline explicit __shared_ptr(const ::std::__weak_ptr<_Tp1, _Lp> &__r)
        : _M_refcount(__r._M_refcount)
      {
        ::std::__shared_ptr<_Tp, _Lp>::_M_ptr = __r._M_ptr;
      }
      template < typename _Tp1, typename _Del >
      inline __shared_ptr(::std::unique_ptr<_Tp1, _Del> &&__r)
        : _M_ptr(__r.get()), _M_refcount()
      {
        auto __tmp = __r.get();
        ::std::__shared_ptr<_Tp, _Lp>::_M_refcount = ::std::__shared_count<_Lp>(std::move(__r));
        __enable_shared_from_this_helper(::std::__shared_ptr<_Tp, _Lp>::_M_refcount, __tmp, __tmp);
      }
      template < typename _Tp1 >
      inline __shared_ptr(::std::auto_ptr<_Tp1> &&__r);
      inline constexpr __shared_ptr(::std::nullptr_t) noexcept(true)
        : _M_ptr(0), _M_refcount()
      {
      }
      template < typename _Tp1 >
      inline ::std::__shared_ptr<_Tp, _Lp> &operator =(const ::std::__shared_ptr<_Tp1, _Lp> &__r) noexcept(true)
      {
        ::std::__shared_ptr<_Tp, _Lp>::_M_ptr = __r._M_ptr;
        ::std::__shared_ptr<_Tp, _Lp>::_M_refcount = __r._M_refcount;
        return *this;
      }
      template < typename _Tp1 >
      inline ::std::__shared_ptr<_Tp, _Lp> &operator =(::std::auto_ptr<_Tp1> &&__r)
      {
        ::std::__shared_ptr<_Tp, _Lp>(std::move(__r)).swap(*this);
        return *this;
      }
      inline ::std::__shared_ptr<_Tp, _Lp> &operator =(::std::__shared_ptr<_Tp, _Lp> &&__r) noexcept(true)
      {
        ::std::__shared_ptr<_Tp, _Lp>(std::move(__r)).swap(*this);
        return *this;
      }
      template < typename _Tp1 >
      inline ::std::__shared_ptr<_Tp, _Lp> &operator =(::std::__shared_ptr<_Tp1, _Lp> &&__r) noexcept(true)
      {
        ::std::__shared_ptr<_Tp, _Lp>(std::move(__r)).swap(*this);
        return *this;
      }
      template < typename _Tp1, typename _Del >
      inline ::std::__shared_ptr<_Tp, _Lp> &operator =(::std::unique_ptr<_Tp1, _Del> &&__r)
      {
        ::std::__shared_ptr<_Tp, _Lp>(std::move(__r)).swap(*this);
        return *this;
      }
      inline void reset() noexcept(true)
      {
        ::std::__shared_ptr<_Tp, _Lp>().swap(*this);
      }
      template < typename _Tp1 >
      inline void reset(_Tp1 *__p)
      {
        ;
        ::std::__shared_ptr<_Tp, _Lp>(__p).swap(*this);
      }
      template < typename _Tp1, typename _Deleter >
      inline void reset(_Tp1 *__p, _Deleter __d)
      {
        ::std::__shared_ptr<_Tp, _Lp>(__p, __d).swap(*this);
      }
      template < typename _Tp1, typename _Deleter, typename _Alloc >
      inline void reset(_Tp1 *__p, _Deleter __d, _Alloc __a)
      {
        ::std::__shared_ptr<_Tp, _Lp>(__p, __d, std::move(__a)).swap(*this);
      }
      inline typename ::std::add_lvalue_reference<_Tp>::type operator *() const  noexcept(true)
      {
        ;
        return *::std::__shared_ptr<_Tp, _Lp>::_M_ptr;
      }
      inline _Tp *operator ->() const  noexcept(true)
      {
        ;
        return ::std::__shared_ptr<_Tp, _Lp>::_M_ptr;
      }
      inline _Tp *get() const  noexcept(true)
      {
        return ::std::__shared_ptr<_Tp, _Lp>::_M_ptr;
      }
      inline explicit operator bool() const 
      {
        return ::std::__shared_ptr<_Tp, _Lp>::_M_ptr == 0 ? false : true;
      }
      inline bool unique() const  noexcept(true)
      {
        return ::std::__shared_ptr<_Tp, _Lp>::_M_refcount._M_unique();
      }
      inline long int use_count() const  noexcept(true)
      {
        return ::std::__shared_ptr<_Tp, _Lp>::_M_refcount._M_get_use_count();
      }
      inline void swap(::std::__shared_ptr<_Tp, _Lp> &__other) noexcept(true)
      {
        std::swap(::std::__shared_ptr<_Tp, _Lp>::_M_ptr, __other._M_ptr);
        ::std::__shared_ptr<_Tp, _Lp>::_M_refcount._M_swap(__other._M_refcount);
      }
      template < typename _Tp1 >
      inline bool owner_before(const ::std::__shared_ptr<_Tp1, _Lp> &__rhs) const 
      {
        return ::std::__shared_ptr<_Tp, _Lp>::_M_refcount._M_less(__rhs._M_refcount);
      }
      template < typename _Tp1 >
      inline bool owner_before(const ::std::__weak_ptr<_Tp1, _Lp> &__rhs) const 
      {
        return ::std::__shared_ptr<_Tp, _Lp>::_M_refcount._M_less(__rhs._M_refcount);
      }
    protected:
      template < typename _Alloc, typename ..._Args >
      inline __shared_ptr(::std::_Sp_make_shared_tag __tag, const _Alloc &__a, _Args &&...__args)
        : _M_ptr(), _M_refcount(__tag, (_Tp *)0, __a, std::forward<_Args>(__args) ...)
      {
        void *__p = ::std::__shared_ptr<_Tp, _Lp>::_M_refcount._M_get_deleter(typeid(__tag));
        ::std::__shared_ptr<_Tp, _Lp>::_M_ptr = static_cast<_Tp *>(__p);
        __enable_shared_from_this_helper(::std::__shared_ptr<_Tp, _Lp>::_M_refcount, ::std::__shared_ptr<_Tp, _Lp>::_M_ptr, ::std::__shared_ptr<_Tp, _Lp>::_M_ptr);
      }
    private:
      inline void *_M_get_deleter(const ::std::type_info &__ti) const  noexcept(true)
      {
        return ::std::__shared_ptr<_Tp, _Lp>::_M_refcount._M_get_deleter(__ti);
      }
      _Tp *_M_ptr;
      ::std::__shared_count<_Lp> _M_refcount;
    template < typename _Tp1, ::__gnu_cxx::_Lock_policy _Lp1, typename _Alloc, typename ..._Args >
    friend ::std::__shared_ptr<_Tp1, _Lp1> __allocate_shared(const _Alloc &, _Args &&...);
    template < typename _Tp1, ::__gnu_cxx::_Lock_policy _Lp1 >
    friend class __shared_ptr;
    template < typename _Tp1, ::__gnu_cxx::_Lock_policy _Lp1 >
    friend class __weak_ptr;
    template < typename _Del, typename _Tp1, ::__gnu_cxx::_Lock_policy _Lp1 >
    friend _Del *get_deleter(const ::std::__shared_ptr<_Tp1, _Lp1> &) throw();
  };
  template < typename _Tp1, typename _Tp2, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator ==(const ::std::__shared_ptr<_Tp1, _Lp> &__a, const ::std::__shared_ptr<_Tp2, _Lp> &__b) noexcept(true);
  template < typename _Tp1, typename _Tp2, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator ==(const ::std::__shared_ptr<_Tp1, _Lp> &__a, const ::std::__shared_ptr<_Tp2, _Lp> &__b) noexcept(true)
  {
    return __a.get() == __b.get();
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator ==(const ::std::__shared_ptr<_Tp, _Lp> &__a, ::std::nullptr_t) noexcept(true);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator ==(const ::std::__shared_ptr<_Tp, _Lp> &__a, ::std::nullptr_t) noexcept(true)
  {
    return !__a;
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator ==(::std::nullptr_t, const ::std::__shared_ptr<_Tp, _Lp> &__a) noexcept(true);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator ==(::std::nullptr_t, const ::std::__shared_ptr<_Tp, _Lp> &__a) noexcept(true)
  {
    return !__a;
  }
  template < typename _Tp1, typename _Tp2, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator !=(const ::std::__shared_ptr<_Tp1, _Lp> &__a, const ::std::__shared_ptr<_Tp2, _Lp> &__b) noexcept(true);
  template < typename _Tp1, typename _Tp2, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator !=(const ::std::__shared_ptr<_Tp1, _Lp> &__a, const ::std::__shared_ptr<_Tp2, _Lp> &__b) noexcept(true)
  {
    return __a.get() != __b.get();
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator !=(const ::std::__shared_ptr<_Tp, _Lp> &__a, ::std::nullptr_t) noexcept(true);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator !=(const ::std::__shared_ptr<_Tp, _Lp> &__a, ::std::nullptr_t) noexcept(true)
  {
    return (bool)__a;
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator !=(::std::nullptr_t, const ::std::__shared_ptr<_Tp, _Lp> &__a) noexcept(true);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator !=(::std::nullptr_t, const ::std::__shared_ptr<_Tp, _Lp> &__a) noexcept(true)
  {
    return (bool)__a;
  }
  template < typename _Tp1, typename _Tp2, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator <(const ::std::__shared_ptr<_Tp1, _Lp> &__a, const ::std::__shared_ptr<_Tp2, _Lp> &__b) noexcept(true);
  template < typename _Tp1, typename _Tp2, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator <(const ::std::__shared_ptr<_Tp1, _Lp> &__a, const ::std::__shared_ptr<_Tp2, _Lp> &__b) noexcept(true)
  {
    typedef typename ::std::common_type<_Tp1 *, _Tp2 *>::type _CT;
    return ::std::less<_CT>()(__a.get(), __b.get());
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator <(const ::std::__shared_ptr<_Tp, _Lp> &__a, ::std::nullptr_t) noexcept(true);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator <(const ::std::__shared_ptr<_Tp, _Lp> &__a, ::std::nullptr_t) noexcept(true)
  {
    return ::std::less<_Tp *>()(__a.get(), nullptr);
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator <(::std::nullptr_t, const ::std::__shared_ptr<_Tp, _Lp> &__a) noexcept(true);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator <(::std::nullptr_t, const ::std::__shared_ptr<_Tp, _Lp> &__a) noexcept(true)
  {
    return ::std::less<_Tp *>()(nullptr, __a.get());
  }
  template < typename _Tp1, typename _Tp2, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator <=(const ::std::__shared_ptr<_Tp1, _Lp> &__a, const ::std::__shared_ptr<_Tp2, _Lp> &__b) noexcept(true);
  template < typename _Tp1, typename _Tp2, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator <=(const ::std::__shared_ptr<_Tp1, _Lp> &__a, const ::std::__shared_ptr<_Tp2, _Lp> &__b) noexcept(true)
  {
    return !(__b < __a);
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator <=(const ::std::__shared_ptr<_Tp, _Lp> &__a, ::std::nullptr_t) noexcept(true);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator <=(const ::std::__shared_ptr<_Tp, _Lp> &__a, ::std::nullptr_t) noexcept(true)
  {
    return !(nullptr < __a);
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator <=(::std::nullptr_t, const ::std::__shared_ptr<_Tp, _Lp> &__a) noexcept(true);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator <=(::std::nullptr_t, const ::std::__shared_ptr<_Tp, _Lp> &__a) noexcept(true)
  {
    return !(__a < nullptr);
  }
  template < typename _Tp1, typename _Tp2, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator >(const ::std::__shared_ptr<_Tp1, _Lp> &__a, const ::std::__shared_ptr<_Tp2, _Lp> &__b) noexcept(true);
  template < typename _Tp1, typename _Tp2, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator >(const ::std::__shared_ptr<_Tp1, _Lp> &__a, const ::std::__shared_ptr<_Tp2, _Lp> &__b) noexcept(true)
  {
    return __b < __a;
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator >(const ::std::__shared_ptr<_Tp, _Lp> &__a, ::std::nullptr_t) noexcept(true);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator >(const ::std::__shared_ptr<_Tp, _Lp> &__a, ::std::nullptr_t) noexcept(true)
  {
    return ::std::less<_Tp *>()(nullptr, __a.get());
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator >(::std::nullptr_t, const ::std::__shared_ptr<_Tp, _Lp> &__a) noexcept(true);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator >(::std::nullptr_t, const ::std::__shared_ptr<_Tp, _Lp> &__a) noexcept(true)
  {
    return ::std::less<_Tp *>()(__a.get(), nullptr);
  }
  template < typename _Tp1, typename _Tp2, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator >=(const ::std::__shared_ptr<_Tp1, _Lp> &__a, const ::std::__shared_ptr<_Tp2, _Lp> &__b) noexcept(true);
  template < typename _Tp1, typename _Tp2, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator >=(const ::std::__shared_ptr<_Tp1, _Lp> &__a, const ::std::__shared_ptr<_Tp2, _Lp> &__b) noexcept(true)
  {
    return !(__a < __b);
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator >=(const ::std::__shared_ptr<_Tp, _Lp> &__a, ::std::nullptr_t) noexcept(true);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator >=(const ::std::__shared_ptr<_Tp, _Lp> &__a, ::std::nullptr_t) noexcept(true)
  {
    return !(__a < nullptr);
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator >=(::std::nullptr_t, const ::std::__shared_ptr<_Tp, _Lp> &__a) noexcept(true);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline bool operator >=(::std::nullptr_t, const ::std::__shared_ptr<_Tp, _Lp> &__a) noexcept(true)
  {
    return !(nullptr < __a);
  }
  template < typename _Sp >
  struct  _Sp_less : ::std::binary_function<_Sp, _Sp, bool>
  {
      inline bool operator ()(const _Sp &__lhs, const _Sp &__rhs) const  noexcept(true)
      {
        typedef typename _Sp::element_type element_type;
        return ::std::less<element_type *>()(__lhs.get(), __rhs.get());
      }
  };
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  struct  less< ::std::__shared_ptr<_Tp, _Lp> > : ::std::_Sp_less< ::std::__shared_ptr<_Tp, _Lp> >
  {
  };
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline void swap(::std::__shared_ptr<_Tp, _Lp> &__a, ::std::__shared_ptr<_Tp, _Lp> &__b) noexcept(true);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline void swap(::std::__shared_ptr<_Tp, _Lp> &__a, ::std::__shared_ptr<_Tp, _Lp> &__b) noexcept(true)
  {
    __a.swap(__b);
  }
  template < typename _Tp, typename _Tp1, ::__gnu_cxx::_Lock_policy _Lp >
  inline ::std::__shared_ptr<_Tp, _Lp> static_pointer_cast(const ::std::__shared_ptr<_Tp1, _Lp> &__r) noexcept(true);
  template < typename _Tp, typename _Tp1, ::__gnu_cxx::_Lock_policy _Lp >
  inline ::std::__shared_ptr<_Tp, _Lp> static_pointer_cast(const ::std::__shared_ptr<_Tp1, _Lp> &__r) noexcept(true)
  {
    return ::std::__shared_ptr<_Tp, _Lp>(__r, static_cast<_Tp *>(__r.get()));
  }
  template < typename _Tp, typename _Tp1, ::__gnu_cxx::_Lock_policy _Lp >
  inline ::std::__shared_ptr<_Tp, _Lp> const_pointer_cast(const ::std::__shared_ptr<_Tp1, _Lp> &__r) noexcept(true);
  template < typename _Tp, typename _Tp1, ::__gnu_cxx::_Lock_policy _Lp >
  inline ::std::__shared_ptr<_Tp, _Lp> const_pointer_cast(const ::std::__shared_ptr<_Tp1, _Lp> &__r) noexcept(true)
  {
    return ::std::__shared_ptr<_Tp, _Lp>(__r, const_cast<_Tp *>(__r.get()));
  }
  template < typename _Tp, typename _Tp1, ::__gnu_cxx::_Lock_policy _Lp >
  inline ::std::__shared_ptr<_Tp, _Lp> dynamic_pointer_cast(const ::std::__shared_ptr<_Tp1, _Lp> &__r) noexcept(true);
  template < typename _Tp, typename _Tp1, ::__gnu_cxx::_Lock_policy _Lp >
  inline ::std::__shared_ptr<_Tp, _Lp> dynamic_pointer_cast(const ::std::__shared_ptr<_Tp1, _Lp> &__r) noexcept(true)
  {
    if (_Tp *__p = dynamic_cast<_Tp *>(__r.get()))
      {
        return ::std::__shared_ptr<_Tp, _Lp>(__r, __p);
      }
    return ::std::__shared_ptr<_Tp, _Lp>();
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  class  __weak_ptr
  {
    public:
      typedef _Tp element_type;
      inline constexpr __weak_ptr() noexcept(true)
        : _M_ptr(0), _M_refcount()
      {
      }
      __weak_ptr(const ::std::__weak_ptr<_Tp, _Lp> &) noexcept(true) = default ;
      ::std::__weak_ptr<_Tp, _Lp> &operator =(const ::std::__weak_ptr<_Tp, _Lp> &) noexcept(true) = default ;
      ~__weak_ptr() = default ;
      template < typename _Tp1, typename __type_tpl__param_2_1__ = typename ::std::enable_if<std::is_convertible<_Tp1 *, _Tp *>::value>::type >
      inline __weak_ptr(const ::std::__weak_ptr<_Tp1, _Lp> &__r) noexcept(true)
        : _M_refcount(__r._M_refcount)
      {
        ::std::__weak_ptr<_Tp, _Lp>::_M_ptr = __r.lock().get();
      }
      template < typename _Tp1, typename __type_tpl__param_2_1__ = typename ::std::enable_if<std::is_convertible<_Tp1 *, _Tp *>::value>::type >
      inline __weak_ptr(const ::std::__shared_ptr<_Tp1, _Lp> &__r) noexcept(true)
        : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
      {
      }
      template < typename _Tp1 >
      inline ::std::__weak_ptr<_Tp, _Lp> &operator =(const ::std::__weak_ptr<_Tp1, _Lp> &__r) noexcept(true)
      {
        ::std::__weak_ptr<_Tp, _Lp>::_M_ptr = __r.lock().get();
        ::std::__weak_ptr<_Tp, _Lp>::_M_refcount = __r._M_refcount;
        return *this;
      }
      template < typename _Tp1 >
      inline ::std::__weak_ptr<_Tp, _Lp> &operator =(const ::std::__shared_ptr<_Tp1, _Lp> &__r) noexcept(true)
      {
        ::std::__weak_ptr<_Tp, _Lp>::_M_ptr = __r._M_ptr;
        ::std::__weak_ptr<_Tp, _Lp>::_M_refcount = __r._M_refcount;
        return *this;
      }
      inline ::std::__shared_ptr<_Tp, _Lp> lock() const  noexcept(true)
      {
        if ((*this).expired())
          {
            return ::std::__shared_ptr<typename ::std::__weak_ptr<_Tp, _Lp>::element_type, _Lp>();
          }
        try
        {
          return ::std::__shared_ptr<typename ::std::__weak_ptr<_Tp, _Lp>::element_type, _Lp>(*this);
        }
        catch (const ::std::bad_weak_ptr &)
        {
          return ::std::__shared_ptr<typename ::std::__weak_ptr<_Tp, _Lp>::element_type, _Lp>();
        }
      }
      inline long int use_count() const  noexcept(true)
      {
        return ::std::__weak_ptr<_Tp, _Lp>::_M_refcount._M_get_use_count();
      }
      inline bool expired() const  noexcept(true)
      {
        return ::std::__weak_ptr<_Tp, _Lp>::_M_refcount._M_get_use_count() == 0;
      }
      template < typename _Tp1 >
      inline bool owner_before(const ::std::__shared_ptr<_Tp1, _Lp> &__rhs) const 
      {
        return ::std::__weak_ptr<_Tp, _Lp>::_M_refcount._M_less(__rhs._M_refcount);
      }
      template < typename _Tp1 >
      inline bool owner_before(const ::std::__weak_ptr<_Tp1, _Lp> &__rhs) const 
      {
        return ::std::__weak_ptr<_Tp, _Lp>::_M_refcount._M_less(__rhs._M_refcount);
      }
      inline void reset() noexcept(true)
      {
        ::std::__weak_ptr<_Tp, _Lp>().swap(*this);
      }
      inline void swap(::std::__weak_ptr<_Tp, _Lp> &__s) noexcept(true)
      {
        std::swap(::std::__weak_ptr<_Tp, _Lp>::_M_ptr, __s._M_ptr);
        ::std::__weak_ptr<_Tp, _Lp>::_M_refcount._M_swap(__s._M_refcount);
      }
    private:
      inline void _M_assign(_Tp *__ptr, const ::std::__shared_count<_Lp> &__refcount) noexcept(true)
      {
        ::std::__weak_ptr<_Tp, _Lp>::_M_ptr = __ptr;
        ::std::__weak_ptr<_Tp, _Lp>::_M_refcount = __refcount;
      }
      _Tp *_M_ptr;
      ::std::__weak_count<_Lp> _M_refcount;
    template < typename _Tp1, ::__gnu_cxx::_Lock_policy _Lp1 >
    friend class __shared_ptr;
    template < typename _Tp1, ::__gnu_cxx::_Lock_policy _Lp1 >
    friend class __weak_ptr;
    friend class ::std::__enable_shared_from_this<_Tp, _Lp>;
    friend class ::std::enable_shared_from_this<_Tp>;
  };
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline void swap(::std::__weak_ptr<_Tp, _Lp> &__a, ::std::__weak_ptr<_Tp, _Lp> &__b) noexcept(true);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline void swap(::std::__weak_ptr<_Tp, _Lp> &__a, ::std::__weak_ptr<_Tp, _Lp> &__b) noexcept(true)
  {
    __a.swap(__b);
  }
  template < typename _Tp, typename _Tp1 >
  struct  _Sp_owner_less : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__lhs, const _Tp &__rhs) const 
      {
        return __lhs.owner_before(__rhs);
      }
      inline bool operator ()(const _Tp &__lhs, const _Tp1 &__rhs) const 
      {
        return __lhs.owner_before(__rhs);
      }
      inline bool operator ()(const _Tp1 &__lhs, const _Tp &__rhs) const 
      {
        return __lhs.owner_before(__rhs);
      }
  };
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  struct  owner_less< ::std::__shared_ptr<_Tp, _Lp> > : ::std::_Sp_owner_less< ::std::__shared_ptr<_Tp, _Lp>, ::std::__weak_ptr<_Tp, _Lp> >
  {
  };
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  struct  owner_less< ::std::__weak_ptr<_Tp, _Lp> > : ::std::_Sp_owner_less< ::std::__weak_ptr<_Tp, _Lp>, ::std::__shared_ptr<_Tp, _Lp> >
  {
  };
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  class  __enable_shared_from_this
  {
    protected:
      inline constexpr __enable_shared_from_this() noexcept(true)
      {
      }
      inline __enable_shared_from_this(const ::std::__enable_shared_from_this<_Tp, _Lp> &) noexcept(true)
      {
      }
      inline ::std::__enable_shared_from_this<_Tp, _Lp> &operator =(const ::std::__enable_shared_from_this<_Tp, _Lp> &) noexcept(true)
      {
        return *this;
      }
      inline ~__enable_shared_from_this()
      {
      }
    public:
      inline ::std::__shared_ptr<_Tp, _Lp> shared_from_this()
      {
        return ::std::__shared_ptr<_Tp, _Lp>(this->_M_weak_this);
      }
      inline ::std::__shared_ptr<const _Tp, _Lp> shared_from_this() const 
      {
        return ::std::__shared_ptr<const _Tp, _Lp>(this->_M_weak_this);
      }
    private:
      template < typename _Tp1 >
      inline void _M_weak_assign(_Tp1 *__p, const ::std::__shared_count<_Lp> &__n) const  noexcept(true)
      {
        ::std::__enable_shared_from_this<_Tp, _Lp>::_M_weak_this._M_assign(__p, __n);
      }
      mutable ::std::__weak_ptr<_Tp, _Lp> _M_weak_this;
    template < typename _Tp1 >
    friend inline void __enable_shared_from_this_helper(const ::std::__shared_count<_Lp> &__pn, const ::std::__enable_shared_from_this<_Tp, _Lp> *__pe, const _Tp1 *__px) throw()
    {
      if (__pe != 0)
        {
          __pe->_M_weak_assign(const_cast<_Tp1 *>(__px), __pn);
        }
    }
  };
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp, typename _Alloc, typename ..._Args >
  inline ::std::__shared_ptr<_Tp, _Lp> __allocate_shared(const _Alloc &__a, _Args &&...__args);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp, typename _Alloc, typename ..._Args >
  inline ::std::__shared_ptr<_Tp, _Lp> __allocate_shared(const _Alloc &__a, _Args &&...__args)
  {
    return ::std::__shared_ptr<_Tp, _Lp>(::std::_Sp_make_shared_tag(), __a, std::forward<_Args>(__args) ...);
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp, typename ..._Args >
  inline ::std::__shared_ptr<_Tp, _Lp> __make_shared(_Args &&...__args);
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp, typename ..._Args >
  inline ::std::__shared_ptr<_Tp, _Lp> __make_shared(_Args &&...__args)
  {
    typedef typename ::std::remove_const<_Tp>::type _Tp_nc;
    return std::__allocate_shared<_Tp, _Lp>(::std::allocator<_Tp_nc>(), std::forward<_Args>(__args) ...);
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  struct  hash< ::std::__shared_ptr<_Tp, _Lp> > : ::std::__hash_base<unsigned long int, ::std::__shared_ptr<_Tp, _Lp> >
  {
      inline ::std::size_t operator ()(const ::std::__shared_ptr<_Tp, _Lp> &__s) const  noexcept(true)
      {
        return ::std::hash<_Tp *>()(__s.get());
      }
  };
  template < typename _Ch, typename _Tr, typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline ::std::basic_ostream<_Ch, _Tr> &operator <<(::std::basic_ostream<_Ch, _Tr> &__os, const ::std::__shared_ptr<_Tp, _Lp> &__p);
  template < typename _Ch, typename _Tr, typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline ::std::basic_ostream<_Ch, _Tr> &operator <<(::std::basic_ostream<_Ch, _Tr> &__os, const ::std::__shared_ptr<_Tp, _Lp> &__p)
  {
    __os << __p.get();
    return __os;
  }
  template < typename _Del, typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline _Del *get_deleter(const ::std::__shared_ptr<_Tp, _Lp> &__p) noexcept(true);
  template < typename _Del, typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  inline _Del *get_deleter(const ::std::__shared_ptr<_Tp, _Lp> &__p) noexcept(true)
  {
    return static_cast<_Del *>(__p._M_get_deleter(typeid(_Del)));
  }
  template < typename _Tp >
  class  shared_ptr : public ::std::__shared_ptr<_Tp>
  {
    public:
      inline constexpr shared_ptr() noexcept(true)
        : __shared_ptr<_Tp>()
      {
      }
      shared_ptr(const ::std::shared_ptr<_Tp> &) noexcept(true) = default ;
      template < typename _Tp1 >
      inline explicit shared_ptr(_Tp1 *__p)
        : __shared_ptr<_Tp>(__p)
      {
      }
      template < typename _Tp1, typename _Deleter >
      inline shared_ptr(_Tp1 *__p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, __d)
      {
      }
      template < typename _Deleter >
      inline shared_ptr(::std::nullptr_t __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, __d)
      {
      }
      template < typename _Tp1, typename _Deleter, typename _Alloc >
      inline shared_ptr(_Tp1 *__p, _Deleter __d, _Alloc __a)
        : __shared_ptr<_Tp>(__p, __d, std::move(__a))
      {
      }
      template < typename _Deleter, typename _Alloc >
      inline shared_ptr(::std::nullptr_t __p, _Deleter __d, _Alloc __a)
        : __shared_ptr<_Tp>(__p, __d, std::move(__a))
      {
      }
      template < typename _Tp1 >
      inline shared_ptr(const ::std::shared_ptr<_Tp1> &__r, _Tp *__p) noexcept(true)
        : __shared_ptr<_Tp>(__r, __p)
      {
      }
      template < typename _Tp1, typename __type_tpl__param_2_1__ = typename ::std::enable_if<std::is_convertible<_Tp1 *, _Tp *>::value>::type >
      inline shared_ptr(const ::std::shared_ptr<_Tp1> &__r) noexcept(true)
        : __shared_ptr<_Tp>(__r)
      {
      }
      inline shared_ptr(::std::shared_ptr<_Tp> &&__r) noexcept(true)
        : __shared_ptr<_Tp>(std::move(__r))
      {
      }
      template < typename _Tp1, typename __type_tpl__param_2_1__ = typename ::std::enable_if<std::is_convertible<_Tp1 *, _Tp *>::value>::type >
      inline shared_ptr(::std::shared_ptr<_Tp1> &&__r) noexcept(true)
        : __shared_ptr<_Tp>(std::move(__r))
      {
      }
      template < typename _Tp1 >
      inline explicit shared_ptr(const ::std::weak_ptr<_Tp1> &__r)
        : __shared_ptr<_Tp>(__r)
      {
      }
      template < typename _Tp1 >
      inline shared_ptr(::std::auto_ptr<_Tp1> &&__r);
      template < typename _Tp1, typename _Del >
      inline shared_ptr(::std::unique_ptr<_Tp1, _Del> &&__r)
        : __shared_ptr<_Tp>(std::move(__r))
      {
      }
      inline constexpr shared_ptr(::std::nullptr_t __p) noexcept(true)
        : __shared_ptr<_Tp>(__p)
      {
      }
      ::std::shared_ptr<_Tp> &operator =(const ::std::shared_ptr<_Tp> &) noexcept(true) = default ;
      template < typename _Tp1 >
      inline ::std::shared_ptr<_Tp> &operator =(const ::std::shared_ptr<_Tp1> &__r) noexcept(true)
      {
        this->__shared_ptr<_Tp>::operator =(__r);
        return *this;
      }
      template < typename _Tp1 >
      inline ::std::shared_ptr<_Tp> &operator =(::std::auto_ptr<_Tp1> &&__r)
      {
        this->__shared_ptr<_Tp>::operator =(std::move(__r));
        return *this;
      }
      inline ::std::shared_ptr<_Tp> &operator =(::std::shared_ptr<_Tp> &&__r) noexcept(true)
      {
        this->__shared_ptr<_Tp>::operator =(std::move(__r));
        return *this;
      }
      template < typename _Tp1 >
      inline ::std::shared_ptr<_Tp> &operator =(::std::shared_ptr<_Tp1> &&__r) noexcept(true)
      {
        this->__shared_ptr<_Tp>::operator =(std::move(__r));
        return *this;
      }
      template < typename _Tp1, typename _Del >
      inline ::std::shared_ptr<_Tp> &operator =(::std::unique_ptr<_Tp1, _Del> &&__r)
      {
        this->__shared_ptr<_Tp>::operator =(std::move(__r));
        return *this;
      }
    private:
      template < typename _Alloc, typename ..._Args >
      inline shared_ptr(::std::_Sp_make_shared_tag __tag, const _Alloc &__a, _Args &&...__args)
        : __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args) ...)
      {
      }
    template < typename _Tp1, typename _Alloc, typename ..._Args >
    friend ::std::shared_ptr<_Tp1> allocate_shared(const _Alloc &, _Args &&...);
  };
  template < typename _Tp1, typename _Tp2 >
  inline bool operator ==(const ::std::shared_ptr<_Tp1> &__a, const ::std::shared_ptr<_Tp2> &__b) noexcept(true);
  template < typename _Tp1, typename _Tp2 >
  inline bool operator ==(const ::std::shared_ptr<_Tp1> &__a, const ::std::shared_ptr<_Tp2> &__b) noexcept(true)
  {
    return __a.get() == __b.get();
  }
  template < typename _Tp >
  inline bool operator ==(const ::std::shared_ptr<_Tp> &__a, ::std::nullptr_t) noexcept(true);
  template < typename _Tp >
  inline bool operator ==(const ::std::shared_ptr<_Tp> &__a, ::std::nullptr_t) noexcept(true)
  {
    return !__a;
  }
  template < typename _Tp >
  inline bool operator ==(::std::nullptr_t, const ::std::shared_ptr<_Tp> &__a) noexcept(true);
  template < typename _Tp >
  inline bool operator ==(::std::nullptr_t, const ::std::shared_ptr<_Tp> &__a) noexcept(true)
  {
    return !__a;
  }
  template < typename _Tp1, typename _Tp2 >
  inline bool operator !=(const ::std::shared_ptr<_Tp1> &__a, const ::std::shared_ptr<_Tp2> &__b) noexcept(true);
  template < typename _Tp1, typename _Tp2 >
  inline bool operator !=(const ::std::shared_ptr<_Tp1> &__a, const ::std::shared_ptr<_Tp2> &__b) noexcept(true)
  {
    return __a.get() != __b.get();
  }
  template < typename _Tp >
  inline bool operator !=(const ::std::shared_ptr<_Tp> &__a, ::std::nullptr_t) noexcept(true);
  template < typename _Tp >
  inline bool operator !=(const ::std::shared_ptr<_Tp> &__a, ::std::nullptr_t) noexcept(true)
  {
    return (bool)__a;
  }
  template < typename _Tp >
  inline bool operator !=(::std::nullptr_t, const ::std::shared_ptr<_Tp> &__a) noexcept(true);
  template < typename _Tp >
  inline bool operator !=(::std::nullptr_t, const ::std::shared_ptr<_Tp> &__a) noexcept(true)
  {
    return (bool)__a;
  }
  template < typename _Tp1, typename _Tp2 >
  inline bool operator <(const ::std::shared_ptr<_Tp1> &__a, const ::std::shared_ptr<_Tp2> &__b) noexcept(true);
  template < typename _Tp1, typename _Tp2 >
  inline bool operator <(const ::std::shared_ptr<_Tp1> &__a, const ::std::shared_ptr<_Tp2> &__b) noexcept(true)
  {
    typedef typename ::std::common_type<_Tp1 *, _Tp2 *>::type _CT;
    return ::std::less<_CT>()(__a.get(), __b.get());
  }
  template < typename _Tp >
  inline bool operator <(const ::std::shared_ptr<_Tp> &__a, ::std::nullptr_t) noexcept(true);
  template < typename _Tp >
  inline bool operator <(const ::std::shared_ptr<_Tp> &__a, ::std::nullptr_t) noexcept(true)
  {
    return ::std::less<_Tp *>()(__a.get(), nullptr);
  }
  template < typename _Tp >
  inline bool operator <(::std::nullptr_t, const ::std::shared_ptr<_Tp> &__a) noexcept(true);
  template < typename _Tp >
  inline bool operator <(::std::nullptr_t, const ::std::shared_ptr<_Tp> &__a) noexcept(true)
  {
    return ::std::less<_Tp *>()(nullptr, __a.get());
  }
  template < typename _Tp1, typename _Tp2 >
  inline bool operator <=(const ::std::shared_ptr<_Tp1> &__a, const ::std::shared_ptr<_Tp2> &__b) noexcept(true);
  template < typename _Tp1, typename _Tp2 >
  inline bool operator <=(const ::std::shared_ptr<_Tp1> &__a, const ::std::shared_ptr<_Tp2> &__b) noexcept(true)
  {
    return !(__b < __a);
  }
  template < typename _Tp >
  inline bool operator <=(const ::std::shared_ptr<_Tp> &__a, ::std::nullptr_t) noexcept(true);
  template < typename _Tp >
  inline bool operator <=(const ::std::shared_ptr<_Tp> &__a, ::std::nullptr_t) noexcept(true)
  {
    return !(nullptr < __a);
  }
  template < typename _Tp >
  inline bool operator <=(::std::nullptr_t, const ::std::shared_ptr<_Tp> &__a) noexcept(true);
  template < typename _Tp >
  inline bool operator <=(::std::nullptr_t, const ::std::shared_ptr<_Tp> &__a) noexcept(true)
  {
    return !(__a < nullptr);
  }
  template < typename _Tp1, typename _Tp2 >
  inline bool operator >(const ::std::shared_ptr<_Tp1> &__a, const ::std::shared_ptr<_Tp2> &__b) noexcept(true);
  template < typename _Tp1, typename _Tp2 >
  inline bool operator >(const ::std::shared_ptr<_Tp1> &__a, const ::std::shared_ptr<_Tp2> &__b) noexcept(true)
  {
    return __b < __a;
  }
  template < typename _Tp >
  inline bool operator >(const ::std::shared_ptr<_Tp> &__a, ::std::nullptr_t) noexcept(true);
  template < typename _Tp >
  inline bool operator >(const ::std::shared_ptr<_Tp> &__a, ::std::nullptr_t) noexcept(true)
  {
    return ::std::less<_Tp *>()(nullptr, __a.get());
  }
  template < typename _Tp >
  inline bool operator >(::std::nullptr_t, const ::std::shared_ptr<_Tp> &__a) noexcept(true);
  template < typename _Tp >
  inline bool operator >(::std::nullptr_t, const ::std::shared_ptr<_Tp> &__a) noexcept(true)
  {
    return ::std::less<_Tp *>()(__a.get(), nullptr);
  }
  template < typename _Tp1, typename _Tp2 >
  inline bool operator >=(const ::std::shared_ptr<_Tp1> &__a, const ::std::shared_ptr<_Tp2> &__b) noexcept(true);
  template < typename _Tp1, typename _Tp2 >
  inline bool operator >=(const ::std::shared_ptr<_Tp1> &__a, const ::std::shared_ptr<_Tp2> &__b) noexcept(true)
  {
    return !(__a < __b);
  }
  template < typename _Tp >
  inline bool operator >=(const ::std::shared_ptr<_Tp> &__a, ::std::nullptr_t) noexcept(true);
  template < typename _Tp >
  inline bool operator >=(const ::std::shared_ptr<_Tp> &__a, ::std::nullptr_t) noexcept(true)
  {
    return !(__a < nullptr);
  }
  template < typename _Tp >
  inline bool operator >=(::std::nullptr_t, const ::std::shared_ptr<_Tp> &__a) noexcept(true);
  template < typename _Tp >
  inline bool operator >=(::std::nullptr_t, const ::std::shared_ptr<_Tp> &__a) noexcept(true)
  {
    return !(nullptr < __a);
  }
  template < typename _Tp >
  struct  less< ::std::shared_ptr<_Tp> > : ::std::_Sp_less< ::std::shared_ptr<_Tp> >
  {
  };
  template < typename _Tp >
  inline void swap(::std::shared_ptr<_Tp> &__a, ::std::shared_ptr<_Tp> &__b) noexcept(true);
  template < typename _Tp >
  inline void swap(::std::shared_ptr<_Tp> &__a, ::std::shared_ptr<_Tp> &__b) noexcept(true)
  {
    __a.swap(__b);
  }
  template < typename _Tp, typename _Tp1 >
  inline ::std::shared_ptr<_Tp> static_pointer_cast(const ::std::shared_ptr<_Tp1> &__r) noexcept(true);
  template < typename _Tp, typename _Tp1 >
  inline ::std::shared_ptr<_Tp> static_pointer_cast(const ::std::shared_ptr<_Tp1> &__r) noexcept(true)
  {
    return ::std::shared_ptr<_Tp>(__r, static_cast<_Tp *>(__r.get()));
  }
  template < typename _Tp, typename _Tp1 >
  inline ::std::shared_ptr<_Tp> const_pointer_cast(const ::std::shared_ptr<_Tp1> &__r) noexcept(true);
  template < typename _Tp, typename _Tp1 >
  inline ::std::shared_ptr<_Tp> const_pointer_cast(const ::std::shared_ptr<_Tp1> &__r) noexcept(true)
  {
    return ::std::shared_ptr<_Tp>(__r, const_cast<_Tp *>(__r.get()));
  }
  template < typename _Tp, typename _Tp1 >
  inline ::std::shared_ptr<_Tp> dynamic_pointer_cast(const ::std::shared_ptr<_Tp1> &__r) noexcept(true);
  template < typename _Tp, typename _Tp1 >
  inline ::std::shared_ptr<_Tp> dynamic_pointer_cast(const ::std::shared_ptr<_Tp1> &__r) noexcept(true)
  {
    if (_Tp *__p = dynamic_cast<_Tp *>(__r.get()))
      {
        return ::std::shared_ptr<_Tp>(__r, __p);
      }
    return ::std::shared_ptr<_Tp>();
  }
  template < typename _Tp >
  class  weak_ptr : public ::std::__weak_ptr<_Tp>
  {
    public:
      inline constexpr weak_ptr() noexcept(true)
        : __weak_ptr<_Tp>()
      {
      }
      template < typename _Tp1, typename __type_tpl__param_2_1__ = typename ::std::enable_if<std::is_convertible<_Tp1 *, _Tp *>::value>::type >
      inline weak_ptr(const ::std::weak_ptr<_Tp1> &__r) noexcept(true)
        : __weak_ptr<_Tp>(__r)
      {
      }
      template < typename _Tp1, typename __type_tpl__param_2_1__ = typename ::std::enable_if<std::is_convertible<_Tp1 *, _Tp *>::value>::type >
      inline weak_ptr(const ::std::shared_ptr<_Tp1> &__r) noexcept(true)
        : __weak_ptr<_Tp>(__r)
      {
      }
      template < typename _Tp1 >
      inline ::std::weak_ptr<_Tp> &operator =(const ::std::weak_ptr<_Tp1> &__r) noexcept(true)
      {
        this->__weak_ptr<_Tp>::operator =(__r);
        return *this;
      }
      template < typename _Tp1 >
      inline ::std::weak_ptr<_Tp> &operator =(const ::std::shared_ptr<_Tp1> &__r) noexcept(true)
      {
        this->__weak_ptr<_Tp>::operator =(__r);
        return *this;
      }
      inline ::std::shared_ptr<_Tp> lock() const  noexcept(true)
      {
        if (this->expired())
          {
            return ::std::shared_ptr<_Tp>();
          }
        try
        {
          return ::std::shared_ptr<_Tp>(*this);
        }
        catch (const ::std::bad_weak_ptr &)
        {
          return ::std::shared_ptr<_Tp>();
        }
      }
  };
  template < typename _Tp >
  inline void swap(::std::weak_ptr<_Tp> &__a, ::std::weak_ptr<_Tp> &__b) noexcept(true);
  template < typename _Tp >
  inline void swap(::std::weak_ptr<_Tp> &__a, ::std::weak_ptr<_Tp> &__b) noexcept(true)
  {
    __a.swap(__b);
  }
  template < typename _Tp >
  struct owner_less;
  template < typename _Tp >
  struct  owner_less< ::std::shared_ptr<_Tp> > : ::std::_Sp_owner_less< ::std::shared_ptr<_Tp>, ::std::weak_ptr<_Tp> >
  {
  };
  template < typename _Tp >
  struct  owner_less< ::std::weak_ptr<_Tp> > : ::std::_Sp_owner_less< ::std::weak_ptr<_Tp>, ::std::shared_ptr<_Tp> >
  {
  };
  template < typename _Tp >
  class  enable_shared_from_this
  {
    protected:
      inline constexpr enable_shared_from_this() noexcept(true)
      {
      }
      inline enable_shared_from_this(const ::std::enable_shared_from_this<_Tp> &) noexcept(true)
      {
      }
      inline ::std::enable_shared_from_this<_Tp> &operator =(const ::std::enable_shared_from_this<_Tp> &) noexcept(true)
      {
        return *this;
      }
      inline ~enable_shared_from_this()
      {
      }
    public:
      inline ::std::shared_ptr<_Tp> shared_from_this()
      {
        return ::std::shared_ptr<_Tp>(this->_M_weak_this);
      }
      inline ::std::shared_ptr<const _Tp> shared_from_this() const 
      {
        return ::std::shared_ptr<const _Tp>(this->_M_weak_this);
      }
    private:
      template < typename _Tp1 >
      inline void _M_weak_assign(_Tp1 *__p, const ::std::__shared_count<> &__n) const  noexcept(true)
      {
        ::std::enable_shared_from_this<_Tp>::_M_weak_this._M_assign(__p, __n);
      }
      mutable ::std::weak_ptr<_Tp> _M_weak_this;
    template < typename _Tp1 >
    friend inline void __enable_shared_from_this_helper(const ::std::__shared_count<> &__pn, const ::std::enable_shared_from_this<_Tp> *__pe, const _Tp1 *__px) throw()
    {
      if (__pe != 0)
        {
          __pe->_M_weak_assign(const_cast<_Tp1 *>(__px), __pn);
        }
    }
  };
  template < typename _Tp, typename _Alloc, typename ..._Args >
  inline ::std::shared_ptr<_Tp> allocate_shared(const _Alloc &__a, _Args &&...__args);
  template < typename _Tp, typename _Alloc, typename ..._Args >
  inline ::std::shared_ptr<_Tp> allocate_shared(const _Alloc &__a, _Args &&...__args)
  {
    return ::std::shared_ptr<_Tp>(::std::_Sp_make_shared_tag(), __a, std::forward<_Args>(__args) ...);
  }
  template < typename _Tp, typename ..._Args >
  inline ::std::shared_ptr<_Tp> make_shared(_Args &&...__args);
  template < typename _Tp, typename ..._Args >
  inline ::std::shared_ptr<_Tp> make_shared(_Args &&...__args)
  {
    typedef typename ::std::remove_const<_Tp>::type _Tp_nc;
    return std::allocate_shared<_Tp>(::std::allocator<_Tp_nc>(), std::forward<_Args>(__args) ...);
  }
  template < typename _Tp >
  struct  hash< ::std::shared_ptr<_Tp> > : ::std::__hash_base<unsigned long int, ::std::shared_ptr<_Tp> >
  {
      inline ::std::size_t operator ()(const ::std::shared_ptr<_Tp> &__s) const  noexcept(true)
      {
        return ::std::hash<_Tp *>()(__s.get());
      }
  };
  template < typename _Tp1 >
  struct __attribute__((__deprecated__))  auto_ptr_ref
  {
      _Tp1 *_M_ptr;
      inline explicit auto_ptr_ref(_Tp1 *__p)
        : _M_ptr(__p)
      {
      }
  };
  template < typename _Tp >
  class __attribute__((__deprecated__))  auto_ptr
  {
      _Tp *_M_ptr;
    public:
      typedef _Tp element_type;
      inline explicit auto_ptr(typename ::std::auto_ptr<_Tp>::element_type *__p  = (0)) throw()
        : _M_ptr(__p)
      {
      }
      inline auto_ptr(::std::auto_ptr<_Tp> &__a) throw()
        : _M_ptr(__a.release())
      {
      }
      template < typename _Tp1 >
      inline auto_ptr(::std::auto_ptr<_Tp1> &__a) throw()
        : _M_ptr(__a.release())
      {
      }
      inline ::std::auto_ptr<_Tp> &operator =(::std::auto_ptr<_Tp> &__a) throw()
      {
        (*this).reset(__a.release());
        return *this;
      }
      template < typename _Tp1 >
      inline ::std::auto_ptr<_Tp> &operator =(::std::auto_ptr<_Tp1> &__a) throw()
      {
        (*this).reset(__a.release());
        return *this;
      }
      inline ~auto_ptr()
      {
        delete ::std::auto_ptr<_Tp>::_M_ptr;
      }
      inline typename ::std::auto_ptr<_Tp>::element_type &operator *() const  throw()
      {
        ;
        return *::std::auto_ptr<_Tp>::_M_ptr;
      }
      inline typename ::std::auto_ptr<_Tp>::element_type *operator ->() const  throw()
      {
        ;
        return ::std::auto_ptr<_Tp>::_M_ptr;
      }
      inline typename ::std::auto_ptr<_Tp>::element_type *get() const  throw()
      {
        return ::std::auto_ptr<_Tp>::_M_ptr;
      }
      inline typename ::std::auto_ptr<_Tp>::element_type *release() throw()
      {
        typename ::std::auto_ptr<_Tp>::element_type *__tmp = ::std::auto_ptr<_Tp>::_M_ptr;
        ::std::auto_ptr<_Tp>::_M_ptr = 0;
        return __tmp;
      }
      inline void reset(typename ::std::auto_ptr<_Tp>::element_type *__p  = (0)) throw()
      {
        if (__p != ::std::auto_ptr<_Tp>::_M_ptr)
          {
            delete ::std::auto_ptr<_Tp>::_M_ptr;
            ::std::auto_ptr<_Tp>::_M_ptr = __p;
          }
      }
      inline auto_ptr(::std::auto_ptr_ref<typename ::std::auto_ptr<_Tp>::element_type> __ref) throw()
        : _M_ptr(__ref._M_ptr)
      {
      }
      inline ::std::auto_ptr<_Tp> &operator =(::std::auto_ptr_ref<typename ::std::auto_ptr<_Tp>::element_type> __ref) throw()
      {
        if (__ref._M_ptr != this->get())
          {
            delete ::std::auto_ptr<_Tp>::_M_ptr;
            ::std::auto_ptr<_Tp>::_M_ptr = __ref._M_ptr;
          }
        return *this;
      }
      template < typename _Tp1 >
      inline operator ::std::auto_ptr_ref<_Tp1>() throw()
      {
        return ::std::auto_ptr_ref<_Tp1>(this->release());
      }
      template < typename _Tp1 >
      inline operator ::std::auto_ptr<_Tp1>() throw()
      {
        return ::std::auto_ptr<_Tp1>(this->release());
      }
  };
  template <>
  class __attribute__((__deprecated__))  auto_ptr<void>
  {
    public:
      typedef void element_type;
  };
  template < ::__gnu_cxx::_Lock_policy _Lp >
  template < typename _Tp >
  inline __shared_count<_Lp>::__shared_count(::std::auto_ptr<_Tp> &&__r)
    : _M_pi(new ::std::_Sp_counted_ptr<_Tp *, _Lp>(__r.get()))
  {
    __r.release();
  }
  template < typename _Tp, ::__gnu_cxx::_Lock_policy _Lp >
  template < typename _Tp1 >
  inline __shared_ptr<_Tp, _Lp>::__shared_ptr(::std::auto_ptr<_Tp1> &&__r)
    : _M_ptr(__r.get()), _M_refcount()
  {
    static_assert(sizeof(_Tp1) > 0, "incomplete type");
    _Tp1 *__tmp = __r.get();
    ::std::__shared_ptr<_Tp, _Lp>::_M_refcount = ::std::__shared_count<_Lp>(std::move(__r));
    __enable_shared_from_this_helper(::std::__shared_ptr<_Tp, _Lp>::_M_refcount, __tmp, __tmp);
  }
  template < typename _Tp >
  template < typename _Tp1 >
  inline shared_ptr<_Tp>::shared_ptr(::std::auto_ptr<_Tp1> &&__r)
    : __shared_ptr<_Tp>(std::move(__r))
  {
  }
  template < typename _Tp, typename _Dp >
  template < typename _Up, typename __type_tpl__param_2_1__ >
  inline unique_ptr<_Tp, _Dp>::unique_ptr(::std::auto_ptr<_Up> &&__u) noexcept(true)
    : _M_t(__u.release(), ((typename ::std::unique_ptr<_Tp, _Dp>::deleter_type())))
  {
  }
}
namespace boost {
  template < typename T >
  class  scoped_ptr
  {
      T *px;
      scoped_ptr(const ::boost::scoped_ptr<T> &);
      ::boost::scoped_ptr<T> &operator =(const ::boost::scoped_ptr<T> &);
      typedef ::boost::scoped_ptr<T> this_type;
      void operator ==(const ::boost::scoped_ptr<T> &) const ;
      void operator !=(const ::boost::scoped_ptr<T> &) const ;
    public:
      typedef T element_type;
      inline explicit scoped_ptr(T *p  = (0))
        : px(p)
      {
      }
      inline explicit scoped_ptr(::std::auto_ptr<T> p) noexcept(true)
        : px(p.release())
      {
      }
      inline ~scoped_ptr()
      {
        boost::checked_delete(::boost::scoped_ptr<T>::px);
      }
      inline void reset(T *p  = (0))
      {
        p == 0 || p != ::boost::scoped_ptr<T>::px ? static_cast<void>(0) : __assert_fail("p == 0 || p != px", "/usr/include/boost/smart_ptr/scoped_ptr.hpp", 87, __PRETTY_FUNCTION__);
        ((typename ::boost::scoped_ptr<T>::this_type(p))).swap(*this);
      }
      inline T &operator *() const 
      {
        ::boost::scoped_ptr<T>::px != 0 ? static_cast<void>(0) : __assert_fail("px != 0", "/usr/include/boost/smart_ptr/scoped_ptr.hpp", 93, __PRETTY_FUNCTION__);
        return *::boost::scoped_ptr<T>::px;
      }
      inline T *operator ->() const 
      {
        ::boost::scoped_ptr<T>::px != 0 ? static_cast<void>(0) : __assert_fail("px != 0", "/usr/include/boost/smart_ptr/scoped_ptr.hpp", 99, __PRETTY_FUNCTION__);
        return ::boost::scoped_ptr<T>::px;
      }
      inline T *get() const  noexcept(true)
      {
        return ::boost::scoped_ptr<T>::px;
      }
      inline explicit operator bool() const  noexcept(true)
      {
        return ::boost::scoped_ptr<T>::px != 0;
      }
      inline bool operator !() const  noexcept(true)
      {
        return ::boost::scoped_ptr<T>::px == 0;
      }
      inline void swap(::boost::scoped_ptr<T> &b) noexcept(true)
      {
        T *tmp = b.px;
        b.px = ::boost::scoped_ptr<T>::px;
        ::boost::scoped_ptr<T>::px = tmp;
      }
  };
  template < typename T >
  inline bool operator ==(const ::boost::scoped_ptr<T> &p, ::boost::detail::sp_nullptr_t) noexcept(true);
  template < typename T >
  inline bool operator ==(const ::boost::scoped_ptr<T> &p, ::boost::detail::sp_nullptr_t) noexcept(true)
  {
    return p.get() == 0;
  }
  template < typename T >
  inline bool operator ==(::boost::detail::sp_nullptr_t, const ::boost::scoped_ptr<T> &p) noexcept(true);
  template < typename T >
  inline bool operator ==(::boost::detail::sp_nullptr_t, const ::boost::scoped_ptr<T> &p) noexcept(true)
  {
    return p.get() == 0;
  }
  template < typename T >
  inline bool operator !=(const ::boost::scoped_ptr<T> &p, ::boost::detail::sp_nullptr_t) noexcept(true);
  template < typename T >
  inline bool operator !=(const ::boost::scoped_ptr<T> &p, ::boost::detail::sp_nullptr_t) noexcept(true)
  {
    return p.get() != 0;
  }
  template < typename T >
  inline bool operator !=(::boost::detail::sp_nullptr_t, const ::boost::scoped_ptr<T> &p) noexcept(true);
  template < typename T >
  inline bool operator !=(::boost::detail::sp_nullptr_t, const ::boost::scoped_ptr<T> &p) noexcept(true)
  {
    return p.get() != 0;
  }
  template < typename T >
  inline void swap(::boost::scoped_ptr<T> &a, ::boost::scoped_ptr<T> &b) noexcept(true);
  template < typename T >
  inline void swap(::boost::scoped_ptr<T> &a, ::boost::scoped_ptr<T> &b) noexcept(true)
  {
    a.swap(b);
  }
  template < typename T >
  inline T *get_pointer(const ::boost::scoped_ptr<T> &p) noexcept(true);
  template < typename T >
  inline T *get_pointer(const ::boost::scoped_ptr<T> &p) noexcept(true)
  {
    return p.get();
  }
  namespace serialization {
    template < typename E >
    inline void throw_exception(const E &e);
    template < typename E >
    inline void throw_exception(const E &e)
    {
      throw e;
    }
  }
  namespace archive {
    class  archive_exception : virtual public ::std::exception
    {
      protected:
        char m_buffer[128L];
      public:
        enum exception_code
        {
          no_exception = 0,
          other_exception = 1,
          unregistered_class = 2,
          invalid_signature = 3,
          unsupported_version = 4,
          pointer_conflict = 5,
          incompatible_native_format = 6,
          array_size_too_short = 7,
          input_stream_error = 8,
          invalid_class_name = 9,
          unregistered_cast = 10,
          unsupported_class_version = 11,
          multiple_code_instantiation = 12,
          output_stream_error = 13
        };
        ::boost::archive::archive_exception::exception_code code;
        archive_exception(::boost::archive::archive_exception::exception_code c, const char *e1  = (0L), const char *e2  = (0L));
        virtual ~archive_exception() throw();
        virtual const char *what() const  throw();
      protected:
        unsigned int append(unsigned int l, const char *a);
        archive_exception();
      public:
    };
  }
  namespace noncopyable_ {
    class  noncopyable
    {
      protected:
        inline constexpr noncopyable() = default ;
        ~noncopyable() = default ;
        noncopyable(const ::boost::noncopyable_::noncopyable &) = delete ;
        ::boost::noncopyable_::noncopyable &operator =(const ::boost::noncopyable_::noncopyable &) = delete ;
    };
  }
  typedef ::boost::noncopyable_::noncopyable noncopyable;
  namespace archive {
    template < typename Ch, typename Tr >
    class  basic_streambuf_locale_saver : ::boost::noncopyable_::noncopyable
    {
      public:
        typedef ::std::basic_streambuf<Ch, Tr> state_type;
        typedef ::std::locale aspect_type;
        inline explicit basic_streambuf_locale_saver(typename ::boost::archive::basic_streambuf_locale_saver<Ch, Tr>::state_type &s)
          : s_save_(s), a_save_(s.getloc())
        {
        }
        inline basic_streambuf_locale_saver(typename ::boost::archive::basic_streambuf_locale_saver<Ch, Tr>::state_type &s, const typename ::boost::archive::basic_streambuf_locale_saver<Ch, Tr>::aspect_type &a)
          : s_save_(s), a_save_(s.pubimbue(a))
        {
        }
        inline ~basic_streambuf_locale_saver()
        {
          this->restore();
        }
        inline void restore()
        {
          ::boost::archive::basic_streambuf_locale_saver<Ch, Tr>::s_save_.pubimbue(::boost::archive::basic_streambuf_locale_saver<Ch, Tr>::a_save_);
        }
      private:
        typename ::boost::archive::basic_streambuf_locale_saver<Ch, Tr>::state_type &s_save_;
        const typename ::boost::archive::basic_streambuf_locale_saver<Ch, Tr>::aspect_type a_save_;
    };
    template < typename IStream >
    class  basic_text_iprimitive
    {
      protected:
        IStream &is;
        ::boost::io::ios_flags_saver flags_saver;
        ::boost::io::ios_precision_saver precision_saver;
        ::boost::scoped_ptr< ::std::locale> archive_locale;
        ::boost::archive::basic_streambuf_locale_saver<typename IStream::char_type, typename IStream::traits_type> locale_saver;
        template < typename T >
        inline void load(T &t)
        {
          if (!::boost::archive::basic_text_iprimitive<IStream>::is.fail())
            {
              ::boost::archive::basic_text_iprimitive<IStream>::is >> t;
              return ;
            }
          boost::serialization::throw_exception(::boost::archive::archive_exception(::boost::archive::archive_exception::input_stream_error /* , 0L, 0L */ ));
        }
        inline void load(char &t)
        {
          short int i;
          (*this).load(i);
          t = i;
        }
        inline void load(signed char &t)
        {
          short int i;
          (*this).load(i);
          t = i;
        }
        inline void load(unsigned char &t)
        {
          unsigned short int i;
          (*this).load(i);
          t = i;
        }
        inline void load(wchar_t &t)
        {
          int i;
          (*this).load(i);
          t = i;
        }
        basic_text_iprimitive(IStream &is, bool no_codecvt);
        ~basic_text_iprimitive();
      public:
        void load_binary(void *address, ::std::size_t count);
    };
  }
  namespace serialization {
    template < typename T >
    struct  pfto_wrapper
    {
        const T &t;
        inline operator const T &()
        {
          return ::boost::serialization::pfto_wrapper<T>::t;
        }
        inline pfto_wrapper(const T &rhs)
          : t(rhs)
        {
        }
    };
    template < typename T >
    ::boost::serialization::pfto_wrapper<T> make_pfto_wrapper(const T &t, int);
    template < typename T >
    ::boost::serialization::pfto_wrapper<T> make_pfto_wrapper(const T &t, int)
    {
      return ::boost::serialization::pfto_wrapper<T>(t);
    }
    template < typename T >
    ::boost::serialization::pfto_wrapper<T> make_pfto_wrapper(const ::boost::serialization::pfto_wrapper<T> &t, int);
    template < typename T >
    ::boost::serialization::pfto_wrapper<T> make_pfto_wrapper(const ::boost::serialization::pfto_wrapper<T> &t, int)
    {
      return t;
    }
    enum tracking_type
    {
      track_never = 0,
      track_selectively = 1,
      track_always = 2
    };
  }
  using ::int8_t;
  using ::int_least8_t;
  using ::int_fast8_t;
  using ::uint8_t;
  using ::uint_least8_t;
  using ::uint_fast8_t;
  using ::int16_t;
  using ::int_least16_t;
  using ::int_fast16_t;
  using ::uint16_t;
  using ::uint_least16_t;
  using ::uint_fast16_t;
  using ::int32_t;
  using ::int_least32_t;
  using ::int_fast32_t;
  using ::uint32_t;
  using ::uint_least32_t;
  using ::uint_fast32_t;
  using ::int64_t;
  using ::int_least64_t;
  using ::int_fast64_t;
  using ::uint64_t;
  using ::uint_least64_t;
  using ::uint_fast64_t;
  using ::intmax_t;
  using ::uintmax_t;
  template < typename T >
  class  integer_traits : public ::std::numeric_limits<T>
  {
    public:
      static const bool is_integral = false;
  };
  namespace detail {
    template < typename T, T min_val, T max_val >
    class  integer_traits_base
    {
      public:
        static const bool is_integral = true;
        static const T const_min = min_val;
        static const T const_max = max_val;
    };
 /* Instantiation of class template '::boost::detail::integer_traits_base<bool, false, true>' */ 
  }
  template <>
  class  integer_traits<bool> : public ::std::numeric_limits<bool>, public ::boost::detail::integer_traits_base<bool, false, true>
  {
    public:
  };
 /* Instantiation of class template '::boost::detail::integer_traits_base<char,  -127 - 1, 127>' */ 
  template <>
  class  integer_traits<char> : public ::std::numeric_limits<char>, public ::boost::detail::integer_traits_base<char,  -127 - 1, 127>
  {
    public:
  };
 /* Instantiation of class template '::boost::detail::integer_traits_base<signed char,  -127 - 1, 127>' */ 
  template <>
  class  integer_traits<signed char> : public ::std::numeric_limits<signed char>, public ::boost::detail::integer_traits_base<signed char,  -127 - 1, 127>
  {
    public:
  };
 /* Instantiation of class template '::boost::detail::integer_traits_base<unsigned char, 0, 127 * 2 + 1>' */ 
  template <>
  class  integer_traits<unsigned char> : public ::std::numeric_limits<unsigned char>, public ::boost::detail::integer_traits_base<unsigned char, 0, 127 * 2 + 1>
  {
    public:
  };
 /* Instantiation of class template '::boost::detail::integer_traits_base<wchar_t,  -2147483647 - 1, 2147483647>' */ 
  template <>
  class  integer_traits<wchar_t> : public ::std::numeric_limits<wchar_t>, public ::boost::detail::integer_traits_base<wchar_t,  -2147483647 - 1, 2147483647>
  {
    public:
  };
 /* Instantiation of class template '::boost::detail::integer_traits_base<short int,  -32767 - 1, 32767>' */ 
  template <>
  class  integer_traits<short int> : public ::std::numeric_limits<short int>, public ::boost::detail::integer_traits_base<short int,  -32767 - 1, 32767>
  {
    public:
  };
 /* Instantiation of class template '::boost::detail::integer_traits_base<unsigned short int, 0, 32767 * 2 + 1>' */ 
  template <>
  class  integer_traits<unsigned short int> : public ::std::numeric_limits<unsigned short int>, public ::boost::detail::integer_traits_base<unsigned short int, 0, 32767 * 2 + 1>
  {
    public:
  };
 /* Instantiation of class template '::boost::detail::integer_traits_base<int,  -2147483647 - 1, 2147483647>' */ 
  template <>
  class  integer_traits<int> : public ::std::numeric_limits<int>, public ::boost::detail::integer_traits_base<int,  -2147483647 - 1, 2147483647>
  {
    public:
  };
 /* Instantiation of class template '::boost::detail::integer_traits_base<unsigned int, 0, 2147483647 * 2U + 1U>' */ 
  template <>
  class  integer_traits<unsigned int> : public ::std::numeric_limits<unsigned int>, public ::boost::detail::integer_traits_base<unsigned int, 0, 2147483647 * 2U + 1U>
  {
    public:
  };
 /* Instantiation of class template '::boost::detail::integer_traits_base<long int,  -9223372036854775807L - 1L, 9223372036854775807L>' */ 
  template <>
  class  integer_traits<long int> : public ::std::numeric_limits<long int>, public ::boost::detail::integer_traits_base<long int,  -9223372036854775807L - 1L, 9223372036854775807L>
  {
    public:
  };
 /* Instantiation of class template '::boost::detail::integer_traits_base<unsigned long int, 0, 9223372036854775807L * 2LU + 1LU>' */ 
  template <>
  class  integer_traits<unsigned long int> : public ::std::numeric_limits<unsigned long int>, public ::boost::detail::integer_traits_base<unsigned long int, 0, 9223372036854775807L * 2LU + 1LU>
  {
    public:
  };
 /* Instantiation of class template '::boost::detail::integer_traits_base<long long int,  -9223372036854775807LL - 1, 9223372036854775807LL>' */ 
  template <>
  class  integer_traits<long long int> : public ::std::numeric_limits<long long int>, public ::boost::detail::integer_traits_base<long long int,  -9223372036854775807LL - 1, 9223372036854775807LL>
  {
    public:
  };
 /* Instantiation of class template '::boost::detail::integer_traits_base<unsigned long long int, 0, 9223372036854775807LL * 2LLU + 1>' */ 
  template <>
  class  integer_traits<unsigned long long int> : public ::std::numeric_limits<unsigned long long int>, public ::boost::detail::integer_traits_base<unsigned long long int, 0, 9223372036854775807LL * 2LLU + 1>
  {
    public:
  };
  namespace archive {
    class  library_version_type
    {
        typedef ::uint_least16_t base_type;
        ::boost::archive::library_version_type::base_type t;
      public:
        inline library_version_type()
          : t(0)
        {
        }
        inline explicit library_version_type(const unsigned int &t_)
          : t(t_)
        {
          static const char __MERCURIUM_PRETTY_FUNCTION__[83L] = "::boost::archive::library_version_type::library_version_type(const unsigned int &)";
          t_ <= ::boost::detail::integer_traits_base<unsigned short int, 0, 32767 * 2 + 1>::const_max ? static_cast<void>(0) : ::__assert_fail("t_ <= boost::integer_traits<base_type>::const_max", "/usr/include/boost/archive/basic_archive.hpp", 47, __MERCURIUM_PRETTY_FUNCTION__);
        }
        inline library_version_type(const ::boost::archive::library_version_type &t_)
          : t(t_.t)
        {
        }
        inline ::boost::archive::library_version_type &operator =(const ::boost::archive::library_version_type &rhs)
        {
          (*this).t = rhs.t;
          return *this;
        }
        inline operator ::boost::archive::library_version_type::base_type() const 
        {
          return (*this).t;
        }
        inline operator ::boost::archive::library_version_type::base_type &()
        {
          return (*this).t;
        }
        inline bool operator ==(const ::boost::archive::library_version_type &rhs) const 
        {
          return (*this).t == rhs.t;
        }
        inline bool operator <(const ::boost::archive::library_version_type &rhs) const 
        {
          return (*this).t < rhs.t;
        }
    };
    ::boost::archive::library_version_type BOOST_ARCHIVE_VERSION();
    class  version_type
    {
        typedef ::uint_least32_t base_type;
        ::boost::archive::version_type::base_type t;
      public:
        inline version_type()
          : t(0)
        {
        }
        inline explicit version_type(const unsigned int &t_)
          : t(t_)
        {
          static const char __MERCURIUM_PRETTY_FUNCTION__[67L] = "::boost::archive::version_type::version_type(const unsigned int &)";
          t_ <= ::boost::detail::integer_traits_base<unsigned int, 0, 2147483647 * 2U + 1U>::const_max ? static_cast<void>(0) : ::__assert_fail("t_ <= boost::integer_traits<base_type>::const_max", "/usr/include/boost/archive/basic_archive.hpp", 83, __MERCURIUM_PRETTY_FUNCTION__);
        }
        inline version_type(const ::boost::archive::version_type &t_)
          : t(t_.t)
        {
        }
        inline ::boost::archive::version_type &operator =(const ::boost::archive::version_type &rhs)
        {
          (*this).t = rhs.t;
          return *this;
        }
        inline operator ::boost::archive::version_type::base_type() const 
        {
          return (*this).t;
        }
        inline operator ::boost::archive::version_type::base_type &()
        {
          return (*this).t;
        }
        inline bool operator ==(const ::boost::archive::version_type &rhs) const 
        {
          return (*this).t == rhs.t;
        }
        inline bool operator <(const ::boost::archive::version_type &rhs) const 
        {
          return (*this).t < rhs.t;
        }
    };
    class  class_id_type
    {
        typedef ::int_least16_t base_type;
        ::boost::archive::class_id_type::base_type t;
      public:
        inline class_id_type()
          : t(0)
        {
        }
        inline explicit class_id_type(const int t_)
          : t(t_)
        {
          static const char __MERCURIUM_PRETTY_FUNCTION__[58L] = "::boost::archive::class_id_type::class_id_type(const int)";
          t_ <= ::boost::detail::integer_traits_base<short int,  -32767 - 1, 32767>::const_max ? static_cast<void>(0) : ::__assert_fail("t_ <= boost::integer_traits<base_type>::const_max", "/usr/include/boost/archive/basic_archive.hpp", 116, __MERCURIUM_PRETTY_FUNCTION__);
        }
        inline explicit class_id_type(const ::std::size_t t_)
          : t(t_)
        {
        }
        inline class_id_type(const ::boost::archive::class_id_type &t_)
          : t(t_.t)
        {
        }
        inline ::boost::archive::class_id_type &operator =(const ::boost::archive::class_id_type &rhs)
        {
          (*this).t = rhs.t;
          return *this;
        }
        inline operator int() const 
        {
          return (*this).t;
        }
        inline operator ::int_least16_t &()
        {
          return (*this).t;
        }
        inline bool operator ==(const ::boost::archive::class_id_type &rhs) const 
        {
          return (*this).t == rhs.t;
        }
        inline bool operator <(const ::boost::archive::class_id_type &rhs) const 
        {
          return (*this).t < rhs.t;
        }
    };
    class  object_id_type
    {
        typedef ::uint_least32_t base_type;
        ::boost::archive::object_id_type::base_type t;
      public:
        inline object_id_type()
          : t(0)
        {
        }
        inline explicit object_id_type(const ::std::size_t &t_)
          : t(t_)
        {
          static const char __MERCURIUM_PRETTY_FUNCTION__[72L] = "::boost::archive::object_id_type::object_id_type(const ::std::size_t &)";
          t_ <= ::boost::detail::integer_traits_base<unsigned int, 0, 2147483647 * 2U + 1U>::const_max ? static_cast<void>(0) : ::__assert_fail("t_ <= boost::integer_traits<base_type>::const_max", "/usr/include/boost/archive/basic_archive.hpp", 155, __MERCURIUM_PRETTY_FUNCTION__);
        }
        inline object_id_type(const ::boost::archive::object_id_type &t_)
          : t(t_.t)
        {
        }
        inline ::boost::archive::object_id_type &operator =(const ::boost::archive::object_id_type &rhs)
        {
          (*this).t = rhs.t;
          return *this;
        }
        inline operator ::uint_least32_t() const 
        {
          return (*this).t;
        }
        inline operator ::uint_least32_t &()
        {
          return (*this).t;
        }
        inline bool operator ==(const ::boost::archive::object_id_type &rhs) const 
        {
          return (*this).t == rhs.t;
        }
        inline bool operator <(const ::boost::archive::object_id_type &rhs) const 
        {
          return (*this).t < rhs.t;
        }
    };
    struct  tracking_type
    {
        bool t;
        inline explicit tracking_type(const bool t_  = (false))
          : t(t_)
        {
        }
        inline tracking_type(const ::boost::archive::tracking_type &t_)
          : t(t_.t)
        {
        }
        inline operator bool() const 
        {
          return (*this).t;
        }
        inline operator bool &()
        {
          return (*this).t;
        }
        inline ::boost::archive::tracking_type &operator =(const bool t_)
        {
          (*this).t = t_;
          return *this;
        }
        inline bool operator ==(const ::boost::archive::tracking_type &rhs) const 
        {
          return (*this).t == rhs.t;
        }
        inline bool operator ==(const bool &rhs) const 
        {
          return (*this).t == rhs;
        }
        inline ::boost::archive::tracking_type &operator =(const ::boost::archive::tracking_type &rhs)
        {
          (*this).t = rhs.t;
          return *this;
        }
    };
    struct  class_name_type : private ::boost::noncopyable_::noncopyable
    {
        char *t;
        inline operator const char *&() const 
        {
          return const_cast<const char *&>((*this).t);
        }
        inline operator char *()
        {
          return (*this).t;
        }
        inline explicit class_name_type(const char *key_)
          : t(const_cast<char *>(key_))
        {
        }
        inline explicit class_name_type(char *key_)
          : t(key_)
        {
        }
        inline ::boost::archive::class_name_type &operator =(const ::boost::archive::class_name_type &rhs)
        {
          (*this).t = rhs.t;
          return *this;
        }
    };
    enum archive_flags
    {
      no_header = 1,
      no_codecvt = 2,
      no_xml_tag_checking = 4,
      no_tracking = 8,
      flags_last = 8
    };
    const char *BOOST_ARCHIVE_SIGNATURE();
    class  class_id_reference_type : public ::boost::archive::class_id_type
    {
      public:
        inline explicit class_id_reference_type(const ::boost::archive::class_id_type tt)
          : ::boost::archive::class_id_type(tt)
        {
        }
    };
    class  class_id_optional_type : public ::boost::archive::class_id_type
    {
      public:
        inline explicit class_id_optional_type(const ::boost::archive::class_id_type tt)
          : ::boost::archive::class_id_type(tt)
        {
        }
    };
    class  object_reference_type : public ::boost::archive::object_id_type
    {
      public:
        inline explicit object_reference_type(const ::boost::archive::object_id_type tt)
          : ::boost::archive::object_id_type(tt)
        {
        }
    };
  }
}
namespace mpl_ { }
namespace boost {
  namespace mpl {
    using namespace ::mpl_;
  }
}
namespace mpl_ {
   namespace aux { }
}
namespace boost {
  namespace mpl {
    namespace aux {
      using namespace ::mpl_::aux;
    }
  }
}
namespace mpl_ {
   template < int N >
  struct int_;
}
namespace boost {
  namespace mpl {
    using ::mpl_::int_;
  }
}
namespace mpl_ {
   struct  integral_c_tag
  {
      static const int value = 0;
  };
}
namespace boost {
  namespace mpl {
    using ::mpl_::integral_c_tag;
  }
}
namespace mpl_ {
   template < int N >
  struct  int_
  {
      static const int value = N;
      typedef ::mpl_::int_<N> type;
      typedef int value_type;
      typedef ::mpl_::integral_c_tag tag;
      typedef ::mpl_::int_<static_cast<int>(::mpl_::int_<N>::value + 1)> next;
      typedef ::mpl_::int_<static_cast<int>(::mpl_::int_<N>::value - 1)> prior;
      inline operator int() const 
      {
        return static_cast<int>(this->value);
      }
  };
}
namespace boost {
  namespace mpl {
    namespace aux {
      template < typename F >
      struct template_arity;
    }
  }
}
namespace mpl_ {
   template < bool C_ >
  struct bool_;
  typedef ::mpl_::bool_<true> true_;
  typedef ::mpl_::bool_<false> false_;
}
namespace boost {
  namespace mpl {
    using ::mpl_::bool_;
    using ::mpl_::true_;
    using ::mpl_::false_;
  }
}
namespace mpl_ {
   template < bool C_ >
  struct  bool_
  {
      static const bool value = C_;
      typedef ::mpl_::integral_c_tag tag;
      typedef ::mpl_::bool_<C_> type;
      typedef bool value_type;
      inline operator bool() const 
      {
        return this->value;
      }
  };
  template < typename T, T N >
  struct integral_c;
}
namespace boost {
  namespace mpl {
    using ::mpl_::integral_c;
  }
}
namespace mpl_ {
   template < typename T, T N >
  struct  integral_c
  {
      static const T value = N;
      typedef ::mpl_::integral_c<T, N> type;
      typedef T value_type;
      typedef ::mpl_::integral_c_tag tag;
      typedef ::mpl_::integral_c<T, static_cast<T>(::mpl_::integral_c<T, N>::value + 1)> next;
      typedef ::mpl_::integral_c<T, static_cast<T>(::mpl_::integral_c<T, N>::value - 1)> prior;
      inline operator T() const 
      {
        return static_cast<T>(this->value);
      }
  };
  template < bool C >
  struct  integral_c<bool, C>
  {
      static const bool value = C;
      typedef ::mpl_::integral_c_tag tag;
      typedef ::mpl_::integral_c<bool, C> type;
      typedef bool value_type;
      inline operator bool() const 
      {
        return this->value;
      }
  };
}
namespace boost {
  template < typename T, T val >
  struct  integral_constant : ::mpl_::integral_c<T, val>
  {
      typedef ::boost::integral_constant<T, val> type;
  };
 /* Instantiation of class template '::mpl_::bool_<true>' */ 
  template <>
  struct  integral_constant<bool, true> : ::mpl_::bool_<true>
  {
      typedef ::boost::integral_constant<bool, true> type;
  };
 /* Instantiation of class template '::mpl_::bool_<false>' */ 
  template <>
  struct  integral_constant<bool, false> : ::mpl_::bool_<false>
  {
      typedef ::boost::integral_constant<bool, false> type;
  };
  typedef ::boost::integral_constant<bool, true> true_type;
  typedef ::boost::integral_constant<bool, false> false_type;
  template < typename T >
  struct  is_integral : ::boost::integral_constant<bool, false>
  {
  };
  template <>
  struct  is_integral<unsigned char> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const unsigned char> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile unsigned char> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile unsigned char> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<unsigned short int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const unsigned short int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile unsigned short int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile unsigned short int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<unsigned int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const unsigned int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile unsigned int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile unsigned int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<unsigned long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const unsigned long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile unsigned long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile unsigned long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<signed char> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const signed char> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile signed char> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile signed char> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<short int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const short int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile short int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile short int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<bool> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const bool> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile bool> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile bool> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<char> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const char> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile char> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile char> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<wchar_t> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const wchar_t> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile wchar_t> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile wchar_t> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<unsigned long long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const unsigned long long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile unsigned long long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile unsigned long long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<long long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const long long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile long long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile long long int> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<__int128> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const __int128> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile __int128> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile __int128> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<unsigned __int128> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const unsigned __int128> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<volatile unsigned __int128> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_integral<const volatile unsigned __int128> : ::boost::integral_constant<bool, true>
  {
  };
  template < typename T >
  struct  is_float : ::boost::integral_constant<bool, false>
  {
  };
  template <>
  struct  is_float<float> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_float<const float> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_float<volatile float> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_float<const volatile float> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_float<double> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_float<const double> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_float<volatile double> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_float<const volatile double> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_float<long double> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_float<const long double> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_float<volatile long double> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_float<const volatile long double> : ::boost::integral_constant<bool, true>
  {
  };
  namespace type_traits {
    template < bool b1, bool b2, bool b3 = false, bool b4 = false, bool b5 = false, bool b6 = false, bool b7 = false >
    struct ice_or;
    template < bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7 >
    struct  ice_or
    {
        static const bool value = true;
    };
    template <>
    struct  ice_or<false, false, false, false, false, false, false>
    {
        static const bool value = false;
    };
  }
  namespace detail {
    template < typename T >
    struct  is_arithmetic_impl
    {
        static const bool value = ::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_float<T>::value>::value;
    };
  }
  template < typename T >
  struct  is_arithmetic : ::boost::integral_constant<bool, ::boost::detail::is_arithmetic_impl<T>::value>
  {
  };
  template < typename T >
  struct  is_void : ::boost::integral_constant<bool, false>
  {
  };
  template <>
  struct  is_void<void> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_void<const void> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_void<volatile void> : ::boost::integral_constant<bool, true>
  {
  };
  template <>
  struct  is_void<const volatile void> : ::boost::integral_constant<bool, true>
  {
  };
  namespace detail {
    template < typename T >
    struct  is_fundamental_impl : ::boost::type_traits::ice_or< ::boost::is_arithmetic<T>::value, ::boost::is_void<T>::value>
    {
    };
  }
  template < typename T >
  struct  is_fundamental : ::boost::integral_constant<bool, ::boost::detail::is_fundamental_impl<T>::value>
  {
  };
  template < typename T, typename U >
  struct  is_same : ::boost::integral_constant<bool, false>
  {
  };
  template < typename T >
  struct  is_same<T, T> : ::boost::integral_constant<bool, true>
  {
  };
  template < typename T >
  struct  is_lvalue_reference : ::boost::integral_constant<bool, false>
  {
  };
  template < typename T >
  struct  is_lvalue_reference<T &> : ::boost::integral_constant<bool, true>
  {
  };
  template < typename T >
  struct  is_rvalue_reference : ::boost::integral_constant<bool, false>
  {
  };
  template < typename T >
  struct  is_rvalue_reference<T &&> : ::boost::integral_constant<bool, true>
  {
  };
  namespace type_traits {
    typedef char yes_type;
    struct  no_type
    {
        char padding[8L];
    };
    template < bool b1, bool b2, bool b3 = true, bool b4 = true, bool b5 = true, bool b6 = true, bool b7 = true >
    struct ice_and;
    template < bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7 >
    struct  ice_and
    {
        static const bool value = false;
    };
    template <>
    struct  ice_and<true, true, true, true, true, true, true>
    {
        static const bool value = true;
    };
    template < bool b >
    struct  ice_not
    {
        static const bool value = true;
    };
    template <>
    struct  ice_not<true>
    {
        static const bool value = false;
    };
    template < int b1, int b2 >
    struct  ice_eq
    {
        static const bool value = b1 == b2;
    };
    template < int b1, int b2 >
    struct  ice_ne
    {
        static const bool value = b1 != b2;
    };
  }
  namespace detail {
    template < typename T >
    struct  is_reference_impl
    {
        static const bool value = ::boost::type_traits::ice_or< ::boost::is_lvalue_reference<T>::value, ::boost::is_rvalue_reference<T>::value>::value;
    };
  }
  template < typename T >
  struct  is_reference : ::boost::integral_constant<bool, ::boost::detail::is_reference_impl<T>::value>
  {
  };
  namespace detail {
    template < typename T >
    struct  cv_traits_imp
    {
    };
    template < typename T >
    struct  cv_traits_imp<T *>
    {
        static const bool is_const = false;
        static const bool is_volatile = false;
        typedef T unqualified_type;
    };
    template < typename T >
    struct  cv_traits_imp<const T *>
    {
        static const bool is_const = true;
        static const bool is_volatile = false;
        typedef T unqualified_type;
    };
    template < typename T >
    struct  cv_traits_imp<volatile T *>
    {
        static const bool is_const = false;
        static const bool is_volatile = true;
        typedef T unqualified_type;
    };
    template < typename T >
    struct  cv_traits_imp<const volatile T *>
    {
        static const bool is_const = true;
        static const bool is_volatile = true;
        typedef T unqualified_type;
    };
    template < typename T >
    struct  is_volatile_rval_filter
    {
        static const bool value = ::boost::detail::cv_traits_imp<T *>::is_volatile;
    };
    template < typename T >
    struct  is_volatile_rval_filter<T &&>
    {
        static const bool value = false;
    };
  }
  template < typename T >
  struct  is_volatile : ::boost::integral_constant<bool, ::boost::detail::is_volatile_rval_filter<T>::value>
  {
  };
  template < typename T >
  struct  is_volatile<T &> : ::boost::integral_constant<bool, false>
  {
  };
  template < typename T >
  struct  is_enum : ::boost::integral_constant<bool, __is_enum(T)>
  {
  };
  template < typename T >
  struct  is_array : ::boost::integral_constant<bool, false>
  {
  };
  template < typename T, ::std::size_t N >
  struct  is_array<T [N]> : ::boost::integral_constant<bool, true>
  {
  };
  template < typename T, ::std::size_t N >
  struct  is_array<const T [N]> : ::boost::integral_constant<bool, true>
  {
  };
  template < typename T, ::std::size_t N >
  struct  is_array<volatile T [N]> : ::boost::integral_constant<bool, true>
  {
  };
  template < typename T, ::std::size_t N >
  struct  is_array<const volatile T [N]> : ::boost::integral_constant<bool, true>
  {
  };
  template < typename T >
  struct  is_array<T []> : ::boost::integral_constant<bool, true>
  {
  };
  template < typename T >
  struct  is_array<const T []> : ::boost::integral_constant<bool, true>
  {
  };
  template < typename T >
  struct  is_array<volatile T []> : ::boost::integral_constant<bool, true>
  {
  };
  template < typename T >
  struct  is_array<const volatile T []> : ::boost::integral_constant<bool, true>
  {
  };
  namespace detail {
    template < typename T >
    struct  is_class_impl
    {
        static const bool value = __is_class(T);
    };
  }
  template < typename T >
  struct  is_class : ::boost::integral_constant<bool, ::boost::detail::is_class_impl<T>::value>
  {
  };
  namespace detail {
    template < typename T >
    struct  rvalue_ref_filter_rem_cv
    {
        typedef typename ::boost::detail::cv_traits_imp<T *>::unqualified_type type;
    };
    template < typename T >
    struct  rvalue_ref_filter_rem_cv<T &&>
    {
        typedef T &&type;
    };
  }
  template < typename T >
  struct  remove_cv
  {
      typedef typename ::boost::detail::rvalue_ref_filter_rem_cv<T>::type type;
  };
  template < typename T >
  struct  remove_cv<T &>
  {
      typedef T &type;
  };
  template < typename T, ::std::size_t N >
  struct  remove_cv<const T [N]>
  {
      typedef T type[N];
  };
  template < typename T, ::std::size_t N >
  struct  remove_cv<volatile T [N]>
  {
      typedef T type[N];
  };
  template < typename T, ::std::size_t N >
  struct  remove_cv<const volatile T [N]>
  {
      typedef T type[N];
  };
  namespace detail {
    template < typename B, typename D >
    struct  is_base_and_derived_impl
    {
        typedef typename ::boost::remove_cv<B>::type ncvB;
        typedef typename ::boost::remove_cv<D>::type ncvD;
        static const bool value = ((__is_base_of(B, D)) && !is_same<B, D>::value) && !::boost::is_same<typename ::boost::detail::is_base_and_derived_impl<B, D>::ncvB, typename ::boost::detail::is_base_and_derived_impl<B, D>::ncvD>::value;
    };
  }
  template < typename Base, typename Derived >
  struct  is_base_and_derived : ::boost::integral_constant<bool, ::boost::detail::is_base_and_derived_impl<Base, Derived>::value>
  {
  };
  template < typename Base, typename Derived >
  struct  is_base_and_derived<Base &, Derived> : ::boost::integral_constant<bool, false>
  {
  };
  template < typename Base, typename Derived >
  struct  is_base_and_derived<Base, Derived &> : ::boost::integral_constant<bool, false>
  {
  };
  template < typename Base, typename Derived >
  struct  is_base_and_derived<Base &, Derived &> : ::boost::integral_constant<bool, false>
  {
  };
  namespace mpl {
    namespace aux {
      template < typename T >
      struct  value_type_wknd
      {
          typedef typename T::value_type type;
      };
    }
  }
}
namespace mpl_ {
   struct void_;
}
namespace boost {
  namespace mpl {
    using ::mpl_::void_;
  }
}
namespace mpl_ {
   struct  na
  {
      typedef ::mpl_::na type;
      enum mcc_enum_anon_68
      {
        value = 0
      };
  };
}
namespace boost {
  namespace mpl {
    using ::mpl_::na;
    template < typename T >
    struct  is_na : ::mpl_::bool_<false>
    {
    };
    template <>
    struct  is_na< ::mpl_::na> : ::mpl_::bool_<true>
    {
    };
    template < typename T >
    struct  is_not_na : ::mpl_::bool_<true>
    {
    };
    template <>
    struct  is_not_na< ::mpl_::na> : ::mpl_::bool_<false>
    {
    };
    template < typename T, typename U >
    struct  if_na
    {
        typedef T type;
    };
    template < typename U >
    struct  if_na< ::mpl_::na, U>
    {
        typedef U type;
    };
    template < typename T = ::mpl_::na, typename Tag = ::mpl_::void_, typename Arity = ::mpl_::int_<aux::template_arity<T>::value> >
    struct lambda;
    template < bool C, typename T1, typename T2 >
    struct  if_c
    {
        typedef T1 type;
    };
    template < typename T1, typename T2 >
    struct  if_c<false, T1, T2>
    {
        typedef T2 type;
    };
    template < typename T1 = ::mpl_::na, typename T2 = ::mpl_::na, typename T3 = ::mpl_::na >
    struct  if_
    {
      private:
        typedef ::boost::mpl::if_c<static_cast<bool>(T1::value), T2, T3> almost_type_;
      public:
        typedef typename ::boost::mpl::if_c<static_cast<bool>(T1::value), T2, T3>::type type;
    };
    template <>
    struct  if_< ::mpl_::na, ::mpl_::na, ::mpl_::na>
    {
        template < typename T1, typename T2, typename T3, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::if_<T1, T2, T3>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::if_< ::mpl_::na, ::mpl_::na, ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::if_< ::mpl_::na, ::mpl_::na, ::mpl_::na> result_;
        typedef ::boost::mpl::if_< ::mpl_::na, ::mpl_::na, ::mpl_::na> type;
    };
 /* Instantiation of class template '::mpl_::int_<3>' */ 
    namespace aux {
      template < typename T1, typename T2, typename T3 >
      struct  template_arity< ::boost::mpl::if_<T1, T2, T3> > : ::mpl_::int_<3>
      {
      };
 /* Instantiation of class template '::mpl_::int_< -1>' */ 
      template <>
      struct  template_arity< ::boost::mpl::if_< ::mpl_::na, ::mpl_::na, ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
    template < typename C = ::mpl_::na, typename F1 = ::mpl_::na, typename F2 = ::mpl_::na >
    struct  eval_if
    {
        typedef typename ::boost::mpl::if_<C, F1, F2>::type f_;
        typedef typename ::boost::mpl::if_<C, F1, F2>::type::type type;
    };
    template < bool C, typename F1, typename F2 >
    struct  eval_if_c
    {
        typedef typename ::boost::mpl::if_c<C, F1, F2>::type f_;
        typedef typename ::boost::mpl::if_c<C, F1, F2>::type::type type;
    };
    template <>
    struct  eval_if< ::mpl_::na, ::mpl_::na, ::mpl_::na>
    {
        template < typename T1, typename T2, typename T3, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::eval_if<T1, T2, T3>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::eval_if< ::mpl_::na, ::mpl_::na, ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::eval_if< ::mpl_::na, ::mpl_::na, ::mpl_::na> result_;
        typedef ::boost::mpl::eval_if< ::mpl_::na, ::mpl_::na, ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1, typename T2, typename T3 >
      struct  template_arity< ::boost::mpl::eval_if<T1, T2, T3> > : ::mpl_::int_<3>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::eval_if< ::mpl_::na, ::mpl_::na, ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
  }
  namespace serialization {
     enum level_type
    {
      not_serializable = 0,
      primitive_type = 1,
      object_serializable = 2,
      object_class_info = 3
    };
    struct basic_traits;
    template < typename T >
    struct  implementation_level_impl
    {
        template < typename U >
        struct  traits_class_level
        {
            typedef typename U::level type;
        };
        typedef ::mpl_::integral_c_tag tag;
        typedef typename ::boost::mpl::eval_if< ::boost::is_base_and_derived< ::boost::serialization::basic_traits, T>, typename ::boost::serialization::implementation_level_impl<T>::template traits_class_level<T>, ::boost::mpl::eval_if< ::boost::is_fundamental<T>, ::mpl_::int_<1>, ::boost::mpl::eval_if< ::boost::is_class<T>, ::mpl_::int_<3>, ::boost::mpl::eval_if< ::boost::is_array<T>, ::mpl_::int_<2>, ::boost::mpl::eval_if< ::boost::is_enum<T>, ::mpl_::int_<1>, ::mpl_::int_<0> > > > > >::type type;
        static const int value = type::value;
    };
    template < typename T >
    struct  implementation_level : ::boost::serialization::implementation_level_impl<const T>
    {
    };
    template < typename T, int L >
    inline bool operator >=(::boost::serialization::implementation_level<T> t, ::boost::serialization::level_type l);
    template < typename T, int L >
    inline bool operator >=(::boost::serialization::implementation_level<T> t, ::boost::serialization::level_type l)
    {
      return t.value >= (int)l;
    }
 /* Instantiation of class template '::mpl_::int_<1>' */ 
    template <>
    struct  implementation_level_impl<const ::boost::archive::library_version_type>
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<1> type;
        static const int value = ::mpl_::int_<1>::value;
    };
    template <>
    struct  implementation_level_impl<const ::boost::archive::version_type>
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<1> type;
        static const int value = ::mpl_::int_<1>::value;
    };
    template <>
    struct  implementation_level_impl<const ::boost::archive::class_id_type>
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<1> type;
        static const int value = ::mpl_::int_<1>::value;
    };
    template <>
    struct  implementation_level_impl<const ::boost::archive::class_id_reference_type>
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<1> type;
        static const int value = ::mpl_::int_<1>::value;
    };
    template <>
    struct  implementation_level_impl<const ::boost::archive::class_id_optional_type>
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<1> type;
        static const int value = ::mpl_::int_<1>::value;
    };
    template <>
    struct  implementation_level_impl<const ::boost::archive::class_name_type>
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<1> type;
        static const int value = ::mpl_::int_<1>::value;
    };
    template <>
    struct  implementation_level_impl<const ::boost::archive::object_id_type>
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<1> type;
        static const int value = ::mpl_::int_<1>::value;
    };
    template <>
    struct  implementation_level_impl<const ::boost::archive::object_reference_type>
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<1> type;
        static const int value = ::mpl_::int_<1>::value;
    };
    template <>
    struct  implementation_level_impl<const ::boost::archive::tracking_type>
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<1> type;
        static const int value = ::mpl_::int_<1>::value;
    };
    template < typename T >
    struct  is_bitwise_serializable : ::boost::is_arithmetic<T>
    {
    };
    template <>
    struct  is_bitwise_serializable< ::boost::archive::library_version_type> : ::mpl_::bool_<true>
    {
    };
    template <>
    struct  is_bitwise_serializable< ::boost::archive::version_type> : ::mpl_::bool_<true>
    {
    };
    template <>
    struct  is_bitwise_serializable< ::boost::archive::class_id_type> : ::mpl_::bool_<true>
    {
    };
    template <>
    struct  is_bitwise_serializable< ::boost::archive::class_id_reference_type> : ::mpl_::bool_<true>
    {
    };
    template <>
    struct  is_bitwise_serializable< ::boost::archive::class_id_optional_type> : ::mpl_::bool_<true>
    {
    };
    template <>
    struct  is_bitwise_serializable< ::boost::archive::class_name_type> : ::mpl_::bool_<true>
    {
    };
    template <>
    struct  is_bitwise_serializable< ::boost::archive::object_id_type> : ::mpl_::bool_<true>
    {
    };
    template <>
    struct  is_bitwise_serializable< ::boost::archive::object_reference_type> : ::mpl_::bool_<true>
    {
    };
    template <>
    struct  is_bitwise_serializable< ::boost::archive::tracking_type> : ::mpl_::bool_<true>
    {
    };
    class extended_type_info;
  }
  namespace archive {
    namespace detail {
      class basic_iarchive_impl;
      class basic_iserializer;
      class basic_pointer_iserializer;
      class  basic_iarchive : ::boost::noncopyable_::noncopyable
      {
          ::boost::archive::detail::basic_iarchive_impl *pimpl;
          virtual void vload(::boost::archive::version_type &t) = 0 ;
          virtual void vload(::boost::archive::object_id_type &t) = 0 ;
          virtual void vload(::boost::archive::class_id_type &t) = 0 ;
          virtual void vload(::boost::archive::class_id_optional_type &t) = 0 ;
          virtual void vload(::boost::archive::class_name_type &t) = 0 ;
          virtual void vload(::boost::archive::tracking_type &t) = 0 ;
        protected:
          basic_iarchive(unsigned int flags);
          virtual ~basic_iarchive();
        public:
          void next_object_pointer(void *t);
          void register_basic_serializer(const ::boost::archive::detail::basic_iserializer &bis);
          void load_object(void *t, const ::boost::archive::detail::basic_iserializer &bis);
          const ::boost::archive::detail::basic_pointer_iserializer *load_pointer(void *&t, const ::boost::archive::detail::basic_pointer_iserializer *bpis_ptr, const ::boost::archive::detail::basic_pointer_iserializer *(*finder)(const ::boost::serialization::extended_type_info &));
          void set_library_version(::boost::archive::library_version_type archive_library_version);
          ::boost::archive::library_version_type get_library_version() const ;
          unsigned int get_flags() const ;
          void reset_object_address(const void *new_address, const void *old_address);
          void delete_created_pointers();
        friend class ::boost::archive::detail::basic_iarchive_impl;
      };
    }
  }
}
namespace std __attribute__((__visibility__("default"))) {
   using ::va_list;
}
namespace boost {
  namespace serialization {
    namespace void_cast_detail {
      class void_caster;
    }
    class  extended_type_info : ::boost::noncopyable_::noncopyable
    {
        const unsigned int m_type_info_key;
        virtual bool is_less_than(const ::boost::serialization::extended_type_info &) const  = 0 ;
        virtual bool is_equal(const ::boost::serialization::extended_type_info &) const  = 0 ;
        const char *m_key;
      protected:
        void key_unregister() const ;
        void key_register() const ;
        extended_type_info(const unsigned int type_info_key, const char *key);
        virtual ~extended_type_info();
      public:
        inline const char *get_key() const 
        {
          return (*this).m_key;
        }
        virtual const char *get_debug_info() const  = 0 ;
        bool operator <(const ::boost::serialization::extended_type_info &rhs) const ;
        bool operator ==(const ::boost::serialization::extended_type_info &rhs) const ;
        inline bool operator !=(const ::boost::serialization::extended_type_info &rhs) const 
        {
          return !(*this).::boost::serialization::extended_type_info::operator ==(rhs);
        }
        static const ::boost::serialization::extended_type_info *find(const char *key);
        virtual void *construct(unsigned int  = (0), ...) const  = 0 ;
        virtual void destroy(const void *const ) const  = 0 ;
      friend class ::boost::serialization::void_cast_detail::void_caster;
    };
    template < typename T >
    struct  guid_defined : ::mpl_::bool_<false>
    {
    };
    namespace ext {
      template < typename T >
      struct  guid_impl
      {
          static inline const char *call()
          {
            return 0L;
          }
      };
    }
    template < typename T >
    inline const char *guid();
    template < typename T >
    inline const char *guid()
    {
      return ext::guid_impl<T>::call();
    }
  }
  namespace archive {
    namespace detail {
      class  basic_serializer : ::boost::noncopyable_::noncopyable
      {
          const ::boost::serialization::extended_type_info *m_eti;
        protected:
          inline explicit basic_serializer(const ::boost::serialization::extended_type_info &eti)
            : m_eti(&eti)
          {
            static const char __MERCURIUM_PRETTY_FUNCTION__[113L] = "::boost::archive::detail::basic_serializer::basic_serializer(const ::boost::serialization::extended_type_info &)";
            0L != &eti ? static_cast<void>(0) : ::__assert_fail("__null != & eti", "/usr/include/boost/archive/detail/basic_serializer.hpp", 45, __MERCURIUM_PRETTY_FUNCTION__);
          }
        public:
          inline bool operator <(const ::boost::archive::detail::basic_serializer &rhs) const 
          {
            return (*this).::boost::archive::detail::basic_serializer::get_eti() < rhs.::boost::archive::detail::basic_serializer::get_eti();
          }
          inline const char *get_debug_info() const 
          {
            return (*(*this).m_eti).get_debug_info();
          }
          inline const ::boost::serialization::extended_type_info &get_eti() const 
          {
            return *(*this).m_eti;
          }
      };
      class  basic_serializer_arg : public ::boost::archive::detail::basic_serializer
      {
        public:
          inline basic_serializer_arg(const ::boost::serialization::extended_type_info &eti)
            : ::boost::archive::detail::basic_serializer(eti)
          {
          }
      };
      class  basic_pointer_iserializer : public ::boost::archive::detail::basic_serializer
      {
        protected:
          explicit basic_pointer_iserializer(const ::boost::serialization::extended_type_info &type_);
          virtual ~basic_pointer_iserializer();
        public:
          virtual const ::boost::archive::detail::basic_iserializer &get_basic_serializer() const  = 0 ;
          virtual void load_object_ptr(::boost::archive::detail::basic_iarchive &ar, void *&x, const unsigned int file_version) const  = 0 ;
      };
    }
  }
  namespace mpl {
     template < typename T = ::mpl_::na >
    struct  identity
    {
        typedef T type;
    };
    template < typename T = ::mpl_::na >
    struct  make_identity
    {
        typedef ::boost::mpl::identity<T> type;
    };
    template <>
    struct  identity< ::mpl_::na>
    {
        template < typename T1, typename T2 = ::mpl_::na, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::identity<T1>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::identity< ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::identity< ::mpl_::na> result_;
        typedef ::boost::mpl::identity< ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1 >
      struct  template_arity< ::boost::mpl::identity<T1> > : ::mpl_::int_<1>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::identity< ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
    template <>
    struct  make_identity< ::mpl_::na>
    {
        template < typename T1, typename T2 = ::mpl_::na, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::make_identity<T1>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::make_identity< ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::make_identity< ::mpl_::na> result_;
        typedef ::boost::mpl::make_identity< ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1 >
      struct  template_arity< ::boost::mpl::make_identity<T1> > : ::mpl_::int_<1>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::make_identity< ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
    template < typename SourceTag, typename TargetTag >
    struct  numeric_cast
    {
        template < typename N >
        struct apply;
    };
    namespace aux {
      template < typename T >
      struct  type_wrapper
      {
          typedef T type;
      };
      template < typename T >
      struct wrapped_type;
      template < typename T >
      struct  wrapped_type< ::boost::mpl::aux::type_wrapper<T> >
      {
          typedef T type;
      };
      typedef char (&no_tag)[1L];
      typedef char (&yes_tag)[2L];
      template < bool C_ >
      struct  yes_no_tag
      {
          typedef ::boost::mpl::aux::no_tag type;
      };
      template <>
      struct  yes_no_tag<true>
      {
          typedef ::boost::mpl::aux::yes_tag type;
      };
      template < long int n >
      struct  weighted_tag
      {
          typedef char (&type)[n];
      };
      template < typename T, typename fallback_ = ::mpl_::bool_<false> >
      struct  has_apply
      {
          struct  gcc_3_2_wknd
          {
              template < typename U >
              static ::boost::mpl::aux::yes_tag test(const volatile ::boost::mpl::aux::type_wrapper<U> *, ::boost::mpl::aux::type_wrapper<typename U::apply> *  = (0));
              static ::boost::mpl::aux::no_tag test(...);
          };
          typedef ::boost::mpl::aux::type_wrapper<T> t_;
          static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<typename ::boost::mpl::aux::has_apply<T, fallback_>::t_ *>(0))) == sizeof(::boost::mpl::aux::yes_tag);
          typedef ::mpl_::bool_< ::boost::mpl::aux::has_apply<T, fallback_>::value> type;
      };
    }
    template < typename F, typename has_apply_ = typename ::boost::mpl::aux::has_apply<F>::type >
    struct  apply_wrap0 : F::template apply<>
    {
    };
    template < typename F >
    struct  apply_wrap0<F, ::mpl_::bool_<true> > : F::apply
    {
    };
    template < typename F, typename T1 >
    struct  apply_wrap1 : F::template apply<T1>
    {
    };
    template < typename F, typename T1, typename T2 >
    struct  apply_wrap2 : F::template apply<T1, T2>
    {
    };
    template < typename F, typename T1, typename T2, typename T3 >
    struct  apply_wrap3 : F::template apply<T1, T2, T3>
    {
    };
    template < typename F, typename T1, typename T2, typename T3, typename T4 >
    struct  apply_wrap4 : F::template apply<T1, T2, T3, T4>
    {
    };
    template < typename F, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct  apply_wrap5 : F::template apply<T1, T2, T3, T4, T5>
    {
    };
  }
}
namespace mpl_ {
   struct  void_
  {
      typedef ::mpl_::void_ type;
  };
}
namespace boost {
  namespace mpl {
    template < typename T >
    struct  is_void_ : ::mpl_::bool_<false>
    {
    };
    template <>
    struct  is_void_< ::mpl_::void_> : ::mpl_::bool_<true>
    {
    };
    template < typename T >
    struct  is_not_void_ : ::mpl_::bool_<true>
    {
    };
    template <>
    struct  is_not_void_< ::mpl_::void_> : ::mpl_::bool_<false>
    {
    };
    template <>
    struct  is_void_< ::mpl_::na>
    {
        template < typename T1, typename T2 = ::mpl_::na, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::is_void_<T1>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::is_void_< ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::is_void_< ::mpl_::na> result_;
        typedef ::boost::mpl::is_void_< ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1 >
      struct  template_arity< ::boost::mpl::is_void_<T1> > : ::mpl_::int_<1>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::is_void_< ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
    template <>
    struct  is_not_void_< ::mpl_::na>
    {
        template < typename T1, typename T2 = ::mpl_::na, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::is_not_void_<T1>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::is_not_void_< ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::is_not_void_< ::mpl_::na> result_;
        typedef ::boost::mpl::is_not_void_< ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1 >
      struct  template_arity< ::boost::mpl::is_not_void_<T1> > : ::mpl_::int_<1>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::is_not_void_< ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
      template < typename T, typename fallback_ = ::mpl_::bool_<false> >
      struct  has_tag
      {
          struct  gcc_3_2_wknd
          {
              template < typename U >
              static ::boost::mpl::aux::yes_tag test(const volatile ::boost::mpl::aux::type_wrapper<U> *, ::boost::mpl::aux::type_wrapper<typename U::tag> *  = (0));
              static ::boost::mpl::aux::no_tag test(...);
          };
          typedef ::boost::mpl::aux::type_wrapper<T> t_;
          static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<typename ::boost::mpl::aux::has_tag<T, fallback_>::t_ *>(0))) == sizeof(::boost::mpl::aux::yes_tag);
          typedef ::mpl_::bool_< ::boost::mpl::aux::has_tag<T, fallback_>::value> type;
      };
      template < typename T >
      struct  tag_impl
      {
          typedef typename T::tag type;
      };
    }
    template < typename T, typename Default = ::mpl_::void_ >
    struct  tag : ::boost::mpl::if_< ::boost::mpl::aux::has_tag<T>, ::boost::mpl::aux::tag_impl<T>, Default>::type
    {
    };
    namespace aux {
      template < typename F, typename Tag1, typename Tag2 >
      struct  cast1st_impl
      {
          template < typename N1, typename N2 >
          struct  apply : ::boost::mpl::apply_wrap2<F, typename ::boost::mpl::apply_wrap1< ::boost::mpl::numeric_cast<Tag1, Tag2>, N1>::type, N2>
          {
          };
      };
      template < typename F, typename Tag1, typename Tag2 >
      struct  cast2nd_impl
      {
          template < typename N1, typename N2 >
          struct  apply : ::boost::mpl::apply_wrap2<F, N1, typename ::boost::mpl::apply_wrap1< ::boost::mpl::numeric_cast<Tag2, Tag1>, N2>::type>
          {
          };
      };
      template < typename T >
      struct  msvc_eti_base : T
      {
          msvc_eti_base();
          typedef T type;
      };
      template <>
      struct  msvc_eti_base<int>
      {
          typedef ::boost::mpl::aux::msvc_eti_base<int> type;
          typedef ::boost::mpl::aux::msvc_eti_base<int> first;
          typedef ::boost::mpl::aux::msvc_eti_base<int> second;
          typedef ::boost::mpl::aux::msvc_eti_base<int> tag;
          enum mcc_enum_anon_69
          {
            value = 0
          };
      };
    }
    template < typename Tag1, typename Tag2 >
    struct  greater_equal_impl : ::boost::mpl::if_c<(Tag1::value > Tag2::value), ::boost::mpl::aux::cast2nd_impl< ::boost::mpl::greater_equal_impl<Tag1, Tag1>, Tag1, Tag2>, ::boost::mpl::aux::cast1st_impl< ::boost::mpl::greater_equal_impl<Tag2, Tag2>, Tag1, Tag2> >::type
    {
    };
    template <>
    struct  greater_equal_impl< ::mpl_::na, ::mpl_::na>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::greater_equal_impl< ::mpl_::na, ::mpl_::na>::apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename Tag >
    struct  greater_equal_impl< ::mpl_::na, Tag>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::greater_equal_impl< ::mpl_::na, Tag>::template apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename Tag >
    struct  greater_equal_impl<Tag, ::mpl_::na>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::greater_equal_impl<Tag, ::mpl_::na>::template apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename T >
    struct  greater_equal_tag
    {
        typedef typename T::tag type;
    };
    template < typename N1 = ::mpl_::na, typename N2 = ::mpl_::na >
    struct  greater_equal : ::boost::mpl::greater_equal_impl<typename ::boost::mpl::greater_equal_tag<N1>::type, typename ::boost::mpl::greater_equal_tag<N2>::type>::template apply<N1, N2>::type
    {
    };
    template <>
    struct  greater_equal< ::mpl_::na, ::mpl_::na>
    {
        template < typename T1, typename T2, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::greater_equal<T1, T2>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::greater_equal< ::mpl_::na, ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::greater_equal< ::mpl_::na, ::mpl_::na> result_;
        typedef ::boost::mpl::greater_equal< ::mpl_::na, ::mpl_::na> type;
    };
 /* Instantiation of class template '::mpl_::int_<2>' */ 
    namespace aux {
      template < typename T1, typename T2 >
      struct  template_arity< ::boost::mpl::greater_equal<T1, T2> > : ::mpl_::int_<2>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::greater_equal< ::mpl_::na, ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
    template <>
    struct  greater_equal_impl< ::mpl_::integral_c_tag, ::mpl_::integral_c_tag>
    {
        template < typename N1, typename N2 >
        struct  apply : ::mpl_::bool_<(N1::value >= N2::value)>
        {
        };
    };
    template < typename Tag1, typename Tag2 >
    struct  equal_to_impl : ::boost::mpl::if_c<(Tag1::value > Tag2::value), ::boost::mpl::aux::cast2nd_impl< ::boost::mpl::equal_to_impl<Tag1, Tag1>, Tag1, Tag2>, ::boost::mpl::aux::cast1st_impl< ::boost::mpl::equal_to_impl<Tag2, Tag2>, Tag1, Tag2> >::type
    {
    };
    template <>
    struct  equal_to_impl< ::mpl_::na, ::mpl_::na>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::equal_to_impl< ::mpl_::na, ::mpl_::na>::apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename Tag >
    struct  equal_to_impl< ::mpl_::na, Tag>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::equal_to_impl< ::mpl_::na, Tag>::template apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename Tag >
    struct  equal_to_impl<Tag, ::mpl_::na>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::equal_to_impl<Tag, ::mpl_::na>::template apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename T >
    struct  equal_to_tag
    {
        typedef typename T::tag type;
    };
    template < typename N1 = ::mpl_::na, typename N2 = ::mpl_::na >
    struct  equal_to : ::boost::mpl::equal_to_impl<typename ::boost::mpl::equal_to_tag<N1>::type, typename ::boost::mpl::equal_to_tag<N2>::type>::template apply<N1, N2>::type
    {
    };
    template <>
    struct  equal_to< ::mpl_::na, ::mpl_::na>
    {
        template < typename T1, typename T2, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::equal_to<T1, T2>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::equal_to< ::mpl_::na, ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::equal_to< ::mpl_::na, ::mpl_::na> result_;
        typedef ::boost::mpl::equal_to< ::mpl_::na, ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1, typename T2 >
      struct  template_arity< ::boost::mpl::equal_to<T1, T2> > : ::mpl_::int_<2>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::equal_to< ::mpl_::na, ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
    template <>
    struct  equal_to_impl< ::mpl_::integral_c_tag, ::mpl_::integral_c_tag>
    {
        template < typename N1, typename N2 >
        struct  apply : ::mpl_::bool_<N1::value == N2::value>
        {
        };
    };
    template < typename T >
    struct  print : ::boost::mpl::identity<T>
    {
        enum mcc_enum_anon_70
        {
          n = sizeof(T) >  -1
        };
    };
  }
  namespace serialization {
    template < int L >
    struct  BOOST_SERIALIZATION_STATIC_WARNING_LINE
    {
    };
    template < bool B, int L >
    struct  static_warning_test
    {
        typename ::boost::mpl::eval_if_c<B, ::mpl_::bool_<true>, ::boost::mpl::identity< ::boost::mpl::print< ::boost::serialization::BOOST_SERIALIZATION_STATIC_WARNING_LINE<L> > > >::type type;
    };
    template < int i >
    struct  BOOST_SERIALIZATION_SS
    {
    };
  }
  template < typename T >
  struct  is_polymorphic : ::boost::integral_constant<bool, __is_polymorphic(T)>
  {
  };
  namespace detail {
    template < typename T, bool is_vol >
    struct  remove_const_helper
    {
        typedef T type;
    };
    template < typename T >
    struct  remove_const_helper<T, true>
    {
        typedef volatile T type;
    };
    template < typename T >
    struct  remove_const_impl
    {
        typedef typename ::boost::detail::remove_const_helper<typename ::boost::detail::cv_traits_imp<T *>::unqualified_type, ::boost::is_volatile<T>::value>::type type;
    };
    template < typename T >
    struct  remove_const_impl<T &&>
    {
        typedef T &&type;
    };
  }
  template < typename T >
  struct  remove_const
  {
      typedef typename ::boost::detail::remove_const_impl<T>::type type;
  };
  template < typename T >
  struct  remove_const<T &>
  {
      typedef T &type;
  };
  template < typename T, ::std::size_t N >
  struct  remove_const<const T [N]>
  {
      typedef T type[N];
  };
  template < typename T, ::std::size_t N >
  struct  remove_const<const volatile T [N]>
  {
      typedef volatile T type[N];
  };
  namespace serialization {
    class  singleton_module : public ::boost::noncopyable_::noncopyable
    {
        static inline bool &get_lock()
        {
          static bool lock(false);
          return lock;
        }
      public:
        static inline void lock()
        {
          ::boost::serialization::singleton_module::get_lock() = true;
        }
        static inline void unlock()
        {
          ::boost::serialization::singleton_module::get_lock() = false;
        }
        static inline bool is_locked()
        {
          return ::boost::serialization::singleton_module::get_lock();
        }
    };
    namespace detail {
      template < typename T >
      class  singleton_wrapper : public T
      {
        public:
          static bool m_is_destroyed;
          inline ~singleton_wrapper()
          {
            ::boost::serialization::detail::singleton_wrapper<T>::m_is_destroyed = true;
          }
      };
      template < typename T >
      bool singleton_wrapper<T>::m_is_destroyed(false);
    }
    template < typename T >
    class  singleton : public ::boost::serialization::singleton_module
    {
        static T &instance;
        static inline void use(const T &)
        {
        }
        static inline T &get_instance()
        {
          static ::boost::serialization::detail::singleton_wrapper<T> t;
          !detail::singleton_wrapper<T>::m_is_destroyed ? static_cast<void>(0) : __assert_fail("! detail::singleton_wrapper< T >::m_is_destroyed", "/usr/include/boost/serialization/singleton.hpp", 131, __PRETTY_FUNCTION__);
          use(::boost::serialization::singleton<T>::instance);
          return static_cast<T &>(t);
        }
      public:
        static inline T &get_mutable_instance()
        {
          !::boost::serialization::singleton_module::is_locked() ? static_cast<void>(0) : __assert_fail("! is_locked()", "/usr/include/boost/serialization/singleton.hpp", 137, __PRETTY_FUNCTION__);
          return get_instance();
        }
        static inline const T &get_const_instance()
        {
          return get_instance();
        }
        static inline bool is_destroyed()
        {
          return detail::singleton_wrapper<T>::m_is_destroyed;
        }
    };
    template < typename T >
    T &singleton<T>::instance = singleton<T>::get_instance();
    template < typename T, int N >
    T *factory(::va_list);
    template < typename T, int N >
    T *factory(::va_list)
    {
      false ? static_cast<void>(0) : __assert_fail("false", "/usr/include/boost/serialization/factory.hpp", 38, __PRETTY_FUNCTION__);
      return 0L;
    }
  }
  namespace archive {
    namespace detail {
      template < typename Archive, typename T >
      class iserializer;
      template < typename Archive, typename T >
      class oserializer;
    }
  }
  namespace serialization {
     template < typename Archive, typename T >
    inline void serialize_adl(Archive &ar, T &t, const unsigned int file_version);
    namespace detail {
      template < typename Archive, typename T >
      struct member_saver;
      template < typename Archive, typename T >
      struct member_loader;
    }
    class  access
    {
      public:
        template < typename Archive, typename T >
        static inline void member_save(Archive &ar, T &t, const unsigned int file_version)
        {
          t.save(ar, file_version);
        }
        template < typename Archive, typename T >
        static inline void member_load(Archive &ar, T &t, const unsigned int file_version)
        {
          t.load(ar, file_version);
        }
        template < typename Archive, typename T >
        static inline void serialize(Archive &ar, T &t, const unsigned int file_version)
        {
          t.serialize(ar, file_version);
        }
        template < typename T >
        static inline void destroy(const T *t)
        {
          delete const_cast<T *>(t);
        }
        template < typename T >
        static inline void construct(T *t)
        {
          ::new (t)T();
        }
        template < typename T, typename U >
        static inline T &cast_reference(U &u)
        {
          return static_cast<T &>(u);
        }
        template < typename T, typename U >
        static inline T *cast_pointer(U *u)
        {
          return static_cast<T *>(u);
        }
      template < typename Archive, typename T >
      friend struct ::boost::serialization::detail::member_saver;
      template < typename Archive, typename T >
      friend struct ::boost::serialization::detail::member_loader;
      template < typename Archive, typename T >
      friend class ::boost::archive::detail::iserializer;
      template < typename Archive, typename T >
      friend class ::boost::archive::detail::oserializer;
      template < typename Archive, typename T >
      friend void serialize(Archive &, T &, const unsigned int);
      template < typename Archive, typename T >
      friend void save_construct_data(Archive &, const T *, const unsigned int);
      template < typename Archive, typename T >
      friend void load_construct_data(Archive &, T *, const unsigned int);
    };
    namespace typeid_system {
      class  extended_type_info_typeid_0 : public ::boost::serialization::extended_type_info
      {
          virtual inline const char *get_debug_info() const 
          {
            if (static_cast<const ::std::type_info *>(0) == (*this).m_ti)
              {
                return static_cast<const char *>(0);
              }
            return (*(*this).m_ti).::std::type_info::name();
          }
        protected:
          const ::std::type_info *m_ti;
          extended_type_info_typeid_0(const char *key);
          virtual ~extended_type_info_typeid_0();
          void type_register(const ::std::type_info &ti);
          void type_unregister();
          const ::boost::serialization::extended_type_info *get_extended_type_info(const ::std::type_info &ti) const ;
        public:
          virtual bool is_less_than(const ::boost::serialization::extended_type_info &rhs) const ;
          virtual bool is_equal(const ::boost::serialization::extended_type_info &rhs) const ;
          inline const ::std::type_info &get_typeid() const 
          {
            return *(*this).m_ti;
          }
      };
    }
    template < typename T >
    class  extended_type_info_typeid : public ::boost::serialization::typeid_system::extended_type_info_typeid_0, public ::boost::serialization::singleton< ::boost::serialization::extended_type_info_typeid<T> >
    {
      public:
        inline extended_type_info_typeid()
          : typeid_system::extended_type_info_typeid_0((*this).get_key())
        {
          (*this).type_register(typeid(T));
          (*this).key_register();
        }
        inline virtual ~extended_type_info_typeid()
        {
          (*this).key_unregister();
          (*this).type_unregister();
        }
        inline const ::boost::serialization::extended_type_info *get_derived_extended_type_info(const T &t) const 
        {
          typedef ::boost::serialization::BOOST_SERIALIZATION_SS<sizeof(::boost::serialization::static_warning_test<boost::is_polymorphic<T>::value, 102>)> STATIC_WARNING_LINE102;
          ;
          return typeid_system::extended_type_info_typeid_0::get_extended_type_info(typeid(t));
        }
        inline const char *get_key() const 
        {
          return boost::serialization::guid<T>();
        }
        inline virtual void *construct(unsigned int count, ...) const 
        {
          ::va_list ap;
          __builtin_va_start(ap, count);
          switch (count)
              {
                case 0 :
                return factory<typename ::boost::remove_const<T>::type, 0>(ap);
                case 1 :
                return factory<typename ::boost::remove_const<T>::type, 1>(ap);
                case 2 :
                return factory<typename ::boost::remove_const<T>::type, 2>(ap);
                case 3 :
                return factory<typename ::boost::remove_const<T>::type, 3>(ap);
                case 4 :
                return factory<typename ::boost::remove_const<T>::type, 4>(ap);
                default :
                false ? static_cast<void>(0) : __assert_fail("false", "/usr/include/boost/serialization/extended_type_info_typeid.hpp", 127, __PRETTY_FUNCTION__);
                return 0L;
              }
        }
        inline virtual void destroy(const void *const p) const 
        {
          boost::serialization::access::destroy(static_cast<const T *>(p));
        }
    };
    template < typename T >
    struct  extended_type_info_impl
    {
        typedef ::boost::serialization::extended_type_info_typeid<T> type;
    };
  }
  namespace type_traits {
    template < typename T >
    struct  is_mem_fun_pointer_impl
    {
        static const bool value = false;
    };
    template < typename R, typename T >
    struct  is_mem_fun_pointer_impl<R (T::*)()>
    {
        static const bool value = true;
    };
    template < typename R, typename T >
    struct  is_mem_fun_pointer_impl<R (T::*)(...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T >
    struct  is_mem_fun_pointer_impl<R (T::*)() const >
    {
        static const bool value = true;
    };
    template < typename R, typename T >
    struct  is_mem_fun_pointer_impl<R (T::*)() volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T >
    struct  is_mem_fun_pointer_impl<R (T::*)() const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T >
    struct  is_mem_fun_pointer_impl<R (T::*)(...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T >
    struct  is_mem_fun_pointer_impl<R (T::*)(...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T >
    struct  is_mem_fun_pointer_impl<R (T::*)(...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, ...) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, ...)>
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24) const volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, ...) const >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, ...) volatile >
    {
        static const bool value = true;
    };
    template < typename R, typename T, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24 >
    struct  is_mem_fun_pointer_impl<R (T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, ...) const volatile >
    {
        static const bool value = true;
    };
  }
  template < typename T >
  struct  is_member_function_pointer : ::boost::integral_constant<bool, ::boost::type_traits::is_mem_fun_pointer_impl<typename ::boost::remove_cv<T>::type>::value>
  {
  };
  template < typename T >
  struct  is_member_pointer : ::boost::integral_constant<bool, ::boost::is_member_function_pointer<T>::value>
  {
  };
  template < typename T, typename U >
  struct  is_member_pointer<U T::*> : ::boost::integral_constant<bool, true>
  {
  };
  template < typename T, typename U >
  struct  is_member_pointer<U T::*const > : ::boost::integral_constant<bool, true>
  {
  };
  template < typename T, typename U >
  struct  is_member_pointer<U T::*volatile > : ::boost::integral_constant<bool, true>
  {
  };
  template < typename T, typename U >
  struct  is_member_pointer<U T::*const volatile > : ::boost::integral_constant<bool, true>
  {
  };
  namespace detail {
    template < typename T >
    struct  is_pointer_helper
    {
        static const bool value = false;
    };
    template < typename T >
    struct  is_pointer_helper<T *>
    {
        static const bool value = true;
    };
    template < typename T >
    struct  is_pointer_impl
    {
        static const bool value = ::boost::type_traits::ice_and< ::boost::detail::is_pointer_helper<typename ::boost::remove_cv<T>::type>::value, ::boost::type_traits::ice_not< ::boost::is_member_pointer<T>::value>::value>::value;
    };
  }
  template < typename T >
  struct  is_pointer : ::boost::integral_constant<bool, ::boost::detail::is_pointer_impl<T>::value>
  {
  };
  template < typename T >
  struct  remove_pointer
  {
      typedef T type;
  };
  template < typename T >
  struct  remove_pointer<T *>
  {
      typedef T type;
  };
  template < typename T >
  struct  remove_pointer<T *const >
  {
      typedef T type;
  };
  template < typename T >
  struct  remove_pointer<T *volatile >
  {
      typedef T type;
  };
  template < typename T >
  struct  remove_pointer<T *const volatile >
  {
      typedef T type;
  };
  namespace detail {
    template < typename T >
    struct  remove_rvalue_ref
    {
        typedef T type;
    };
    template < typename T >
    struct  remove_rvalue_ref<T &&>
    {
        typedef T type;
    };
  }
  template < typename T >
  struct  remove_reference
  {
      typedef typename ::boost::detail::remove_rvalue_ref<T>::type type;
  };
  template < typename T >
  struct  remove_reference<T &>
  {
      typedef T type;
  };
  namespace mpl {
    namespace aux {
      template < typename T >
      struct  nested_type_wknd : T::type
      {
      };
      template < bool C_, typename T1, typename T2, typename T3, typename T4 >
      struct  or_impl : ::mpl_::bool_<true>
      {
      };
      template < typename T1, typename T2, typename T3, typename T4 >
      struct  or_impl<false, T1, T2, T3, T4> : ::boost::mpl::aux::or_impl< ::boost::mpl::aux::nested_type_wknd<T1>::value, T2, T3, T4, ::mpl_::bool_<false> >
      {
      };
      template <>
      struct  or_impl<false, ::mpl_::bool_<false>, ::mpl_::bool_<false>, ::mpl_::bool_<false>, ::mpl_::bool_<false> > : ::mpl_::bool_<false>
      {
      };
    }
    template < typename T1 = ::mpl_::na, typename T2 = ::mpl_::na, typename T3 = ::mpl_::false_, typename T4 = ::mpl_::false_, typename T5 = ::mpl_::false_ >
    struct  or_ : ::boost::mpl::aux::or_impl< ::boost::mpl::aux::nested_type_wknd<T1>::value, T2, T3, T4, T5>
    {
    };
    template <>
    struct  or_< ::mpl_::na, ::mpl_::na>
    {
        template < typename T1, typename T2, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::or_<T1, T2>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::or_< ::mpl_::na, ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::or_< ::mpl_::na, ::mpl_::na> result_;
        typedef ::boost::mpl::or_< ::mpl_::na, ::mpl_::na> type;
    };
 /* Instantiation of class template '::mpl_::int_<5>' */ 
    namespace aux {
      template < typename T1, typename T2, typename T3, typename T4, typename T5 >
      struct  template_arity< ::boost::mpl::or_<T1, T2, T3, T4, T5> > : ::mpl_::int_<5>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::or_< ::mpl_::na, ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
      template < bool C_, typename T1, typename T2, typename T3, typename T4 >
      struct  and_impl : ::mpl_::bool_<false>
      {
      };
      template < typename T1, typename T2, typename T3, typename T4 >
      struct  and_impl<true, T1, T2, T3, T4> : ::boost::mpl::aux::and_impl< ::boost::mpl::aux::nested_type_wknd<T1>::value, T2, T3, T4, ::mpl_::bool_<true> >
      {
      };
      template <>
      struct  and_impl<true, ::mpl_::bool_<true>, ::mpl_::bool_<true>, ::mpl_::bool_<true>, ::mpl_::bool_<true> > : ::mpl_::bool_<true>
      {
      };
    }
    template < typename T1 = ::mpl_::na, typename T2 = ::mpl_::na, typename T3 = ::mpl_::true_, typename T4 = ::mpl_::true_, typename T5 = ::mpl_::true_ >
    struct  and_ : ::boost::mpl::aux::and_impl< ::boost::mpl::aux::nested_type_wknd<T1>::value, T2, T3, T4, T5>
    {
    };
    template <>
    struct  and_< ::mpl_::na, ::mpl_::na>
    {
        template < typename T1, typename T2, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::and_<T1, T2>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::and_< ::mpl_::na, ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::and_< ::mpl_::na, ::mpl_::na> result_;
        typedef ::boost::mpl::and_< ::mpl_::na, ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1, typename T2, typename T3, typename T4, typename T5 >
      struct  template_arity< ::boost::mpl::and_<T1, T2, T3, T4, T5> > : ::mpl_::int_<5>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::and_< ::mpl_::na, ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
      template < long int C_ >
      struct  not_impl : ::mpl_::bool_<!C_>
      {
      };
    }
    template < typename T = ::mpl_::na >
    struct  not_ : ::boost::mpl::aux::not_impl< ::boost::mpl::aux::nested_type_wknd<T>::value>
    {
    };
    template <>
    struct  not_< ::mpl_::na>
    {
        template < typename T1, typename T2 = ::mpl_::na, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::not_<T1>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::not_< ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::not_< ::mpl_::na> result_;
        typedef ::boost::mpl::not_< ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1 >
      struct  template_arity< ::boost::mpl::not_<T1> > : ::mpl_::int_<1>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::not_< ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
  }
  namespace serialization {
     namespace smart_cast_impl {
      template < typename T >
      struct  reference
      {
          struct  polymorphic
          {
              struct  linear
              {
                  template < typename U >
                  static inline T cast(U &u)
                  {
                    return static_cast<T>(u);
                  }
              };
              struct  cross
              {
                  template < typename U >
                  static inline T cast(U &u)
                  {
                    return dynamic_cast<T>(u);
                  }
              };
              template < typename U >
              static inline T cast(U &u)
              {
                return cross::cast(u);
              }
          };
          struct  non_polymorphic
          {
              template < typename U >
              static inline T cast(U &u)
              {
                return static_cast<T>(u);
              }
          };
          template < typename U >
          static inline T cast(U &u)
          {
            typedef typename ::boost::mpl::eval_if< ::boost::is_polymorphic<U>, ::boost::mpl::identity<typename ::boost::serialization::smart_cast_impl::reference<T>::polymorphic>, ::boost::mpl::identity<typename ::boost::serialization::smart_cast_impl::reference<T>::non_polymorphic> >::type typex;
            return typex::cast(u);
          }
      };
      template < typename T >
      struct  pointer
      {
          struct  polymorphic
          {
              template < typename U >
              static inline T cast(U *u)
              {
                T tmp = dynamic_cast<T>(u);
                if (tmp == 0)
                  {
                    ::boost::serialization::throw_exception /* < ::std::bad_cast> */ (::std::bad_cast());
                  }
                return tmp;
              }
          };
          struct  non_polymorphic
          {
              template < typename U >
              static inline T cast(U *u)
              {
                return static_cast<T>(u);
              }
          };
          template < typename U >
          static inline T cast(U *u)
          {
            typedef typename ::boost::mpl::eval_if< ::boost::is_polymorphic<U>, ::boost::mpl::identity<typename ::boost::serialization::smart_cast_impl::pointer<T>::polymorphic>, ::boost::mpl::identity<typename ::boost::serialization::smart_cast_impl::pointer<T>::non_polymorphic> >::type typex;
            return typex::cast(u);
          }
      };
      template < typename TPtr >
      struct  void_pointer
      {
          template < typename UPtr >
          static inline TPtr cast(UPtr uptr)
          {
            return static_cast<TPtr>(uptr);
          }
      };
      template < typename T >
      struct  error
      {
          template < typename U >
          static inline T cast(U u)
          {
            static_assert(sizeof(T) == 0, "sizeof(T)==0");
            return *static_cast<T *>(0L);
          }
      };
    }
    template < typename T, typename U >
    T smart_cast(U u);
    template < typename T, typename U >
    T smart_cast(U u)
    {
      typedef typename ::boost::mpl::eval_if< ::boost::mpl::or_< ::boost::is_same<void *, U>, ::boost::is_same<void *, T>, ::boost::is_same<const void *, U>, ::boost::is_same<const void *, T> >, ::boost::mpl::identity< ::boost::serialization::smart_cast_impl::void_pointer<T> >, ::boost::mpl::eval_if< ::boost::is_pointer<U>, ::boost::mpl::identity< ::boost::serialization::smart_cast_impl::pointer<T> >, ::boost::mpl::eval_if< ::boost::is_reference<U>, ::boost::mpl::identity< ::boost::serialization::smart_cast_impl::reference<T> >, ::boost::mpl::identity< ::boost::serialization::smart_cast_impl::error<T> > > > >::type typex;
      return typex::cast(u);
    }
    template < typename T, typename U >
    T smart_cast_reference(U &u);
    template < typename T, typename U >
    T smart_cast_reference(U &u)
    {
      return smart_cast_impl::reference<T>::cast(u);
    }
  }
  namespace detail {
    template < typename T >
    struct  is_const_rvalue_filter
    {
        static const bool value = ::boost::detail::cv_traits_imp<T *>::is_const;
    };
    template < typename T >
    struct  is_const_rvalue_filter<T &&>
    {
        static const bool value = false;
    };
  }
  template < typename T >
  struct  is_const : ::boost::integral_constant<bool, ::boost::detail::is_const_rvalue_filter<T>::value>
  {
  };
  template < typename T >
  struct  is_const<T &> : ::boost::integral_constant<bool, false>
  {
  };
  template < typename T >
  struct  remove_extent
  {
      typedef T type;
  };
  template < typename T, ::std::size_t N >
  struct  remove_extent<T [N]>
  {
      typedef T type;
  };
  template < typename T, ::std::size_t N >
  struct  remove_extent<const T [N]>
  {
      typedef const T type;
  };
  template < typename T, ::std::size_t N >
  struct  remove_extent<volatile T [N]>
  {
      typedef volatile T type;
  };
  template < typename T, ::std::size_t N >
  struct  remove_extent<const volatile T [N]>
  {
      typedef const volatile T type;
  };
  template < typename T >
  struct  remove_extent<T []>
  {
      typedef T type;
  };
  template < typename T >
  struct  remove_extent<const T []>
  {
      typedef const T type;
  };
  template < typename T >
  struct  remove_extent<volatile T []>
  {
      typedef volatile T type;
  };
  template < typename T >
  struct  remove_extent<const volatile T []>
  {
      typedef const volatile T type;
  };
  namespace detail {
    template < typename T >
    struct  is_abstract_imp
    {
        static const bool value = __is_abstract(T);
    };
  }
  template < typename T >
  struct  is_abstract : ::boost::integral_constant<bool, ::boost::detail::is_abstract_imp<T>::value>
  {
  };
  namespace serialization {
    template < typename T >
    struct  is_abstract : ::boost::is_abstract<T>
    {
    };
  }
  namespace detail {
    template < typename U, U x >
    struct test;
    template < typename T >
    struct  has_new_operator_impl
    {
        template < typename U >
        static ::boost::type_traits::yes_type check_sig1(U *, ::boost::detail::test<void *(*)(unsigned long int), &U::operator new> *  = (0L));
        template < typename U >
        static ::boost::type_traits::no_type check_sig1(...);
        template < typename U >
        static ::boost::type_traits::yes_type check_sig2(U *, ::boost::detail::test<void *(*)(unsigned long int, const ::std::nothrow_t &), &U::operator new> *  = (0L));
        template < typename U >
        static ::boost::type_traits::no_type check_sig2(...);
        template < typename U >
        static ::boost::type_traits::yes_type check_sig3(U *, ::boost::detail::test<void *(*)(unsigned long int, void *), &U::operator new> *  = (0L));
        template < typename U >
        static ::boost::type_traits::no_type check_sig3(...);
        template < typename U >
        static ::boost::type_traits::yes_type check_sig4(U *, ::boost::detail::test<void *(*)(unsigned long int), &U::operator new[]> *  = (0L));
        template < typename U >
        static ::boost::type_traits::no_type check_sig4(...);
        template < typename U >
        static ::boost::type_traits::yes_type check_sig5(U *, ::boost::detail::test<void *(*)(unsigned long int, const ::std::nothrow_t &), &U::operator new[]> *  = (0L));
        template < typename U >
        static ::boost::type_traits::no_type check_sig5(...);
        template < typename U >
        static ::boost::type_traits::yes_type check_sig6(U *, ::boost::detail::test<void *(*)(unsigned long int, void *), &U::operator new[]> *  = (0L));
        template < typename U >
        static ::boost::type_traits::no_type check_sig6(...);
        static const unsigned int s1 = sizeof(has_new_operator_impl<T>::template check_sig1<T>(0));
        static const unsigned int s2 = sizeof(has_new_operator_impl<T>::template check_sig2<T>(0));
        static const unsigned int s3 = sizeof(has_new_operator_impl<T>::template check_sig3<T>(0));
        static const unsigned int s4 = sizeof(has_new_operator_impl<T>::template check_sig4<T>(0));
        static const unsigned int s5 = sizeof(has_new_operator_impl<T>::template check_sig5<T>(0));
        static const unsigned int s6 = sizeof(has_new_operator_impl<T>::template check_sig6<T>(0));
        static const bool value = ::boost::type_traits::ice_or< ::boost::detail::has_new_operator_impl<T>::s1 == sizeof(::boost::type_traits::yes_type), ::boost::detail::has_new_operator_impl<T>::s2 == sizeof(::boost::type_traits::yes_type), ::boost::detail::has_new_operator_impl<T>::s3 == sizeof(::boost::type_traits::yes_type), ::boost::detail::has_new_operator_impl<T>::s4 == sizeof(::boost::type_traits::yes_type), ::boost::detail::has_new_operator_impl<T>::s5 == sizeof(::boost::type_traits::yes_type), ::boost::detail::has_new_operator_impl<T>::s6 == sizeof(::boost::type_traits::yes_type)>::value;
    };
  }
  template < typename T >
  struct  has_new_operator : ::boost::integral_constant<bool, ::boost::detail::has_new_operator_impl<T>::value>
  {
  };
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Tp, typename _CharT = char, typename _Traits = ::std::char_traits<_CharT>, typename _Dist = ::std::ptrdiff_t >
  class  istream_iterator : public ::std::iterator< ::std::input_iterator_tag, _Tp, _Dist, const _Tp *, const _Tp &>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef ::std::basic_istream<_CharT, _Traits> istream_type;
    private:
      typename ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist>::istream_type *_M_stream;
      _Tp _M_value;
      bool _M_ok;
    public:
      inline constexpr istream_iterator()
        : _M_stream(0), _M_value(), _M_ok(false)
      {
      }
      inline istream_iterator(typename ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist>::istream_type &__s)
        : _M_stream(&__s)
      {
        (*this)._M_read();
      }
      inline istream_iterator(const ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist> &__obj)
        : _M_stream(__obj._M_stream), _M_value(__obj._M_value), _M_ok(__obj._M_ok)
      {
      }
      inline const _Tp &operator *() const 
      {
        ;
        return ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist>::_M_value;
      }
      inline const _Tp *operator ->() const 
      {
        return &(*this).operator *();
      }
      inline ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist> &operator ++()
      {
        ;
        (*this)._M_read();
        return *this;
      }
      inline ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist> operator ++(int)
      {
        ;
        ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist> __tmp = *this;
        (*this)._M_read();
        return __tmp;
      }
      inline bool _M_equal(const ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist> &__x) const 
      {
        return ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist>::_M_ok == __x._M_ok && (!::std::istream_iterator<_Tp, _CharT, _Traits, _Dist>::_M_ok || ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist>::_M_stream == __x._M_stream);
      }
    private:
      inline void _M_read()
      {
        ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist>::_M_ok = ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist>::_M_stream && *::std::istream_iterator<_Tp, _CharT, _Traits, _Dist>::_M_stream ? true : false;
        if (::std::istream_iterator<_Tp, _CharT, _Traits, _Dist>::_M_ok)
          {
            *::std::istream_iterator<_Tp, _CharT, _Traits, _Dist>::_M_stream >> ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist>::_M_value;
            ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist>::_M_ok = *::std::istream_iterator<_Tp, _CharT, _Traits, _Dist>::_M_stream ? true : false;
          }
      }
  };
  template < typename _Tp, typename _CharT, typename _Traits, typename _Dist >
  inline bool operator ==(const ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist> &__x, const ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist> &__y);
  template < typename _Tp, typename _CharT, typename _Traits, typename _Dist >
  inline bool operator ==(const ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist> &__x, const ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist> &__y)
  {
    return __x._M_equal(__y);
  }
  template < typename _Tp, typename _CharT, typename _Traits, typename _Dist >
  inline bool operator !=(const ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist> &__x, const ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist> &__y);
  template < typename _Tp, typename _CharT, typename _Traits, typename _Dist >
  inline bool operator !=(const ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist> &__x, const ::std::istream_iterator<_Tp, _CharT, _Traits, _Dist> &__y)
  {
    return !__x._M_equal(__y);
  }
  template < typename _Tp, typename _CharT = char, typename _Traits = ::std::char_traits<_CharT> >
  class  ostream_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef ::std::basic_ostream<_CharT, _Traits> ostream_type;
    private:
      typename ::std::ostream_iterator<_Tp, _CharT, _Traits>::ostream_type *_M_stream;
      const _CharT *_M_string;
    public:
      inline ostream_iterator(typename ::std::ostream_iterator<_Tp, _CharT, _Traits>::ostream_type &__s)
        : _M_stream(&__s), _M_string(0)
      {
      }
      inline ostream_iterator(typename ::std::ostream_iterator<_Tp, _CharT, _Traits>::ostream_type &__s, const _CharT *__c)
        : _M_stream(&__s), _M_string(__c)
      {
      }
      inline ostream_iterator(const ::std::ostream_iterator<_Tp, _CharT, _Traits> &__obj)
        : _M_stream(__obj._M_stream), _M_string(__obj._M_string)
      {
      }
      inline ::std::ostream_iterator<_Tp, _CharT, _Traits> &operator =(const _Tp &__value)
      {
        ;
        *::std::ostream_iterator<_Tp, _CharT, _Traits>::_M_stream << __value;
        if (::std::ostream_iterator<_Tp, _CharT, _Traits>::_M_string)
          {
            *::std::ostream_iterator<_Tp, _CharT, _Traits>::_M_stream << ::std::ostream_iterator<_Tp, _CharT, _Traits>::_M_string;
          }
        return *this;
      }
      inline ::std::ostream_iterator<_Tp, _CharT, _Traits> &operator *()
      {
        return *this;
      }
      inline ::std::ostream_iterator<_Tp, _CharT, _Traits> &operator ++()
      {
        return *this;
      }
      inline ::std::ostream_iterator<_Tp, _CharT, _Traits> &operator ++(int)
      {
        return *this;
      }
  };
}
namespace boost {
  namespace detail {
    template < typename Category, typename T, typename Distance, typename Pointer, typename Reference >
    struct  iterator_base : ::std::iterator<Category, T, Distance, Pointer, Reference>
    {
    };
  }
  template < typename Category, typename T, typename Distance = ::std::ptrdiff_t, typename Pointer = T *, typename Reference = T & >
  struct  iterator : ::boost::detail::iterator_base<Category, T, Distance, Pointer, Reference>
  {
  };
  namespace detail {
    template < typename T >
    class  empty_base
    {
    };
  }
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  less_than_comparable2 : B
  {
    friend inline bool operator <=(const T &x, const U &y)
    {
      return !static_cast<bool>(x > y);
    }
    friend inline bool operator >=(const T &x, const U &y)
    {
      return !static_cast<bool>(x < y);
    }
    friend inline bool operator >(const U &x, const T &y)
    {
      return y < x;
    }
    friend inline bool operator <(const U &x, const T &y)
    {
      return y > x;
    }
    friend inline bool operator <=(const U &x, const T &y)
    {
      return !static_cast<bool>(y < x);
    }
    friend inline bool operator >=(const U &x, const T &y)
    {
      return !static_cast<bool>(y > x);
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  less_than_comparable1 : B
  {
    friend inline bool operator >(const T &x, const T &y)
    {
      return y < x;
    }
    friend inline bool operator <=(const T &x, const T &y)
    {
      return !static_cast<bool>(y < x);
    }
    friend inline bool operator >=(const T &x, const T &y)
    {
      return !static_cast<bool>(x < y);
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  equality_comparable2 : B
  {
    friend inline bool operator ==(const U &y, const T &x)
    {
      return x == y;
    }
    friend inline bool operator !=(const U &y, const T &x)
    {
      return !static_cast<bool>(x == y);
    }
    friend inline bool operator !=(const T &y, const U &x)
    {
      return !static_cast<bool>(y == x);
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  equality_comparable1 : B
  {
    friend inline bool operator !=(const T &x, const T &y)
    {
      return !static_cast<bool>(x == y);
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  multipliable2 : B
  {
    friend inline T operator *(const T &lhs, const U &rhs)
    {
      T nrv(lhs);
      nrv *= rhs;
      return nrv;
    }
    friend inline T operator *(const U &lhs, const T &rhs)
    {
      T nrv(rhs);
      nrv *= lhs;
      return nrv;
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  multipliable1 : B
  {
    friend inline T operator *(const T &lhs, const T &rhs)
    {
      T nrv(lhs);
      nrv *= rhs;
      return nrv;
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  addable2 : B
  {
    friend inline T operator +(const T &lhs, const U &rhs)
    {
      T nrv(lhs);
      nrv += rhs;
      return nrv;
    }
    friend inline T operator +(const U &lhs, const T &rhs)
    {
      T nrv(rhs);
      nrv += lhs;
      return nrv;
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  addable1 : B
  {
    friend inline T operator +(const T &lhs, const T &rhs)
    {
      T nrv(lhs);
      nrv += rhs;
      return nrv;
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  subtractable2 : B
  {
    friend inline T operator -(const T &lhs, const U &rhs)
    {
      T nrv(lhs);
      nrv -= rhs;
      return nrv;
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  subtractable2_left : B
  {
    friend inline T operator -(const U &lhs, const T &rhs)
    {
      T nrv(lhs);
      nrv -= rhs;
      return nrv;
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  subtractable1 : B
  {
    friend inline T operator -(const T &lhs, const T &rhs)
    {
      T nrv(lhs);
      nrv -= rhs;
      return nrv;
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  dividable2 : B
  {
    friend inline T operator /(const T &lhs, const U &rhs)
    {
      T nrv(lhs);
      nrv /= rhs;
      return nrv;
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  dividable2_left : B
  {
    friend inline T operator /(const U &lhs, const T &rhs)
    {
      T nrv(lhs);
      nrv /= rhs;
      return nrv;
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  dividable1 : B
  {
    friend inline T operator /(const T &lhs, const T &rhs)
    {
      T nrv(lhs);
      nrv /= rhs;
      return nrv;
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  modable2 : B
  {
    friend inline T operator %(const T &lhs, const U &rhs)
    {
      T nrv(lhs);
      nrv %= rhs;
      return nrv;
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  modable2_left : B
  {
    friend inline T operator %(const U &lhs, const T &rhs)
    {
      T nrv(lhs);
      nrv %= rhs;
      return nrv;
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  modable1 : B
  {
    friend inline T operator %(const T &lhs, const T &rhs)
    {
      T nrv(lhs);
      nrv %= rhs;
      return nrv;
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  xorable2 : B
  {
    friend inline T operator ^(const T &lhs, const U &rhs)
    {
      T nrv(lhs);
      nrv ^= rhs;
      return nrv;
    }
    friend inline T operator ^(const U &lhs, const T &rhs)
    {
      T nrv(rhs);
      nrv ^= lhs;
      return nrv;
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  xorable1 : B
  {
    friend inline T operator ^(const T &lhs, const T &rhs)
    {
      T nrv(lhs);
      nrv ^= rhs;
      return nrv;
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  andable2 : B
  {
    friend inline T operator &(const T &lhs, const U &rhs)
    {
      T nrv(lhs);
      nrv &= rhs;
      return nrv;
    }
    friend inline T operator &(const U &lhs, const T &rhs)
    {
      T nrv(rhs);
      nrv &= lhs;
      return nrv;
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  andable1 : B
  {
    friend inline T operator &(const T &lhs, const T &rhs)
    {
      T nrv(lhs);
      nrv &= rhs;
      return nrv;
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  orable2 : B
  {
    friend inline T operator |(const T &lhs, const U &rhs)
    {
      T nrv(lhs);
      nrv |= rhs;
      return nrv;
    }
    friend inline T operator |(const U &lhs, const T &rhs)
    {
      T nrv(rhs);
      nrv |= lhs;
      return nrv;
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  orable1 : B
  {
    friend inline T operator |(const T &lhs, const T &rhs)
    {
      T nrv(lhs);
      nrv |= rhs;
      return nrv;
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  incrementable : B
  {
    private:
      typedef T incrementable_type;
    friend inline T operator ++(T &x, int)
    {
      typename ::boost::incrementable<T, B>::incrementable_type nrv(x);
       ++x;
      return nrv;
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  decrementable : B
  {
    private:
      typedef T decrementable_type;
    friend inline T operator --(T &x, int)
    {
      typename ::boost::decrementable<T, B>::decrementable_type nrv(x);
       --x;
      return nrv;
    }
  };
  template < typename T, typename P, typename B = ::boost::detail::empty_base<T> >
  struct  dereferenceable : B
  {
      inline P operator ->() const 
      {
        return &*static_cast<const T &>(*this);
      }
  };
  template < typename T, typename I, typename R, typename B = ::boost::detail::empty_base<T> >
  struct  indexable : B
  {
      inline R operator [](I n) const 
      {
        return *(static_cast<const T &>(*this) + n);
      }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  left_shiftable2 : B
  {
    friend inline T operator <<(const T &lhs, const U &rhs)
    {
      T nrv(lhs);
      nrv <<= rhs;
      return nrv;
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  left_shiftable1 : B
  {
    friend inline T operator <<(const T &lhs, const T &rhs)
    {
      T nrv(lhs);
      nrv <<= rhs;
      return nrv;
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  right_shiftable2 : B
  {
    friend inline T operator >>(const T &lhs, const U &rhs)
    {
      T nrv(lhs);
      nrv >>= rhs;
      return nrv;
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  right_shiftable1 : B
  {
    friend inline T operator >>(const T &lhs, const T &rhs)
    {
      T nrv(lhs);
      nrv >>= rhs;
      return nrv;
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  equivalent2 : B
  {
    friend inline bool operator ==(const T &x, const U &y)
    {
      return !static_cast<bool>(x < y) && !static_cast<bool>(x > y);
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  equivalent1 : B
  {
    friend inline bool operator ==(const T &x, const T &y)
    {
      return !static_cast<bool>(x < y) && !static_cast<bool>(y < x);
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  partially_ordered2 : B
  {
    friend inline bool operator <=(const T &x, const U &y)
    {
      return static_cast<bool>(x < y) || static_cast<bool>(x == y);
    }
    friend inline bool operator >=(const T &x, const U &y)
    {
      return static_cast<bool>(x > y) || static_cast<bool>(x == y);
    }
    friend inline bool operator >(const U &x, const T &y)
    {
      return y < x;
    }
    friend inline bool operator <(const U &x, const T &y)
    {
      return y > x;
    }
    friend inline bool operator <=(const U &x, const T &y)
    {
      return static_cast<bool>(y > x) || static_cast<bool>(y == x);
    }
    friend inline bool operator >=(const U &x, const T &y)
    {
      return static_cast<bool>(y < x) || static_cast<bool>(y == x);
    }
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  partially_ordered1 : B
  {
    friend inline bool operator >(const T &x, const T &y)
    {
      return y < x;
    }
    friend inline bool operator <=(const T &x, const T &y)
    {
      return static_cast<bool>(x < y) || static_cast<bool>(x == y);
    }
    friend inline bool operator >=(const T &x, const T &y)
    {
      return static_cast<bool>(y < x) || static_cast<bool>(x == y);
    }
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  totally_ordered2 : ::boost::less_than_comparable2<T, U, ::boost::equality_comparable2<T, U, B> >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  totally_ordered1 : ::boost::less_than_comparable1<T, ::boost::equality_comparable1<T, B> >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  additive2 : ::boost::addable2<T, U, ::boost::subtractable2<T, U, B> >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  additive1 : ::boost::addable1<T, ::boost::subtractable1<T, B> >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  multiplicative2 : ::boost::multipliable2<T, U, ::boost::dividable2<T, U, B> >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  multiplicative1 : ::boost::multipliable1<T, ::boost::dividable1<T, B> >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  integer_multiplicative2 : ::boost::multiplicative2<T, U, ::boost::modable2<T, U, B> >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  integer_multiplicative1 : ::boost::multiplicative1<T, ::boost::modable1<T, B> >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  arithmetic2 : ::boost::additive2<T, U, ::boost::multiplicative2<T, U, B> >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  arithmetic1 : ::boost::additive1<T, ::boost::multiplicative1<T, B> >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  integer_arithmetic2 : ::boost::additive2<T, U, ::boost::integer_multiplicative2<T, U, B> >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  integer_arithmetic1 : ::boost::additive1<T, ::boost::integer_multiplicative1<T, B> >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  bitwise2 : ::boost::xorable2<T, U, ::boost::andable2<T, U, ::boost::orable2<T, U, B> > >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  bitwise1 : ::boost::xorable1<T, ::boost::andable1<T, ::boost::orable1<T, B> > >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  unit_steppable : ::boost::incrementable<T, ::boost::decrementable<T, B> >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  shiftable2 : ::boost::left_shiftable2<T, U, ::boost::right_shiftable2<T, U, B> >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  shiftable1 : ::boost::left_shiftable1<T, ::boost::right_shiftable1<T, B> >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  ring_operators2 : ::boost::additive2<T, U, ::boost::subtractable2_left<T, U, ::boost::multipliable2<T, U, B> > >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  ring_operators1 : ::boost::additive1<T, ::boost::multipliable1<T, B> >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  ordered_ring_operators2 : ::boost::ring_operators2<T, U, ::boost::totally_ordered2<T, U, B> >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  ordered_ring_operators1 : ::boost::ring_operators1<T, ::boost::totally_ordered1<T, B> >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  field_operators2 : ::boost::ring_operators2<T, U, ::boost::dividable2<T, U, ::boost::dividable2_left<T, U, B> > >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  field_operators1 : ::boost::ring_operators1<T, ::boost::dividable1<T, B> >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  ordered_field_operators2 : ::boost::field_operators2<T, U, ::boost::totally_ordered2<T, U, B> >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  ordered_field_operators1 : ::boost::field_operators1<T, ::boost::totally_ordered1<T, B> >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  euclidian_ring_operators2 : ::boost::ring_operators2<T, U, ::boost::dividable2<T, U, ::boost::dividable2_left<T, U, ::boost::modable2<T, U, ::boost::modable2_left<T, U, B> > > > >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  euclidian_ring_operators1 : ::boost::ring_operators1<T, ::boost::dividable1<T, ::boost::modable1<T, B> > >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  ordered_euclidian_ring_operators2 : ::boost::totally_ordered2<T, U, ::boost::euclidian_ring_operators2<T, U, B> >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  ordered_euclidian_ring_operators1 : ::boost::totally_ordered1<T, ::boost::euclidian_ring_operators1<T, B> >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  euclidean_ring_operators2 : ::boost::ring_operators2<T, U, ::boost::dividable2<T, U, ::boost::dividable2_left<T, U, ::boost::modable2<T, U, ::boost::modable2_left<T, U, B> > > > >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  euclidean_ring_operators1 : ::boost::ring_operators1<T, ::boost::dividable1<T, ::boost::modable1<T, B> > >
  {
  };
  template < typename T, typename U, typename B = ::boost::detail::empty_base<T> >
  struct  ordered_euclidean_ring_operators2 : ::boost::totally_ordered2<T, U, ::boost::euclidean_ring_operators2<T, U, B> >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  ordered_euclidean_ring_operators1 : ::boost::totally_ordered1<T, ::boost::euclidean_ring_operators1<T, B> >
  {
  };
  template < typename T, typename P, typename B = ::boost::detail::empty_base<T> >
  struct  input_iteratable : ::boost::equality_comparable1<T, ::boost::incrementable<T, ::boost::dereferenceable<T, P, B> > >
  {
  };
  template < typename T, typename B = ::boost::detail::empty_base<T> >
  struct  output_iteratable : ::boost::incrementable<T, B>
  {
  };
  template < typename T, typename P, typename B = ::boost::detail::empty_base<T> >
  struct  forward_iteratable : ::boost::input_iteratable<T, P, B>
  {
  };
  template < typename T, typename P, typename B = ::boost::detail::empty_base<T> >
  struct  bidirectional_iteratable : ::boost::forward_iteratable<T, P, ::boost::decrementable<T, B> >
  {
  };
  template < typename T, typename P, typename D, typename R, typename B = ::boost::detail::empty_base<T> >
  struct  random_access_iteratable : ::boost::bidirectional_iteratable<T, P, ::boost::less_than_comparable1<T, ::boost::additive2<T, D, ::boost::indexable<T, D, R, B> > > >
  {
  };
  namespace detail {
    struct  true_t
    {
    };
    struct  false_t
    {
    };
  }
  template < typename T >
  struct  is_chained_base
  {
      typedef ::boost::detail::false_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  less_than_comparable : ::boost::less_than_comparable2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  less_than_comparable<T, U, B, ::boost::detail::true_t> : ::boost::less_than_comparable1<T, U>
  {
  };
  template < typename T, typename B >
  struct  less_than_comparable<T, T, B, ::boost::detail::false_t> : ::boost::less_than_comparable1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::less_than_comparable<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::less_than_comparable2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::less_than_comparable1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  equality_comparable : ::boost::equality_comparable2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  equality_comparable<T, U, B, ::boost::detail::true_t> : ::boost::equality_comparable1<T, U>
  {
  };
  template < typename T, typename B >
  struct  equality_comparable<T, T, B, ::boost::detail::false_t> : ::boost::equality_comparable1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::equality_comparable<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::equality_comparable2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::equality_comparable1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  multipliable : ::boost::multipliable2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  multipliable<T, U, B, ::boost::detail::true_t> : ::boost::multipliable1<T, U>
  {
  };
  template < typename T, typename B >
  struct  multipliable<T, T, B, ::boost::detail::false_t> : ::boost::multipliable1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::multipliable<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::multipliable2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::multipliable1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  addable : ::boost::addable2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  addable<T, U, B, ::boost::detail::true_t> : ::boost::addable1<T, U>
  {
  };
  template < typename T, typename B >
  struct  addable<T, T, B, ::boost::detail::false_t> : ::boost::addable1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::addable<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::addable2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::addable1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  subtractable : ::boost::subtractable2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  subtractable<T, U, B, ::boost::detail::true_t> : ::boost::subtractable1<T, U>
  {
  };
  template < typename T, typename B >
  struct  subtractable<T, T, B, ::boost::detail::false_t> : ::boost::subtractable1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::subtractable<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::subtractable2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::subtractable1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::subtractable2_left<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  dividable : ::boost::dividable2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  dividable<T, U, B, ::boost::detail::true_t> : ::boost::dividable1<T, U>
  {
  };
  template < typename T, typename B >
  struct  dividable<T, T, B, ::boost::detail::false_t> : ::boost::dividable1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::dividable<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::dividable2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::dividable1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::dividable2_left<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  modable : ::boost::modable2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  modable<T, U, B, ::boost::detail::true_t> : ::boost::modable1<T, U>
  {
  };
  template < typename T, typename B >
  struct  modable<T, T, B, ::boost::detail::false_t> : ::boost::modable1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::modable<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::modable2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::modable1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::modable2_left<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  xorable : ::boost::xorable2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  xorable<T, U, B, ::boost::detail::true_t> : ::boost::xorable1<T, U>
  {
  };
  template < typename T, typename B >
  struct  xorable<T, T, B, ::boost::detail::false_t> : ::boost::xorable1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::xorable<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::xorable2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::xorable1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  andable : ::boost::andable2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  andable<T, U, B, ::boost::detail::true_t> : ::boost::andable1<T, U>
  {
  };
  template < typename T, typename B >
  struct  andable<T, T, B, ::boost::detail::false_t> : ::boost::andable1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::andable<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::andable2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::andable1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  orable : ::boost::orable2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  orable<T, U, B, ::boost::detail::true_t> : ::boost::orable1<T, U>
  {
  };
  template < typename T, typename B >
  struct  orable<T, T, B, ::boost::detail::false_t> : ::boost::orable1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::orable<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::orable2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::orable1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::incrementable<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::decrementable<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::dereferenceable<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename V, typename B >
  struct  is_chained_base< ::boost::indexable<T, U, V, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  left_shiftable : ::boost::left_shiftable2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  left_shiftable<T, U, B, ::boost::detail::true_t> : ::boost::left_shiftable1<T, U>
  {
  };
  template < typename T, typename B >
  struct  left_shiftable<T, T, B, ::boost::detail::false_t> : ::boost::left_shiftable1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::left_shiftable<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::left_shiftable2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::left_shiftable1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  right_shiftable : ::boost::right_shiftable2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  right_shiftable<T, U, B, ::boost::detail::true_t> : ::boost::right_shiftable1<T, U>
  {
  };
  template < typename T, typename B >
  struct  right_shiftable<T, T, B, ::boost::detail::false_t> : ::boost::right_shiftable1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::right_shiftable<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::right_shiftable2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::right_shiftable1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  equivalent : ::boost::equivalent2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  equivalent<T, U, B, ::boost::detail::true_t> : ::boost::equivalent1<T, U>
  {
  };
  template < typename T, typename B >
  struct  equivalent<T, T, B, ::boost::detail::false_t> : ::boost::equivalent1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::equivalent<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::equivalent2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::equivalent1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  partially_ordered : ::boost::partially_ordered2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  partially_ordered<T, U, B, ::boost::detail::true_t> : ::boost::partially_ordered1<T, U>
  {
  };
  template < typename T, typename B >
  struct  partially_ordered<T, T, B, ::boost::detail::false_t> : ::boost::partially_ordered1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::partially_ordered<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::partially_ordered2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::partially_ordered1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  totally_ordered : ::boost::totally_ordered2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  totally_ordered<T, U, B, ::boost::detail::true_t> : ::boost::totally_ordered1<T, U>
  {
  };
  template < typename T, typename B >
  struct  totally_ordered<T, T, B, ::boost::detail::false_t> : ::boost::totally_ordered1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::totally_ordered<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::totally_ordered2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::totally_ordered1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  additive : ::boost::additive2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  additive<T, U, B, ::boost::detail::true_t> : ::boost::additive1<T, U>
  {
  };
  template < typename T, typename B >
  struct  additive<T, T, B, ::boost::detail::false_t> : ::boost::additive1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::additive<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::additive2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::additive1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  multiplicative : ::boost::multiplicative2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  multiplicative<T, U, B, ::boost::detail::true_t> : ::boost::multiplicative1<T, U>
  {
  };
  template < typename T, typename B >
  struct  multiplicative<T, T, B, ::boost::detail::false_t> : ::boost::multiplicative1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::multiplicative<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::multiplicative2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::multiplicative1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  integer_multiplicative : ::boost::integer_multiplicative2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  integer_multiplicative<T, U, B, ::boost::detail::true_t> : ::boost::integer_multiplicative1<T, U>
  {
  };
  template < typename T, typename B >
  struct  integer_multiplicative<T, T, B, ::boost::detail::false_t> : ::boost::integer_multiplicative1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::integer_multiplicative<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::integer_multiplicative2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::integer_multiplicative1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  arithmetic : ::boost::arithmetic2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  arithmetic<T, U, B, ::boost::detail::true_t> : ::boost::arithmetic1<T, U>
  {
  };
  template < typename T, typename B >
  struct  arithmetic<T, T, B, ::boost::detail::false_t> : ::boost::arithmetic1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::arithmetic<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::arithmetic2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::arithmetic1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  integer_arithmetic : ::boost::integer_arithmetic2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  integer_arithmetic<T, U, B, ::boost::detail::true_t> : ::boost::integer_arithmetic1<T, U>
  {
  };
  template < typename T, typename B >
  struct  integer_arithmetic<T, T, B, ::boost::detail::false_t> : ::boost::integer_arithmetic1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::integer_arithmetic<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::integer_arithmetic2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::integer_arithmetic1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  bitwise : ::boost::bitwise2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  bitwise<T, U, B, ::boost::detail::true_t> : ::boost::bitwise1<T, U>
  {
  };
  template < typename T, typename B >
  struct  bitwise<T, T, B, ::boost::detail::false_t> : ::boost::bitwise1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::bitwise<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::bitwise2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::bitwise1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::unit_steppable<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  shiftable : ::boost::shiftable2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  shiftable<T, U, B, ::boost::detail::true_t> : ::boost::shiftable1<T, U>
  {
  };
  template < typename T, typename B >
  struct  shiftable<T, T, B, ::boost::detail::false_t> : ::boost::shiftable1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::shiftable<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::shiftable2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::shiftable1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  ring_operators : ::boost::ring_operators2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  ring_operators<T, U, B, ::boost::detail::true_t> : ::boost::ring_operators1<T, U>
  {
  };
  template < typename T, typename B >
  struct  ring_operators<T, T, B, ::boost::detail::false_t> : ::boost::ring_operators1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::ring_operators<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::ring_operators2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::ring_operators1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  ordered_ring_operators : ::boost::ordered_ring_operators2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  ordered_ring_operators<T, U, B, ::boost::detail::true_t> : ::boost::ordered_ring_operators1<T, U>
  {
  };
  template < typename T, typename B >
  struct  ordered_ring_operators<T, T, B, ::boost::detail::false_t> : ::boost::ordered_ring_operators1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::ordered_ring_operators<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::ordered_ring_operators2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::ordered_ring_operators1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  field_operators : ::boost::field_operators2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  field_operators<T, U, B, ::boost::detail::true_t> : ::boost::field_operators1<T, U>
  {
  };
  template < typename T, typename B >
  struct  field_operators<T, T, B, ::boost::detail::false_t> : ::boost::field_operators1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::field_operators<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::field_operators2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::field_operators1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  ordered_field_operators : ::boost::ordered_field_operators2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  ordered_field_operators<T, U, B, ::boost::detail::true_t> : ::boost::ordered_field_operators1<T, U>
  {
  };
  template < typename T, typename B >
  struct  ordered_field_operators<T, T, B, ::boost::detail::false_t> : ::boost::ordered_field_operators1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::ordered_field_operators<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::ordered_field_operators2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::ordered_field_operators1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  euclidian_ring_operators : ::boost::euclidian_ring_operators2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  euclidian_ring_operators<T, U, B, ::boost::detail::true_t> : ::boost::euclidian_ring_operators1<T, U>
  {
  };
  template < typename T, typename B >
  struct  euclidian_ring_operators<T, T, B, ::boost::detail::false_t> : ::boost::euclidian_ring_operators1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::euclidian_ring_operators<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::euclidian_ring_operators2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::euclidian_ring_operators1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  ordered_euclidian_ring_operators : ::boost::ordered_euclidian_ring_operators2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  ordered_euclidian_ring_operators<T, U, B, ::boost::detail::true_t> : ::boost::ordered_euclidian_ring_operators1<T, U>
  {
  };
  template < typename T, typename B >
  struct  ordered_euclidian_ring_operators<T, T, B, ::boost::detail::false_t> : ::boost::ordered_euclidian_ring_operators1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::ordered_euclidian_ring_operators<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::ordered_euclidian_ring_operators2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::ordered_euclidian_ring_operators1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  euclidean_ring_operators : ::boost::euclidean_ring_operators2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  euclidean_ring_operators<T, U, B, ::boost::detail::true_t> : ::boost::euclidean_ring_operators1<T, U>
  {
  };
  template < typename T, typename B >
  struct  euclidean_ring_operators<T, T, B, ::boost::detail::false_t> : ::boost::euclidean_ring_operators1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::euclidean_ring_operators<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::euclidean_ring_operators2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::euclidean_ring_operators1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U = T, typename B = ::boost::detail::empty_base<T>, typename O = typename ::boost::is_chained_base<U>::value >
  struct  ordered_euclidean_ring_operators : ::boost::ordered_euclidean_ring_operators2<T, U, B>
  {
  };
  template < typename T, typename U, typename B >
  struct  ordered_euclidean_ring_operators<T, U, B, ::boost::detail::true_t> : ::boost::ordered_euclidean_ring_operators1<T, U>
  {
  };
  template < typename T, typename B >
  struct  ordered_euclidean_ring_operators<T, T, B, ::boost::detail::false_t> : ::boost::ordered_euclidean_ring_operators1<T, B>
  {
  };
  template < typename T, typename U, typename B, typename O >
  struct  is_chained_base< ::boost::ordered_euclidean_ring_operators<T, U, B, O> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::ordered_euclidean_ring_operators2<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::ordered_euclidean_ring_operators1<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::input_iteratable<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename B >
  struct  is_chained_base< ::boost::output_iteratable<T, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::forward_iteratable<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename B >
  struct  is_chained_base< ::boost::bidirectional_iteratable<T, U, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U, typename V, typename W, typename B >
  struct  is_chained_base< ::boost::random_access_iteratable<T, U, V, W, B> >
  {
      typedef ::boost::detail::true_t value;
  };
  template < typename T, typename U >
  struct  operators2 : ::boost::totally_ordered2<T, U, ::boost::integer_arithmetic2<T, U, ::boost::bitwise2<T, U> > >
  {
  };
  template < typename T, typename U = T >
  struct  operators : ::boost::operators2<T, U>
  {
  };
  template < typename T >
  struct  operators<T, T> : ::boost::totally_ordered<T, ::boost::integer_arithmetic<T, ::boost::bitwise<T, ::boost::unit_steppable<T> > > >
  {
  };
  template < typename T, typename V, typename D = ::std::ptrdiff_t, typename P = const V *, typename R = const V & >
  struct  input_iterator_helper : ::boost::input_iteratable<T, P, ::boost::iterator< ::std::input_iterator_tag, V, D, P, R> >
  {
  };
  template < typename T >
  struct  output_iterator_helper : ::boost::output_iteratable<T, ::boost::iterator< ::std::output_iterator_tag, void, void, void, void> >
  {
      inline T &operator *()
      {
        return static_cast<T &>(*this);
      }
      inline T &operator ++()
      {
        return static_cast<T &>(*this);
      }
  };
  template < typename T, typename V, typename D = ::std::ptrdiff_t, typename P = V *, typename R = V & >
  struct  forward_iterator_helper : ::boost::forward_iteratable<T, P, ::boost::iterator< ::std::forward_iterator_tag, V, D, P, R> >
  {
  };
  template < typename T, typename V, typename D = ::std::ptrdiff_t, typename P = V *, typename R = V & >
  struct  bidirectional_iterator_helper : ::boost::bidirectional_iteratable<T, P, ::boost::iterator< ::std::bidirectional_iterator_tag, V, D, P, R> >
  {
  };
  template < typename T, typename V, typename D = ::std::ptrdiff_t, typename P = V *, typename R = V & >
  struct  random_access_iterator_helper : ::boost::random_access_iteratable<T, P, D, R, ::boost::iterator< ::std::random_access_iterator_tag, V, D, P, R> >
  {
    friend inline D requires_difference_operator(const T &x, const T &y)
    {
      return x - y;
    }
  };
 /* Instantiation of class template '::boost::detail::empty_base<struct version_type>' */ 
 /* Instantiation of class template '::boost::equality_comparable2<struct version_type, unsigned int, ::boost::detail::empty_base<struct version_type> >' */ 
 /* Instantiation of class template '::boost::less_than_comparable2<struct version_type, unsigned int, ::boost::equality_comparable2<struct version_type, unsigned int, ::boost::detail::empty_base<struct version_type> > >' */ 
 /* Instantiation of class template '::boost::totally_ordered2<struct version_type, unsigned int>' */ 
 /* Instantiation of class template '::boost::equality_comparable1<struct version_type, ::boost::totally_ordered2<struct version_type, unsigned int> >' */ 
 /* Instantiation of class template '::boost::less_than_comparable1<struct version_type, ::boost::equality_comparable1<struct version_type, ::boost::totally_ordered2<struct version_type, unsigned int> > >' */ 
 /* Instantiation of class template '::boost::totally_ordered1<struct version_type, ::boost::totally_ordered2<struct version_type, unsigned int> >' */ 
  namespace serialization {
    struct  version_type : ::boost::totally_ordered1< ::boost::serialization::version_type, ::boost::totally_ordered2< ::boost::serialization::version_type, unsigned int> >
    {
        unsigned int t;
        inline explicit version_type(const unsigned int t_)
          : t(t_)
        {
        }
        inline version_type()
          : t()
        {
        }
        inline version_type(const ::boost::serialization::version_type &t_)
          : t(t_.t)
        {
        }
        inline ::boost::serialization::version_type &operator =(const ::boost::serialization::version_type &rhs)
        {
          (*this).t = rhs.t;
          return *this;
        }
        inline ::boost::serialization::version_type &operator =(const unsigned int &rhs)
        {
          (*this).t = rhs;
          return *this;
        }
        inline operator const unsigned int &() const 
        {
          return (*this).t;
        }
        inline operator unsigned int &()
        {
          return (*this).t;
        }
        inline bool operator ==(const ::boost::serialization::version_type &rhs) const 
        {
          return (*this).t == rhs.t;
        }
        inline bool operator <(const ::boost::serialization::version_type &rhs) const 
        {
          return (*this).t < rhs.t;
        }
    };
    template < typename Archive, typename T >
    inline void serialize(Archive &ar, T &t, const unsigned int file_version);
    template < typename Archive, typename T >
    inline void serialize(Archive &ar, T &t, const unsigned int file_version)
    {
      access::serialize(ar, t, static_cast<unsigned int>(file_version));
    }
    template < typename Archive, typename T >
    inline void save_construct_data(Archive &, const T *, const unsigned int);
    template < typename Archive, typename T >
    inline void save_construct_data(Archive &, const T *, const unsigned int)
    {
    }
    template < typename Archive, typename T >
    inline void load_construct_data(Archive &, T *t, const unsigned int);
    template < typename Archive, typename T >
    inline void load_construct_data(Archive &, T *t, const unsigned int)
    {
      access::construct(t);
    }
    template < typename Archive, typename T >
    inline void serialize_adl(Archive &ar, T &t, const unsigned int file_version)
    {
      const ::boost::serialization::version_type v((file_version));
      serialize(ar, t, v);
    }
    template < typename Archive, typename T >
    inline void save_construct_data_adl(Archive &ar, const T *t, const unsigned int file_version);
    template < typename Archive, typename T >
    inline void save_construct_data_adl(Archive &ar, const T *t, const unsigned int file_version)
    {
      const ::boost::serialization::version_type v((file_version));
      save_construct_data(ar, t, v);
    }
    template < typename Archive, typename T >
    inline void load_construct_data_adl(Archive &ar, T *t, const unsigned int file_version);
    template < typename Archive, typename T >
    inline void load_construct_data_adl(Archive &ar, T *t, const unsigned int file_version)
    {
      const ::boost::serialization::version_type v((file_version));
      load_construct_data(ar, t, v);
    }
  }
}
namespace mpl_ {
   struct  failed
  {
  };
  template < bool C >
  struct  assert
  {
      typedef void *type;
  };
  template <>
  struct  assert<false>
  {
      typedef ::mpl_::assert<false> type;
  };
  template < bool C >
  int assertion_failed(typename ::mpl_::assert<C>::type);
  template < bool C >
  struct  assertion
  {
      static int failed(::mpl_::assert<false>);
  };
  template <>
  struct  assertion<true>
  {
      static int failed(void *);
  };
  struct  assert_
  {
      template < typename T1, typename T2 = ::mpl_::na, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na >
      struct  types
      {
      };
      static const ::mpl_::assert_ arg;
      enum relations
      {
        equal = 1,
        not_equal = 2,
        greater = 3,
        greater_equal = 4,
        less = 5,
        less_equal = 6
      };
  };
 /* Instantiation of class template '::boost::mpl::aux::weighted_tag<1L>' */ 
  ::boost::mpl::aux::weighted_tag<1L>::type operator ==(::mpl_::assert_, ::mpl_::assert_);
 /* Instantiation of class template '::boost::mpl::aux::weighted_tag<2L>' */ 
  ::boost::mpl::aux::weighted_tag<2L>::type operator !=(::mpl_::assert_, ::mpl_::assert_);
 /* Instantiation of class template '::boost::mpl::aux::weighted_tag<3L>' */ 
  ::boost::mpl::aux::weighted_tag<3L>::type operator >(::mpl_::assert_, ::mpl_::assert_);
 /* Instantiation of class template '::boost::mpl::aux::weighted_tag<4L>' */ 
  ::boost::mpl::aux::weighted_tag<4L>::type operator >=(::mpl_::assert_, ::mpl_::assert_);
 /* Instantiation of class template '::boost::mpl::aux::weighted_tag<5L>' */ 
  ::boost::mpl::aux::weighted_tag<5L>::type operator <(::mpl_::assert_, ::mpl_::assert_);
 /* Instantiation of class template '::boost::mpl::aux::weighted_tag<6L>' */ 
  ::boost::mpl::aux::weighted_tag<6L>::type operator <=(::mpl_::assert_, ::mpl_::assert_);
  template < ::mpl_::assert_::relations r, long int x, long int y >
  struct  assert_relation
  {
  };
  template < bool __nontype_tpl_param_1_0__ >
  struct  assert_arg_pred_impl
  {
      typedef int type;
  };
  template <>
  struct  assert_arg_pred_impl<true>
  {
      typedef void *type;
  };
  template < typename P >
  struct  assert_arg_pred
  {
      typedef typename P::type p_type;
      typedef typename ::mpl_::assert_arg_pred_impl<p_type::value>::type type;
  };
  template < typename P >
  struct  assert_arg_pred_not
  {
      typedef typename P::type p_type;
      enum mcc_enum_anon_71
      {
        p = !p_type::value
      };
      typedef typename ::mpl_::assert_arg_pred_impl< ::mpl_::assert_arg_pred_not<P>::p>::type type;
  };
  template < typename Pred >
  ::mpl_::failed ************Pred::************assert_arg(void (*)(Pred), typename ::mpl_::assert_arg_pred<Pred>::type);
  template < typename Pred >
  ::mpl_::failed ************(::boost::mpl::not_<Pred>::************assert_not_arg(void (*)(Pred), typename ::mpl_::assert_arg_pred_not<Pred>::type));
  template < typename Pred >
  ::mpl_::assert<false> assert_arg(void (*)(Pred), typename ::mpl_::assert_arg_pred_not<Pred>::type);
  template < typename Pred >
  ::mpl_::assert<false> assert_not_arg(void (*)(Pred), typename ::mpl_::assert_arg_pred<Pred>::type);
}
namespace boost {
  namespace serialization {
    template < typename T >
    struct  version
    {
        template < typename U >
        struct  traits_class_version
        {
            typedef typename U::version type;
        };
        typedef ::mpl_::integral_c_tag tag;
        typedef typename ::boost::mpl::eval_if< ::boost::is_base_and_derived< ::boost::serialization::basic_traits, T>, typename ::boost::serialization::version<T>::template traits_class_version<T>, ::mpl_::int_<0> >::type type;
        static const int value = version::type::value;
    };
  }
  namespace mpl {
    template < typename Tag1, typename Tag2 >
    struct  less_impl : ::boost::mpl::if_c<(Tag1::value > Tag2::value), ::boost::mpl::aux::cast2nd_impl< ::boost::mpl::less_impl<Tag1, Tag1>, Tag1, Tag2>, ::boost::mpl::aux::cast1st_impl< ::boost::mpl::less_impl<Tag2, Tag2>, Tag1, Tag2> >::type
    {
    };
    template <>
    struct  less_impl< ::mpl_::na, ::mpl_::na>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::less_impl< ::mpl_::na, ::mpl_::na>::apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename Tag >
    struct  less_impl< ::mpl_::na, Tag>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::less_impl< ::mpl_::na, Tag>::template apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename Tag >
    struct  less_impl<Tag, ::mpl_::na>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::less_impl<Tag, ::mpl_::na>::template apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename T >
    struct  less_tag
    {
        typedef typename T::tag type;
    };
    template < typename N1 = ::mpl_::na, typename N2 = ::mpl_::na >
    struct  less : ::boost::mpl::less_impl<typename ::boost::mpl::less_tag<N1>::type, typename ::boost::mpl::less_tag<N2>::type>::template apply<N1, N2>::type
    {
    };
    template <>
    struct  less< ::mpl_::na, ::mpl_::na>
    {
        template < typename T1, typename T2, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::less<T1, T2>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::less< ::mpl_::na, ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::less< ::mpl_::na, ::mpl_::na> result_;
        typedef ::boost::mpl::less< ::mpl_::na, ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1, typename T2 >
      struct  template_arity< ::boost::mpl::less<T1, T2> > : ::mpl_::int_<2>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::less< ::mpl_::na, ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
    template <>
    struct  less_impl< ::mpl_::integral_c_tag, ::mpl_::integral_c_tag>
    {
        template < typename N1, typename N2 >
        struct  apply : ::mpl_::bool_<(N2::value > N1::value)>
        {
        };
    };
    template < typename Tag1, typename Tag2 >
    struct  not_equal_to_impl : ::boost::mpl::if_c<(Tag1::value > Tag2::value), ::boost::mpl::aux::cast2nd_impl< ::boost::mpl::not_equal_to_impl<Tag1, Tag1>, Tag1, Tag2>, ::boost::mpl::aux::cast1st_impl< ::boost::mpl::not_equal_to_impl<Tag2, Tag2>, Tag1, Tag2> >::type
    {
    };
    template <>
    struct  not_equal_to_impl< ::mpl_::na, ::mpl_::na>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::not_equal_to_impl< ::mpl_::na, ::mpl_::na>::apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename Tag >
    struct  not_equal_to_impl< ::mpl_::na, Tag>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::not_equal_to_impl< ::mpl_::na, Tag>::template apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename Tag >
    struct  not_equal_to_impl<Tag, ::mpl_::na>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::not_equal_to_impl<Tag, ::mpl_::na>::template apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename T >
    struct  not_equal_to_tag
    {
        typedef typename T::tag type;
    };
    template < typename N1 = ::mpl_::na, typename N2 = ::mpl_::na >
    struct  not_equal_to : ::boost::mpl::not_equal_to_impl<typename ::boost::mpl::not_equal_to_tag<N1>::type, typename ::boost::mpl::not_equal_to_tag<N2>::type>::template apply<N1, N2>::type
    {
    };
    template <>
    struct  not_equal_to< ::mpl_::na, ::mpl_::na>
    {
        template < typename T1, typename T2, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::not_equal_to<T1, T2>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::not_equal_to< ::mpl_::na, ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::not_equal_to< ::mpl_::na, ::mpl_::na> result_;
        typedef ::boost::mpl::not_equal_to< ::mpl_::na, ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1, typename T2 >
      struct  template_arity< ::boost::mpl::not_equal_to<T1, T2> > : ::mpl_::int_<2>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::not_equal_to< ::mpl_::na, ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
    template <>
    struct  not_equal_to_impl< ::mpl_::integral_c_tag, ::mpl_::integral_c_tag>
    {
        template < typename N1, typename N2 >
        struct  apply : ::mpl_::bool_<N1::value != N2::value>
        {
        };
    };
    template < typename Tag1, typename Tag2 >
    struct  greater_impl : ::boost::mpl::if_c<(Tag1::value > Tag2::value), ::boost::mpl::aux::cast2nd_impl< ::boost::mpl::greater_impl<Tag1, Tag1>, Tag1, Tag2>, ::boost::mpl::aux::cast1st_impl< ::boost::mpl::greater_impl<Tag2, Tag2>, Tag1, Tag2> >::type
    {
    };
    template <>
    struct  greater_impl< ::mpl_::na, ::mpl_::na>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::greater_impl< ::mpl_::na, ::mpl_::na>::apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename Tag >
    struct  greater_impl< ::mpl_::na, Tag>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::greater_impl< ::mpl_::na, Tag>::template apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename Tag >
    struct  greater_impl<Tag, ::mpl_::na>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::greater_impl<Tag, ::mpl_::na>::template apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename T >
    struct  greater_tag
    {
        typedef typename T::tag type;
    };
    template < typename N1 = ::mpl_::na, typename N2 = ::mpl_::na >
    struct  greater : ::boost::mpl::greater_impl<typename ::boost::mpl::greater_tag<N1>::type, typename ::boost::mpl::greater_tag<N2>::type>::template apply<N1, N2>::type
    {
    };
    template <>
    struct  greater< ::mpl_::na, ::mpl_::na>
    {
        template < typename T1, typename T2, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::greater<T1, T2>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::greater< ::mpl_::na, ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::greater< ::mpl_::na, ::mpl_::na> result_;
        typedef ::boost::mpl::greater< ::mpl_::na, ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1, typename T2 >
      struct  template_arity< ::boost::mpl::greater<T1, T2> > : ::mpl_::int_<2>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::greater< ::mpl_::na, ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
    template <>
    struct  greater_impl< ::mpl_::integral_c_tag, ::mpl_::integral_c_tag>
    {
        template < typename N1, typename N2 >
        struct  apply : ::mpl_::bool_<(N1::value > N2::value)>
        {
        };
    };
    template < typename Tag1, typename Tag2 >
    struct  less_equal_impl : ::boost::mpl::if_c<(Tag1::value > Tag2::value), ::boost::mpl::aux::cast2nd_impl< ::boost::mpl::less_equal_impl<Tag1, Tag1>, Tag1, Tag2>, ::boost::mpl::aux::cast1st_impl< ::boost::mpl::less_equal_impl<Tag2, Tag2>, Tag1, Tag2> >::type
    {
    };
    template <>
    struct  less_equal_impl< ::mpl_::na, ::mpl_::na>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::less_equal_impl< ::mpl_::na, ::mpl_::na>::apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename Tag >
    struct  less_equal_impl< ::mpl_::na, Tag>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::less_equal_impl< ::mpl_::na, Tag>::template apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename Tag >
    struct  less_equal_impl<Tag, ::mpl_::na>
    {
        template < typename U1, typename U2 >
        struct  apply
        {
            typedef typename ::boost::mpl::less_equal_impl<Tag, ::mpl_::na>::template apply<U1, U2> type;
            static const int value = 0;
        };
    };
    template < typename T >
    struct  less_equal_tag
    {
        typedef typename T::tag type;
    };
    template < typename N1 = ::mpl_::na, typename N2 = ::mpl_::na >
    struct  less_equal : ::boost::mpl::less_equal_impl<typename ::boost::mpl::less_equal_tag<N1>::type, typename ::boost::mpl::less_equal_tag<N2>::type>::template apply<N1, N2>::type
    {
    };
    template <>
    struct  less_equal< ::mpl_::na, ::mpl_::na>
    {
        template < typename T1, typename T2, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::less_equal<T1, T2>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::less_equal< ::mpl_::na, ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::less_equal< ::mpl_::na, ::mpl_::na> result_;
        typedef ::boost::mpl::less_equal< ::mpl_::na, ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1, typename T2 >
      struct  template_arity< ::boost::mpl::less_equal<T1, T2> > : ::mpl_::int_<2>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::less_equal< ::mpl_::na, ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
    template <>
    struct  less_equal_impl< ::mpl_::integral_c_tag, ::mpl_::integral_c_tag>
    {
        template < typename N1, typename N2 >
        struct  apply : ::mpl_::bool_<N1::value <= N2::value>
        {
        };
    };
  }
  namespace serialization {
    struct  basic_traits
    {
    };
    template < typename T >
    struct extended_type_info_impl;
    template < typename T, int Level, int Tracking, unsigned int Version = 0, typename ETII = ::boost::serialization::extended_type_info_impl<T>, typename Wrapper = ::mpl_::false_ >
    struct  traits : ::boost::serialization::basic_traits
    {
        static_assert(Version == 0 || Level >= ::boost::serialization::object_class_info, "Version == 0 || Level >= object_class_info");
        static_assert(Tracking == ::boost::serialization::track_never || Level >= ::boost::serialization::object_serializable, "Tracking == track_never || Level >= object_serializable");
        typedef ::mpl_::int_<Level> level;
        typedef ::mpl_::int_<Tracking> tracking;
        typedef ::mpl_::int_<Version> version;
        typedef ETII type_info_implementation;
        typedef Wrapper is_wrapper;
    };
    template < typename T >
    struct  type_info_implementation
    {
        template < typename U >
        struct  traits_class_typeinfo_implementation
        {
            typedef typename U::type_info_implementation::type type;
        };
        typedef typename ::boost::mpl::eval_if< ::boost::is_base_and_derived< ::boost::serialization::basic_traits, T>, typename ::boost::serialization::type_info_implementation<T>::template traits_class_typeinfo_implementation<T>, ::boost::mpl::identity<typename ::boost::serialization::extended_type_info_impl<T>::type> >::type type;
    };
    template < typename T >
    struct  tracking_level_impl
    {
        template < typename U >
        struct  traits_class_tracking
        {
            typedef typename U::tracking type;
        };
        typedef ::mpl_::integral_c_tag tag;
        typedef typename ::boost::mpl::eval_if< ::boost::is_base_and_derived< ::boost::serialization::basic_traits, T>, typename ::boost::serialization::tracking_level_impl<T>::template traits_class_tracking<T>, ::boost::mpl::eval_if< ::boost::is_pointer<T>, ::mpl_::int_<0>, ::boost::mpl::eval_if< ::boost::mpl::equal_to< ::boost::serialization::implementation_level<T>, ::mpl_::int_<1> >, ::mpl_::int_<0>, ::mpl_::int_<1> > > >::type type;
        static const int value = type::value;
    };
    template < typename T >
    struct  tracking_level : ::boost::serialization::tracking_level_impl<const T>
    {
    };
    template < typename T, ::boost::serialization::tracking_type L >
    inline bool operator >=(::boost::serialization::tracking_level<T> t, ::boost::serialization::tracking_type l);
    template < typename T, ::boost::serialization::tracking_type L >
    inline bool operator >=(::boost::serialization::tracking_level<T> t, ::boost::serialization::tracking_type l)
    {
      return t.value >= (int)l;
    }
  }
  namespace archive {
    namespace detail {
      template < typename Archive >
      class interface_oarchive;
      template < typename Archive >
      class interface_iarchive;
    }
  }
  namespace serialization {
     namespace detail {
      template < typename Archive, typename T >
      struct  member_saver
      {
          static inline void invoke(Archive &ar, const T &t, const unsigned int file_version)
          {
            access::member_save(ar, t, file_version);
          }
      };
      template < typename Archive, typename T >
      struct  member_loader
      {
          static inline void invoke(Archive &ar, T &t, const unsigned int file_version)
          {
            access::member_load(ar, t, file_version);
          }
      };
    }
    template < typename Archive, typename T >
    inline void split_member(Archive &ar, T &t, const unsigned int file_version);
    template < typename Archive, typename T >
    inline void split_member(Archive &ar, T &t, const unsigned int file_version)
    {
      typedef typename ::boost::mpl::eval_if<typename Archive::is_saving, ::boost::mpl::identity< ::boost::serialization::detail::member_saver<Archive, T> >, ::boost::mpl::identity< ::boost::serialization::detail::member_loader<Archive, T> > >::type typex;
      typex::invoke(ar, t, file_version);
    }
    template < typename Derived, typename Base >
    inline const ::boost::serialization::void_cast_detail::void_caster &void_cast_register(const Derived *  = (0L), const Base *  = (0L));
    namespace detail {
      template < typename B, typename D >
      struct  base_cast
      {
          typedef typename ::boost::mpl::if_< ::boost::is_const<D>, const B, B>::type type;
          static_assert(is_const<typename ::boost::serialization::detail::base_cast<B, D>::type>::value == is_const<D>::value, "is_const<type>::value == is_const<D>::value");
      };
      template < typename Base, typename Derived >
      struct  base_register
      {
          struct  polymorphic
          {
              static inline const void *invoke()
              {
                const Base *const b = 0;
                const Derived *const d = 0;
                return &void_cast_register(d, b);
              }
          };
          struct  non_polymorphic
          {
              static inline const void *invoke()
              {
                return 0;
              }
          };
          static inline const void *invoke()
          {
            typedef typename ::boost::mpl::eval_if< ::boost::is_polymorphic<Base>, ::boost::mpl::identity<typename ::boost::serialization::detail::base_register<Base, Derived>::polymorphic>, ::boost::mpl::identity<typename ::boost::serialization::detail::base_register<Base, Derived>::non_polymorphic> >::type type;
            return type::invoke();
          }
      };
    }
    template < typename Base, typename Derived >
    typename ::boost::serialization::detail::base_cast<Base, Derived>::type &base_object(Derived &d);
    template < typename Base, typename Derived >
    typename ::boost::serialization::detail::base_cast<Base, Derived>::type &base_object(Derived &d)
    {
      static_assert(is_base_and_derived<Base, Derived>::value, "( is_base_and_derived<Base,Derived>::value)");
      static_assert(!is_pointer<Derived>::value, "! is_pointer<Derived>::value");
      typedef typename ::boost::serialization::detail::base_cast<Base, Derived>::type type;
      detail::base_register<type, Derived>::invoke();
      return access::cast_reference<type, Derived>(d);
    }
    template < typename T, int Level = ::boost::serialization::object_serializable, int Tracking = ::boost::serialization::track_never, unsigned int Version = 0, typename ETII = ::boost::serialization::extended_type_info_impl<T> >
    struct  wrapper_traits : ::boost::serialization::traits<T, Level, Tracking, Version, ETII, ::mpl_::bool_<true> >
    {
    };
    template < typename T >
    struct  is_wrapper_impl : ::boost::mpl::eval_if< ::boost::is_base_and_derived< ::boost::serialization::basic_traits, T>, ::mpl_::bool_<true>, ::mpl_::bool_<false> >::type
    {
    };
    template < typename T >
    struct  is_wrapper
    {
        typedef typename ::boost::serialization::is_wrapper_impl<const T>::type type;
    };
    template < typename T >
    struct  nvp : ::std::pair<const char *, T *>, ::boost::serialization::wrapper_traits<const ::boost::serialization::nvp<T> >
    {
        inline explicit nvp(const char *name_, T &t)
          : std::pair<const char *, T *>(name_, (T *)&t)
        {
        }
        inline nvp(const ::boost::serialization::nvp<T> &rhs)
          : std::pair<const char *, T *>(rhs.first, (T *)rhs.second)
        {
        }
        inline const char *name() const 
        {
          return this->first;
        }
        inline T &value() const 
        {
          return *this->second;
        }
        inline const T &const_value() const 
        {
          return *this->second;
        }
        template < typename Archivex >
        inline void save(Archivex &ar, const unsigned int) const 
        {
          ar.operator <<((*this).const_value());
        }
        template < typename Archivex >
        inline void load(Archivex &ar, const unsigned int)
        {
          ar.operator >>((*this).value());
        }
        template < typename Archive >
        inline void serialize(Archive &ar, const unsigned int file_version)
        {
          boost::serialization::split_member(ar, *this, file_version);
        }
    };
    template < typename T >
    inline const ::boost::serialization::nvp<T> make_nvp(const char *name, T &t);
    template < typename T >
    inline const ::boost::serialization::nvp<T> make_nvp(const char *name, T &t)
    {
      return ::boost::serialization::nvp<T>(name, t);
    }
  }
  namespace detail {
    template < typename B, typename D >
    struct  is_base_of_imp
    {
        typedef typename ::boost::remove_cv<B>::type ncvB;
        typedef typename ::boost::remove_cv<D>::type ncvD;
        static const bool value = ::boost::type_traits::ice_or< ::boost::detail::is_base_and_derived_impl<typename ::boost::detail::is_base_of_imp<B, D>::ncvB, typename ::boost::detail::is_base_of_imp<B, D>::ncvD>::value, ::boost::type_traits::ice_and< ::boost::is_same<typename ::boost::detail::is_base_of_imp<B, D>::ncvB, typename ::boost::detail::is_base_of_imp<B, D>::ncvD>::value, ::boost::is_class<typename ::boost::detail::is_base_of_imp<B, D>::ncvB>::value>::value>::value;
    };
  }
  template < typename Base, typename Derived >
  struct  is_base_of : ::boost::integral_constant<bool, ::boost::detail::is_base_of_imp<Base, Derived>::value>
  {
  };
  template < typename Base, typename Derived >
  struct  is_base_of<Base &, Derived> : ::boost::integral_constant<bool, false>
  {
  };
  template < typename Base, typename Derived >
  struct  is_base_of<Base, Derived &> : ::boost::integral_constant<bool, false>
  {
  };
  template < typename Base, typename Derived >
  struct  is_base_of<Base &, Derived &> : ::boost::integral_constant<bool, false>
  {
  };
  namespace detail {
    template < typename Base, typename Derived, typename tag >
    struct  is_virtual_base_of_impl
    {
        static const bool value = false;
    };
    template < typename Base, typename Derived >
    struct  is_virtual_base_of_impl<Base, Derived, ::mpl_::bool_<true> >
    {
        struct  boost_type_traits_internal_struct_X : Derived, virtual Base
        {
            boost_type_traits_internal_struct_X();
            boost_type_traits_internal_struct_X(const typename ::boost::detail::is_virtual_base_of_impl<Base, Derived, ::mpl_::bool_<true> >::boost_type_traits_internal_struct_X &);
            typename ::boost::detail::is_virtual_base_of_impl<Base, Derived, ::mpl_::bool_<true> >::boost_type_traits_internal_struct_X &operator =(const typename ::boost::detail::is_virtual_base_of_impl<Base, Derived, ::mpl_::bool_<true> >::boost_type_traits_internal_struct_X &);
            ~boost_type_traits_internal_struct_X() throw();
        };
        struct  boost_type_traits_internal_struct_Y : Derived
        {
            boost_type_traits_internal_struct_Y();
            boost_type_traits_internal_struct_Y(const typename ::boost::detail::is_virtual_base_of_impl<Base, Derived, ::mpl_::bool_<true> >::boost_type_traits_internal_struct_Y &);
            typename ::boost::detail::is_virtual_base_of_impl<Base, Derived, ::mpl_::bool_<true> >::boost_type_traits_internal_struct_Y &operator =(const typename ::boost::detail::is_virtual_base_of_impl<Base, Derived, ::mpl_::bool_<true> >::boost_type_traits_internal_struct_Y &);
            ~boost_type_traits_internal_struct_Y() throw();
        };
        static const bool value = sizeof(typename ::boost::detail::is_virtual_base_of_impl<Base, Derived, ::mpl_::bool_<true> >::boost_type_traits_internal_struct_X) == sizeof(typename ::boost::detail::is_virtual_base_of_impl<Base, Derived, ::mpl_::bool_<true> >::boost_type_traits_internal_struct_Y);
    };
    template < typename Base, typename Derived >
    struct  is_virtual_base_of_impl2
    {
        typedef typename ::boost::mpl::and_< ::boost::is_base_of<Base, Derived>, ::boost::mpl::not_< ::boost::is_same<Base, Derived> > >::type tag_type;
        typedef ::boost::detail::is_virtual_base_of_impl<Base, Derived, typename ::boost::detail::is_virtual_base_of_impl2<Base, Derived>::tag_type> imp;
        static const bool value = imp::value;
    };
  }
  template < typename Base, typename Derived >
  struct  is_virtual_base_of : ::boost::integral_constant<bool, ::boost::detail::is_virtual_base_of_impl2<Base, Derived>::value>
  {
  };
  template < typename Base, typename Derived >
  struct  is_virtual_base_of<Base &, Derived> : ::boost::integral_constant<bool, false>
  {
  };
  template < typename Base, typename Derived >
  struct  is_virtual_base_of<Base, Derived &> : ::boost::integral_constant<bool, false>
  {
  };
  template < typename Base, typename Derived >
  struct  is_virtual_base_of<Base &, Derived &> : ::boost::integral_constant<bool, false>
  {
  };
  namespace serialization {
    const void *void_upcast(const ::boost::serialization::extended_type_info &derived, const ::boost::serialization::extended_type_info &base, const void *const t);
    inline void *void_upcast(const ::boost::serialization::extended_type_info &derived, const ::boost::serialization::extended_type_info &base, void *const t)
    {
      return const_cast<void *>(::boost::serialization::void_upcast(derived, base, const_cast<const void *>(t)));
    }
    const void *void_downcast(const ::boost::serialization::extended_type_info &derived, const ::boost::serialization::extended_type_info &base, const void *const t);
    inline void *void_downcast(const ::boost::serialization::extended_type_info &derived, const ::boost::serialization::extended_type_info &base, void *const t)
    {
      return const_cast<void *>(::boost::serialization::void_downcast(derived, base, const_cast<const void *>(t)));
    }
    namespace void_cast_detail {
      class  void_caster : ::boost::noncopyable_::noncopyable
      {
        protected:
          void recursive_register(bool includes_virtual_base  = (false)) const ;
          void recursive_unregister() const ;
          virtual bool has_virtual_base() const  = 0 ;
        public:
          const ::boost::serialization::extended_type_info *m_derived;
          const ::boost::serialization::extended_type_info *m_base;
          ::std::ptrdiff_t m_difference;
          const ::boost::serialization::void_cast_detail::void_caster *const m_parent;
          bool operator <(const ::boost::serialization::void_cast_detail::void_caster &rhs) const ;
          inline const ::boost::serialization::void_cast_detail::void_caster &operator *()
          {
            return *this;
          }
          virtual const void *upcast(const void *const t) const  = 0 ;
          virtual const void *downcast(const void *const t) const  = 0 ;
          inline void_caster(const ::boost::serialization::extended_type_info *derived, const ::boost::serialization::extended_type_info *base, ::std::ptrdiff_t difference  = (0), const ::boost::serialization::void_cast_detail::void_caster *const parent  = (0))
            : m_derived(derived), m_base(base), m_difference(difference), m_parent(parent)
          {
          }
          virtual inline ~void_caster()
          {
          }
        friend const void *(::boost::serialization::void_upcast)(const ::boost::serialization::extended_type_info &, const ::boost::serialization::extended_type_info &, const void *const );
        friend const void *(::boost::serialization::void_downcast)(const ::boost::serialization::extended_type_info &, const ::boost::serialization::extended_type_info &, const void *const );
      };
      template < typename Derived, typename Base >
      class  void_caster_primitive : public ::boost::serialization::void_cast_detail::void_caster
      {
          inline virtual const void *downcast(const void *const t) const 
          {
            const Derived *d = boost::serialization::smart_cast<const Derived *, const Base *>(static_cast<const Base *>(t));
            return d;
          }
          inline virtual const void *upcast(const void *const t) const 
          {
            const Base *b = boost::serialization::smart_cast<const Base *, const Derived *>(static_cast<const Derived *>(t));
            return b;
          }
          inline virtual bool has_virtual_base() const 
          {
            return false;
          }
        public:
          void_caster_primitive();
          virtual ~void_caster_primitive();
      };
      template < typename Derived, typename Base >
      void_caster_primitive<Derived, Base>::void_caster_primitive()
        : void_caster(&type_info_implementation<Derived>::type::get_const_instance(), &type_info_implementation<Base>::type::get_const_instance(), reinterpret_cast< ::std::ptrdiff_t>(static_cast<Derived *>(reinterpret_cast<Base *>(1))) - 1)
      {
        (*this).recursive_register();
      }
      template < typename Derived, typename Base >
      void_caster_primitive<Derived, Base>::~void_caster_primitive()
      {
        (*this).recursive_unregister();
      }
      template < typename Derived, typename Base >
      class  void_caster_virtual_base : public ::boost::serialization::void_cast_detail::void_caster
      {
          inline virtual bool has_virtual_base() const 
          {
            return true;
          }
        public:
          inline virtual const void *downcast(const void *const t) const 
          {
            const Derived *d = dynamic_cast<const Derived *>(static_cast<const Base *>(t));
            return d;
          }
          inline virtual const void *upcast(const void *const t) const 
          {
            const Base *b = dynamic_cast<const Base *>(static_cast<const Derived *>(t));
            return b;
          }
          void_caster_virtual_base();
          virtual ~void_caster_virtual_base();
      };
      template < typename Derived, typename Base >
      void_caster_virtual_base<Derived, Base>::void_caster_virtual_base()
        : void_caster(&type_info_implementation<Derived>::type::get_const_instance(), &type_info_implementation<Base>::type::get_const_instance())
      {
        (*this).recursive_register(true);
      }
      template < typename Derived, typename Base >
      void_caster_virtual_base<Derived, Base>::~void_caster_virtual_base()
      {
        (*this).recursive_unregister();
      }
      template < typename Derived, typename Base >
      struct  void_caster_base : ::boost::serialization::void_cast_detail::void_caster
      {
          typedef typename ::boost::mpl::eval_if< ::boost::is_virtual_base_of<Base, Derived>, ::boost::mpl::identity< ::boost::serialization::void_cast_detail::void_caster_virtual_base<Derived, Base> >, ::boost::mpl::identity< ::boost::serialization::void_cast_detail::void_caster_primitive<Derived, Base> > >::type type;
      };
    }
    template < typename Derived, typename Base >
    inline const ::boost::serialization::void_cast_detail::void_caster &void_cast_register(const Derived *, const Base *)
    {
      typedef typename ::boost::mpl::eval_if< ::boost::is_virtual_base_of<Base, Derived>, ::boost::mpl::identity< ::boost::serialization::void_cast_detail::void_caster_virtual_base<Derived, Base> >, ::boost::mpl::identity< ::boost::serialization::void_cast_detail::void_caster_primitive<Derived, Base> > >::type typex;
      return singleton<typex>::get_const_instance();
    }
    template < typename Derived, typename Base >
    class  void_caster : public ::boost::serialization::void_cast_detail::void_caster_base<Derived, Base>::type
    {
    };
  }
  namespace mpl {
    template < typename Value >
    struct  always
    {
        template < typename T, typename T2 = ::mpl_::na, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply
        {
            typedef Value type;
        };
    };
    template < typename F, typename T1 = ::mpl_::na, typename T2 = ::mpl_::na, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
    struct apply;
    template < typename F >
    struct apply0;
    template < typename F, typename T1 >
    struct apply1;
    template < typename F, typename T1, typename T2 >
    struct apply2;
    template < typename F, typename T1, typename T2, typename T3 >
    struct apply3;
    template < typename F, typename T1, typename T2, typename T3, typename T4 >
    struct apply4;
    template < typename F, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct apply5;
  }
}
namespace mpl_ {
   template < int N >
  struct arg;
}
namespace boost {
  namespace mpl {
    using ::mpl_::arg;
  }
}
namespace mpl_ {
   template <>
  struct  arg< -1>
  {
      static const int value =  -1;
      template < typename U1 = ::mpl_::na, typename U2 = ::mpl_::na, typename U3 = ::mpl_::na, typename U4 = ::mpl_::na, typename U5 = ::mpl_::na >
      struct  apply
      {
          typedef U1 type;
          enum mcc_enum_anon_72
          {
            mpl_assertion_in_line_27 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(::boost::mpl::is_na<typename ::mpl_::arg< -1>::apply<U1, U2, U3, U4, U5>::type>))0, 1)))
          };
      };
  };
  template <>
  struct  arg<1>
  {
      static const int value = 1;
      typedef ::mpl_::arg<2> next;
      template < typename U1 = ::mpl_::na, typename U2 = ::mpl_::na, typename U3 = ::mpl_::na, typename U4 = ::mpl_::na, typename U5 = ::mpl_::na >
      struct  apply
      {
          typedef U1 type;
          enum mcc_enum_anon_73
          {
            mpl_assertion_in_line_45 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(::boost::mpl::is_na<typename ::mpl_::arg<1>::apply<U1, U2, U3, U4, U5>::type>))0, 1)))
          };
      };
  };
  template <>
  struct  arg<2>
  {
      static const int value = 2;
      typedef ::mpl_::arg<3> next;
      template < typename U1 = ::mpl_::na, typename U2 = ::mpl_::na, typename U3 = ::mpl_::na, typename U4 = ::mpl_::na, typename U5 = ::mpl_::na >
      struct  apply
      {
          typedef U2 type;
          enum mcc_enum_anon_74
          {
            mpl_assertion_in_line_63 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(::boost::mpl::is_na<typename ::mpl_::arg<2>::apply<U1, U2, U3, U4, U5>::type>))0, 1)))
          };
      };
  };
  template <>
  struct  arg<3>
  {
      static const int value = 3;
      typedef ::mpl_::arg<4> next;
      template < typename U1 = ::mpl_::na, typename U2 = ::mpl_::na, typename U3 = ::mpl_::na, typename U4 = ::mpl_::na, typename U5 = ::mpl_::na >
      struct  apply
      {
          typedef U3 type;
          enum mcc_enum_anon_75
          {
            mpl_assertion_in_line_81 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(::boost::mpl::is_na<typename ::mpl_::arg<3>::apply<U1, U2, U3, U4, U5>::type>))0, 1)))
          };
      };
  };
  template <>
  struct  arg<4>
  {
      static const int value = 4;
      typedef ::mpl_::arg<5> next;
      template < typename U1 = ::mpl_::na, typename U2 = ::mpl_::na, typename U3 = ::mpl_::na, typename U4 = ::mpl_::na, typename U5 = ::mpl_::na >
      struct  apply
      {
          typedef U4 type;
          enum mcc_enum_anon_76
          {
            mpl_assertion_in_line_99 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(::boost::mpl::is_na<typename ::mpl_::arg<4>::apply<U1, U2, U3, U4, U5>::type>))0, 1)))
          };
      };
  };
  template <>
  struct  arg<5>
  {
      static const int value = 5;
      typedef ::mpl_::arg<6> next;
      template < typename U1 = ::mpl_::na, typename U2 = ::mpl_::na, typename U3 = ::mpl_::na, typename U4 = ::mpl_::na, typename U5 = ::mpl_::na >
      struct  apply
      {
          typedef U5 type;
          enum mcc_enum_anon_77
          {
            mpl_assertion_in_line_117 = sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void (*)(::boost::mpl::is_na<typename ::mpl_::arg<5>::apply<U1, U2, U3, U4, U5>::type>))0, 1)))
          };
      };
  };
  typedef ::mpl_::arg< -1> _;
}
namespace boost {
  namespace mpl {
    using ::mpl_::_;
    namespace placeholders {
      using ::mpl_::_;
    }
  }
}
namespace mpl_ {
   typedef ::mpl_::arg<1> _1;
}
namespace boost {
  namespace mpl {
    using ::mpl_::_1;
    namespace placeholders {
      using ::mpl_::_1;
    }
  }
}
namespace mpl_ {
   typedef ::mpl_::arg<2> _2;
}
namespace boost {
  namespace mpl {
    using ::mpl_::_2;
    namespace placeholders {
      using ::mpl_::_2;
    }
  }
}
namespace mpl_ {
   typedef ::mpl_::arg<3> _3;
}
namespace boost {
  namespace mpl {
    using ::mpl_::_3;
    namespace placeholders {
      using ::mpl_::_3;
    }
  }
}
namespace mpl_ {
   typedef ::mpl_::arg<4> _4;
}
namespace boost {
  namespace mpl {
    using ::mpl_::_4;
    namespace placeholders {
      using ::mpl_::_4;
    }
  }
}
namespace mpl_ {
   typedef ::mpl_::arg<5> _5;
}
namespace boost {
  namespace mpl {
    using ::mpl_::_5;
    namespace placeholders {
      using ::mpl_::_5;
    }
  }
}
namespace mpl_ {
   typedef ::mpl_::arg<6> _6;
}
namespace boost {
  namespace mpl {
    using ::mpl_::_6;
    namespace placeholders {
      using ::mpl_::_6;
    }
    template < typename F, typename T1 = ::mpl_::na, typename T2 = ::mpl_::na, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
    struct bind;
    template < typename F >
    struct bind0;
    template < typename F, typename T1 >
    struct bind1;
    template < typename F, typename T1, typename T2 >
    struct bind2;
    template < typename F, typename T1, typename T2, typename T3 >
    struct bind3;
    template < typename F, typename T1, typename T2, typename T3, typename T4 >
    struct bind4;
    template < typename F, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct bind5;
    template < typename T = ::mpl_::na >
    struct  next
    {
        typedef typename T::next type;
    };
    template < typename T = ::mpl_::na >
    struct  prior
    {
        typedef typename T::prior type;
    };
    template <>
    struct  next< ::mpl_::na>
    {
        template < typename T1, typename T2 = ::mpl_::na, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::next<T1>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::next< ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::next< ::mpl_::na> result_;
        typedef ::boost::mpl::next< ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1 >
      struct  template_arity< ::boost::mpl::next<T1> > : ::mpl_::int_<1>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::next< ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
    template <>
    struct  prior< ::mpl_::na>
    {
        template < typename T1, typename T2 = ::mpl_::na, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::prior<T1>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::prior< ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::prior< ::mpl_::na> result_;
        typedef ::boost::mpl::prior< ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1 >
      struct  template_arity< ::boost::mpl::prior<T1> > : ::mpl_::int_<1>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::prior< ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
    template < typename T = ::mpl_::na, int not_le_ = 0 >
    struct  protect : T
    {
        typedef ::boost::mpl::protect<T, not_le_> type;
    };
    template <>
    struct  protect< ::mpl_::na>
    {
        template < typename T1, typename T2 = ::mpl_::na, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::protect<T1>
        {
        };
    };
    namespace aux {
      template < typename T1 >
      struct  template_arity< ::boost::mpl::protect<T1> > : ::mpl_::int_<1>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::protect< ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
      template < typename T, typename U1, typename U2, typename U3, typename U4, typename U5 >
      struct  resolve_bind_arg
      {
          typedef T type;
      };
      template < typename T, typename Arg >
      struct  replace_unnamed_arg
      {
          typedef Arg next;
          typedef T type;
      };
      template < typename Arg >
      struct  replace_unnamed_arg< ::mpl_::arg< -1>, Arg>
      {
          typedef typename Arg::next next;
          typedef Arg type;
      };
      template < int N, typename U1, typename U2, typename U3, typename U4, typename U5 >
      struct  resolve_bind_arg< ::mpl_::arg<N>, U1, U2, U3, U4, U5>
      {
          typedef typename ::boost::mpl::apply_wrap5< ::mpl_::arg<N>, U1, U2, U3, U4, U5>::type type;
      };
      template < typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename U1, typename U2, typename U3, typename U4, typename U5 >
      struct  resolve_bind_arg< ::boost::mpl::bind<F, T1, T2, T3, T4, T5>, U1, U2, U3, U4, U5>
      {
          typedef ::boost::mpl::bind<F, T1, T2, T3, T4, T5> f_;
          typedef typename ::boost::mpl::apply_wrap5<typename ::boost::mpl::aux::resolve_bind_arg< ::boost::mpl::bind<F, T1, T2, T3, T4, T5>, U1, U2, U3, U4, U5>::f_, U1, U2, U3, U4, U5>::type type;
      };
    }
    template < typename F >
    struct  bind0
    {
        template < typename U1 = ::mpl_::na, typename U2 = ::mpl_::na, typename U3 = ::mpl_::na, typename U4 = ::mpl_::na, typename U5 = ::mpl_::na >
        struct  apply
        {
          private:
            typedef ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> > r0;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> >::type a0;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> >::next n1;
            typedef typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind0<F>::template apply<U1, U2, U3, U4, U5>::a0, U1, U2, U3, U4, U5>::type f_;
          public:
            typedef typename ::boost::mpl::apply_wrap0<typename ::boost::mpl::bind0<F>::template apply<U1, U2, U3, U4, U5>::f_>::type type;
        };
    };
    namespace aux {
      template < typename F, typename U1, typename U2, typename U3, typename U4, typename U5 >
      struct  resolve_bind_arg< ::boost::mpl::bind0<F>, U1, U2, U3, U4, U5>
      {
          typedef ::boost::mpl::bind0<F> f_;
          typedef typename ::boost::mpl::apply_wrap5<typename ::boost::mpl::aux::resolve_bind_arg< ::boost::mpl::bind0<F>, U1, U2, U3, U4, U5>::f_, U1, U2, U3, U4, U5>::type type;
      };
      template < typename T1 >
      struct  template_arity< ::boost::mpl::bind0<T1> > : ::mpl_::int_<1>
      {
      };
    }
    template < typename F >
    struct  bind<F, ::mpl_::na, ::mpl_::na, ::mpl_::na, ::mpl_::na, ::mpl_::na> : ::boost::mpl::bind0<F>
    {
    };
    template < typename F, typename T1 >
    struct  bind1
    {
        template < typename U1 = ::mpl_::na, typename U2 = ::mpl_::na, typename U3 = ::mpl_::na, typename U4 = ::mpl_::na, typename U5 = ::mpl_::na >
        struct  apply
        {
          private:
            typedef ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> > r0;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> >::type a0;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> >::next n1;
            typedef typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind1<F, T1>::template apply<U1, U2, U3, U4, U5>::a0, U1, U2, U3, U4, U5>::type f_;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind1<F, T1>::template apply<U1, U2, U3, U4, U5>::n1> r1;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind1<F, T1>::template apply<U1, U2, U3, U4, U5>::n1>::type a1;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind1<F, T1>::template apply<U1, U2, U3, U4, U5>::n1>::next n2;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind1<F, T1>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5> t1;
          public:
            typedef typename ::boost::mpl::apply_wrap1<typename ::boost::mpl::bind1<F, T1>::template apply<U1, U2, U3, U4, U5>::f_, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind1<F, T1>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5>::type>::type type;
        };
    };
    namespace aux {
      template < typename F, typename T1, typename U1, typename U2, typename U3, typename U4, typename U5 >
      struct  resolve_bind_arg< ::boost::mpl::bind1<F, T1>, U1, U2, U3, U4, U5>
      {
          typedef ::boost::mpl::bind1<F, T1> f_;
          typedef typename ::boost::mpl::apply_wrap5<typename ::boost::mpl::aux::resolve_bind_arg< ::boost::mpl::bind1<F, T1>, U1, U2, U3, U4, U5>::f_, U1, U2, U3, U4, U5>::type type;
      };
      template < typename T1, typename T2 >
      struct  template_arity< ::boost::mpl::bind1<T1, T2> > : ::mpl_::int_<2>
      {
      };
    }
    template < typename F, typename T1 >
    struct  bind<F, T1, ::mpl_::na, ::mpl_::na, ::mpl_::na, ::mpl_::na> : ::boost::mpl::bind1<F, T1>
    {
    };
    template < typename F, typename T1, typename T2 >
    struct  bind2
    {
        template < typename U1 = ::mpl_::na, typename U2 = ::mpl_::na, typename U3 = ::mpl_::na, typename U4 = ::mpl_::na, typename U5 = ::mpl_::na >
        struct  apply
        {
          private:
            typedef ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> > r0;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> >::type a0;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> >::next n1;
            typedef typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind2<F, T1, T2>::template apply<U1, U2, U3, U4, U5>::a0, U1, U2, U3, U4, U5>::type f_;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind2<F, T1, T2>::template apply<U1, U2, U3, U4, U5>::n1> r1;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind2<F, T1, T2>::template apply<U1, U2, U3, U4, U5>::n1>::type a1;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind2<F, T1, T2>::template apply<U1, U2, U3, U4, U5>::n1>::next n2;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind2<F, T1, T2>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5> t1;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind2<F, T1, T2>::template apply<U1, U2, U3, U4, U5>::n2> r2;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind2<F, T1, T2>::template apply<U1, U2, U3, U4, U5>::n2>::type a2;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind2<F, T1, T2>::template apply<U1, U2, U3, U4, U5>::n2>::next n3;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind2<F, T1, T2>::template apply<U1, U2, U3, U4, U5>::a2, U1, U2, U3, U4, U5> t2;
          public:
            typedef typename ::boost::mpl::apply_wrap2<typename ::boost::mpl::bind2<F, T1, T2>::template apply<U1, U2, U3, U4, U5>::f_, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind2<F, T1, T2>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5>::type, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind2<F, T1, T2>::template apply<U1, U2, U3, U4, U5>::a2, U1, U2, U3, U4, U5>::type>::type type;
        };
    };
    namespace aux {
      template < typename F, typename T1, typename T2, typename U1, typename U2, typename U3, typename U4, typename U5 >
      struct  resolve_bind_arg< ::boost::mpl::bind2<F, T1, T2>, U1, U2, U3, U4, U5>
      {
          typedef ::boost::mpl::bind2<F, T1, T2> f_;
          typedef typename ::boost::mpl::apply_wrap5<typename ::boost::mpl::aux::resolve_bind_arg< ::boost::mpl::bind2<F, T1, T2>, U1, U2, U3, U4, U5>::f_, U1, U2, U3, U4, U5>::type type;
      };
      template < typename T1, typename T2, typename T3 >
      struct  template_arity< ::boost::mpl::bind2<T1, T2, T3> > : ::mpl_::int_<3>
      {
      };
    }
    template < typename F, typename T1, typename T2 >
    struct  bind<F, T1, T2, ::mpl_::na, ::mpl_::na, ::mpl_::na> : ::boost::mpl::bind2<F, T1, T2>
    {
    };
    template < typename F, typename T1, typename T2, typename T3 >
    struct  bind3
    {
        template < typename U1 = ::mpl_::na, typename U2 = ::mpl_::na, typename U3 = ::mpl_::na, typename U4 = ::mpl_::na, typename U5 = ::mpl_::na >
        struct  apply
        {
          private:
            typedef ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> > r0;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> >::type a0;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> >::next n1;
            typedef typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a0, U1, U2, U3, U4, U5>::type f_;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n1> r1;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n1>::type a1;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n1>::next n2;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5> t1;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n2> r2;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n2>::type a2;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n2>::next n3;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a2, U1, U2, U3, U4, U5> t2;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n3> r3;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n3>::type a3;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n3>::next n4;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a3, U1, U2, U3, U4, U5> t3;
          public:
            typedef typename ::boost::mpl::apply_wrap3<typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::f_, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5>::type, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a2, U1, U2, U3, U4, U5>::type, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3<F, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a3, U1, U2, U3, U4, U5>::type>::type type;
        };
    };
    namespace aux {
      template < typename F, typename T1, typename T2, typename T3, typename U1, typename U2, typename U3, typename U4, typename U5 >
      struct  resolve_bind_arg< ::boost::mpl::bind3<F, T1, T2, T3>, U1, U2, U3, U4, U5>
      {
          typedef ::boost::mpl::bind3<F, T1, T2, T3> f_;
          typedef typename ::boost::mpl::apply_wrap5<typename ::boost::mpl::aux::resolve_bind_arg< ::boost::mpl::bind3<F, T1, T2, T3>, U1, U2, U3, U4, U5>::f_, U1, U2, U3, U4, U5>::type type;
      };
 /* Instantiation of class template '::mpl_::int_<4>' */ 
      template < typename T1, typename T2, typename T3, typename T4 >
      struct  template_arity< ::boost::mpl::bind3<T1, T2, T3, T4> > : ::mpl_::int_<4>
      {
      };
    }
    template < typename F, typename T1, typename T2, typename T3 >
    struct  bind<F, T1, T2, T3, ::mpl_::na, ::mpl_::na> : ::boost::mpl::bind3<F, T1, T2, T3>
    {
    };
    template < typename F, typename T1, typename T2, typename T3, typename T4 >
    struct  bind4
    {
        template < typename U1 = ::mpl_::na, typename U2 = ::mpl_::na, typename U3 = ::mpl_::na, typename U4 = ::mpl_::na, typename U5 = ::mpl_::na >
        struct  apply
        {
          private:
            typedef ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> > r0;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> >::type a0;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> >::next n1;
            typedef typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::a0, U1, U2, U3, U4, U5>::type f_;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::n1> r1;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::n1>::type a1;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::n1>::next n2;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5> t1;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::n2> r2;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::n2>::type a2;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::n2>::next n3;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::a2, U1, U2, U3, U4, U5> t2;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::n3> r3;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::n3>::type a3;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::n3>::next n4;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::a3, U1, U2, U3, U4, U5> t3;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T4, typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::n4> r4;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T4, typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::n4>::type a4;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T4, typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::n4>::next n5;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::a4, U1, U2, U3, U4, U5> t4;
          public:
            typedef typename ::boost::mpl::apply_wrap4<typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::f_, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5>::type, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::a2, U1, U2, U3, U4, U5>::type, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::a3, U1, U2, U3, U4, U5>::type, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind4<F, T1, T2, T3, T4>::template apply<U1, U2, U3, U4, U5>::a4, U1, U2, U3, U4, U5>::type>::type type;
        };
    };
    namespace aux {
      template < typename F, typename T1, typename T2, typename T3, typename T4, typename U1, typename U2, typename U3, typename U4, typename U5 >
      struct  resolve_bind_arg< ::boost::mpl::bind4<F, T1, T2, T3, T4>, U1, U2, U3, U4, U5>
      {
          typedef ::boost::mpl::bind4<F, T1, T2, T3, T4> f_;
          typedef typename ::boost::mpl::apply_wrap5<typename ::boost::mpl::aux::resolve_bind_arg< ::boost::mpl::bind4<F, T1, T2, T3, T4>, U1, U2, U3, U4, U5>::f_, U1, U2, U3, U4, U5>::type type;
      };
      template < typename T1, typename T2, typename T3, typename T4, typename T5 >
      struct  template_arity< ::boost::mpl::bind4<T1, T2, T3, T4, T5> > : ::mpl_::int_<5>
      {
      };
    }
    template < typename F, typename T1, typename T2, typename T3, typename T4 >
    struct  bind<F, T1, T2, T3, T4, ::mpl_::na> : ::boost::mpl::bind4<F, T1, T2, T3, T4>
    {
    };
    template < typename F, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct  bind5
    {
        template < typename U1 = ::mpl_::na, typename U2 = ::mpl_::na, typename U3 = ::mpl_::na, typename U4 = ::mpl_::na, typename U5 = ::mpl_::na >
        struct  apply
        {
          private:
            typedef ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> > r0;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> >::type a0;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<F, ::mpl_::arg<1> >::next n1;
            typedef typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::a0, U1, U2, U3, U4, U5>::type f_;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n1> r1;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n1>::type a1;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T1, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n1>::next n2;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5> t1;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n2> r2;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n2>::type a2;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n2>::next n3;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::a2, U1, U2, U3, U4, U5> t2;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n3> r3;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n3>::type a3;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n3>::next n4;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::a3, U1, U2, U3, U4, U5> t3;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T4, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n4> r4;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T4, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n4>::type a4;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T4, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n4>::next n5;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::a4, U1, U2, U3, U4, U5> t4;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T5, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n5> r5;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T5, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n5>::type a5;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T5, typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::n5>::next n6;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::a5, U1, U2, U3, U4, U5> t5;
          public:
            typedef typename ::boost::mpl::apply_wrap5<typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::f_, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5>::type, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::a2, U1, U2, U3, U4, U5>::type, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::a3, U1, U2, U3, U4, U5>::type, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::a4, U1, U2, U3, U4, U5>::type, typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>::template apply<U1, U2, U3, U4, U5>::a5, U1, U2, U3, U4, U5>::type>::type type;
        };
    };
    namespace aux {
      template < typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename U1, typename U2, typename U3, typename U4, typename U5 >
      struct  resolve_bind_arg< ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>, U1, U2, U3, U4, U5>
      {
          typedef ::boost::mpl::bind5<F, T1, T2, T3, T4, T5> f_;
          typedef typename ::boost::mpl::apply_wrap5<typename ::boost::mpl::aux::resolve_bind_arg< ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>, U1, U2, U3, U4, U5>::f_, U1, U2, U3, U4, U5>::type type;
      };
 /* Instantiation of class template '::mpl_::int_<6>' */ 
      template < typename T1, typename T2, typename T3, typename T4, typename T5, typename T6 >
      struct  template_arity< ::boost::mpl::bind5<T1, T2, T3, T4, T5, T6> > : ::mpl_::int_<6>
      {
      };
    }
    template < typename F, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct  bind : ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>
    {
    };
    template <     template < typename T1, typename T2, typename T3 > class F, typename Tag >
    struct quote3;
    template < typename T1, typename T2, typename T3 >
    struct if_;
    template < typename Tag, typename T1, typename T2, typename T3 >
    struct  bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>
    {
        template < typename U1 = ::mpl_::na, typename U2 = ::mpl_::na, typename U3 = ::mpl_::na, typename U4 = ::mpl_::na, typename U5 = ::mpl_::na >
        struct  apply
        {
          private:
            typedef ::mpl_::arg<1> n1;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T1, ::mpl_::arg<1> > r1;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T1, ::mpl_::arg<1> >::type a1;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T1, ::mpl_::arg<1> >::next n2;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5> t1;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n2> r2;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n2>::type a2;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n2>::next n3;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a2, U1, U2, U3, U4, U5> t2;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n3> r3;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n3>::type a3;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n3>::next n4;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a3, U1, U2, U3, U4, U5> t3;
            typedef typename ::boost::mpl::if_<typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5>::type, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::t2, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::t3>::type f_;
          public:
            typedef typename ::boost::mpl::if_<typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5>::type, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::t2, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::if_, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::t3>::type::type type;
        };
    };
    template <     template < typename T1, typename T2, typename T3 > class F, typename Tag >
    struct quote3;
    template < typename T1, typename T2, typename T3 >
    struct eval_if;
    template < typename Tag, typename T1, typename T2, typename T3 >
    struct  bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>
    {
        template < typename U1 = ::mpl_::na, typename U2 = ::mpl_::na, typename U3 = ::mpl_::na, typename U4 = ::mpl_::na, typename U5 = ::mpl_::na >
        struct  apply
        {
          private:
            typedef ::mpl_::arg<1> n1;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T1, ::mpl_::arg<1> > r1;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T1, ::mpl_::arg<1> >::type a1;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T1, ::mpl_::arg<1> >::next n2;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5> t1;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n2> r2;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n2>::type a2;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T2, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n2>::next n3;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a2, U1, U2, U3, U4, U5> t2;
            typedef ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n3> r3;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n3>::type a3;
            typedef typename ::boost::mpl::aux::replace_unnamed_arg<T3, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::n3>::next n4;
            typedef ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a3, U1, U2, U3, U4, U5> t3;
            typedef typename ::boost::mpl::eval_if<typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5>::type, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::t2, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::t3>::type f_;
          public:
            typedef typename ::boost::mpl::eval_if<typename ::boost::mpl::aux::resolve_bind_arg<typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::a1, U1, U2, U3, U4, U5>::type, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::t2, typename ::boost::mpl::bind3< ::boost::mpl::quote3< ::boost::mpl::eval_if, Tag>, T1, T2, T3>::template apply<U1, U2, U3, U4, U5>::t3>::type::type type;
        };
    };
    namespace aux {
      template < typename T, typename fallback_ = ::mpl_::bool_<true> >
      struct  has_type
      {
          struct  gcc_3_2_wknd
          {
              template < typename U >
              static ::boost::mpl::aux::yes_tag test(const volatile ::boost::mpl::aux::type_wrapper<U> *, ::boost::mpl::aux::type_wrapper<typename U::type> *  = (0));
              static ::boost::mpl::aux::no_tag test(...);
          };
          typedef ::boost::mpl::aux::type_wrapper<T> t_;
          static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<typename ::boost::mpl::aux::has_type<T, fallback_>::t_ *>(0))) == sizeof(::boost::mpl::aux::yes_tag);
          typedef ::mpl_::bool_< ::boost::mpl::aux::has_type<T, fallback_>::value> type;
      };
    }
    template < typename T, bool has_type_ >
    struct  quote_impl
    {
        typedef typename T::type type;
    };
    template < typename T >
    struct  quote_impl<T, false>
    {
        typedef T type;
    };
    template <     template < typename P1 > class F, typename Tag = ::mpl_::void_ >
    struct  quote1
    {
        template < typename U1 >
        struct  apply : ::boost::mpl::quote_impl<F<U1>, aux::has_type<F<U1> >::value>
        {
        };
    };
    template <     template < typename P1, typename P2 > class F, typename Tag = ::mpl_::void_ >
    struct  quote2
    {
        template < typename U1, typename U2 >
        struct  apply : ::boost::mpl::quote_impl<F<U1, U2>, aux::has_type<F<U1, U2> >::value>
        {
        };
    };
    template <     template < typename P1, typename P2, typename P3 > class F, typename Tag = ::mpl_::void_ >
    struct  quote3
    {
        template < typename U1, typename U2, typename U3 >
        struct  apply : ::boost::mpl::quote_impl<F<U1, U2, U3>, aux::has_type<F<U1, U2, U3> >::value>
        {
        };
    };
    template <     template < typename P1, typename P2, typename P3, typename P4 > class F, typename Tag = ::mpl_::void_ >
    struct  quote4
    {
        template < typename U1, typename U2, typename U3, typename U4 >
        struct  apply : ::boost::mpl::quote_impl<F<U1, U2, U3, U4>, aux::has_type<F<U1, U2, U3, U4> >::value>
        {
        };
    };
    template <     template < typename P1, typename P2, typename P3, typename P4, typename P5 > class F, typename Tag = ::mpl_::void_ >
    struct  quote5
    {
        template < typename U1, typename U2, typename U3, typename U4, typename U5 >
        struct  apply : ::boost::mpl::quote_impl<F<U1, U2, U3, U4, U5>, aux::has_type<F<U1, U2, U3, U4, U5> >::value>
        {
        };
    };
    namespace aux {
      template < int N >
      struct  arity_tag
      {
          typedef char (&type)[N + 1];
      };
      template < int C1, int C2, int C3, int C4, int C5, int C6 >
      struct  max_arity
      {
          static const int value = C6 > 0 ? C6 : C5 > 0 ? C5 : C4 > 0 ? C4 : C3 > 0 ? C3 : C2 > 0 ? C2 : C1 > 0 ? C1 :  -1;
      };
 /* Instantiation of class template '::boost::mpl::aux::arity_tag<0>' */ 
      ::boost::mpl::aux::arity_tag<0>::type arity_helper(...);
 /* Instantiation of class template '::boost::mpl::aux::arity_tag<1>' */ 
      template <       template < typename P1 > class F, typename T1 >
      ::boost::mpl::aux::arity_tag<1>::type arity_helper(::boost::mpl::aux::type_wrapper<F<T1> >, ::boost::mpl::aux::arity_tag<1>);
 /* Instantiation of class template '::boost::mpl::aux::arity_tag<2>' */ 
      template <       template < typename P1, typename P2 > class F, typename T1, typename T2 >
      ::boost::mpl::aux::arity_tag<2>::type arity_helper(::boost::mpl::aux::type_wrapper<F<T1, T2> >, ::boost::mpl::aux::arity_tag<2>);
 /* Instantiation of class template '::boost::mpl::aux::arity_tag<3>' */ 
      template <       template < typename P1, typename P2, typename P3 > class F, typename T1, typename T2, typename T3 >
      ::boost::mpl::aux::arity_tag<3>::type arity_helper(::boost::mpl::aux::type_wrapper<F<T1, T2, T3> >, ::boost::mpl::aux::arity_tag<3>);
 /* Instantiation of class template '::boost::mpl::aux::arity_tag<4>' */ 
      template <       template < typename P1, typename P2, typename P3, typename P4 > class F, typename T1, typename T2, typename T3, typename T4 >
      ::boost::mpl::aux::arity_tag<4>::type arity_helper(::boost::mpl::aux::type_wrapper<F<T1, T2, T3, T4> >, ::boost::mpl::aux::arity_tag<4>);
 /* Instantiation of class template '::boost::mpl::aux::arity_tag<5>' */ 
      template <       template < typename P1, typename P2, typename P3, typename P4, typename P5 > class F, typename T1, typename T2, typename T3, typename T4, typename T5 >
      ::boost::mpl::aux::arity_tag<5>::type arity_helper(::boost::mpl::aux::type_wrapper<F<T1, T2, T3, T4, T5> >, ::boost::mpl::aux::arity_tag<5>);
 /* Instantiation of class template '::boost::mpl::aux::arity_tag<6>' */ 
      template <       template < typename P1, typename P2, typename P3, typename P4, typename P5, typename P6 > class F, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6 >
      ::boost::mpl::aux::arity_tag<6>::type arity_helper(::boost::mpl::aux::type_wrapper<F<T1, T2, T3, T4, T5, T6> >, ::boost::mpl::aux::arity_tag<6>);
      template < typename F, int N >
      struct  template_arity_impl
      {
          static const int value = sizeof(::boost::mpl::aux::arity_helper(::boost::mpl::aux::type_wrapper<F>(), ::boost::mpl::aux::arity_tag<N>())) - 1;
      };
      template < typename F >
      struct  template_arity
      {
          static const int value = max_arity<template_arity_impl<F, 1>::value, template_arity_impl<F, 2>::value, template_arity_impl<F, 3>::value, template_arity_impl<F, 4>::value, template_arity_impl<F, 5>::value, template_arity_impl<F, 6>::value>::value;
          typedef ::mpl_::int_< ::boost::mpl::aux::template_arity<F>::value> type;
      };
      template < bool C1 = false, bool C2 = false, bool C3 = false, bool C4 = false, bool C5 = false >
      struct  lambda_or : ::mpl_::bool_<true>
      {
      };
      template <>
      struct  lambda_or<false, false, false, false, false> : ::mpl_::bool_<false>
      {
      };
    }
    template < typename T, typename Tag, typename Arity >
    struct  lambda
    {
        typedef ::mpl_::false_ is_le;
        typedef T result_;
        typedef T type;
    };
    template < typename T >
    struct  is_lambda_expression : ::boost::mpl::lambda<T>::is_le
    {
    };
    template < int N, typename Tag >
    struct  lambda< ::mpl_::arg<N>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::true_ is_le;
        typedef ::mpl_::arg<N> result_;
        typedef ::boost::mpl::protect<typename ::boost::mpl::lambda< ::mpl_::arg<N>, Tag, ::mpl_::int_< -1> >::result_> type;
    };
    template < typename F, typename Tag >
    struct  lambda< ::boost::mpl::bind0<F>, Tag, ::mpl_::int_<1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::bind0<F> result_;
        typedef typename ::boost::mpl::lambda< ::boost::mpl::bind0<F>, Tag, ::mpl_::int_<1> >::result_ type;
    };
    namespace aux {
      template < typename IsLE, typename Tag,       template < typename P1 > class F, typename L1 >
      struct  le_result1
      {
          typedef F<typename L1::type> result_;
          typedef typename ::boost::mpl::aux::le_result1<IsLE, Tag, F, L1>::result_ type;
      };
      template < typename Tag,       template < typename P1 > class F, typename L1 >
      struct  le_result1< ::mpl_::bool_<true>, Tag, F, L1>
      {
          typedef ::boost::mpl::bind1< ::boost::mpl::quote1<F, Tag>, typename L1::result_> result_;
          typedef ::boost::mpl::protect<typename ::boost::mpl::aux::le_result1< ::mpl_::bool_<true>, Tag, F, L1>::result_> type;
      };
    }
    template <     template < typename P1 > class F, typename T1, typename Tag >
    struct  lambda<F<T1>, Tag, ::mpl_::int_<1> >
    {
        typedef ::boost::mpl::lambda<T1, Tag> l1;
        typedef typename ::boost::mpl::lambda<T1, Tag>::is_le is_le1;
        typedef typename ::boost::mpl::aux::lambda_or<is_le1::value>::type is_le;
        typedef ::boost::mpl::aux::le_result1<typename ::boost::mpl::lambda<F<T1>, Tag, ::mpl_::int_<1> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1>, Tag, ::mpl_::int_<1> >::l1> le_result_;
        typedef typename ::boost::mpl::aux::le_result1<typename ::boost::mpl::lambda<F<T1>, Tag, ::mpl_::int_<1> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1>, Tag, ::mpl_::int_<1> >::l1>::result_ result_;
        typedef typename ::boost::mpl::aux::le_result1<typename ::boost::mpl::lambda<F<T1>, Tag, ::mpl_::int_<1> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1>, Tag, ::mpl_::int_<1> >::l1>::type type;
    };
    template < typename F, typename T1, typename Tag >
    struct  lambda< ::boost::mpl::bind1<F, T1>, Tag, ::mpl_::int_<2> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::bind1<F, T1> result_;
        typedef typename ::boost::mpl::lambda< ::boost::mpl::bind1<F, T1>, Tag, ::mpl_::int_<2> >::result_ type;
    };
    namespace aux {
      template < typename IsLE, typename Tag,       template < typename P1, typename P2 > class F, typename L1, typename L2 >
      struct  le_result2
      {
          typedef F<typename L1::type, typename L2::type> result_;
          typedef typename ::boost::mpl::aux::le_result2<IsLE, Tag, F, L1, L2>::result_ type;
      };
      template < typename Tag,       template < typename P1, typename P2 > class F, typename L1, typename L2 >
      struct  le_result2< ::mpl_::bool_<true>, Tag, F, L1, L2>
      {
          typedef ::boost::mpl::bind2< ::boost::mpl::quote2<F, Tag>, typename L1::result_, typename L2::result_> result_;
          typedef ::boost::mpl::protect<typename ::boost::mpl::aux::le_result2< ::mpl_::bool_<true>, Tag, F, L1, L2>::result_> type;
      };
    }
    template <     template < typename P1, typename P2 > class F, typename T1, typename T2, typename Tag >
    struct  lambda<F<T1, T2>, Tag, ::mpl_::int_<2> >
    {
        typedef ::boost::mpl::lambda<T1, Tag> l1;
        typedef ::boost::mpl::lambda<T2, Tag> l2;
        typedef typename ::boost::mpl::lambda<T1, Tag>::is_le is_le1;
        typedef typename ::boost::mpl::lambda<T2, Tag>::is_le is_le2;
        typedef typename ::boost::mpl::aux::lambda_or<is_le1::value, is_le2::value>::type is_le;
        typedef ::boost::mpl::aux::le_result2<typename ::boost::mpl::lambda<F<T1, T2>, Tag, ::mpl_::int_<2> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1, T2>, Tag, ::mpl_::int_<2> >::l1, typename ::boost::mpl::lambda<F<T1, T2>, Tag, ::mpl_::int_<2> >::l2> le_result_;
        typedef typename ::boost::mpl::aux::le_result2<typename ::boost::mpl::lambda<F<T1, T2>, Tag, ::mpl_::int_<2> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1, T2>, Tag, ::mpl_::int_<2> >::l1, typename ::boost::mpl::lambda<F<T1, T2>, Tag, ::mpl_::int_<2> >::l2>::result_ result_;
        typedef typename ::boost::mpl::aux::le_result2<typename ::boost::mpl::lambda<F<T1, T2>, Tag, ::mpl_::int_<2> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1, T2>, Tag, ::mpl_::int_<2> >::l1, typename ::boost::mpl::lambda<F<T1, T2>, Tag, ::mpl_::int_<2> >::l2>::type type;
    };
    template < typename F, typename T1, typename T2, typename Tag >
    struct  lambda< ::boost::mpl::bind2<F, T1, T2>, Tag, ::mpl_::int_<3> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::bind2<F, T1, T2> result_;
        typedef typename ::boost::mpl::lambda< ::boost::mpl::bind2<F, T1, T2>, Tag, ::mpl_::int_<3> >::result_ type;
    };
    namespace aux {
      template < typename IsLE, typename Tag,       template < typename P1, typename P2, typename P3 > class F, typename L1, typename L2, typename L3 >
      struct  le_result3
      {
          typedef F<typename L1::type, typename L2::type, typename L3::type> result_;
          typedef typename ::boost::mpl::aux::le_result3<IsLE, Tag, F, L1, L2, L3>::result_ type;
      };
      template < typename Tag,       template < typename P1, typename P2, typename P3 > class F, typename L1, typename L2, typename L3 >
      struct  le_result3< ::mpl_::bool_<true>, Tag, F, L1, L2, L3>
      {
          typedef ::boost::mpl::bind3< ::boost::mpl::quote3<F, Tag>, typename L1::result_, typename L2::result_, typename L3::result_> result_;
          typedef ::boost::mpl::protect<typename ::boost::mpl::aux::le_result3< ::mpl_::bool_<true>, Tag, F, L1, L2, L3>::result_> type;
      };
    }
    template <     template < typename P1, typename P2, typename P3 > class F, typename T1, typename T2, typename T3, typename Tag >
    struct  lambda<F<T1, T2, T3>, Tag, ::mpl_::int_<3> >
    {
        typedef ::boost::mpl::lambda<T1, Tag> l1;
        typedef ::boost::mpl::lambda<T2, Tag> l2;
        typedef ::boost::mpl::lambda<T3, Tag> l3;
        typedef typename ::boost::mpl::lambda<T1, Tag>::is_le is_le1;
        typedef typename ::boost::mpl::lambda<T2, Tag>::is_le is_le2;
        typedef typename ::boost::mpl::lambda<T3, Tag>::is_le is_le3;
        typedef typename ::boost::mpl::aux::lambda_or<is_le1::value, is_le2::value, is_le3::value>::type is_le;
        typedef ::boost::mpl::aux::le_result3<typename ::boost::mpl::lambda<F<T1, T2, T3>, Tag, ::mpl_::int_<3> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1, T2, T3>, Tag, ::mpl_::int_<3> >::l1, typename ::boost::mpl::lambda<F<T1, T2, T3>, Tag, ::mpl_::int_<3> >::l2, typename ::boost::mpl::lambda<F<T1, T2, T3>, Tag, ::mpl_::int_<3> >::l3> le_result_;
        typedef typename ::boost::mpl::aux::le_result3<typename ::boost::mpl::lambda<F<T1, T2, T3>, Tag, ::mpl_::int_<3> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1, T2, T3>, Tag, ::mpl_::int_<3> >::l1, typename ::boost::mpl::lambda<F<T1, T2, T3>, Tag, ::mpl_::int_<3> >::l2, typename ::boost::mpl::lambda<F<T1, T2, T3>, Tag, ::mpl_::int_<3> >::l3>::result_ result_;
        typedef typename ::boost::mpl::aux::le_result3<typename ::boost::mpl::lambda<F<T1, T2, T3>, Tag, ::mpl_::int_<3> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1, T2, T3>, Tag, ::mpl_::int_<3> >::l1, typename ::boost::mpl::lambda<F<T1, T2, T3>, Tag, ::mpl_::int_<3> >::l2, typename ::boost::mpl::lambda<F<T1, T2, T3>, Tag, ::mpl_::int_<3> >::l3>::type type;
    };
    template < typename F, typename T1, typename T2, typename T3, typename Tag >
    struct  lambda< ::boost::mpl::bind3<F, T1, T2, T3>, Tag, ::mpl_::int_<4> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::bind3<F, T1, T2, T3> result_;
        typedef typename ::boost::mpl::lambda< ::boost::mpl::bind3<F, T1, T2, T3>, Tag, ::mpl_::int_<4> >::result_ type;
    };
    namespace aux {
      template < typename IsLE, typename Tag,       template < typename P1, typename P2, typename P3, typename P4 > class F, typename L1, typename L2, typename L3, typename L4 >
      struct  le_result4
      {
          typedef F<typename L1::type, typename L2::type, typename L3::type, typename L4::type> result_;
          typedef typename ::boost::mpl::aux::le_result4<IsLE, Tag, F, L1, L2, L3, L4>::result_ type;
      };
      template < typename Tag,       template < typename P1, typename P2, typename P3, typename P4 > class F, typename L1, typename L2, typename L3, typename L4 >
      struct  le_result4< ::mpl_::bool_<true>, Tag, F, L1, L2, L3, L4>
      {
          typedef ::boost::mpl::bind4< ::boost::mpl::quote4<F, Tag>, typename L1::result_, typename L2::result_, typename L3::result_, typename L4::result_> result_;
          typedef ::boost::mpl::protect<typename ::boost::mpl::aux::le_result4< ::mpl_::bool_<true>, Tag, F, L1, L2, L3, L4>::result_> type;
      };
    }
    template <     template < typename P1, typename P2, typename P3, typename P4 > class F, typename T1, typename T2, typename T3, typename T4, typename Tag >
    struct  lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >
    {
        typedef ::boost::mpl::lambda<T1, Tag> l1;
        typedef ::boost::mpl::lambda<T2, Tag> l2;
        typedef ::boost::mpl::lambda<T3, Tag> l3;
        typedef ::boost::mpl::lambda<T4, Tag> l4;
        typedef typename ::boost::mpl::lambda<T1, Tag>::is_le is_le1;
        typedef typename ::boost::mpl::lambda<T2, Tag>::is_le is_le2;
        typedef typename ::boost::mpl::lambda<T3, Tag>::is_le is_le3;
        typedef typename ::boost::mpl::lambda<T4, Tag>::is_le is_le4;
        typedef typename ::boost::mpl::aux::lambda_or<is_le1::value, is_le2::value, is_le3::value, is_le4::value>::type is_le;
        typedef ::boost::mpl::aux::le_result4<typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::l1, typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::l2, typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::l3, typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::l4> le_result_;
        typedef typename ::boost::mpl::aux::le_result4<typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::l1, typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::l2, typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::l3, typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::l4>::result_ result_;
        typedef typename ::boost::mpl::aux::le_result4<typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::l1, typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::l2, typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::l3, typename ::boost::mpl::lambda<F<T1, T2, T3, T4>, Tag, ::mpl_::int_<4> >::l4>::type type;
    };
    template < typename F, typename T1, typename T2, typename T3, typename T4, typename Tag >
    struct  lambda< ::boost::mpl::bind4<F, T1, T2, T3, T4>, Tag, ::mpl_::int_<5> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::bind4<F, T1, T2, T3, T4> result_;
        typedef typename ::boost::mpl::lambda< ::boost::mpl::bind4<F, T1, T2, T3, T4>, Tag, ::mpl_::int_<5> >::result_ type;
    };
    namespace aux {
      template < typename IsLE, typename Tag,       template < typename P1, typename P2, typename P3, typename P4, typename P5 > class F, typename L1, typename L2, typename L3, typename L4, typename L5 >
      struct  le_result5
      {
          typedef F<typename L1::type, typename L2::type, typename L3::type, typename L4::type, typename L5::type> result_;
          typedef typename ::boost::mpl::aux::le_result5<IsLE, Tag, F, L1, L2, L3, L4, L5>::result_ type;
      };
      template < typename Tag,       template < typename P1, typename P2, typename P3, typename P4, typename P5 > class F, typename L1, typename L2, typename L3, typename L4, typename L5 >
      struct  le_result5< ::mpl_::bool_<true>, Tag, F, L1, L2, L3, L4, L5>
      {
          typedef ::boost::mpl::bind5< ::boost::mpl::quote5<F, Tag>, typename L1::result_, typename L2::result_, typename L3::result_, typename L4::result_, typename L5::result_> result_;
          typedef ::boost::mpl::protect<typename ::boost::mpl::aux::le_result5< ::mpl_::bool_<true>, Tag, F, L1, L2, L3, L4, L5>::result_> type;
      };
    }
    template <     template < typename P1, typename P2, typename P3, typename P4, typename P5 > class F, typename T1, typename T2, typename T3, typename T4, typename T5, typename Tag >
    struct  lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >
    {
        typedef ::boost::mpl::lambda<T1, Tag> l1;
        typedef ::boost::mpl::lambda<T2, Tag> l2;
        typedef ::boost::mpl::lambda<T3, Tag> l3;
        typedef ::boost::mpl::lambda<T4, Tag> l4;
        typedef ::boost::mpl::lambda<T5, Tag> l5;
        typedef typename ::boost::mpl::lambda<T1, Tag>::is_le is_le1;
        typedef typename ::boost::mpl::lambda<T2, Tag>::is_le is_le2;
        typedef typename ::boost::mpl::lambda<T3, Tag>::is_le is_le3;
        typedef typename ::boost::mpl::lambda<T4, Tag>::is_le is_le4;
        typedef typename ::boost::mpl::lambda<T5, Tag>::is_le is_le5;
        typedef typename ::boost::mpl::aux::lambda_or<is_le1::value, is_le2::value, is_le3::value, is_le4::value, is_le5::value>::type is_le;
        typedef ::boost::mpl::aux::le_result5<typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l1, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l2, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l3, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l4, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l5> le_result_;
        typedef typename ::boost::mpl::aux::le_result5<typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l1, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l2, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l3, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l4, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l5>::result_ result_;
        typedef typename ::boost::mpl::aux::le_result5<typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::is_le, Tag, F, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l1, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l2, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l3, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l4, typename ::boost::mpl::lambda<F<T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<5> >::l5>::type type;
    };
    template < typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename Tag >
    struct  lambda< ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<6> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::bind5<F, T1, T2, T3, T4, T5> result_;
        typedef typename ::boost::mpl::lambda< ::boost::mpl::bind5<F, T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<6> >::result_ type;
    };
    template < typename T, typename Tag >
    struct  lambda< ::boost::mpl::protect<T>, Tag, ::mpl_::int_<1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::protect<T> result_;
        typedef typename ::boost::mpl::lambda< ::boost::mpl::protect<T>, Tag, ::mpl_::int_<1> >::result_ type;
    };
    template < typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename Tag >
    struct  lambda< ::boost::mpl::bind<F, T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<6> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::bind<F, T1, T2, T3, T4, T5> result_;
        typedef typename ::boost::mpl::lambda< ::boost::mpl::bind<F, T1, T2, T3, T4, T5>, Tag, ::mpl_::int_<6> >::result_ type;
    };
    template < typename F, typename Tag1, typename Tag2, typename Arity >
    struct  lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >
    {
        typedef ::boost::mpl::lambda<F, Tag2> l1;
        typedef ::boost::mpl::lambda<Tag1, Tag2> l2;
        typedef typename ::boost::mpl::lambda<F, Tag2>::is_le is_le;
        typedef ::boost::mpl::bind1< ::boost::mpl::quote1< ::boost::mpl::aux::template_arity>, typename ::boost::mpl::lambda<F, Tag2>::result_> arity_;
        typedef ::boost::mpl::lambda<typename ::boost::mpl::if_<typename ::boost::mpl::lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >::is_le, typename ::boost::mpl::lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >::arity_, Arity>::type, Tag2> l3;
        typedef ::boost::mpl::aux::le_result3<typename ::boost::mpl::lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >::is_le, Tag2, ::boost::mpl::lambda, typename ::boost::mpl::lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >::l1, typename ::boost::mpl::lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >::l2, typename ::boost::mpl::lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >::l3> le_result_;
        typedef typename ::boost::mpl::aux::le_result3<typename ::boost::mpl::lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >::is_le, Tag2, ::boost::mpl::lambda, typename ::boost::mpl::lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >::l1, typename ::boost::mpl::lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >::l2, typename ::boost::mpl::lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >::l3>::result_ result_;
        typedef typename ::boost::mpl::aux::le_result3<typename ::boost::mpl::lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >::is_le, Tag2, ::boost::mpl::lambda, typename ::boost::mpl::lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >::l1, typename ::boost::mpl::lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >::l2, typename ::boost::mpl::lambda< ::boost::mpl::lambda<F, Tag1, Arity>, Tag2, ::mpl_::int_<3> >::l3>::type type;
    };
 /* Instantiation of class template '::boost::mpl::aux::type_wrapper< ::mpl_::na>' */ 
 /* Instantiation of class template '::boost::mpl::aux::template_arity_impl< ::mpl_::na, 1>' */ 
 /* Instantiation of class template '::boost::mpl::aux::template_arity_impl< ::mpl_::na, 2>' */ 
 /* Instantiation of class template '::boost::mpl::aux::template_arity_impl< ::mpl_::na, 3>' */ 
 /* Instantiation of class template '::boost::mpl::aux::template_arity_impl< ::mpl_::na, 4>' */ 
 /* Instantiation of class template '::boost::mpl::aux::template_arity_impl< ::mpl_::na, 5>' */ 
 /* Instantiation of class template '::boost::mpl::aux::template_arity_impl< ::mpl_::na, 6>' */ 
 /* Instantiation of class template '::boost::mpl::aux::max_arity<0, 0, 0, 0, 0, 0>' */ 
 /* Instantiation of class template '::boost::mpl::aux::template_arity< ::mpl_::na>' */ 
    template <>
    struct  lambda< ::mpl_::na, ::mpl_::na>
    {
        template < typename T1, typename T2, typename T3 = ::mpl_::na, typename T4 = ::mpl_::na, typename T5 = ::mpl_::na >
        struct  apply : ::boost::mpl::lambda<T1, T2>
        {
        };
    };
    template < typename Tag >
    struct  lambda< ::boost::mpl::lambda< ::mpl_::na, ::mpl_::na>, Tag, ::mpl_::int_< -1> >
    {
        typedef ::mpl_::false_ is_le;
        typedef ::boost::mpl::lambda< ::mpl_::na, ::mpl_::na> result_;
        typedef ::boost::mpl::lambda< ::mpl_::na, ::mpl_::na> type;
    };
    namespace aux {
      template < typename T1, typename T2, typename T3 >
      struct  template_arity< ::boost::mpl::lambda<T1, T2, T3> > : ::mpl_::int_<3>
      {
      };
      template <>
      struct  template_arity< ::boost::mpl::lambda< ::mpl_::na, ::mpl_::na> > : ::mpl_::int_< -1>
      {
      };
    }
    template < typename F >
    struct  apply0 : ::boost::mpl::apply_wrap0<typename ::boost::mpl::lambda<F>::type>
    {
    };
    template < typename F >
    struct  apply<F, ::mpl_::na, ::mpl_::na, ::mpl_::na, ::mpl_::na, ::mpl_::na> : ::boost::mpl::apply0<F>
    {
    };
    template < typename F, typename T1 >
    struct  apply1 : ::boost::mpl::apply_wrap1<typename ::boost::mpl::lambda<F>::type, T1>
    {
    };
    template < typename F, typename T1 >
    struct  apply<F, T1, ::mpl_::na, ::mpl_::na, ::mpl_::na, ::mpl_::na> : ::boost::mpl::apply1<F, T1>
    {
    };
    template < typename F, typename T1, typename T2 >
    struct  apply2 : ::boost::mpl::apply_wrap2<typename ::boost::mpl::lambda<F>::type, T1, T2>
    {
    };
    template < typename F, typename T1, typename T2 >
    struct  apply<F, T1, T2, ::mpl_::na, ::mpl_::na, ::mpl_::na> : ::boost::mpl::apply2<F, T1, T2>
    {
    };
    template < typename F, typename T1, typename T2, typename T3 >
    struct  apply3 : ::boost::mpl::apply_wrap3<typename ::boost::mpl::lambda<F>::type, T1, T2, T3>
    {
    };
    template < typename F, typename T1, typename T2, typename T3 >
    struct  apply<F, T1, T2, T3, ::mpl_::na, ::mpl_::na> : ::boost::mpl::apply3<F, T1, T2, T3>
    {
    };
    template < typename F, typename T1, typename T2, typename T3, typename T4 >
    struct  apply4 : ::boost::mpl::apply_wrap4<typename ::boost::mpl::lambda<F>::type, T1, T2, T3, T4>
    {
    };
    template < typename F, typename T1, typename T2, typename T3, typename T4 >
    struct  apply<F, T1, T2, T3, T4, ::mpl_::na> : ::boost::mpl::apply4<F, T1, T2, T3, T4>
    {
    };
    template < typename F, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct  apply5 : ::boost::mpl::apply_wrap5<typename ::boost::mpl::lambda<F>::type, T1, T2, T3, T4, T5>
    {
    };
    template < typename F, typename T1, typename T2, typename T3, typename T4, typename T5 >
    struct  apply : ::boost::mpl::apply5<F, T1, T2, T3, T4, T5>
    {
    };
  }
}
namespace std __attribute__((__visibility__("default"))) {
   template < typename _IIter, typename _Predicate >
  inline bool all_of(_IIter __first, _IIter __last, _Predicate __pred);
  template < typename _IIter, typename _Predicate >
  inline bool any_of(_IIter __first, _IIter __last, _Predicate __pred);
  template < typename _FIter, typename _Tp >
  bool binary_search(_FIter __first, _FIter __last, const _Tp &__val);
  template < typename _FIter, typename _Tp, typename _Compare >
  bool binary_search(_FIter __first, _FIter __last, const _Tp &__val, _Compare __comp);
  template < typename _IIter, typename _OIter, typename _Predicate >
  _OIter copy_if(_IIter __first, _IIter __last, _OIter __result, _Predicate __pred);
  template < typename _IIter, typename _Size, typename _OIter >
  inline _OIter copy_n(_IIter __first, _Size __n, _OIter __result);
  template < typename _FIter, typename _Tp >
  ::std::pair<_FIter, _FIter> equal_range(_FIter __first, _FIter __last, const _Tp &__val);
  template < typename _FIter, typename _Tp, typename _Compare >
  ::std::pair<_FIter, _FIter> equal_range(_FIter __first, _FIter __last, const _Tp &__val, _Compare __comp);
  template < typename _FIter1, typename _FIter2 >
  inline _FIter1 find_end(_FIter1 __first1, _FIter1 __last1, _FIter2 __first2, _FIter2 __last2);
  template < typename _FIter1, typename _FIter2, typename _BinaryPredicate >
  inline _FIter1 find_end(_FIter1 __first1, _FIter1 __last1, _FIter2 __first2, _FIter2 __last2, _BinaryPredicate __comp);
  template < typename _IIter, typename _Predicate >
  inline _IIter find_if_not(_IIter __first, _IIter __last, _Predicate __pred);
  template < typename _IIter1, typename _IIter2 >
  bool includes(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2);
  template < typename _IIter1, typename _IIter2, typename _Compare >
  bool includes(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _Compare __comp);
  template < typename _BIter >
  void inplace_merge(_BIter __first, _BIter __middle, _BIter __last);
  template < typename _BIter, typename _Compare >
  void inplace_merge(_BIter __first, _BIter __middle, _BIter __last, _Compare __comp);
  template < typename _RAIter >
  inline bool is_heap(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  inline bool is_heap(_RAIter __first, _RAIter __last, _Compare __comp);
  template < typename _RAIter >
  inline _RAIter is_heap_until(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  inline _RAIter is_heap_until(_RAIter __first, _RAIter __last, _Compare __comp);
  template < typename _IIter, typename _Predicate >
  inline bool is_partitioned(_IIter __first, _IIter __last, _Predicate __pred);
  template < typename _FIter1, typename _FIter2 >
  bool is_permutation(_FIter1 __first1, _FIter1 __last1, _FIter2 __first2);
  template < typename _FIter1, typename _FIter2, typename _BinaryPredicate >
  bool is_permutation(_FIter1 __first1, _FIter1 __last1, _FIter2 __first2, _BinaryPredicate __pred);
  template < typename _FIter >
  inline bool is_sorted(_FIter __first, _FIter __last);
  template < typename _FIter, typename _Compare >
  inline bool is_sorted(_FIter __first, _FIter __last, _Compare __comp);
  template < typename _FIter >
  _FIter is_sorted_until(_FIter __first, _FIter __last);
  template < typename _FIter, typename _Compare >
  _FIter is_sorted_until(_FIter __first, _FIter __last, _Compare __comp);
  template < typename _FIter, typename _Tp, typename _Compare >
  _FIter lower_bound(_FIter __first, _FIter __last, const _Tp &__val, _Compare __comp);
  template < typename _RAIter >
  void make_heap(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  void make_heap(_RAIter __first, _RAIter __last, _Compare __comp);
  template < typename _Tp >
  inline ::std::pair<const _Tp &, const _Tp &> minmax(const _Tp &__a, const _Tp &__b);
  template < typename _Tp, typename _Compare >
  inline ::std::pair<const _Tp &, const _Tp &> minmax(const _Tp &__a, const _Tp &__b, _Compare __comp);
  template < typename _FIter >
  ::std::pair<_FIter, _FIter> minmax_element(_FIter __first, _FIter __last);
  template < typename _FIter, typename _Compare >
  ::std::pair<_FIter, _FIter> minmax_element(_FIter __first, _FIter __last, _Compare __comp);
  template < typename _Tp >
  inline _Tp min(::std::initializer_list<_Tp> __l);
  template < typename _Tp, typename _Compare >
  inline _Tp min(::std::initializer_list<_Tp> __l, _Compare __comp);
  template < typename _Tp >
  inline _Tp max(::std::initializer_list<_Tp> __l);
  template < typename _Tp, typename _Compare >
  inline _Tp max(::std::initializer_list<_Tp> __l, _Compare __comp);
  template < typename _Tp >
  inline ::std::pair<_Tp, _Tp> minmax(::std::initializer_list<_Tp> __l);
  template < typename _Tp, typename _Compare >
  inline ::std::pair<_Tp, _Tp> minmax(::std::initializer_list<_Tp> __l, _Compare __comp);
  template < typename _BIter >
  bool next_permutation(_BIter __first, _BIter __last);
  template < typename _BIter, typename _Compare >
  bool next_permutation(_BIter __first, _BIter __last, _Compare __comp);
  template < typename _IIter, typename _Predicate >
  inline bool none_of(_IIter __first, _IIter __last, _Predicate __pred);
  template < typename _IIter, typename _RAIter >
  _RAIter partial_sort_copy(_IIter __first, _IIter __last, _RAIter __result_first, _RAIter __result_last);
  template < typename _IIter, typename _RAIter, typename _Compare >
  _RAIter partial_sort_copy(_IIter __first, _IIter __last, _RAIter __result_first, _RAIter __result_last, _Compare __comp);
  template < typename _IIter, typename _OIter1, typename _OIter2, typename _Predicate >
  ::std::pair<_OIter1, _OIter2> partition_copy(_IIter __first, _IIter __last, _OIter1 __out_true, _OIter2 __out_false, _Predicate __pred);
  template < typename _FIter, typename _Predicate >
  _FIter partition_point(_FIter __first, _FIter __last, _Predicate __pred);
  template < typename _RAIter >
  inline void pop_heap(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  inline void pop_heap(_RAIter __first, _RAIter __last, _Compare __comp);
  template < typename _BIter >
  bool prev_permutation(_BIter __first, _BIter __last);
  template < typename _BIter, typename _Compare >
  bool prev_permutation(_BIter __first, _BIter __last, _Compare __comp);
  template < typename _RAIter >
  inline void push_heap(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  inline void push_heap(_RAIter __first, _RAIter __last, _Compare __comp);
  template < typename _FIter, typename _Tp >
  _FIter remove(_FIter __first, _FIter __last, const _Tp &__value);
  template < typename _FIter, typename _Predicate >
  _FIter remove_if(_FIter __first, _FIter __last, _Predicate __pred);
  template < typename _IIter, typename _OIter, typename _Tp >
  _OIter remove_copy(_IIter __first, _IIter __last, _OIter __result, const _Tp &__value);
  template < typename _IIter, typename _OIter, typename _Predicate >
  _OIter remove_copy_if(_IIter __first, _IIter __last, _OIter __result, _Predicate __pred);
  template < typename _IIter, typename _OIter, typename _Tp >
  _OIter replace_copy(_IIter __first, _IIter __last, _OIter __result, const _Tp &__old_value, const _Tp &__new_value);
  template < typename _Iter, typename _OIter, typename _Predicate, typename _Tp >
  _OIter replace_copy_if(_Iter __first, _Iter __last, _OIter __result, _Predicate __pred, const _Tp &__new_value);
  template < typename _BIter >
  inline void reverse(_BIter __first, _BIter __last);
  template < typename _BIter, typename _OIter >
  _OIter reverse_copy(_BIter __first, _BIter __last, _OIter __result);
  template < typename _FIter >
  inline void rotate(_FIter __first, _FIter __middle, _FIter __last);
  template < typename _FIter, typename _OIter >
  _OIter rotate_copy(_FIter __first, _FIter __middle, _FIter __last, _OIter __result);
  template < typename _RAIter, typename _UGenerator >
  void shuffle(_RAIter __first, _RAIter __last, _UGenerator &&__g);
  template < typename _RAIter >
  void sort_heap(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  void sort_heap(_RAIter __first, _RAIter __last, _Compare __comp);
  template < typename _BIter, typename _Predicate >
  _BIter stable_partition(_BIter __first, _BIter __last, _Predicate __pred);
  template < typename _FIter >
  _FIter unique(_FIter __first, _FIter __last);
  template < typename _FIter, typename _BinaryPredicate >
  _FIter unique(_FIter __first, _FIter __last, _BinaryPredicate __binary_pred);
  template < typename _FIter, typename _Tp >
  _FIter upper_bound(_FIter __first, _FIter __last, const _Tp &__val);
  template < typename _FIter, typename _Tp, typename _Compare >
  _FIter upper_bound(_FIter __first, _FIter __last, const _Tp &__val, _Compare __comp);
  template < typename _FIter >
  _FIter adjacent_find(_FIter __first, _FIter __last);
  template < typename _FIter, typename _BinaryPredicate >
  _FIter adjacent_find(_FIter __first, _FIter __last, _BinaryPredicate __binary_pred);
  template < typename _IIter, typename _Tp >
  typename ::std::iterator_traits<_IIter>::difference_type count(_IIter __first, _IIter __last, const _Tp &__value);
  template < typename _IIter, typename _Predicate >
  typename ::std::iterator_traits<_IIter>::difference_type count_if(_IIter __first, _IIter __last, _Predicate __pred);
  template < typename _IIter, typename _Tp >
  inline _IIter find(_IIter __first, _IIter __last, const _Tp &__val);
  template < typename _FIter1, typename _FIter2 >
  _FIter1 find_first_of(_FIter1 __first1, _FIter1 __last1, _FIter2 __first2, _FIter2 __last2);
  template < typename _FIter1, typename _FIter2, typename _BinaryPredicate >
  _FIter1 find_first_of(_FIter1 __first1, _FIter1 __last1, _FIter2 __first2, _FIter2 __last2, _BinaryPredicate __comp);
  template < typename _IIter, typename _Predicate >
  inline _IIter find_if(_IIter __first, _IIter __last, _Predicate __pred);
  template < typename _IIter, typename _Funct >
  _Funct for_each(_IIter __first, _IIter __last, _Funct __f);
  template < typename _FIter, typename _Generator >
  void generate(_FIter __first, _FIter __last, _Generator __gen);
  template < typename _OIter, typename _Size, typename _Generator >
  _OIter generate_n(_OIter __first, _Size __n, _Generator __gen);
  template < typename _FIter >
  _FIter max_element(_FIter __first, _FIter __last);
  template < typename _FIter, typename _Compare >
  _FIter max_element(_FIter __first, _FIter __last, _Compare __comp);
  template < typename _IIter1, typename _IIter2, typename _OIter >
  _OIter merge(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result);
  template < typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
  _OIter merge(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result, _Compare __comp);
  template < typename _FIter >
  _FIter min_element(_FIter __first, _FIter __last);
  template < typename _FIter, typename _Compare >
  _FIter min_element(_FIter __first, _FIter __last, _Compare __comp);
  template < typename _RAIter >
  inline void nth_element(_RAIter __first, _RAIter __nth, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  inline void nth_element(_RAIter __first, _RAIter __nth, _RAIter __last, _Compare __comp);
  template < typename _RAIter >
  inline void partial_sort(_RAIter __first, _RAIter __middle, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  inline void partial_sort(_RAIter __first, _RAIter __middle, _RAIter __last, _Compare __comp);
  template < typename _BIter, typename _Predicate >
  inline _BIter partition(_BIter __first, _BIter __last, _Predicate __pred);
  template < typename _RAIter >
  inline void random_shuffle(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Generator >
  void random_shuffle(_RAIter __first, _RAIter __last, _Generator &&__rand);
  template < typename _FIter, typename _Tp >
  void replace(_FIter __first, _FIter __last, const _Tp &__old_value, const _Tp &__new_value);
  template < typename _FIter, typename _Predicate, typename _Tp >
  void replace_if(_FIter __first, _FIter __last, _Predicate __pred, const _Tp &__new_value);
  template < typename _FIter1, typename _FIter2 >
  _FIter1 search(_FIter1 __first1, _FIter1 __last1, _FIter2 __first2, _FIter2 __last2);
  template < typename _FIter1, typename _FIter2, typename _BinaryPredicate >
  _FIter1 search(_FIter1 __first1, _FIter1 __last1, _FIter2 __first2, _FIter2 __last2, _BinaryPredicate __predicate);
  template < typename _FIter, typename _Size, typename _Tp >
  _FIter search_n(_FIter __first, _FIter __last, _Size __count, const _Tp &__val);
  template < typename _FIter, typename _Size, typename _Tp, typename _BinaryPredicate >
  _FIter search_n(_FIter __first, _FIter __last, _Size __count, const _Tp &__val, _BinaryPredicate __binary_pred);
  template < typename _IIter1, typename _IIter2, typename _OIter >
  _OIter set_difference(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result);
  template < typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
  _OIter set_difference(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result, _Compare __comp);
  template < typename _IIter1, typename _IIter2, typename _OIter >
  _OIter set_intersection(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result);
  template < typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
  _OIter set_intersection(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result, _Compare __comp);
  template < typename _IIter1, typename _IIter2, typename _OIter >
  _OIter set_symmetric_difference(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result);
  template < typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
  _OIter set_symmetric_difference(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result, _Compare __comp);
  template < typename _IIter1, typename _IIter2, typename _OIter >
  _OIter set_union(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result);
  template < typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
  _OIter set_union(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _OIter __result, _Compare __comp);
  template < typename _RAIter >
  inline void sort(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  inline void sort(_RAIter __first, _RAIter __last, _Compare __comp);
  template < typename _RAIter >
  inline void stable_sort(_RAIter __first, _RAIter __last);
  template < typename _RAIter, typename _Compare >
  inline void stable_sort(_RAIter __first, _RAIter __last, _Compare __comp);
  template < typename _IIter, typename _OIter, typename _UnaryOperation >
  _OIter transform(_IIter __first, _IIter __last, _OIter __result, _UnaryOperation __unary_op);
  template < typename _IIter1, typename _IIter2, typename _OIter, typename _BinaryOperation >
  _OIter transform(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _OIter __result, _BinaryOperation __binary_op);
  template < typename _IIter, typename _OIter >
  inline _OIter unique_copy(_IIter __first, _IIter __last, _OIter __result);
  template < typename _IIter, typename _OIter, typename _BinaryPredicate >
  inline _OIter unique_copy(_IIter __first, _IIter __last, _OIter __result, _BinaryPredicate __binary_pred);
  template < typename _RandomAccessIterator, typename _Distance >
  _Distance __is_heap_until(_RandomAccessIterator __first, _Distance __n);
  template < typename _RandomAccessIterator, typename _Distance >
  _Distance __is_heap_until(_RandomAccessIterator __first, _Distance __n)
  {
    _Distance __parent = 0;
    for (_Distance __child = 1; __child < __n;  ++__child)
      {
        if (__first[__parent] < __first[__child])
          {
            return __child;
          }
        if ((__child & 1) == 0)
          {
             ++__parent;
          }
      }
    return __n;
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Compare >
  _Distance __is_heap_until(_RandomAccessIterator __first, _Distance __n, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Distance, typename _Compare >
  _Distance __is_heap_until(_RandomAccessIterator __first, _Distance __n, _Compare __comp)
  {
    _Distance __parent = 0;
    for (_Distance __child = 1; __child < __n;  ++__child)
      {
        if (__comp(__first[__parent], __first[__child]))
          {
            return __child;
          }
        if ((__child & 1) == 0)
          {
             ++__parent;
          }
      }
    return __n;
  }
  template < typename _RandomAccessIterator, typename _Distance >
  inline bool __is_heap(_RandomAccessIterator __first, _Distance __n);
  template < typename _RandomAccessIterator, typename _Distance >
  inline bool __is_heap(_RandomAccessIterator __first, _Distance __n)
  {
    return std::__is_heap_until(__first, __n) == __n;
  }
  template < typename _RandomAccessIterator, typename _Compare, typename _Distance >
  inline bool __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n);
  template < typename _RandomAccessIterator, typename _Compare, typename _Distance >
  inline bool __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
  {
    return std::__is_heap_until(__first, __n, __comp) == __n;
  }
  template < typename _RandomAccessIterator >
  inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    return std::__is_heap(__first, std::distance(__first, __last));
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    return std::__is_heap(__first, __comp, std::distance(__first, __last));
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp >
  void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value);
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp >
  void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value)
  {
    _Distance __parent = (__holeIndex - 1) / 2;
    while (__holeIndex > __topIndex && *(__first + __parent) < __value)
      {
        *(__first + __holeIndex) = std::move(*(__first + __parent));
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
      }
    *(__first + __holeIndex) = std::move(__value);
  }
  template < typename _RandomAccessIterator >
  inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    ;
    _ValueType __value = std::move(*(__last - 1));
    std::__push_heap(__first, _DistanceType(__last - __first - 1), _DistanceType(0), std::move(__value));
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare >
  void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare >
  void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value, _Compare __comp)
  {
    _Distance __parent = (__holeIndex - 1) / 2;
    while (__holeIndex > __topIndex && __comp(*(__first + __parent), __value))
      {
        *(__first + __holeIndex) = std::move(*(__first + __parent));
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
      }
    *(__first + __holeIndex) = std::move(__value);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    ;
    _ValueType __value = std::move(*(__last - 1));
    std::__push_heap(__first, _DistanceType(__last - __first - 1), _DistanceType(0), std::move(__value), __comp);
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp >
  void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value);
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp >
  void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value)
  {
    const _Distance __topIndex = __holeIndex;
    _Distance __secondChild = __holeIndex;
    while (__secondChild < (__len - 1) / 2)
      {
        __secondChild = 2 * (__secondChild + 1);
        if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
          {
            __secondChild--;
          }
        *(__first + __holeIndex) = std::move(*(__first + __secondChild));
        __holeIndex = __secondChild;
      }
    if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
      {
        __secondChild = 2 * (__secondChild + 1);
        *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)));
        __holeIndex = __secondChild - 1;
      }
    std::__push_heap(__first, __holeIndex, __topIndex, std::move(__value));
  }
  template < typename _RandomAccessIterator >
  inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result);
  template < typename _RandomAccessIterator >
  inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    _ValueType __value = std::move(*__result);
    *__result = std::move(*__first);
    std::__adjust_heap(__first, _DistanceType(0), _DistanceType(__last - __first), std::move(__value));
  }
  template < typename _RandomAccessIterator >
  inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    ;
    ;
    ;
    if (__last - __first > 1)
      {
         --__last;
        std::__pop_heap(__first, __last, __last);
      }
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare >
  void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare >
  void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value, _Compare __comp)
  {
    const _Distance __topIndex = __holeIndex;
    _Distance __secondChild = __holeIndex;
    while (__secondChild < (__len - 1) / 2)
      {
        __secondChild = 2 * (__secondChild + 1);
        if (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1))))
          {
            __secondChild--;
          }
        *(__first + __holeIndex) = std::move(*(__first + __secondChild));
        __holeIndex = __secondChild;
      }
    if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
      {
        __secondChild = 2 * (__secondChild + 1);
        *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)));
        __holeIndex = __secondChild - 1;
      }
    std::__push_heap(__first, __holeIndex, __topIndex, std::move(__value), __comp);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    _ValueType __value = std::move(*__result);
    *__result = std::move(*__first);
    std::__adjust_heap(__first, _DistanceType(0), _DistanceType(__last - __first), std::move(__value), __comp);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    ;
    ;
    ;
    if (__last - __first > 1)
      {
         --__last;
        std::__pop_heap(__first, __last, __last, __comp);
      }
  }
  template < typename _RandomAccessIterator >
  void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    if (__last - __first < 2)
      {
        return ;
      }
    const _DistanceType __len = __last - __first;
    _DistanceType __parent = (__len - 2) / 2;
    while (true)
      {
        _ValueType __value = std::move(*(__first + __parent));
        std::__adjust_heap(__first, __parent, __len, std::move(__value));
        if (__parent == 0)
          {
            return ;
          }
        __parent--;
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    if (__last - __first < 2)
      {
        return ;
      }
    const _DistanceType __len = __last - __first;
    _DistanceType __parent = (__len - 2) / 2;
    while (true)
      {
        _ValueType __value = std::move(*(__first + __parent));
        std::__adjust_heap(__first, __parent, __len, std::move(__value), __comp);
        if (__parent == 0)
          {
            return ;
          }
        __parent--;
      }
  }
  template < typename _RandomAccessIterator >
  void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    ;
    ;
    while (__last - __first > 1)
      {
         --__last;
        std::__pop_heap(__first, __last, __last);
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    ;
    ;
    while (__last - __first > 1)
      {
         --__last;
        std::__pop_heap(__first, __last, __last, __comp);
      }
  }
  template < typename _RandomAccessIterator >
  inline _RandomAccessIterator is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    ;
    return __first + std::__is_heap_until(__first, std::distance(__first, __last));
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline _RandomAccessIterator is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    ;
    return __first + std::__is_heap_until(__first, std::distance(__first, __last), __comp);
  }
  template < typename _RandomAccessIterator >
  inline bool is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    return std::is_heap_until(__first, __last) == __last;
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline bool is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    return std::is_heap_until(__first, __last, __comp) == __last;
  }
}
typedef float float_t;
typedef double double_t;
extern "C"
{
  extern double acos(double __x) throw();
}
extern "C"
{
  extern double __acos(double __x) throw();
}
extern "C"
{
  extern double asin(double __x) throw();
}
extern "C"
{
  extern double __asin(double __x) throw();
}
extern "C"
{
  extern double atan(double __x) throw();
}
extern "C"
{
  extern double __atan(double __x) throw();
}
extern "C"
{
  extern double atan2(double __y, double __x) throw();
}
extern "C"
{
  extern double __atan2(double __y, double __x) throw();
}
extern "C"
{
  extern double cos(double __x) throw();
}
extern "C"
{
  extern double __cos(double __x) throw();
}
extern "C"
{
  extern double sin(double __x) throw();
}
extern "C"
{
  extern double __sin(double __x) throw();
}
extern "C"
{
  extern double tan(double __x) throw();
}
extern "C"
{
  extern double __tan(double __x) throw();
}
extern "C"
{
  extern double cosh(double __x) throw();
}
extern "C"
{
  extern double __cosh(double __x) throw();
}
extern "C"
{
  extern double sinh(double __x) throw();
}
extern "C"
{
  extern double __sinh(double __x) throw();
}
extern "C"
{
  extern double tanh(double __x) throw();
}
extern "C"
{
  extern double __tanh(double __x) throw();
}
extern "C"
{
  extern void sincos(double __x, double *__sinx, double *__cosx) throw();
}
extern "C"
{
  extern void __sincos(double __x, double *__sinx, double *__cosx) throw();
}
extern "C"
{
  extern double acosh(double __x) throw();
}
extern "C"
{
  extern double __acosh(double __x) throw();
}
extern "C"
{
  extern double asinh(double __x) throw();
}
extern "C"
{
  extern double __asinh(double __x) throw();
}
extern "C"
{
  extern double atanh(double __x) throw();
}
extern "C"
{
  extern double __atanh(double __x) throw();
}
extern "C"
{
  extern double exp(double __x) throw();
}
extern "C"
{
  extern double __exp(double __x) throw();
}
extern "C"
{
  extern double frexp(double __x, int *__exponent) throw();
}
extern "C"
{
  extern double __frexp(double __x, int *__exponent) throw();
}
extern "C"
{
  extern double ldexp(double __x, int __exponent) throw();
}
extern "C"
{
  extern double __ldexp(double __x, int __exponent) throw();
}
extern "C"
{
  extern double log(double __x) throw();
}
extern "C"
{
  extern double __log(double __x) throw();
}
extern "C"
{
  extern double log10(double __x) throw();
}
extern "C"
{
  extern double __log10(double __x) throw();
}
extern "C"
{
  extern double modf(double __x, double *__iptr) throw();
}
extern "C"
{
  extern double __modf(double __x, double *__iptr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern double exp10(double __x) throw();
}
extern "C"
{
  extern double __exp10(double __x) throw();
}
extern "C"
{
  extern double pow10(double __x) throw();
}
extern "C"
{
  extern double __pow10(double __x) throw();
}
extern "C"
{
  extern double expm1(double __x) throw();
}
extern "C"
{
  extern double __expm1(double __x) throw();
}
extern "C"
{
  extern double log1p(double __x) throw();
}
extern "C"
{
  extern double __log1p(double __x) throw();
}
extern "C"
{
  extern double logb(double __x) throw();
}
extern "C"
{
  extern double __logb(double __x) throw();
}
extern "C"
{
  extern double exp2(double __x) throw();
}
extern "C"
{
  extern double __exp2(double __x) throw();
}
extern "C"
{
  extern double log2(double __x) throw();
}
extern "C"
{
  extern double __log2(double __x) throw();
}
extern "C"
{
  extern double pow(double __x, double __y) throw();
}
extern "C"
{
  extern double __pow(double __x, double __y) throw();
}
extern "C"
{
  extern double sqrt(double __x) throw();
}
extern "C"
{
  extern double __sqrt(double __x) throw();
}
extern "C"
{
  extern double hypot(double __x, double __y) throw();
}
extern "C"
{
  extern double __hypot(double __x, double __y) throw();
}
extern "C"
{
  extern double cbrt(double __x) throw();
}
extern "C"
{
  extern double __cbrt(double __x) throw();
}
extern "C"
{
  extern double ceil(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __ceil(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double fabs(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __fabs(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double floor(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __floor(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double fmod(double __x, double __y) throw();
}
extern "C"
{
  extern double __fmod(double __x, double __y) throw();
}
extern "C"
{
  extern int __isinf(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __finite(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isinf(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int finite(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern double drem(double __x, double __y) throw();
}
extern "C"
{
  extern double __drem(double __x, double __y) throw();
}
extern "C"
{
  extern double significand(double __x) throw();
}
extern "C"
{
  extern double __significand(double __x) throw();
}
extern "C"
{
  extern double copysign(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __copysign(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double nan(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __nan(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __isnan(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isnan(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern double j0(double) throw();
}
extern "C"
{
  extern double __j0(double) throw();
}
extern "C"
{
  extern double j1(double) throw();
}
extern "C"
{
  extern double __j1(double) throw();
}
extern "C"
{
  extern double jn(int, double) throw();
}
extern "C"
{
  extern double __jn(int, double) throw();
}
extern "C"
{
  extern double y0(double) throw();
}
extern "C"
{
  extern double __y0(double) throw();
}
extern "C"
{
  extern double y1(double) throw();
}
extern "C"
{
  extern double __y1(double) throw();
}
extern "C"
{
  extern double yn(int, double) throw();
}
extern "C"
{
  extern double __yn(int, double) throw();
}
extern "C"
{
  extern double erf(double) throw();
}
extern "C"
{
  extern double __erf(double) throw();
}
extern "C"
{
  extern double erfc(double) throw();
}
extern "C"
{
  extern double __erfc(double) throw();
}
extern "C"
{
  extern double lgamma(double) throw();
}
extern "C"
{
  extern double __lgamma(double) throw();
}
extern "C"
{
  extern double tgamma(double) throw();
}
extern "C"
{
  extern double __tgamma(double) throw();
}
extern "C"
{
  extern double gamma(double) throw();
}
extern "C"
{
  extern double __gamma(double) throw();
}
extern "C"
{
  extern double lgamma_r(double, int *__signgamp) throw();
}
extern "C"
{
  extern double __lgamma_r(double, int *__signgamp) throw();
}
extern "C"
{
  extern double rint(double __x) throw();
}
extern "C"
{
  extern double __rint(double __x) throw();
}
extern "C"
{
  extern double nextafter(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __nextafter(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double nexttoward(double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __nexttoward(double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double remainder(double __x, double __y) throw();
}
extern "C"
{
  extern double __remainder(double __x, double __y) throw();
}
extern "C"
{
  extern double scalbn(double __x, int __n) throw();
}
extern "C"
{
  extern double __scalbn(double __x, int __n) throw();
}
extern "C"
{
  extern int ilogb(double __x) throw();
}
extern "C"
{
  extern int __ilogb(double __x) throw();
}
extern "C"
{
  extern double scalbln(double __x, long int __n) throw();
}
extern "C"
{
  extern double __scalbln(double __x, long int __n) throw();
}
extern "C"
{
  extern double nearbyint(double __x) throw();
}
extern "C"
{
  extern double __nearbyint(double __x) throw();
}
extern "C"
{
  extern double round(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __round(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double trunc(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __trunc(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double remquo(double __x, double __y, int *__quo) throw();
}
extern "C"
{
  extern double __remquo(double __x, double __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrint(double __x) throw();
}
extern "C"
{
  extern long int __lrint(double __x) throw();
}
extern "C"
{
  extern long long int llrint(double __x) throw();
}
extern "C"
{
  extern long long int __llrint(double __x) throw();
}
extern "C"
{
  extern long int lround(double __x) throw();
}
extern "C"
{
  extern long int __lround(double __x) throw();
}
extern "C"
{
  extern long long int llround(double __x) throw();
}
extern "C"
{
  extern long long int __llround(double __x) throw();
}
extern "C"
{
  extern double fdim(double __x, double __y) throw();
}
extern "C"
{
  extern double __fdim(double __x, double __y) throw();
}
extern "C"
{
  extern double fmax(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __fmax(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double fmin(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __fmin(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __fpclassify(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern inline int __signbit(double __x) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern double fma(double __x, double __y, double __z) throw();
}
extern "C"
{
  extern double __fma(double __x, double __y, double __z) throw();
}
extern "C"
{
  extern int __issignaling(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern double scalb(double __x, double __n) throw();
}
extern "C"
{
  extern double __scalb(double __x, double __n) throw();
}
extern "C"
{
  extern float acosf(float __x) throw();
}
extern "C"
{
  extern float __acosf(float __x) throw();
}
extern "C"
{
  extern float asinf(float __x) throw();
}
extern "C"
{
  extern float __asinf(float __x) throw();
}
extern "C"
{
  extern float atanf(float __x) throw();
}
extern "C"
{
  extern float __atanf(float __x) throw();
}
extern "C"
{
  extern float atan2f(float __y, float __x) throw();
}
extern "C"
{
  extern float __atan2f(float __y, float __x) throw();
}
extern "C"
{
  extern float cosf(float __x) throw();
}
extern "C"
{
  extern float __cosf(float __x) throw();
}
extern "C"
{
  extern float sinf(float __x) throw();
}
extern "C"
{
  extern float __sinf(float __x) throw();
}
extern "C"
{
  extern float tanf(float __x) throw();
}
extern "C"
{
  extern float __tanf(float __x) throw();
}
extern "C"
{
  extern float coshf(float __x) throw();
}
extern "C"
{
  extern float __coshf(float __x) throw();
}
extern "C"
{
  extern float sinhf(float __x) throw();
}
extern "C"
{
  extern float __sinhf(float __x) throw();
}
extern "C"
{
  extern float tanhf(float __x) throw();
}
extern "C"
{
  extern float __tanhf(float __x) throw();
}
extern "C"
{
  extern void sincosf(float __x, float *__sinx, float *__cosx) throw();
}
extern "C"
{
  extern void __sincosf(float __x, float *__sinx, float *__cosx) throw();
}
extern "C"
{
  extern float acoshf(float __x) throw();
}
extern "C"
{
  extern float __acoshf(float __x) throw();
}
extern "C"
{
  extern float asinhf(float __x) throw();
}
extern "C"
{
  extern float __asinhf(float __x) throw();
}
extern "C"
{
  extern float atanhf(float __x) throw();
}
extern "C"
{
  extern float __atanhf(float __x) throw();
}
extern "C"
{
  extern float expf(float __x) throw();
}
extern "C"
{
  extern float __expf(float __x) throw();
}
extern "C"
{
  extern float frexpf(float __x, int *__exponent) throw();
}
extern "C"
{
  extern float __frexpf(float __x, int *__exponent) throw();
}
extern "C"
{
  extern float ldexpf(float __x, int __exponent) throw();
}
extern "C"
{
  extern float __ldexpf(float __x, int __exponent) throw();
}
extern "C"
{
  extern float logf(float __x) throw();
}
extern "C"
{
  extern float __logf(float __x) throw();
}
extern "C"
{
  extern float log10f(float __x) throw();
}
extern "C"
{
  extern float __log10f(float __x) throw();
}
extern "C"
{
  extern float modff(float __x, float *__iptr) throw();
}
extern "C"
{
  extern float __modff(float __x, float *__iptr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern float exp10f(float __x) throw();
}
extern "C"
{
  extern float __exp10f(float __x) throw();
}
extern "C"
{
  extern float pow10f(float __x) throw();
}
extern "C"
{
  extern float __pow10f(float __x) throw();
}
extern "C"
{
  extern float expm1f(float __x) throw();
}
extern "C"
{
  extern float __expm1f(float __x) throw();
}
extern "C"
{
  extern float log1pf(float __x) throw();
}
extern "C"
{
  extern float __log1pf(float __x) throw();
}
extern "C"
{
  extern float logbf(float __x) throw();
}
extern "C"
{
  extern float __logbf(float __x) throw();
}
extern "C"
{
  extern float exp2f(float __x) throw();
}
extern "C"
{
  extern float __exp2f(float __x) throw();
}
extern "C"
{
  extern float log2f(float __x) throw();
}
extern "C"
{
  extern float __log2f(float __x) throw();
}
extern "C"
{
  extern float powf(float __x, float __y) throw();
}
extern "C"
{
  extern float __powf(float __x, float __y) throw();
}
extern "C"
{
  extern float sqrtf(float __x) throw();
}
extern "C"
{
  extern float __sqrtf(float __x) throw();
}
extern "C"
{
  extern float hypotf(float __x, float __y) throw();
}
extern "C"
{
  extern float __hypotf(float __x, float __y) throw();
}
extern "C"
{
  extern float cbrtf(float __x) throw();
}
extern "C"
{
  extern float __cbrtf(float __x) throw();
}
extern "C"
{
  extern float ceilf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __ceilf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float fabsf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __fabsf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float floorf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __floorf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float fmodf(float __x, float __y) throw();
}
extern "C"
{
  extern float __fmodf(float __x, float __y) throw();
}
extern "C"
{
  extern int __isinff(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __finitef(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isinff(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int finitef(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern float dremf(float __x, float __y) throw();
}
extern "C"
{
  extern float __dremf(float __x, float __y) throw();
}
extern "C"
{
  extern float significandf(float __x) throw();
}
extern "C"
{
  extern float __significandf(float __x) throw();
}
extern "C"
{
  extern float copysignf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __copysignf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float nanf(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __nanf(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __isnanf(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isnanf(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern float j0f(float) throw();
}
extern "C"
{
  extern float __j0f(float) throw();
}
extern "C"
{
  extern float j1f(float) throw();
}
extern "C"
{
  extern float __j1f(float) throw();
}
extern "C"
{
  extern float jnf(int, float) throw();
}
extern "C"
{
  extern float __jnf(int, float) throw();
}
extern "C"
{
  extern float y0f(float) throw();
}
extern "C"
{
  extern float __y0f(float) throw();
}
extern "C"
{
  extern float y1f(float) throw();
}
extern "C"
{
  extern float __y1f(float) throw();
}
extern "C"
{
  extern float ynf(int, float) throw();
}
extern "C"
{
  extern float __ynf(int, float) throw();
}
extern "C"
{
  extern float erff(float) throw();
}
extern "C"
{
  extern float __erff(float) throw();
}
extern "C"
{
  extern float erfcf(float) throw();
}
extern "C"
{
  extern float __erfcf(float) throw();
}
extern "C"
{
  extern float lgammaf(float) throw();
}
extern "C"
{
  extern float __lgammaf(float) throw();
}
extern "C"
{
  extern float tgammaf(float) throw();
}
extern "C"
{
  extern float __tgammaf(float) throw();
}
extern "C"
{
  extern float gammaf(float) throw();
}
extern "C"
{
  extern float __gammaf(float) throw();
}
extern "C"
{
  extern float lgammaf_r(float, int *__signgamp) throw();
}
extern "C"
{
  extern float __lgammaf_r(float, int *__signgamp) throw();
}
extern "C"
{
  extern float rintf(float __x) throw();
}
extern "C"
{
  extern float __rintf(float __x) throw();
}
extern "C"
{
  extern float nextafterf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __nextafterf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float nexttowardf(float __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __nexttowardf(float __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float remainderf(float __x, float __y) throw();
}
extern "C"
{
  extern float __remainderf(float __x, float __y) throw();
}
extern "C"
{
  extern float scalbnf(float __x, int __n) throw();
}
extern "C"
{
  extern float __scalbnf(float __x, int __n) throw();
}
extern "C"
{
  extern int ilogbf(float __x) throw();
}
extern "C"
{
  extern int __ilogbf(float __x) throw();
}
extern "C"
{
  extern float scalblnf(float __x, long int __n) throw();
}
extern "C"
{
  extern float __scalblnf(float __x, long int __n) throw();
}
extern "C"
{
  extern float nearbyintf(float __x) throw();
}
extern "C"
{
  extern float __nearbyintf(float __x) throw();
}
extern "C"
{
  extern float roundf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __roundf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float truncf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __truncf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float remquof(float __x, float __y, int *__quo) throw();
}
extern "C"
{
  extern float __remquof(float __x, float __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrintf(float __x) throw();
}
extern "C"
{
  extern long int __lrintf(float __x) throw();
}
extern "C"
{
  extern long long int llrintf(float __x) throw();
}
extern "C"
{
  extern long long int __llrintf(float __x) throw();
}
extern "C"
{
  extern long int lroundf(float __x) throw();
}
extern "C"
{
  extern long int __lroundf(float __x) throw();
}
extern "C"
{
  extern long long int llroundf(float __x) throw();
}
extern "C"
{
  extern long long int __llroundf(float __x) throw();
}
extern "C"
{
  extern float fdimf(float __x, float __y) throw();
}
extern "C"
{
  extern float __fdimf(float __x, float __y) throw();
}
extern "C"
{
  extern float fmaxf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __fmaxf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float fminf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __fminf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __fpclassifyf(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern inline int __signbitf(float __x) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern float fmaf(float __x, float __y, float __z) throw();
}
extern "C"
{
  extern float __fmaf(float __x, float __y, float __z) throw();
}
extern "C"
{
  extern int __issignalingf(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern float scalbf(float __x, float __n) throw();
}
extern "C"
{
  extern float __scalbf(float __x, float __n) throw();
}
extern "C"
{
  extern long double acosl(long double __x) throw();
}
extern "C"
{
  extern long double __acosl(long double __x) throw();
}
extern "C"
{
  extern long double asinl(long double __x) throw();
}
extern "C"
{
  extern long double __asinl(long double __x) throw();
}
extern "C"
{
  extern long double atanl(long double __x) throw();
}
extern "C"
{
  extern long double __atanl(long double __x) throw();
}
extern "C"
{
  extern long double atan2l(long double __y, long double __x) throw();
}
extern "C"
{
  extern long double __atan2l(long double __y, long double __x) throw();
}
extern "C"
{
  extern long double cosl(long double __x) throw();
}
extern "C"
{
  extern long double __cosl(long double __x) throw();
}
extern "C"
{
  extern long double sinl(long double __x) throw();
}
extern "C"
{
  extern long double __sinl(long double __x) throw();
}
extern "C"
{
  extern long double tanl(long double __x) throw();
}
extern "C"
{
  extern long double __tanl(long double __x) throw();
}
extern "C"
{
  extern long double coshl(long double __x) throw();
}
extern "C"
{
  extern long double __coshl(long double __x) throw();
}
extern "C"
{
  extern long double sinhl(long double __x) throw();
}
extern "C"
{
  extern long double __sinhl(long double __x) throw();
}
extern "C"
{
  extern long double tanhl(long double __x) throw();
}
extern "C"
{
  extern long double __tanhl(long double __x) throw();
}
extern "C"
{
  extern void sincosl(long double __x, long double *__sinx, long double *__cosx) throw();
}
extern "C"
{
  extern void __sincosl(long double __x, long double *__sinx, long double *__cosx) throw();
}
extern "C"
{
  extern long double acoshl(long double __x) throw();
}
extern "C"
{
  extern long double __acoshl(long double __x) throw();
}
extern "C"
{
  extern long double asinhl(long double __x) throw();
}
extern "C"
{
  extern long double __asinhl(long double __x) throw();
}
extern "C"
{
  extern long double atanhl(long double __x) throw();
}
extern "C"
{
  extern long double __atanhl(long double __x) throw();
}
extern "C"
{
  extern long double expl(long double __x) throw();
}
extern "C"
{
  extern long double __expl(long double __x) throw();
}
extern "C"
{
  extern long double frexpl(long double __x, int *__exponent) throw();
}
extern "C"
{
  extern long double __frexpl(long double __x, int *__exponent) throw();
}
extern "C"
{
  extern long double ldexpl(long double __x, int __exponent) throw();
}
extern "C"
{
  extern long double __ldexpl(long double __x, int __exponent) throw();
}
extern "C"
{
  extern long double logl(long double __x) throw();
}
extern "C"
{
  extern long double __logl(long double __x) throw();
}
extern "C"
{
  extern long double log10l(long double __x) throw();
}
extern "C"
{
  extern long double __log10l(long double __x) throw();
}
extern "C"
{
  extern long double modfl(long double __x, long double *__iptr) throw();
}
extern "C"
{
  extern long double __modfl(long double __x, long double *__iptr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern long double exp10l(long double __x) throw();
}
extern "C"
{
  extern long double __exp10l(long double __x) throw();
}
extern "C"
{
  extern long double pow10l(long double __x) throw();
}
extern "C"
{
  extern long double __pow10l(long double __x) throw();
}
extern "C"
{
  extern long double expm1l(long double __x) throw();
}
extern "C"
{
  extern long double __expm1l(long double __x) throw();
}
extern "C"
{
  extern long double log1pl(long double __x) throw();
}
extern "C"
{
  extern long double __log1pl(long double __x) throw();
}
extern "C"
{
  extern long double logbl(long double __x) throw();
}
extern "C"
{
  extern long double __logbl(long double __x) throw();
}
extern "C"
{
  extern long double exp2l(long double __x) throw();
}
extern "C"
{
  extern long double __exp2l(long double __x) throw();
}
extern "C"
{
  extern long double log2l(long double __x) throw();
}
extern "C"
{
  extern long double __log2l(long double __x) throw();
}
extern "C"
{
  extern long double powl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __powl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double sqrtl(long double __x) throw();
}
extern "C"
{
  extern long double __sqrtl(long double __x) throw();
}
extern "C"
{
  extern long double hypotl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __hypotl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double cbrtl(long double __x) throw();
}
extern "C"
{
  extern long double __cbrtl(long double __x) throw();
}
extern "C"
{
  extern long double ceill(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __ceill(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double fabsl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __fabsl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double floorl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __floorl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double fmodl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __fmodl(long double __x, long double __y) throw();
}
extern "C"
{
  extern int __isinfl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __finitel(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isinfl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int finitel(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double dreml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __dreml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double significandl(long double __x) throw();
}
extern "C"
{
  extern long double __significandl(long double __x) throw();
}
extern "C"
{
  extern long double copysignl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __copysignl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double nanl(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __nanl(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __isnanl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isnanl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double j0l(long double) throw();
}
extern "C"
{
  extern long double __j0l(long double) throw();
}
extern "C"
{
  extern long double j1l(long double) throw();
}
extern "C"
{
  extern long double __j1l(long double) throw();
}
extern "C"
{
  extern long double jnl(int, long double) throw();
}
extern "C"
{
  extern long double __jnl(int, long double) throw();
}
extern "C"
{
  extern long double y0l(long double) throw();
}
extern "C"
{
  extern long double __y0l(long double) throw();
}
extern "C"
{
  extern long double y1l(long double) throw();
}
extern "C"
{
  extern long double __y1l(long double) throw();
}
extern "C"
{
  extern long double ynl(int, long double) throw();
}
extern "C"
{
  extern long double __ynl(int, long double) throw();
}
extern "C"
{
  extern long double erfl(long double) throw();
}
extern "C"
{
  extern long double __erfl(long double) throw();
}
extern "C"
{
  extern long double erfcl(long double) throw();
}
extern "C"
{
  extern long double __erfcl(long double) throw();
}
extern "C"
{
  extern long double lgammal(long double) throw();
}
extern "C"
{
  extern long double __lgammal(long double) throw();
}
extern "C"
{
  extern long double tgammal(long double) throw();
}
extern "C"
{
  extern long double __tgammal(long double) throw();
}
extern "C"
{
  extern long double gammal(long double) throw();
}
extern "C"
{
  extern long double __gammal(long double) throw();
}
extern "C"
{
  extern long double lgammal_r(long double, int *__signgamp) throw();
}
extern "C"
{
  extern long double __lgammal_r(long double, int *__signgamp) throw();
}
extern "C"
{
  extern long double rintl(long double __x) throw();
}
extern "C"
{
  extern long double __rintl(long double __x) throw();
}
extern "C"
{
  extern long double nextafterl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __nextafterl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double nexttowardl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __nexttowardl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double remainderl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __remainderl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double scalbnl(long double __x, int __n) throw();
}
extern "C"
{
  extern long double __scalbnl(long double __x, int __n) throw();
}
extern "C"
{
  extern int ilogbl(long double __x) throw();
}
extern "C"
{
  extern int __ilogbl(long double __x) throw();
}
extern "C"
{
  extern long double scalblnl(long double __x, long int __n) throw();
}
extern "C"
{
  extern long double __scalblnl(long double __x, long int __n) throw();
}
extern "C"
{
  extern long double nearbyintl(long double __x) throw();
}
extern "C"
{
  extern long double __nearbyintl(long double __x) throw();
}
extern "C"
{
  extern long double roundl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __roundl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double truncl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __truncl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double remquol(long double __x, long double __y, int *__quo) throw();
}
extern "C"
{
  extern long double __remquol(long double __x, long double __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrintl(long double __x) throw();
}
extern "C"
{
  extern long int __lrintl(long double __x) throw();
}
extern "C"
{
  extern long long int llrintl(long double __x) throw();
}
extern "C"
{
  extern long long int __llrintl(long double __x) throw();
}
extern "C"
{
  extern long int lroundl(long double __x) throw();
}
extern "C"
{
  extern long int __lroundl(long double __x) throw();
}
extern "C"
{
  extern long long int llroundl(long double __x) throw();
}
extern "C"
{
  extern long long int __llroundl(long double __x) throw();
}
extern "C"
{
  extern long double fdiml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __fdiml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double fmaxl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __fmaxl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double fminl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __fminl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __fpclassifyl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern inline int __signbitl(long double __x) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern long double fmal(long double __x, long double __y, long double __z) throw();
}
extern "C"
{
  extern long double __fmal(long double __x, long double __y, long double __z) throw();
}
extern "C"
{
  extern int __issignalingl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double scalbl(long double __x, long double __n) throw();
}
extern "C"
{
  extern long double __scalbl(long double __x, long double __n) throw();
}
extern "C"
{
  extern int signgam;
}
enum mcc_enum_anon_78
{
  FP_NAN = 0,
  FP_INFINITE = 1,
  FP_ZERO = 2,
  FP_SUBNORMAL = 3,
  FP_NORMAL = 4
};
enum _LIB_VERSION_TYPE
{
  _IEEE_ =  -1,
  _SVID_ = 0,
  _XOPEN_ = 1,
  _POSIX_ = 2,
  _ISOC_ = 3
};
extern "C"
{
  extern ::_LIB_VERSION_TYPE _LIB_VERSION;
}
struct  __exception
{
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
};
extern "C"
{
  extern int matherr(::__exception *__exc) throw();
}
extern "C"
{
  extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) int __signbitf(float __x) throw()
  {
    int __m;
    __asm__ ("pmovmskb %1, %0" : "=r"(__m) : "x"(__x));
    return (__m & 8) != 0;
  }
}
extern "C"
{
  extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) int __signbit(double __x) throw()
  {
    int __m;
    __asm__ ("pmovmskb %1, %0" : "=r"(__m) : "x"(__x));
    return (__m & 128) != 0;
  }
}
extern "C"
{
  extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__always_inline__)) __attribute__((__gnu_inline__)) int __signbitl(long double __x) throw()
  {
    __extension__ union  mcc_union_anon_50
    {
        __extension__ long double __l;
        __extension__ int __i[3L];
    };
    __extension__ mcc_union_anon_50 __u = { /* .mcc_union_anon_50::__l =  */ __x};
    return (__u.__i[2] & 32768) != 0;
  }
}
namespace std __attribute__((__visibility__("default"))) {
  inline constexpr double abs(double __x)
  {
    return __builtin_fabs(__x);
  }
  inline constexpr float abs(float __x)
  {
    return __builtin_fabsf(__x);
  }
  inline constexpr long double abs(long double __x)
  {
    return __builtin_fabsl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type abs(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type abs(_Tp __x)
  {
    return __builtin_fabs(__x);
  }
  using ::acos;
  inline constexpr float acos(float __x)
  {
    return __builtin_acosf(__x);
  }
  inline constexpr long double acos(long double __x)
  {
    return __builtin_acosl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acos(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acos(_Tp __x)
  {
    return __builtin_acos(__x);
  }
  using ::asin;
  inline constexpr float asin(float __x)
  {
    return __builtin_asinf(__x);
  }
  inline constexpr long double asin(long double __x)
  {
    return __builtin_asinl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asin(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asin(_Tp __x)
  {
    return __builtin_asin(__x);
  }
  using ::atan;
  inline constexpr float atan(float __x)
  {
    return __builtin_atanf(__x);
  }
  inline constexpr long double atan(long double __x)
  {
    return __builtin_atanl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atan(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atan(_Tp __x)
  {
    return __builtin_atan(__x);
  }
  using ::atan2;
  inline constexpr float atan2(float __y, float __x)
  {
    return __builtin_atan2f(__y, __x);
  }
  inline constexpr long double atan2(long double __y, long double __x)
  {
    return __builtin_atan2l(__y, __x);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type atan2(_Tp __y, _Up __x);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type atan2(_Tp __y, _Up __x)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return atan2(__type(__y), __type(__x));
  }
  using ::ceil;
  inline constexpr float ceil(float __x)
  {
    return __builtin_ceilf(__x);
  }
  inline constexpr long double ceil(long double __x)
  {
    return __builtin_ceill(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ceil(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ceil(_Tp __x)
  {
    return __builtin_ceil(__x);
  }
  using ::cos;
  inline constexpr float cos(float __x)
  {
    return __builtin_cosf(__x);
  }
  inline constexpr long double cos(long double __x)
  {
    return __builtin_cosl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cos(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cos(_Tp __x)
  {
    return __builtin_cos(__x);
  }
  using ::cosh;
  inline constexpr float cosh(float __x)
  {
    return __builtin_coshf(__x);
  }
  inline constexpr long double cosh(long double __x)
  {
    return __builtin_coshl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cosh(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cosh(_Tp __x)
  {
    return __builtin_cosh(__x);
  }
  using ::exp;
  inline constexpr float exp(float __x)
  {
    return __builtin_expf(__x);
  }
  inline constexpr long double exp(long double __x)
  {
    return __builtin_expl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp(_Tp __x)
  {
    return __builtin_exp(__x);
  }
  using ::fabs;
  inline constexpr float fabs(float __x)
  {
    return __builtin_fabsf(__x);
  }
  inline constexpr long double fabs(long double __x)
  {
    return __builtin_fabsl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type fabs(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type fabs(_Tp __x)
  {
    return __builtin_fabs(__x);
  }
  using ::floor;
  inline constexpr float floor(float __x)
  {
    return __builtin_floorf(__x);
  }
  inline constexpr long double floor(long double __x)
  {
    return __builtin_floorl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type floor(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type floor(_Tp __x)
  {
    return __builtin_floor(__x);
  }
  using ::fmod;
  inline constexpr float fmod(float __x, float __y)
  {
    return __builtin_fmodf(__x, __y);
  }
  inline constexpr long double fmod(long double __x, long double __y)
  {
    return __builtin_fmodl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fmod(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fmod(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return fmod(__type(__x), __type(__y));
  }
  using ::frexp;
  inline float frexp(float __x, int *__exp)
  {
    return __builtin_frexpf(__x, __exp);
  }
  inline long double frexp(long double __x, int *__exp)
  {
    return __builtin_frexpl(__x, __exp);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type frexp(_Tp __x, int *__exp);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type frexp(_Tp __x, int *__exp)
  {
    return __builtin_frexp(__x, __exp);
  }
  using ::ldexp;
  inline constexpr float ldexp(float __x, int __exp)
  {
    return __builtin_ldexpf(__x, __exp);
  }
  inline constexpr long double ldexp(long double __x, int __exp)
  {
    return __builtin_ldexpl(__x, __exp);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ldexp(_Tp __x, int __exp);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ldexp(_Tp __x, int __exp)
  {
    return __builtin_ldexp(__x, __exp);
  }
  using ::log;
  inline constexpr float log(float __x)
  {
    return __builtin_logf(__x);
  }
  inline constexpr long double log(long double __x)
  {
    return __builtin_logl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log(_Tp __x)
  {
    return __builtin_log(__x);
  }
  using ::log10;
  inline constexpr float log10(float __x)
  {
    return __builtin_log10f(__x);
  }
  inline constexpr long double log10(long double __x)
  {
    return __builtin_log10l(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log10(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log10(_Tp __x)
  {
    return __builtin_log10(__x);
  }
  using ::modf;
  inline float modf(float __x, float *__iptr)
  {
    return __builtin_modff(__x, __iptr);
  }
  inline long double modf(long double __x, long double *__iptr)
  {
    return __builtin_modfl(__x, __iptr);
  }
  using ::pow;
  inline constexpr float pow(float __x, float __y)
  {
    return __builtin_powf(__x, __y);
  }
  inline constexpr long double pow(long double __x, long double __y)
  {
    return __builtin_powl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type pow(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type pow(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return pow(__type(__x), __type(__y));
  }
  using ::sin;
  inline constexpr float sin(float __x)
  {
    return __builtin_sinf(__x);
  }
  inline constexpr long double sin(long double __x)
  {
    return __builtin_sinl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sin(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sin(_Tp __x)
  {
    return __builtin_sin(__x);
  }
  using ::sinh;
  inline constexpr float sinh(float __x)
  {
    return __builtin_sinhf(__x);
  }
  inline constexpr long double sinh(long double __x)
  {
    return __builtin_sinhl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sinh(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sinh(_Tp __x)
  {
    return __builtin_sinh(__x);
  }
  using ::sqrt;
  inline constexpr float sqrt(float __x)
  {
    return __builtin_sqrtf(__x);
  }
  inline constexpr long double sqrt(long double __x)
  {
    return __builtin_sqrtl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sqrt(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sqrt(_Tp __x)
  {
    return __builtin_sqrt(__x);
  }
  using ::tan;
  inline constexpr float tan(float __x)
  {
    return __builtin_tanf(__x);
  }
  inline constexpr long double tan(long double __x)
  {
    return __builtin_tanl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tan(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tan(_Tp __x)
  {
    return __builtin_tan(__x);
  }
  using ::tanh;
  inline constexpr float tanh(float __x)
  {
    return __builtin_tanhf(__x);
  }
  inline constexpr long double tanh(long double __x)
  {
    return __builtin_tanhl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tanh(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tanh(_Tp __x)
  {
    return __builtin_tanh(__x);
  }
  inline constexpr int fpclassify(float __x)
  {
    return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
  }
  inline constexpr int fpclassify(double __x)
  {
    return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
  }
  inline constexpr int fpclassify(long double __x)
  {
    return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type fpclassify(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type fpclassify(_Tp __x)
  {
    return __x != 0 ? 4 : 2;
  }
  inline constexpr bool isfinite(float __x)
  {
    return __builtin_isfinite(__x);
  }
  inline constexpr bool isfinite(double __x)
  {
    return __builtin_isfinite(__x);
  }
  inline constexpr bool isfinite(long double __x)
  {
    return __builtin_isfinite(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isfinite(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isfinite(_Tp __x)
  {
    return true;
  }
  inline constexpr bool isinf(float __x)
  {
    return __builtin_isinf(__x);
  }
  inline constexpr bool isinf(double __x)
  {
    return __builtin_isinf(__x);
  }
  inline constexpr bool isinf(long double __x)
  {
    return __builtin_isinf(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isinf(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isinf(_Tp __x)
  {
    return false;
  }
  inline constexpr bool isnan(float __x)
  {
    return __builtin_isnan(__x);
  }
  inline constexpr bool isnan(double __x)
  {
    return __builtin_isnan(__x);
  }
  inline constexpr bool isnan(long double __x)
  {
    return __builtin_isnan(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isnan(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isnan(_Tp __x)
  {
    return false;
  }
  inline constexpr bool isnormal(float __x)
  {
    return __builtin_isnormal(__x);
  }
  inline constexpr bool isnormal(double __x)
  {
    return __builtin_isnormal(__x);
  }
  inline constexpr bool isnormal(long double __x)
  {
    return __builtin_isnormal(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isnormal(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isnormal(_Tp __x)
  {
    return __x != 0 ? true : false;
  }
  inline constexpr bool signbit(float __x)
  {
    return __builtin_signbit(__x);
  }
  inline constexpr bool signbit(double __x)
  {
    return __builtin_signbit(__x);
  }
  inline constexpr bool signbit(long double __x)
  {
    return __builtin_signbit(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type signbit(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type signbit(_Tp __x)
  {
    return __x < 0 ? true : false;
  }
  inline constexpr bool isgreater(float __x, float __y)
  {
    return __builtin_isgreater(__x, __y);
  }
  inline constexpr bool isgreater(double __x, double __y)
  {
    return __builtin_isgreater(__x, __y);
  }
  inline constexpr bool isgreater(long double __x, long double __y)
  {
    return __builtin_isgreater(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isgreater(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isgreater(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_isgreater(__type(__x), __type(__y));
  }
  inline constexpr bool isgreaterequal(float __x, float __y)
  {
    return __builtin_isgreaterequal(__x, __y);
  }
  inline constexpr bool isgreaterequal(double __x, double __y)
  {
    return __builtin_isgreaterequal(__x, __y);
  }
  inline constexpr bool isgreaterequal(long double __x, long double __y)
  {
    return __builtin_isgreaterequal(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isgreaterequal(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isgreaterequal(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_isgreaterequal(__type(__x), __type(__y));
  }
  inline constexpr bool isless(float __x, float __y)
  {
    return __builtin_isless(__x, __y);
  }
  inline constexpr bool isless(double __x, double __y)
  {
    return __builtin_isless(__x, __y);
  }
  inline constexpr bool isless(long double __x, long double __y)
  {
    return __builtin_isless(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isless(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isless(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_isless(__type(__x), __type(__y));
  }
  inline constexpr bool islessequal(float __x, float __y)
  {
    return __builtin_islessequal(__x, __y);
  }
  inline constexpr bool islessequal(double __x, double __y)
  {
    return __builtin_islessequal(__x, __y);
  }
  inline constexpr bool islessequal(long double __x, long double __y)
  {
    return __builtin_islessequal(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type islessequal(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type islessequal(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_islessequal(__type(__x), __type(__y));
  }
  inline constexpr bool islessgreater(float __x, float __y)
  {
    return __builtin_islessgreater(__x, __y);
  }
  inline constexpr bool islessgreater(double __x, double __y)
  {
    return __builtin_islessgreater(__x, __y);
  }
  inline constexpr bool islessgreater(long double __x, long double __y)
  {
    return __builtin_islessgreater(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type islessgreater(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type islessgreater(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_islessgreater(__type(__x), __type(__y));
  }
  inline constexpr bool isunordered(float __x, float __y)
  {
    return __builtin_isunordered(__x, __y);
  }
  inline constexpr bool isunordered(double __x, double __y)
  {
    return __builtin_isunordered(__x, __y);
  }
  inline constexpr bool isunordered(long double __x, long double __y)
  {
    return __builtin_isunordered(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isunordered(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isunordered(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_isunordered(__type(__x), __type(__y));
  }
  using ::double_t;
  using ::float_t;
  using ::acosh;
  using ::acoshf;
  using ::acoshl;
  using ::asinh;
  using ::asinhf;
  using ::asinhl;
  using ::atanh;
  using ::atanhf;
  using ::atanhl;
  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;
  using ::copysign;
  using ::copysignf;
  using ::copysignl;
  using ::erf;
  using ::erff;
  using ::erfl;
  using ::erfc;
  using ::erfcf;
  using ::erfcl;
  using ::exp2;
  using ::exp2f;
  using ::exp2l;
  using ::expm1;
  using ::expm1f;
  using ::expm1l;
  using ::fdim;
  using ::fdimf;
  using ::fdiml;
  using ::fma;
  using ::fmaf;
  using ::fmal;
  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;
  using ::fmin;
  using ::fminf;
  using ::fminl;
  using ::hypot;
  using ::hypotf;
  using ::hypotl;
  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;
  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;
  using ::llrint;
  using ::llrintf;
  using ::llrintl;
  using ::llround;
  using ::llroundf;
  using ::llroundl;
  using ::log1p;
  using ::log1pf;
  using ::log1pl;
  using ::log2;
  using ::log2f;
  using ::log2l;
  using ::logb;
  using ::logbf;
  using ::logbl;
  using ::lrint;
  using ::lrintf;
  using ::lrintl;
  using ::lround;
  using ::lroundf;
  using ::lroundl;
  using ::nan;
  using ::nanf;
  using ::nanl;
  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;
  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;
  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;
  using ::remainder;
  using ::remainderf;
  using ::remainderl;
  using ::remquo;
  using ::remquof;
  using ::remquol;
  using ::rint;
  using ::rintf;
  using ::rintl;
  using ::round;
  using ::roundf;
  using ::roundl;
  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;
  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;
  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;
  using ::trunc;
  using ::truncf;
  using ::truncl;
  inline constexpr float acosh(float __x)
  {
    return __builtin_acoshf(__x);
  }
  inline constexpr long double acosh(long double __x)
  {
    return __builtin_acoshl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acosh(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acosh(_Tp __x)
  {
    return __builtin_acosh(__x);
  }
  inline constexpr float asinh(float __x)
  {
    return __builtin_asinhf(__x);
  }
  inline constexpr long double asinh(long double __x)
  {
    return __builtin_asinhl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asinh(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asinh(_Tp __x)
  {
    return __builtin_asinh(__x);
  }
  inline constexpr float atanh(float __x)
  {
    return __builtin_atanhf(__x);
  }
  inline constexpr long double atanh(long double __x)
  {
    return __builtin_atanhl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atanh(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atanh(_Tp __x)
  {
    return __builtin_atanh(__x);
  }
  inline constexpr float cbrt(float __x)
  {
    return __builtin_cbrtf(__x);
  }
  inline constexpr long double cbrt(long double __x)
  {
    return __builtin_cbrtl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cbrt(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cbrt(_Tp __x)
  {
    return __builtin_cbrt(__x);
  }
  inline constexpr float copysign(float __x, float __y)
  {
    return __builtin_copysignf(__x, __y);
  }
  inline constexpr long double copysign(long double __x, long double __y)
  {
    return __builtin_copysignl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type copysign(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type copysign(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return copysign(__type(__x), __type(__y));
  }
  inline constexpr float erf(float __x)
  {
    return __builtin_erff(__x);
  }
  inline constexpr long double erf(long double __x)
  {
    return __builtin_erfl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type erf(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type erf(_Tp __x)
  {
    return __builtin_erf(__x);
  }
  inline constexpr float erfc(float __x)
  {
    return __builtin_erfcf(__x);
  }
  inline constexpr long double erfc(long double __x)
  {
    return __builtin_erfcl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type erfc(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type erfc(_Tp __x)
  {
    return __builtin_erfc(__x);
  }
  inline constexpr float exp2(float __x)
  {
    return __builtin_exp2f(__x);
  }
  inline constexpr long double exp2(long double __x)
  {
    return __builtin_exp2l(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp2(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp2(_Tp __x)
  {
    return __builtin_exp2(__x);
  }
  inline constexpr float expm1(float __x)
  {
    return __builtin_expm1f(__x);
  }
  inline constexpr long double expm1(long double __x)
  {
    return __builtin_expm1l(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type expm1(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type expm1(_Tp __x)
  {
    return __builtin_expm1(__x);
  }
  inline constexpr float fdim(float __x, float __y)
  {
    return __builtin_fdimf(__x, __y);
  }
  inline constexpr long double fdim(long double __x, long double __y)
  {
    return __builtin_fdiml(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fdim(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fdim(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return fdim(__type(__x), __type(__y));
  }
  inline constexpr float fma(float __x, float __y, float __z)
  {
    return __builtin_fmaf(__x, __y, __z);
  }
  inline constexpr long double fma(long double __x, long double __y, long double __z)
  {
    return __builtin_fmal(__x, __y, __z);
  }
  template < typename _Tp, typename _Up, typename _Vp >
  inline constexpr typename ::__gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type fma(_Tp __x, _Up __y, _Vp __z);
  template < typename _Tp, typename _Up, typename _Vp >
  inline constexpr typename ::__gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type fma(_Tp __x, _Up __y, _Vp __z)
  {
    typedef typename ::__gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
    return fma(__type(__x), __type(__y), __type(__z));
  }
  inline constexpr float fmax(float __x, float __y)
  {
    return __builtin_fmaxf(__x, __y);
  }
  inline constexpr long double fmax(long double __x, long double __y)
  {
    return __builtin_fmaxl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fmax(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fmax(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return fmax(__type(__x), __type(__y));
  }
  inline constexpr float fmin(float __x, float __y)
  {
    return __builtin_fminf(__x, __y);
  }
  inline constexpr long double fmin(long double __x, long double __y)
  {
    return __builtin_fminl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fmin(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fmin(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return fmin(__type(__x), __type(__y));
  }
  inline constexpr float hypot(float __x, float __y)
  {
    return __builtin_hypotf(__x, __y);
  }
  inline constexpr long double hypot(long double __x, long double __y)
  {
    return __builtin_hypotl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type hypot(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type hypot(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return hypot(__type(__x), __type(__y));
  }
  inline constexpr int ilogb(float __x)
  {
    return __builtin_ilogbf(__x);
  }
  inline constexpr int ilogb(long double __x)
  {
    return __builtin_ilogbl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type ilogb(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type ilogb(_Tp __x)
  {
    return __builtin_ilogb(__x);
  }
  inline constexpr float lgamma(float __x)
  {
    return __builtin_lgammaf(__x);
  }
  inline constexpr long double lgamma(long double __x)
  {
    return __builtin_lgammal(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type lgamma(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type lgamma(_Tp __x)
  {
    return __builtin_lgamma(__x);
  }
  inline constexpr long long int llrint(float __x)
  {
    return __builtin_llrintf(__x);
  }
  inline constexpr long long int llrint(long double __x)
  {
    return __builtin_llrintl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long long int>::__type llrint(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long long int>::__type llrint(_Tp __x)
  {
    return __builtin_llrint(__x);
  }
  inline constexpr long long int llround(float __x)
  {
    return __builtin_llroundf(__x);
  }
  inline constexpr long long int llround(long double __x)
  {
    return __builtin_llroundl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long long int>::__type llround(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long long int>::__type llround(_Tp __x)
  {
    return __builtin_llround(__x);
  }
  inline constexpr float log1p(float __x)
  {
    return __builtin_log1pf(__x);
  }
  inline constexpr long double log1p(long double __x)
  {
    return __builtin_log1pl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log1p(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log1p(_Tp __x)
  {
    return __builtin_log1p(__x);
  }
  inline constexpr float log2(float __x)
  {
    return __builtin_log2f(__x);
  }
  inline constexpr long double log2(long double __x)
  {
    return __builtin_log2l(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log2(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log2(_Tp __x)
  {
    return __builtin_log2(__x);
  }
  inline constexpr float logb(float __x)
  {
    return __builtin_logbf(__x);
  }
  inline constexpr long double logb(long double __x)
  {
    return __builtin_logbl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type logb(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type logb(_Tp __x)
  {
    return __builtin_logb(__x);
  }
  inline constexpr long int lrint(float __x)
  {
    return __builtin_lrintf(__x);
  }
  inline constexpr long int lrint(long double __x)
  {
    return __builtin_lrintl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long int>::__type lrint(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long int>::__type lrint(_Tp __x)
  {
    return __builtin_lrint(__x);
  }
  inline constexpr long int lround(float __x)
  {
    return __builtin_lroundf(__x);
  }
  inline constexpr long int lround(long double __x)
  {
    return __builtin_lroundl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long int>::__type lround(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long int>::__type lround(_Tp __x)
  {
    return __builtin_lround(__x);
  }
  inline constexpr float nearbyint(float __x)
  {
    return __builtin_nearbyintf(__x);
  }
  inline constexpr long double nearbyint(long double __x)
  {
    return __builtin_nearbyintl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type nearbyint(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type nearbyint(_Tp __x)
  {
    return __builtin_nearbyint(__x);
  }
  inline constexpr float nextafter(float __x, float __y)
  {
    return __builtin_nextafterf(__x, __y);
  }
  inline constexpr long double nextafter(long double __x, long double __y)
  {
    return __builtin_nextafterl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type nextafter(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type nextafter(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return nextafter(__type(__x), __type(__y));
  }
  inline constexpr float nexttoward(float __x, long double __y)
  {
    return __builtin_nexttowardf(__x, __y);
  }
  inline constexpr long double nexttoward(long double __x, long double __y)
  {
    return __builtin_nexttowardl(__x, __y);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type nexttoward(_Tp __x, long double __y);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type nexttoward(_Tp __x, long double __y)
  {
    return __builtin_nexttoward(__x, __y);
  }
  inline constexpr float remainder(float __x, float __y)
  {
    return __builtin_remainderf(__x, __y);
  }
  inline constexpr long double remainder(long double __x, long double __y)
  {
    return __builtin_remainderl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type remainder(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type remainder(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return remainder(__type(__x), __type(__y));
  }
  inline float remquo(float __x, float __y, int *__pquo)
  {
    return __builtin_remquof(__x, __y, __pquo);
  }
  inline long double remquo(long double __x, long double __y, int *__pquo)
  {
    return __builtin_remquol(__x, __y, __pquo);
  }
  template < typename _Tp, typename _Up >
  inline typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type remquo(_Tp __x, _Up __y, int *__pquo);
  template < typename _Tp, typename _Up >
  inline typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type remquo(_Tp __x, _Up __y, int *__pquo)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return remquo(__type(__x), __type(__y), __pquo);
  }
  inline constexpr float rint(float __x)
  {
    return __builtin_rintf(__x);
  }
  inline constexpr long double rint(long double __x)
  {
    return __builtin_rintl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type rint(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type rint(_Tp __x)
  {
    return __builtin_rint(__x);
  }
  inline constexpr float round(float __x)
  {
    return __builtin_roundf(__x);
  }
  inline constexpr long double round(long double __x)
  {
    return __builtin_roundl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type round(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type round(_Tp __x)
  {
    return __builtin_round(__x);
  }
  inline constexpr float scalbln(float __x, long int __ex)
  {
    return __builtin_scalblnf(__x, __ex);
  }
  inline constexpr long double scalbln(long double __x, long int __ex)
  {
    return __builtin_scalblnl(__x, __ex);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type scalbln(_Tp __x, long int __ex);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type scalbln(_Tp __x, long int __ex)
  {
    return __builtin_scalbln(__x, __ex);
  }
  inline constexpr float scalbn(float __x, int __ex)
  {
    return __builtin_scalbnf(__x, __ex);
  }
  inline constexpr long double scalbn(long double __x, int __ex)
  {
    return __builtin_scalbnl(__x, __ex);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type scalbn(_Tp __x, int __ex);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type scalbn(_Tp __x, int __ex)
  {
    return __builtin_scalbn(__x, __ex);
  }
  inline constexpr float tgamma(float __x)
  {
    return __builtin_tgammaf(__x);
  }
  inline constexpr long double tgamma(long double __x)
  {
    return __builtin_tgammal(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tgamma(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tgamma(_Tp __x)
  {
    return __builtin_tgamma(__x);
  }
  inline constexpr float trunc(float __x)
  {
    return __builtin_truncf(__x);
  }
  inline constexpr long double trunc(long double __x)
  {
    return __builtin_truncl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type trunc(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type trunc(_Tp __x)
  {
    return __builtin_trunc(__x);
  }
  template < typename _RealType, ::std::size_t __bits, typename _UniformRandomNumberGenerator >
  _RealType generate_canonical(_UniformRandomNumberGenerator &__urng);
  namespace __detail {
    template < typename _UIntType, ::std::size_t __w, bool __nontype_tpl_param_1_2__ = __w < static_cast< ::std::size_t>(std::numeric_limits<_UIntType>::digits) >
    struct  _Shift
    {
        static const _UIntType __value = 0;
    };
    template < typename _UIntType, ::std::size_t __w >
    struct  _Shift<_UIntType, __w, true>
    {
        static const _UIntType __value = _UIntType(1) << __w;
    };
    template < int __s, int __which = (__s <= 8 * sizeof(int)) + (__s <= 8 * sizeof(long int)) + (__s <= 8 * sizeof(long long int)) + (__s <= 128) >
    struct  _Select_uint_least_t
    {
        static_assert(__which < 0, "sorry, would be too much trouble for a slow result");
    };
    template < int __s >
    struct  _Select_uint_least_t<__s, 4>
    {
        typedef unsigned int type;
    };
    template < int __s >
    struct  _Select_uint_least_t<__s, 3>
    {
        typedef unsigned long int type;
    };
    template < int __s >
    struct  _Select_uint_least_t<__s, 2>
    {
        typedef unsigned long long int type;
    };
    template < int __s >
    struct  _Select_uint_least_t<__s, 1>
    {
        typedef unsigned __int128 type;
    };
    template < typename _Tp, _Tp __m, _Tp __a, _Tp __c, bool __big_enough = !(__m & (__m - 1)) || ((_Tp( -1) - __c) / __a >= __m - 1), bool __schrage_ok = __m % __a < __m / __a >
    struct  _Mod
    {
        typedef typename ::std::__detail::_Select_uint_least_t<std::__lg(__a) + std::__lg(__m) + 2>::type _Tp2;
        static inline _Tp __calc(_Tp __x)
        {
          return static_cast<_Tp>((((typename ::std::__detail::_Mod<_Tp, __m, __a, __c, __big_enough, __schrage_ok>::_Tp2(__a))) * __x + __c) % __m);
        }
    };
    template < typename _Tp, _Tp __m, _Tp __a, _Tp __c >
    struct  _Mod<_Tp, __m, __a, __c, false, true>
    {
        static _Tp __calc(_Tp __x);
    };
    template < typename _Tp, _Tp __m, _Tp __a, _Tp __c, bool __s >
    struct  _Mod<_Tp, __m, __a, __c, true, __s>
    {
        static inline _Tp __calc(_Tp __x)
        {
          _Tp __res = __a * __x + __c;
          if (__m)
            {
              __res %= __m;
            }
          return __res;
        }
    };
    template < typename _Tp, _Tp __m, _Tp __a = 1, _Tp __c = 0 >
    inline _Tp __mod(_Tp __x);
    template < typename _Tp, _Tp __m, _Tp __a, _Tp __c >
    inline _Tp __mod(_Tp __x)
    {
      return _Mod<_Tp, __m, __a, __c>::__calc(__x);
    }
    template < typename _Tp >
    inline bool _Power_of_2(_Tp __x);
    template < typename _Tp >
    inline bool _Power_of_2(_Tp __x)
    {
      return ((__x - 1) & __x) == 0;
    }
    template < typename _Engine, typename _DInputType >
    struct  _Adaptor
    {
        inline _Adaptor(_Engine &__g)
          : _M_g(__g)
        {
        }
        inline _DInputType min() const 
        {
          return _DInputType(0);
        }
        inline _DInputType max() const 
        {
          return _DInputType(1);
        }
        inline _DInputType operator ()()
        {
          return std::generate_canonical<_DInputType, std::numeric_limits<_DInputType>::digits, _Engine>(::std::__detail::_Adaptor<_Engine, _DInputType>::_M_g);
        }
      private:
        _Engine &_M_g;
    };
  }
  template < typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m >
  class  linear_congruential_engine
  {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument substituting _UIntType not an unsigned integral type");
      static_assert(__m == 0U || (__a < __m && __c < __m), "template argument substituting __m out of bounds");
    public:
      typedef _UIntType result_type;
      static constexpr const typename ::std::linear_congruential_engine<_UIntType, __a, __c, __m>::result_type multiplier = __a;
      static constexpr const typename ::std::linear_congruential_engine<_UIntType, __a, __c, __m>::result_type increment = __c;
      static constexpr const typename ::std::linear_congruential_engine<_UIntType, __a, __c, __m>::result_type modulus = __m;
      static constexpr const typename ::std::linear_congruential_engine<_UIntType, __a, __c, __m>::result_type default_seed = 1U;
      inline explicit linear_congruential_engine(typename ::std::linear_congruential_engine<_UIntType, __a, __c, __m>::result_type __s  = (::std::linear_congruential_engine<_UIntType, __a, __c, __m>::default_seed))
      {
        (*this).seed(__s);
      }
      template < typename _Sseq, typename __type_tpl__param_2_1__ = typename ::std::enable_if<!std::is_same<_Sseq, ::std::linear_congruential_engine<_UIntType, __a, __c, __m> >::value>::type >
      inline explicit linear_congruential_engine(_Sseq &__q)
      {
        (*this).seed(__q);
      }
      void seed(typename ::std::linear_congruential_engine<_UIntType, __a, __c, __m>::result_type __s  = (::std::linear_congruential_engine<_UIntType, __a, __c, __m>::default_seed));
      template < typename _Sseq >
      typename ::std::enable_if<std::is_class<_Sseq>::value>::type seed(_Sseq &__q);
      static inline constexpr typename ::std::linear_congruential_engine<_UIntType, __a, __c, __m>::result_type min()
      {
        return __c == 0U ? 1U : 0U;
      }
      static inline constexpr typename ::std::linear_congruential_engine<_UIntType, __a, __c, __m>::result_type max()
      {
        return __m - 1U;
      }
      inline void discard(unsigned long long int __z)
      {
        for (; __z != 0LLU;  --__z)
          {
            (*this)();
          }
      }
      inline typename ::std::linear_congruential_engine<_UIntType, __a, __c, __m>::result_type operator ()()
      {
        ::std::linear_congruential_engine<_UIntType, __a, __c, __m>::_M_x = __detail::__mod<_UIntType, __m, __a, __c>(::std::linear_congruential_engine<_UIntType, __a, __c, __m>::_M_x);
        return ::std::linear_congruential_engine<_UIntType, __a, __c, __m>::_M_x;
      }
    private:
      _UIntType _M_x;
    friend inline bool operator ==(const ::std::linear_congruential_engine<_UIntType, __a, __c, __m> &__lhs, const ::std::linear_congruential_engine<_UIntType, __a, __c, __m> &__rhs)
    {
      return __lhs._M_x == __rhs._M_x;
    }
    template < typename _UIntType1, _UIntType1 __a1, _UIntType1 __c1, _UIntType1 __m1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::linear_congruential_engine<_UIntType1, __a1, __c1, __m1> &);
    template < typename _UIntType1, _UIntType1 __a1, _UIntType1 __c1, _UIntType1 __m1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::linear_congruential_engine<_UIntType1, __a1, __c1, __m1> &);
  };
  template < typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m >
  inline bool operator !=(const ::std::linear_congruential_engine<_UIntType, __a, __c, __m> &__lhs, const ::std::linear_congruential_engine<_UIntType, __a, __c, __m> &__rhs);
  template < typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m >
  inline bool operator !=(const ::std::linear_congruential_engine<_UIntType, __a, __c, __m> &__lhs, const ::std::linear_congruential_engine<_UIntType, __a, __c, __m> &__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __n, ::std::size_t __m, ::std::size_t __r, _UIntType __a, ::std::size_t __u, _UIntType __d, ::std::size_t __s, _UIntType __b, ::std::size_t __t, _UIntType __c, ::std::size_t __l, _UIntType __f >
  class  mersenne_twister_engine
  {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument substituting _UIntType not an unsigned integral type");
      static_assert(1U <= __m && __m <= __n, "template argument substituting __m out of bounds");
      static_assert(__r <= __w, "template argument substituting __r out of bound");
      static_assert(__u <= __w, "template argument substituting __u out of bound");
      static_assert(__s <= __w, "template argument substituting __s out of bound");
      static_assert(__t <= __w, "template argument substituting __t out of bound");
      static_assert(__l <= __w, "template argument substituting __l out of bound");
      static_assert(__w <= std::numeric_limits<_UIntType>::digits, "template argument substituting __w out of bound");
      static_assert(__a <= __detail::_Shift<_UIntType, __w>::__value - 1, "template argument substituting __a out of bound");
      static_assert(__b <= __detail::_Shift<_UIntType, __w>::__value - 1, "template argument substituting __b out of bound");
      static_assert(__c <= __detail::_Shift<_UIntType, __w>::__value - 1, "template argument substituting __c out of bound");
      static_assert(__d <= __detail::_Shift<_UIntType, __w>::__value - 1, "template argument substituting __d out of bound");
      static_assert(__f <= __detail::_Shift<_UIntType, __w>::__value - 1, "template argument substituting __f out of bound");
    public:
      typedef _UIntType result_type;
      static constexpr const ::std::size_t word_size = __w;
      static constexpr const ::std::size_t state_size = __n;
      static constexpr const ::std::size_t shift_size = __m;
      static constexpr const ::std::size_t mask_bits = __r;
      static constexpr const typename ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type xor_mask = __a;
      static constexpr const ::std::size_t tempering_u = __u;
      static constexpr const typename ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type tempering_d = __d;
      static constexpr const ::std::size_t tempering_s = __s;
      static constexpr const typename ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type tempering_b = __b;
      static constexpr const ::std::size_t tempering_t = __t;
      static constexpr const typename ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type tempering_c = __c;
      static constexpr const ::std::size_t tempering_l = __l;
      static constexpr const typename ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type initialization_multiplier = __f;
      static constexpr const typename ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type default_seed = 5489U;
      inline explicit mersenne_twister_engine(typename ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type __sd  = (::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::default_seed))
      {
        (*this).seed(__sd);
      }
      template < typename _Sseq, typename __type_tpl__param_2_1__ = typename ::std::enable_if<!std::is_same<_Sseq, ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> >::value>::type >
      inline explicit mersenne_twister_engine(_Sseq &__q)
      {
        (*this).seed(__q);
      }
      void seed(typename ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type __sd  = (::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::default_seed));
      template < typename _Sseq >
      typename ::std::enable_if<std::is_class<_Sseq>::value>::type seed(_Sseq &__q);
      static inline constexpr typename ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type min()
      {
        return 0;
      }
      static inline constexpr typename ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type max()
      {
        return __detail::_Shift<_UIntType, __w>::__value - 1;
      }
      void discard(unsigned long long int __z);
      typename ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type operator ()();
    private:
      void _M_gen_rand();
      _UIntType _M_x[::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::state_size];
      ::std::size_t _M_p;
    friend inline bool operator ==(const ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> &__lhs, const ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> &__rhs)
    {
      return std::equal(__lhs._M_x, __lhs._M_x + ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::state_size, __rhs._M_x) && __lhs._M_p == __rhs._M_p;
    }
    template < typename _UIntType1, ::std::size_t __w1, ::std::size_t __n1, ::std::size_t __m1, ::std::size_t __r1, _UIntType1 __a1, ::std::size_t __u1, _UIntType1 __d1, ::std::size_t __s1, _UIntType1 __b1, ::std::size_t __t1, _UIntType1 __c1, ::std::size_t __l1, _UIntType1 __f1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::mersenne_twister_engine<_UIntType1, __w1, __n1, __m1, __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1, __l1, __f1> &);
    template < typename _UIntType1, ::std::size_t __w1, ::std::size_t __n1, ::std::size_t __m1, ::std::size_t __r1, _UIntType1 __a1, ::std::size_t __u1, _UIntType1 __d1, ::std::size_t __s1, _UIntType1 __b1, ::std::size_t __t1, _UIntType1 __c1, ::std::size_t __l1, _UIntType1 __f1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::mersenne_twister_engine<_UIntType1, __w1, __n1, __m1, __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1, __l1, __f1> &);
  };
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __n, ::std::size_t __m, ::std::size_t __r, _UIntType __a, ::std::size_t __u, _UIntType __d, ::std::size_t __s, _UIntType __b, ::std::size_t __t, _UIntType __c, ::std::size_t __l, _UIntType __f >
  inline bool operator !=(const ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> &__lhs, const ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> &__rhs);
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __n, ::std::size_t __m, ::std::size_t __r, _UIntType __a, ::std::size_t __u, _UIntType __d, ::std::size_t __s, _UIntType __b, ::std::size_t __t, _UIntType __c, ::std::size_t __l, _UIntType __f >
  inline bool operator !=(const ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> &__lhs, const ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> &__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __s, ::std::size_t __r >
  class  subtract_with_carry_engine
  {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument substituting _UIntType not an unsigned integral type");
      static_assert(0U < __s && __s < __r, "template argument substituting __s out of bounds");
      static_assert(0U < __w && __w <= std::numeric_limits<_UIntType>::digits, "template argument substituting __w out of bounds");
    public:
      typedef _UIntType result_type;
      static constexpr const ::std::size_t word_size = __w;
      static constexpr const ::std::size_t short_lag = __s;
      static constexpr const ::std::size_t long_lag = __r;
      static constexpr const typename ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::result_type default_seed = 19780503U;
      inline explicit subtract_with_carry_engine(typename ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::result_type __sd  = (::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::default_seed))
      {
        (*this).seed(__sd);
      }
      template < typename _Sseq, typename __type_tpl__param_2_1__ = typename ::std::enable_if<!std::is_same<_Sseq, ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r> >::value>::type >
      inline explicit subtract_with_carry_engine(_Sseq &__q)
      {
        (*this).seed(__q);
      }
      void seed(typename ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::result_type __value  = (::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::default_seed));
      template < typename _Sseq >
      typename ::std::enable_if<std::is_class<_Sseq>::value>::type seed(_Sseq &__q);
      static inline constexpr typename ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::result_type min()
      {
        return 0;
      }
      static inline constexpr typename ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::result_type max()
      {
        return __detail::_Shift<_UIntType, __w>::__value - 1;
      }
      inline void discard(unsigned long long int __z)
      {
        for (; __z != 0LLU;  --__z)
          {
            (*this)();
          }
      }
      typename ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::result_type operator ()();
    private:
      _UIntType _M_x[::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag];
      _UIntType _M_carry;
      ::std::size_t _M_p;
    friend inline bool operator ==(const ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r> &__lhs, const ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r> &__rhs)
    {
      return (std::equal(__lhs._M_x, __lhs._M_x + ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag, __rhs._M_x) && __lhs._M_carry == __rhs._M_carry) && __lhs._M_p == __rhs._M_p;
    }
    template < typename _UIntType1, ::std::size_t __w1, ::std::size_t __s1, ::std::size_t __r1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::subtract_with_carry_engine<_UIntType1, __w1, __s1, __r1> &);
    template < typename _UIntType1, ::std::size_t __w1, ::std::size_t __s1, ::std::size_t __r1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::subtract_with_carry_engine<_UIntType1, __w1, __s1, __r1> &);
  };
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __s, ::std::size_t __r >
  inline bool operator !=(const ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r> &__lhs, const ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r> &__rhs);
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __s, ::std::size_t __r >
  inline bool operator !=(const ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r> &__lhs, const ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r> &__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _RandomNumberEngine, ::std::size_t __p, ::std::size_t __r >
  class  discard_block_engine
  {
      static_assert(1 <= __r && __r <= __p, "template argument substituting __r out of bounds");
    public:
      typedef typename _RandomNumberEngine::result_type result_type;
      static constexpr const ::std::size_t block_size = __p;
      static constexpr const ::std::size_t used_block = __r;
      inline discard_block_engine()
        : _M_b(), _M_n(0)
      {
      }
      inline explicit discard_block_engine(const _RandomNumberEngine &__rng)
        : _M_b(__rng), _M_n(0)
      {
      }
      inline explicit discard_block_engine(_RandomNumberEngine &&__rng)
        : _M_b(std::move(__rng)), _M_n(0)
      {
      }
      inline explicit discard_block_engine(typename ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::result_type __s)
        : _M_b(__s), _M_n(0)
      {
      }
      template < typename _Sseq, typename __type_tpl__param_2_1__ = typename ::std::enable_if<!std::is_same<_Sseq, ::std::discard_block_engine<_RandomNumberEngine, __p, __r> >::value && !std::is_same<_Sseq, _RandomNumberEngine>::value>::type >
      inline explicit discard_block_engine(_Sseq &__q)
        : _M_b(__q), _M_n(0)
      {
      }
      inline void seed()
      {
        ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::_M_b.seed();
        ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::_M_n = 0;
      }
      inline void seed(typename ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::result_type __s)
      {
        ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::_M_b.seed(__s);
        ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::_M_n = 0;
      }
      template < typename _Sseq >
      inline void seed(_Sseq &__q)
      {
        ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::_M_b.seed(__q);
        ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::_M_n = 0;
      }
      inline const _RandomNumberEngine &base() const  noexcept(true)
      {
        return ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::_M_b;
      }
      static inline constexpr typename ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::result_type min()
      {
        return _RandomNumberEngine::min();
      }
      static inline constexpr typename ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::result_type max()
      {
        return _RandomNumberEngine::max();
      }
      inline void discard(unsigned long long int __z)
      {
        for (; __z != 0LLU;  --__z)
          {
            (*this)();
          }
      }
      typename ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::result_type operator ()();
    private:
      _RandomNumberEngine _M_b;
      ::std::size_t _M_n;
    friend inline bool operator ==(const ::std::discard_block_engine<_RandomNumberEngine, __p, __r> &__lhs, const ::std::discard_block_engine<_RandomNumberEngine, __p, __r> &__rhs)
    {
      return __lhs._M_b == __rhs._M_b && __lhs._M_n == __rhs._M_n;
    }
    template < typename _RandomNumberEngine1, ::std::size_t __p1, ::std::size_t __r1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::discard_block_engine<_RandomNumberEngine1, __p1, __r1> &);
    template < typename _RandomNumberEngine1, ::std::size_t __p1, ::std::size_t __r1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::discard_block_engine<_RandomNumberEngine1, __p1, __r1> &);
  };
  template < typename _RandomNumberEngine, ::std::size_t __p, ::std::size_t __r >
  inline bool operator !=(const ::std::discard_block_engine<_RandomNumberEngine, __p, __r> &__lhs, const ::std::discard_block_engine<_RandomNumberEngine, __p, __r> &__rhs);
  template < typename _RandomNumberEngine, ::std::size_t __p, ::std::size_t __r >
  inline bool operator !=(const ::std::discard_block_engine<_RandomNumberEngine, __p, __r> &__lhs, const ::std::discard_block_engine<_RandomNumberEngine, __p, __r> &__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _RandomNumberEngine, ::std::size_t __w, typename _UIntType >
  class  independent_bits_engine
  {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument substituting _UIntType not an unsigned integral type");
      static_assert(0U < __w && __w <= std::numeric_limits<_UIntType>::digits, "template argument substituting __w out of bounds");
    public:
      typedef _UIntType result_type;
      inline independent_bits_engine()
        : _M_b()
      {
      }
      inline explicit independent_bits_engine(const _RandomNumberEngine &__rng)
        : _M_b(__rng)
      {
      }
      inline explicit independent_bits_engine(_RandomNumberEngine &&__rng)
        : _M_b(std::move(__rng))
      {
      }
      inline explicit independent_bits_engine(typename ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::result_type __s)
        : _M_b(__s)
      {
      }
      template < typename _Sseq, typename __type_tpl__param_2_1__ = typename ::std::enable_if<!std::is_same<_Sseq, ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType> >::value && !std::is_same<_Sseq, _RandomNumberEngine>::value>::type >
      inline explicit independent_bits_engine(_Sseq &__q)
        : _M_b(__q)
      {
      }
      inline void seed()
      {
        ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::_M_b.seed();
      }
      inline void seed(typename ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::result_type __s)
      {
        ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::_M_b.seed(__s);
      }
      template < typename _Sseq >
      inline void seed(_Sseq &__q)
      {
        ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::_M_b.seed(__q);
      }
      inline const _RandomNumberEngine &base() const  noexcept(true)
      {
        return ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::_M_b;
      }
      static inline constexpr typename ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::result_type min()
      {
        return 0U;
      }
      static inline constexpr typename ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::result_type max()
      {
        return __detail::_Shift<_UIntType, __w>::__value - 1;
      }
      inline void discard(unsigned long long int __z)
      {
        for (; __z != 0LLU;  --__z)
          {
            (*this)();
          }
      }
      typename ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::result_type operator ()();
    private:
      _RandomNumberEngine _M_b;
    friend inline bool operator ==(const ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType> &__lhs, const ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType> &__rhs)
    {
      return __lhs._M_b == __rhs._M_b;
    }
    template < typename _CharT, typename _Traits >
    friend inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType> &__x)
    {
      __is >> __x._M_b;
      return __is;
    }
  };
  template < typename _RandomNumberEngine, ::std::size_t __w, typename _UIntType >
  inline bool operator !=(const ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType> &__lhs, const ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType> &__rhs);
  template < typename _RandomNumberEngine, ::std::size_t __w, typename _UIntType >
  inline bool operator !=(const ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType> &__lhs, const ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType> &__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _RandomNumberEngine, ::std::size_t __w, typename _UIntType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType> &__x);
  template < typename _RandomNumberEngine, ::std::size_t __w, typename _UIntType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType> &__x)
  {
    __os << __x.base();
    return __os;
  }
  template < typename _RandomNumberEngine, ::std::size_t __k >
  class  shuffle_order_engine
  {
      static_assert(1U <= __k, "template argument substituting __k out of bound");
    public:
      typedef typename _RandomNumberEngine::result_type result_type;
      static constexpr const ::std::size_t table_size = __k;
      inline shuffle_order_engine()
        : _M_b()
      {
        (*this)._M_initialize();
      }
      inline explicit shuffle_order_engine(const _RandomNumberEngine &__rng)
        : _M_b(__rng)
      {
        (*this)._M_initialize();
      }
      inline explicit shuffle_order_engine(_RandomNumberEngine &&__rng)
        : _M_b(std::move(__rng))
      {
        (*this)._M_initialize();
      }
      inline explicit shuffle_order_engine(typename ::std::shuffle_order_engine<_RandomNumberEngine, __k>::result_type __s)
        : _M_b(__s)
      {
        (*this)._M_initialize();
      }
      template < typename _Sseq, typename __type_tpl__param_2_1__ = typename ::std::enable_if<!std::is_same<_Sseq, ::std::shuffle_order_engine<_RandomNumberEngine, __k> >::value && !std::is_same<_Sseq, _RandomNumberEngine>::value>::type >
      inline explicit shuffle_order_engine(_Sseq &__q)
        : _M_b(__q)
      {
        (*this)._M_initialize();
      }
      inline void seed()
      {
        ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_b.seed();
        (*this)._M_initialize();
      }
      inline void seed(typename ::std::shuffle_order_engine<_RandomNumberEngine, __k>::result_type __s)
      {
        ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_b.seed(__s);
        (*this)._M_initialize();
      }
      template < typename _Sseq >
      inline void seed(_Sseq &__q)
      {
        ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_b.seed(__q);
        (*this)._M_initialize();
      }
      inline const _RandomNumberEngine &base() const  noexcept(true)
      {
        return ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_b;
      }
      static inline constexpr typename ::std::shuffle_order_engine<_RandomNumberEngine, __k>::result_type min()
      {
        return _RandomNumberEngine::min();
      }
      static inline constexpr typename ::std::shuffle_order_engine<_RandomNumberEngine, __k>::result_type max()
      {
        return _RandomNumberEngine::max();
      }
      inline void discard(unsigned long long int __z)
      {
        for (; __z != 0LLU;  --__z)
          {
            (*this)();
          }
      }
      typename ::std::shuffle_order_engine<_RandomNumberEngine, __k>::result_type operator ()();
    private:
      inline void _M_initialize()
      {
        for (::std::size_t __i(0); __i < __k;  ++__i)
          {
            ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_v[__i] = ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_b();
          }
        ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_y = ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_b();
      }
      _RandomNumberEngine _M_b;
      typename ::std::shuffle_order_engine<_RandomNumberEngine, __k>::result_type _M_v[__k];
      typename ::std::shuffle_order_engine<_RandomNumberEngine, __k>::result_type _M_y;
    friend inline bool operator ==(const ::std::shuffle_order_engine<_RandomNumberEngine, __k> &__lhs, const ::std::shuffle_order_engine<_RandomNumberEngine, __k> &__rhs)
    {
      return (__lhs._M_b == __rhs._M_b && std::equal(__lhs._M_v, __lhs._M_v + __k, __rhs._M_v)) && __lhs._M_y == __rhs._M_y;
    }
    template < typename _RandomNumberEngine1, ::std::size_t __k1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::shuffle_order_engine<_RandomNumberEngine1, __k1> &);
    template < typename _RandomNumberEngine1, ::std::size_t __k1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::shuffle_order_engine<_RandomNumberEngine1, __k1> &);
  };
  template < typename _RandomNumberEngine, ::std::size_t __k >
  inline bool operator !=(const ::std::shuffle_order_engine<_RandomNumberEngine, __k> &__lhs, const ::std::shuffle_order_engine<_RandomNumberEngine, __k> &__rhs);
  template < typename _RandomNumberEngine, ::std::size_t __k >
  inline bool operator !=(const ::std::shuffle_order_engine<_RandomNumberEngine, __k> &__lhs, const ::std::shuffle_order_engine<_RandomNumberEngine, __k> &__rhs)
  {
    return !(__lhs == __rhs);
  }
  typedef ::std::linear_congruential_engine<unsigned long int, 16807LU, 0LU, 2147483647LU> minstd_rand0;
  typedef ::std::linear_congruential_engine<unsigned long int, 48271LU, 0LU, 2147483647LU> minstd_rand;
  typedef ::std::mersenne_twister_engine<unsigned long int, 32LU, 624LU, 397LU, 31LU, 2567483615LU, 11LU, 4294967295LU, 7LU, 2636928640LU, 15LU, 4022730752LU, 18LU, 1812433253LU> mt19937;
  typedef ::std::mersenne_twister_engine<unsigned long int, 64LU, 312LU, 156LU, 31LU, 13043109905998158313LLU, 29LU, 6148914691236517205LLU, 17LU, 8202884508482404352LLU, 37LU, 18444473444759240704LLU, 43LU, 6364136223846793005LLU> mt19937_64;
  typedef ::std::subtract_with_carry_engine<unsigned long int, 24LU, 10LU, 24LU> ranlux24_base;
  typedef ::std::subtract_with_carry_engine<unsigned long int, 48LU, 5LU, 12LU> ranlux48_base;
  typedef ::std::discard_block_engine< ::std::subtract_with_carry_engine<unsigned long int, 24LU, 10LU, 24LU>, 223LU, 23LU> ranlux24;
  typedef ::std::discard_block_engine< ::std::subtract_with_carry_engine<unsigned long int, 48LU, 5LU, 12LU>, 389LU, 11LU> ranlux48;
  typedef ::std::shuffle_order_engine< ::std::linear_congruential_engine<unsigned long int, 16807LU, 0LU, 2147483647LU>, 256LU> knuth_b;
  typedef ::std::minstd_rand0 default_random_engine;
 /* Instantiation of class template '::std::remove_volatile<unsigned long int>' */ 
 /* Instantiation of class template '::std::remove_const<unsigned long int>' */ 
 /* Instantiation of class template '::std::remove_cv<unsigned long int>' */ 
 /* Instantiation of class template '::std::is_integral<unsigned long int>' */ 
 /* Instantiation of class template '::std::conditional<true, ::std::is_integral<unsigned long int>, ::std::is_floating_point<unsigned long int> >' */ 
 /* Instantiation of class template '::std::__or_< ::std::is_integral<unsigned long int>, ::std::is_floating_point<unsigned long int> >' */ 
 /* Instantiation of class template '::std::is_arithmetic<unsigned long int>' */ 
 /* Instantiation of class template '::std::conditional<true, ::std::__not_< ::std::is_signed<unsigned long int> >, ::std::is_arithmetic<unsigned long int> >' */ 
 /* Instantiation of class template '::std::__is_floating_point_helper<unsigned long int>' */ 
 /* Instantiation of class template '::std::is_floating_point<unsigned long int>' */ 
 /* Instantiation of class template '::std::__is_signed_helper<unsigned long int, true, false>' */ 
 /* Instantiation of class template '::std::is_signed<unsigned long int>' */ 
 /* Instantiation of class template '::std::__not_< ::std::is_signed<unsigned long int> >' */ 
 /* Instantiation of class template '::std::__and_< ::std::is_arithmetic<unsigned long int>, ::std::__not_< ::std::is_signed<unsigned long int> > >' */ 
 /* Instantiation of class template '::std::is_unsigned<unsigned long int>' */ 
 /* Instantiation of class template '::std::__detail::_Shift<unsigned long int, 32LU, true>' */ 
 /* Instantiation of class template '::std::mersenne_twister_engine<unsigned long int, 32LU, 624LU, 397LU, 31LU, 2567483615LU, 11LU, 4294967295LU, 7LU, 2636928640LU, 15LU, 4022730752LU, 18LU, 1812433253LU>' */ 
 /* Instantiation of template function '::std::mersenne_twister_engine<unsigned long int, 32LU, 624LU, 397LU, 31LU, 2567483615LU, 11LU, 4294967295LU, 7LU, 2636928640LU, 15LU, 4022730752LU, 18LU, 1812433253LU>::mersenne_twister_engine(unsigned long int)' */ 
  class  random_device
  {
    public:
      typedef unsigned int result_type;
      inline explicit random_device(const ::std::string &__token  = ("default"))
      {
        (*this).::std::random_device::_M_init(__token);
      }
      inline ~random_device()
      {
        (*this).::std::random_device::_M_fini();
      }
      static inline constexpr ::std::random_device::result_type min()
      {
        return std::numeric_limits< ::std::random_device::result_type>::min();
      }
      static inline constexpr ::std::random_device::result_type max()
      {
        return std::numeric_limits< ::std::random_device::result_type>::max();
      }
      inline double entropy() const  noexcept(true)
      {
        return 0.00000000000000000000000000000000000000000000000000000e+00;
      }
      inline ::std::random_device::result_type operator ()()
      {
        return (*this).::std::random_device::_M_getval();
      }
      random_device(const ::std::random_device &) = delete ;
      void operator =(const ::std::random_device &) = delete ;
    private:
      void _M_init(const ::std::string &__token);
      void _M_init_pretr1(const ::std::string &__token);
      void _M_fini();
      ::std::random_device::result_type _M_getval();
      ::std::random_device::result_type _M_getval_pretr1();
      union 
      {
          ::FILE *_M_file;
          ::std::mt19937 _M_mt;
      };
  };
  template < typename _IntType = int >
  class  uniform_int_distribution
  {
      static_assert(std::is_integral<_IntType>::value, "template argument not an integral type");
    public:
      typedef _IntType result_type;
      struct  param_type
      {
          typedef ::std::uniform_int_distribution<_IntType> distribution_type;
          inline explicit param_type(_IntType __a  = (0), _IntType __b  = (std::numeric_limits<_IntType>::max()))
            : _M_a(__a), _M_b(__b)
          {
            ;
          }
          inline typename ::std::uniform_int_distribution<_IntType>::result_type a() const 
          {
            return ::std::uniform_int_distribution<_IntType>::param_type::_M_a;
          }
          inline typename ::std::uniform_int_distribution<_IntType>::result_type b() const 
          {
            return ::std::uniform_int_distribution<_IntType>::param_type::_M_b;
          }
        private:
          _IntType _M_a;
          _IntType _M_b;
        friend inline bool operator ==(const typename ::std::uniform_int_distribution<_IntType>::param_type &__p1, const typename ::std::uniform_int_distribution<_IntType>::param_type &__p2)
        {
          return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b;
        }
      };
      inline explicit uniform_int_distribution(_IntType __a  = (0), _IntType __b  = (std::numeric_limits<_IntType>::max()))
        : _M_param(__a, __b)
      {
      }
      inline explicit uniform_int_distribution(const typename ::std::uniform_int_distribution<_IntType>::param_type &__p)
        : _M_param(__p)
      {
      }
      inline void reset()
      {
      }
      inline typename ::std::uniform_int_distribution<_IntType>::result_type a() const 
      {
        return ::std::uniform_int_distribution<_IntType>::_M_param.a();
      }
      inline typename ::std::uniform_int_distribution<_IntType>::result_type b() const 
      {
        return ::std::uniform_int_distribution<_IntType>::_M_param.b();
      }
      inline typename ::std::uniform_int_distribution<_IntType>::param_type param() const 
      {
        return ::std::uniform_int_distribution<_IntType>::_M_param;
      }
      inline void param(const typename ::std::uniform_int_distribution<_IntType>::param_type &__param)
      {
        ::std::uniform_int_distribution<_IntType>::_M_param = __param;
      }
      inline typename ::std::uniform_int_distribution<_IntType>::result_type min() const 
      {
        return this->a();
      }
      inline typename ::std::uniform_int_distribution<_IntType>::result_type max() const 
      {
        return this->b();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::uniform_int_distribution<_IntType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::uniform_int_distribution<_IntType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      typename ::std::uniform_int_distribution<_IntType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::uniform_int_distribution<_IntType>::param_type &__param);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::uniform_int_distribution<_IntType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::uniform_int_distribution<_IntType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::uniform_int_distribution<_IntType>::result_type *__f, typename ::std::uniform_int_distribution<_IntType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::uniform_int_distribution<_IntType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::uniform_int_distribution<_IntType>::param_type &__param);
      typename ::std::uniform_int_distribution<_IntType>::param_type _M_param;
    friend inline bool operator ==(const ::std::uniform_int_distribution<_IntType> &__d1, const ::std::uniform_int_distribution<_IntType> &__d2)
    {
      return __d1._M_param == __d2._M_param;
    }
  };
  template < typename _IntType >
  inline bool operator !=(const ::std::uniform_int_distribution<_IntType> &__d1, const ::std::uniform_int_distribution<_IntType> &__d2);
  template < typename _IntType >
  inline bool operator !=(const ::std::uniform_int_distribution<_IntType> &__d1, const ::std::uniform_int_distribution<_IntType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::uniform_int_distribution<_IntType> &__x);
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::uniform_int_distribution<_IntType> &__x);
  template < typename _RealType = double >
  class  uniform_real_distribution
  {
      static_assert(std::is_floating_point<_RealType>::value, "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct  param_type
      {
          typedef ::std::uniform_real_distribution<_RealType> distribution_type;
          inline explicit param_type(_RealType __a  = (_RealType(0)), _RealType __b  = (_RealType(1)))
            : _M_a(__a), _M_b(__b)
          {
            ;
          }
          inline typename ::std::uniform_real_distribution<_RealType>::result_type a() const 
          {
            return ::std::uniform_real_distribution<_RealType>::param_type::_M_a;
          }
          inline typename ::std::uniform_real_distribution<_RealType>::result_type b() const 
          {
            return ::std::uniform_real_distribution<_RealType>::param_type::_M_b;
          }
        private:
          _RealType _M_a;
          _RealType _M_b;
        friend inline bool operator ==(const typename ::std::uniform_real_distribution<_RealType>::param_type &__p1, const typename ::std::uniform_real_distribution<_RealType>::param_type &__p2)
        {
          return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b;
        }
      };
      inline explicit uniform_real_distribution(_RealType __a  = (_RealType(0)), _RealType __b  = (_RealType(1)))
        : _M_param(__a, __b)
      {
      }
      inline explicit uniform_real_distribution(const typename ::std::uniform_real_distribution<_RealType>::param_type &__p)
        : _M_param(__p)
      {
      }
      inline void reset()
      {
      }
      inline typename ::std::uniform_real_distribution<_RealType>::result_type a() const 
      {
        return ::std::uniform_real_distribution<_RealType>::_M_param.a();
      }
      inline typename ::std::uniform_real_distribution<_RealType>::result_type b() const 
      {
        return ::std::uniform_real_distribution<_RealType>::_M_param.b();
      }
      inline typename ::std::uniform_real_distribution<_RealType>::param_type param() const 
      {
        return ::std::uniform_real_distribution<_RealType>::_M_param;
      }
      inline void param(const typename ::std::uniform_real_distribution<_RealType>::param_type &__param)
      {
        ::std::uniform_real_distribution<_RealType>::_M_param = __param;
      }
      inline typename ::std::uniform_real_distribution<_RealType>::result_type min() const 
      {
        return this->a();
      }
      inline typename ::std::uniform_real_distribution<_RealType>::result_type max() const 
      {
        return this->b();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::uniform_real_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::uniform_real_distribution<_RealType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::uniform_real_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::uniform_real_distribution<_RealType>::param_type &__p)
      {
        ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, typename ::std::uniform_real_distribution<_RealType>::result_type> __aurng(__urng);
        return __aurng() * (__p.b() - __p.a()) + __p.a();
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::uniform_real_distribution<_RealType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::uniform_real_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::uniform_real_distribution<_RealType>::result_type *__f, typename ::std::uniform_real_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::uniform_real_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::uniform_real_distribution<_RealType>::param_type &__p);
      typename ::std::uniform_real_distribution<_RealType>::param_type _M_param;
    friend inline bool operator ==(const ::std::uniform_real_distribution<_RealType> &__d1, const ::std::uniform_real_distribution<_RealType> &__d2)
    {
      return __d1._M_param == __d2._M_param;
    }
  };
  template < typename _IntType >
  inline bool operator !=(const ::std::uniform_real_distribution<_IntType> &__d1, const ::std::uniform_real_distribution<_IntType> &__d2);
  template < typename _IntType >
  inline bool operator !=(const ::std::uniform_real_distribution<_IntType> &__d1, const ::std::uniform_real_distribution<_IntType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::uniform_real_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::uniform_real_distribution<_RealType> &__x);
  template < typename _RealType = double >
  class  normal_distribution
  {
      static_assert(std::is_floating_point<_RealType>::value, "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct  param_type
      {
          typedef ::std::normal_distribution<_RealType> distribution_type;
          inline explicit param_type(_RealType __mean  = (_RealType(0)), _RealType __stddev  = (_RealType(1)))
            : _M_mean(__mean), _M_stddev(__stddev)
          {
            ;
          }
          inline _RealType mean() const 
          {
            return ::std::normal_distribution<_RealType>::param_type::_M_mean;
          }
          inline _RealType stddev() const 
          {
            return ::std::normal_distribution<_RealType>::param_type::_M_stddev;
          }
        private:
          _RealType _M_mean;
          _RealType _M_stddev;
        friend inline bool operator ==(const typename ::std::normal_distribution<_RealType>::param_type &__p1, const typename ::std::normal_distribution<_RealType>::param_type &__p2)
        {
          return __p1._M_mean == __p2._M_mean && __p1._M_stddev == __p2._M_stddev;
        }
      };
      inline explicit normal_distribution(typename ::std::normal_distribution<_RealType>::result_type __mean  = (((typename ::std::normal_distribution<_RealType>::result_type(0)))), typename ::std::normal_distribution<_RealType>::result_type __stddev  = (((typename ::std::normal_distribution<_RealType>::result_type(1)))))
        : _M_param(__mean, __stddev), _M_saved_available(false)
      {
      }
      inline explicit normal_distribution(const typename ::std::normal_distribution<_RealType>::param_type &__p)
        : _M_param(__p), _M_saved_available(false)
      {
      }
      inline void reset()
      {
        ::std::normal_distribution<_RealType>::_M_saved_available = false;
      }
      inline _RealType mean() const 
      {
        return ::std::normal_distribution<_RealType>::_M_param.mean();
      }
      inline _RealType stddev() const 
      {
        return ::std::normal_distribution<_RealType>::_M_param.stddev();
      }
      inline typename ::std::normal_distribution<_RealType>::param_type param() const 
      {
        return ::std::normal_distribution<_RealType>::_M_param;
      }
      inline void param(const typename ::std::normal_distribution<_RealType>::param_type &__param)
      {
        ::std::normal_distribution<_RealType>::_M_param = __param;
      }
      inline typename ::std::normal_distribution<_RealType>::result_type min() const 
      {
        return std::numeric_limits<typename ::std::normal_distribution<_RealType>::result_type>::lowest();
      }
      inline typename ::std::normal_distribution<_RealType>::result_type max() const 
      {
        return std::numeric_limits<typename ::std::normal_distribution<_RealType>::result_type>::max();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::normal_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::normal_distribution<_RealType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      typename ::std::normal_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::normal_distribution<_RealType>::param_type &__param);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::normal_distribution<_RealType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::normal_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::normal_distribution<_RealType>::result_type *__f, typename ::std::normal_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::normal_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::normal_distribution<_RealType>::param_type &__param);
      typename ::std::normal_distribution<_RealType>::param_type _M_param;
      typename ::std::normal_distribution<_RealType>::result_type _M_saved;
      bool _M_saved_available;
    template < typename _RealType1 >
    friend bool operator ==(const ::std::normal_distribution<_RealType1> &, const ::std::normal_distribution<_RealType1> &);
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::normal_distribution<_RealType1> &);
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::normal_distribution<_RealType1> &);
  };
  template < typename _RealType >
  inline bool operator !=(const ::std::normal_distribution<_RealType> &__d1, const ::std::normal_distribution<_RealType> &__d2);
  template < typename _RealType >
  inline bool operator !=(const ::std::normal_distribution<_RealType> &__d1, const ::std::normal_distribution<_RealType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _RealType = double >
  class  lognormal_distribution
  {
      static_assert(std::is_floating_point<_RealType>::value, "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct  param_type
      {
          typedef ::std::lognormal_distribution<_RealType> distribution_type;
          inline explicit param_type(_RealType __m  = (_RealType(0)), _RealType __s  = (_RealType(1)))
            : _M_m(__m), _M_s(__s)
          {
          }
          inline _RealType m() const 
          {
            return ::std::lognormal_distribution<_RealType>::param_type::_M_m;
          }
          inline _RealType s() const 
          {
            return ::std::lognormal_distribution<_RealType>::param_type::_M_s;
          }
        private:
          _RealType _M_m;
          _RealType _M_s;
        friend inline bool operator ==(const typename ::std::lognormal_distribution<_RealType>::param_type &__p1, const typename ::std::lognormal_distribution<_RealType>::param_type &__p2)
        {
          return __p1._M_m == __p2._M_m && __p1._M_s == __p2._M_s;
        }
      };
      inline explicit lognormal_distribution(_RealType __m  = (_RealType(0)), _RealType __s  = (_RealType(1)))
        : _M_param(__m, __s), _M_nd()
      {
      }
      inline explicit lognormal_distribution(const typename ::std::lognormal_distribution<_RealType>::param_type &__p)
        : _M_param(__p), _M_nd()
      {
      }
      inline void reset()
      {
        ::std::lognormal_distribution<_RealType>::_M_nd.reset();
      }
      inline _RealType m() const 
      {
        return ::std::lognormal_distribution<_RealType>::_M_param.m();
      }
      inline _RealType s() const 
      {
        return ::std::lognormal_distribution<_RealType>::_M_param.s();
      }
      inline typename ::std::lognormal_distribution<_RealType>::param_type param() const 
      {
        return ::std::lognormal_distribution<_RealType>::_M_param;
      }
      inline void param(const typename ::std::lognormal_distribution<_RealType>::param_type &__param)
      {
        ::std::lognormal_distribution<_RealType>::_M_param = __param;
      }
      inline typename ::std::lognormal_distribution<_RealType>::result_type min() const 
      {
        return ((typename ::std::lognormal_distribution<_RealType>::result_type(0)));
      }
      inline typename ::std::lognormal_distribution<_RealType>::result_type max() const 
      {
        return std::numeric_limits<typename ::std::lognormal_distribution<_RealType>::result_type>::max();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::lognormal_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::lognormal_distribution<_RealType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::lognormal_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::lognormal_distribution<_RealType>::param_type &__p)
      {
        return std::exp(__p.s() * ::std::lognormal_distribution<_RealType>::_M_nd(__urng) + __p.m());
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::lognormal_distribution<_RealType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::lognormal_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::lognormal_distribution<_RealType>::result_type *__f, typename ::std::lognormal_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::lognormal_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::lognormal_distribution<_RealType>::param_type &__p);
      typename ::std::lognormal_distribution<_RealType>::param_type _M_param;
      ::std::normal_distribution<typename ::std::lognormal_distribution<_RealType>::result_type> _M_nd;
    friend inline bool operator ==(const ::std::lognormal_distribution<_RealType> &__d1, const ::std::lognormal_distribution<_RealType> &__d2)
    {
      return __d1._M_param == __d2._M_param && __d1._M_nd == __d2._M_nd;
    }
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::lognormal_distribution<_RealType1> &);
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::lognormal_distribution<_RealType1> &);
  };
  template < typename _RealType >
  inline bool operator !=(const ::std::lognormal_distribution<_RealType> &__d1, const ::std::lognormal_distribution<_RealType> &__d2);
  template < typename _RealType >
  inline bool operator !=(const ::std::lognormal_distribution<_RealType> &__d1, const ::std::lognormal_distribution<_RealType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _RealType = double >
  class  gamma_distribution
  {
      static_assert(std::is_floating_point<_RealType>::value, "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct  param_type
      {
          typedef ::std::gamma_distribution<_RealType> distribution_type;
          inline explicit param_type(_RealType __alpha_val  = (_RealType(1)), _RealType __beta_val  = (_RealType(1)))
            : _M_alpha(__alpha_val), _M_beta(__beta_val)
          {
            ;
            (*this)._M_initialize();
          }
          inline _RealType alpha() const 
          {
            return ::std::gamma_distribution<_RealType>::param_type::_M_alpha;
          }
          inline _RealType beta() const 
          {
            return ::std::gamma_distribution<_RealType>::param_type::_M_beta;
          }
        private:
          void _M_initialize();
          _RealType _M_alpha;
          _RealType _M_beta;
          _RealType _M_malpha;
          _RealType _M_a2;
        friend class ::std::gamma_distribution<_RealType>;
        friend inline bool operator ==(const typename ::std::gamma_distribution<_RealType>::param_type &__p1, const typename ::std::gamma_distribution<_RealType>::param_type &__p2)
        {
          return __p1._M_alpha == __p2._M_alpha && __p1._M_beta == __p2._M_beta;
        }
      };
      inline explicit gamma_distribution(_RealType __alpha_val  = (_RealType(1)), _RealType __beta_val  = (_RealType(1)))
        : _M_param(__alpha_val, __beta_val), _M_nd()
      {
      }
      inline explicit gamma_distribution(const typename ::std::gamma_distribution<_RealType>::param_type &__p)
        : _M_param(__p), _M_nd()
      {
      }
      inline void reset()
      {
        ::std::gamma_distribution<_RealType>::_M_nd.reset();
      }
      inline _RealType alpha() const 
      {
        return ::std::gamma_distribution<_RealType>::_M_param.alpha();
      }
      inline _RealType beta() const 
      {
        return ::std::gamma_distribution<_RealType>::_M_param.beta();
      }
      inline typename ::std::gamma_distribution<_RealType>::param_type param() const 
      {
        return ::std::gamma_distribution<_RealType>::_M_param;
      }
      inline void param(const typename ::std::gamma_distribution<_RealType>::param_type &__param)
      {
        ::std::gamma_distribution<_RealType>::_M_param = __param;
      }
      inline typename ::std::gamma_distribution<_RealType>::result_type min() const 
      {
        return ((typename ::std::gamma_distribution<_RealType>::result_type(0)));
      }
      inline typename ::std::gamma_distribution<_RealType>::result_type max() const 
      {
        return std::numeric_limits<typename ::std::gamma_distribution<_RealType>::result_type>::max();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::gamma_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::gamma_distribution<_RealType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      typename ::std::gamma_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::gamma_distribution<_RealType>::param_type &__param);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::gamma_distribution<_RealType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::gamma_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::gamma_distribution<_RealType>::result_type *__f, typename ::std::gamma_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::gamma_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::gamma_distribution<_RealType>::param_type &__param);
      typename ::std::gamma_distribution<_RealType>::param_type _M_param;
      ::std::normal_distribution<typename ::std::gamma_distribution<_RealType>::result_type> _M_nd;
    friend inline bool operator ==(const ::std::gamma_distribution<_RealType> &__d1, const ::std::gamma_distribution<_RealType> &__d2)
    {
      return __d1._M_param == __d2._M_param && __d1._M_nd == __d2._M_nd;
    }
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::gamma_distribution<_RealType1> &);
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::gamma_distribution<_RealType1> &);
  };
  template < typename _RealType >
  inline bool operator !=(const ::std::gamma_distribution<_RealType> &__d1, const ::std::gamma_distribution<_RealType> &__d2);
  template < typename _RealType >
  inline bool operator !=(const ::std::gamma_distribution<_RealType> &__d1, const ::std::gamma_distribution<_RealType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _RealType = double >
  class  chi_squared_distribution
  {
      static_assert(std::is_floating_point<_RealType>::value, "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct  param_type
      {
          typedef ::std::chi_squared_distribution<_RealType> distribution_type;
          inline explicit param_type(_RealType __n  = (_RealType(1)))
            : _M_n(__n)
          {
          }
          inline _RealType n() const 
          {
            return ::std::chi_squared_distribution<_RealType>::param_type::_M_n;
          }
        private:
          _RealType _M_n;
        friend inline bool operator ==(const typename ::std::chi_squared_distribution<_RealType>::param_type &__p1, const typename ::std::chi_squared_distribution<_RealType>::param_type &__p2)
        {
          return __p1._M_n == __p2._M_n;
        }
      };
      inline explicit chi_squared_distribution(_RealType __n  = (_RealType(1)))
        : _M_param(__n), _M_gd(__n / 2)
      {
      }
      inline explicit chi_squared_distribution(const typename ::std::chi_squared_distribution<_RealType>::param_type &__p)
        : _M_param(__p), _M_gd(__p.n() / 2)
      {
      }
      inline void reset()
      {
        ::std::chi_squared_distribution<_RealType>::_M_gd.reset();
      }
      inline _RealType n() const 
      {
        return ::std::chi_squared_distribution<_RealType>::_M_param.n();
      }
      inline typename ::std::chi_squared_distribution<_RealType>::param_type param() const 
      {
        return ::std::chi_squared_distribution<_RealType>::_M_param;
      }
      inline void param(const typename ::std::chi_squared_distribution<_RealType>::param_type &__param)
      {
        ::std::chi_squared_distribution<_RealType>::_M_param = __param;
      }
      inline typename ::std::chi_squared_distribution<_RealType>::result_type min() const 
      {
        return ((typename ::std::chi_squared_distribution<_RealType>::result_type(0)));
      }
      inline typename ::std::chi_squared_distribution<_RealType>::result_type max() const 
      {
        return std::numeric_limits<typename ::std::chi_squared_distribution<_RealType>::result_type>::max();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::chi_squared_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return 2 * ::std::chi_squared_distribution<_RealType>::_M_gd(__urng);
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::chi_squared_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::chi_squared_distribution<_RealType>::param_type &__p)
      {
        typedef typename ::std::gamma_distribution<typename ::std::chi_squared_distribution<_RealType>::result_type>::param_type param_type;
        return 2 * ::std::chi_squared_distribution<_RealType>::_M_gd(__urng, param_type(__p.n() / 2));
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate_impl(__f, __t, __urng);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::chi_squared_distribution<_RealType>::param_type &__p)
      {
        typename ::std::gamma_distribution<typename ::std::chi_squared_distribution<_RealType>::result_type>::param_type __p2(__p.n() / 2);
        this->__generate_impl(__f, __t, __urng, __p2);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::chi_squared_distribution<_RealType>::result_type *__f, typename ::std::chi_squared_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate_impl(__f, __t, __urng);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::chi_squared_distribution<_RealType>::result_type *__f, typename ::std::chi_squared_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::chi_squared_distribution<_RealType>::param_type &__p)
      {
        typename ::std::gamma_distribution<typename ::std::chi_squared_distribution<_RealType>::result_type>::param_type __p2(__p.n() / 2);
        this->__generate_impl(__f, __t, __urng, __p2);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::gamma_distribution<typename ::std::chi_squared_distribution<_RealType>::result_type>::param_type &__p);
      typename ::std::chi_squared_distribution<_RealType>::param_type _M_param;
      ::std::gamma_distribution<typename ::std::chi_squared_distribution<_RealType>::result_type> _M_gd;
    friend inline bool operator ==(const ::std::chi_squared_distribution<_RealType> &__d1, const ::std::chi_squared_distribution<_RealType> &__d2)
    {
      return __d1._M_param == __d2._M_param && __d1._M_gd == __d2._M_gd;
    }
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::chi_squared_distribution<_RealType1> &);
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::chi_squared_distribution<_RealType1> &);
  };
  template < typename _RealType >
  inline bool operator !=(const ::std::chi_squared_distribution<_RealType> &__d1, const ::std::chi_squared_distribution<_RealType> &__d2);
  template < typename _RealType >
  inline bool operator !=(const ::std::chi_squared_distribution<_RealType> &__d1, const ::std::chi_squared_distribution<_RealType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _RealType = double >
  class  cauchy_distribution
  {
      static_assert(std::is_floating_point<_RealType>::value, "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct  param_type
      {
          typedef ::std::cauchy_distribution<_RealType> distribution_type;
          inline explicit param_type(_RealType __a  = (_RealType(0)), _RealType __b  = (_RealType(1)))
            : _M_a(__a), _M_b(__b)
          {
          }
          inline _RealType a() const 
          {
            return ::std::cauchy_distribution<_RealType>::param_type::_M_a;
          }
          inline _RealType b() const 
          {
            return ::std::cauchy_distribution<_RealType>::param_type::_M_b;
          }
        private:
          _RealType _M_a;
          _RealType _M_b;
        friend inline bool operator ==(const typename ::std::cauchy_distribution<_RealType>::param_type &__p1, const typename ::std::cauchy_distribution<_RealType>::param_type &__p2)
        {
          return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b;
        }
      };
      inline explicit cauchy_distribution(_RealType __a  = (_RealType(0)), _RealType __b  = (_RealType(1)))
        : _M_param(__a, __b)
      {
      }
      inline explicit cauchy_distribution(const typename ::std::cauchy_distribution<_RealType>::param_type &__p)
        : _M_param(__p)
      {
      }
      inline void reset()
      {
      }
      inline _RealType a() const 
      {
        return ::std::cauchy_distribution<_RealType>::_M_param.a();
      }
      inline _RealType b() const 
      {
        return ::std::cauchy_distribution<_RealType>::_M_param.b();
      }
      inline typename ::std::cauchy_distribution<_RealType>::param_type param() const 
      {
        return ::std::cauchy_distribution<_RealType>::_M_param;
      }
      inline void param(const typename ::std::cauchy_distribution<_RealType>::param_type &__param)
      {
        ::std::cauchy_distribution<_RealType>::_M_param = __param;
      }
      inline typename ::std::cauchy_distribution<_RealType>::result_type min() const 
      {
        return std::numeric_limits<typename ::std::cauchy_distribution<_RealType>::result_type>::lowest();
      }
      inline typename ::std::cauchy_distribution<_RealType>::result_type max() const 
      {
        return std::numeric_limits<typename ::std::cauchy_distribution<_RealType>::result_type>::max();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::cauchy_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::cauchy_distribution<_RealType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      typename ::std::cauchy_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::cauchy_distribution<_RealType>::param_type &__p);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::cauchy_distribution<_RealType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::cauchy_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::cauchy_distribution<_RealType>::result_type *__f, typename ::std::cauchy_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::cauchy_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::cauchy_distribution<_RealType>::param_type &__p);
      typename ::std::cauchy_distribution<_RealType>::param_type _M_param;
    friend inline bool operator ==(const ::std::cauchy_distribution<_RealType> &__d1, const ::std::cauchy_distribution<_RealType> &__d2)
    {
      return __d1._M_param == __d2._M_param;
    }
  };
  template < typename _RealType >
  inline bool operator !=(const ::std::cauchy_distribution<_RealType> &__d1, const ::std::cauchy_distribution<_RealType> &__d2);
  template < typename _RealType >
  inline bool operator !=(const ::std::cauchy_distribution<_RealType> &__d1, const ::std::cauchy_distribution<_RealType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::cauchy_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::cauchy_distribution<_RealType> &__x);
  template < typename _RealType = double >
  class  fisher_f_distribution
  {
      static_assert(std::is_floating_point<_RealType>::value, "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct  param_type
      {
          typedef ::std::fisher_f_distribution<_RealType> distribution_type;
          inline explicit param_type(_RealType __m  = (_RealType(1)), _RealType __n  = (_RealType(1)))
            : _M_m(__m), _M_n(__n)
          {
          }
          inline _RealType m() const 
          {
            return ::std::fisher_f_distribution<_RealType>::param_type::_M_m;
          }
          inline _RealType n() const 
          {
            return ::std::fisher_f_distribution<_RealType>::param_type::_M_n;
          }
        private:
          _RealType _M_m;
          _RealType _M_n;
        friend inline bool operator ==(const typename ::std::fisher_f_distribution<_RealType>::param_type &__p1, const typename ::std::fisher_f_distribution<_RealType>::param_type &__p2)
        {
          return __p1._M_m == __p2._M_m && __p1._M_n == __p2._M_n;
        }
      };
      inline explicit fisher_f_distribution(_RealType __m  = (_RealType(1)), _RealType __n  = (_RealType(1)))
        : _M_param(__m, __n), _M_gd_x(__m / 2), _M_gd_y(__n / 2)
      {
      }
      inline explicit fisher_f_distribution(const typename ::std::fisher_f_distribution<_RealType>::param_type &__p)
        : _M_param(__p), _M_gd_x(__p.m() / 2), _M_gd_y(__p.n() / 2)
      {
      }
      inline void reset()
      {
        ::std::fisher_f_distribution<_RealType>::_M_gd_x.reset();
        ::std::fisher_f_distribution<_RealType>::_M_gd_y.reset();
      }
      inline _RealType m() const 
      {
        return ::std::fisher_f_distribution<_RealType>::_M_param.m();
      }
      inline _RealType n() const 
      {
        return ::std::fisher_f_distribution<_RealType>::_M_param.n();
      }
      inline typename ::std::fisher_f_distribution<_RealType>::param_type param() const 
      {
        return ::std::fisher_f_distribution<_RealType>::_M_param;
      }
      inline void param(const typename ::std::fisher_f_distribution<_RealType>::param_type &__param)
      {
        ::std::fisher_f_distribution<_RealType>::_M_param = __param;
      }
      inline typename ::std::fisher_f_distribution<_RealType>::result_type min() const 
      {
        return ((typename ::std::fisher_f_distribution<_RealType>::result_type(0)));
      }
      inline typename ::std::fisher_f_distribution<_RealType>::result_type max() const 
      {
        return std::numeric_limits<typename ::std::fisher_f_distribution<_RealType>::result_type>::max();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::fisher_f_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return ::std::fisher_f_distribution<_RealType>::_M_gd_x(__urng) * (*this).n() / (::std::fisher_f_distribution<_RealType>::_M_gd_y(__urng) * (*this).m());
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::fisher_f_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::fisher_f_distribution<_RealType>::param_type &__p)
      {
        typedef typename ::std::gamma_distribution<typename ::std::fisher_f_distribution<_RealType>::result_type>::param_type param_type;
        return ::std::fisher_f_distribution<_RealType>::_M_gd_x(__urng, param_type(__p.m() / 2)) * (*this).n() / (::std::fisher_f_distribution<_RealType>::_M_gd_y(__urng, param_type(__p.n() / 2)) * (*this).m());
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate_impl(__f, __t, __urng);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::fisher_f_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::fisher_f_distribution<_RealType>::result_type *__f, typename ::std::fisher_f_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate_impl(__f, __t, __urng);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::fisher_f_distribution<_RealType>::result_type *__f, typename ::std::fisher_f_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::fisher_f_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::fisher_f_distribution<_RealType>::param_type &__p);
      typename ::std::fisher_f_distribution<_RealType>::param_type _M_param;
      ::std::gamma_distribution<typename ::std::fisher_f_distribution<_RealType>::result_type> _M_gd_x;
      ::std::gamma_distribution<typename ::std::fisher_f_distribution<_RealType>::result_type> _M_gd_y;
    friend inline bool operator ==(const ::std::fisher_f_distribution<_RealType> &__d1, const ::std::fisher_f_distribution<_RealType> &__d2)
    {
      return (__d1._M_param == __d2._M_param && __d1._M_gd_x == __d2._M_gd_x) && __d1._M_gd_y == __d2._M_gd_y;
    }
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::fisher_f_distribution<_RealType1> &);
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::fisher_f_distribution<_RealType1> &);
  };
  template < typename _RealType >
  inline bool operator !=(const ::std::fisher_f_distribution<_RealType> &__d1, const ::std::fisher_f_distribution<_RealType> &__d2);
  template < typename _RealType >
  inline bool operator !=(const ::std::fisher_f_distribution<_RealType> &__d1, const ::std::fisher_f_distribution<_RealType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _RealType = double >
  class  student_t_distribution
  {
      static_assert(std::is_floating_point<_RealType>::value, "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct  param_type
      {
          typedef ::std::student_t_distribution<_RealType> distribution_type;
          inline explicit param_type(_RealType __n  = (_RealType(1)))
            : _M_n(__n)
          {
          }
          inline _RealType n() const 
          {
            return ::std::student_t_distribution<_RealType>::param_type::_M_n;
          }
        private:
          _RealType _M_n;
        friend inline bool operator ==(const typename ::std::student_t_distribution<_RealType>::param_type &__p1, const typename ::std::student_t_distribution<_RealType>::param_type &__p2)
        {
          return __p1._M_n == __p2._M_n;
        }
      };
      inline explicit student_t_distribution(_RealType __n  = (_RealType(1)))
        : _M_param(__n), _M_nd(), _M_gd(__n / 2, 2)
      {
      }
      inline explicit student_t_distribution(const typename ::std::student_t_distribution<_RealType>::param_type &__p)
        : _M_param(__p), _M_nd(), _M_gd(__p.n() / 2, 2)
      {
      }
      inline void reset()
      {
        ::std::student_t_distribution<_RealType>::_M_nd.reset();
        ::std::student_t_distribution<_RealType>::_M_gd.reset();
      }
      inline _RealType n() const 
      {
        return ::std::student_t_distribution<_RealType>::_M_param.n();
      }
      inline typename ::std::student_t_distribution<_RealType>::param_type param() const 
      {
        return ::std::student_t_distribution<_RealType>::_M_param;
      }
      inline void param(const typename ::std::student_t_distribution<_RealType>::param_type &__param)
      {
        ::std::student_t_distribution<_RealType>::_M_param = __param;
      }
      inline typename ::std::student_t_distribution<_RealType>::result_type min() const 
      {
        return std::numeric_limits<typename ::std::student_t_distribution<_RealType>::result_type>::lowest();
      }
      inline typename ::std::student_t_distribution<_RealType>::result_type max() const 
      {
        return std::numeric_limits<typename ::std::student_t_distribution<_RealType>::result_type>::max();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::student_t_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return ::std::student_t_distribution<_RealType>::_M_nd(__urng) * std::sqrt((*this).n() / ::std::student_t_distribution<_RealType>::_M_gd(__urng));
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::student_t_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::student_t_distribution<_RealType>::param_type &__p)
      {
        typedef typename ::std::gamma_distribution<typename ::std::student_t_distribution<_RealType>::result_type>::param_type param_type;
        const typename ::std::student_t_distribution<_RealType>::result_type __g = ::std::student_t_distribution<_RealType>::_M_gd(__urng, param_type(__p.n() / 2, 2));
        return ::std::student_t_distribution<_RealType>::_M_nd(__urng) * std::sqrt(__p.n() / __g);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate_impl(__f, __t, __urng);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::student_t_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::student_t_distribution<_RealType>::result_type *__f, typename ::std::student_t_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate_impl(__f, __t, __urng);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::student_t_distribution<_RealType>::result_type *__f, typename ::std::student_t_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::student_t_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::student_t_distribution<_RealType>::param_type &__p);
      typename ::std::student_t_distribution<_RealType>::param_type _M_param;
      ::std::normal_distribution<typename ::std::student_t_distribution<_RealType>::result_type> _M_nd;
      ::std::gamma_distribution<typename ::std::student_t_distribution<_RealType>::result_type> _M_gd;
    friend inline bool operator ==(const ::std::student_t_distribution<_RealType> &__d1, const ::std::student_t_distribution<_RealType> &__d2)
    {
      return (__d1._M_param == __d2._M_param && __d1._M_nd == __d2._M_nd) && __d1._M_gd == __d2._M_gd;
    }
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::student_t_distribution<_RealType1> &);
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::student_t_distribution<_RealType1> &);
  };
  template < typename _RealType >
  inline bool operator !=(const ::std::student_t_distribution<_RealType> &__d1, const ::std::student_t_distribution<_RealType> &__d2);
  template < typename _RealType >
  inline bool operator !=(const ::std::student_t_distribution<_RealType> &__d1, const ::std::student_t_distribution<_RealType> &__d2)
  {
    return !(__d1 == __d2);
  }
  class  bernoulli_distribution
  {
    public:
      typedef bool result_type;
      struct  param_type
      {
          typedef ::std::bernoulli_distribution distribution_type;
          inline explicit param_type(double __p  = (5.00000000000000000000000000000000000000000000000000000e-01))
            : _M_p(__p)
          {
            ;
          }
          inline double p() const 
          {
            return (*this)._M_p;
          }
        private:
          double _M_p;
        public:
        friend inline bool operator ==(const ::std::bernoulli_distribution::param_type &__p1, const ::std::bernoulli_distribution::param_type &__p2)
        {
          return __p1._M_p == __p2._M_p;
        }
      };
      inline explicit bernoulli_distribution(double __p  = (5.00000000000000000000000000000000000000000000000000000e-01))
        : _M_param(__p)
      {
      }
      inline explicit bernoulli_distribution(const ::std::bernoulli_distribution::param_type &__p)
        : _M_param(__p)
      {
      }
      inline void reset()
      {
      }
      inline double p() const 
      {
        return (*this)._M_param.::std::bernoulli_distribution::param_type::p();
      }
      inline ::std::bernoulli_distribution::param_type param() const 
      {
        return (*this)._M_param;
      }
      inline void param(const ::std::bernoulli_distribution::param_type &__param)
      {
        (*this)._M_param = __param;
      }
      inline ::std::bernoulli_distribution::result_type min() const 
      {
        return std::numeric_limits< ::std::bernoulli_distribution::result_type>::min();
      }
      inline ::std::bernoulli_distribution::result_type max() const 
      {
        return std::numeric_limits< ::std::bernoulli_distribution::result_type>::max();
      }
      template < typename _UniformRandomNumberGenerator >
      inline ::std::bernoulli_distribution::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return (*this).operator ()(__urng, (*this)._M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      inline ::std::bernoulli_distribution::result_type operator ()(_UniformRandomNumberGenerator &__urng, const ::std::bernoulli_distribution::param_type &__p)
      {
        ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, double> __aurng(__urng);
        if (__aurng() - __aurng.min() < __p.::std::bernoulli_distribution::param_type::p() * (__aurng.max() - __aurng.min()))
          {
            return true;
          }
        return false;
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        (*this).__generate(__f, __t, __urng, (*this)._M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const ::std::bernoulli_distribution::param_type &__p)
      {
        (*this).__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(::std::bernoulli_distribution::result_type *__f, ::std::bernoulli_distribution::result_type *__t, _UniformRandomNumberGenerator &__urng, const ::std::bernoulli_distribution::param_type &__p)
      {
        (*this).__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const ::std::bernoulli_distribution::param_type &__p);
      ::std::bernoulli_distribution::param_type _M_param;
    public:
    friend inline bool operator ==(const ::std::bernoulli_distribution &__d1, const ::std::bernoulli_distribution &__d2)
    {
      return __d1._M_param == __d2._M_param;
    }
  };
  inline bool operator !=(const ::std::bernoulli_distribution &__d1, const ::std::bernoulli_distribution &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::bernoulli_distribution &__x);
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::bernoulli_distribution &__x);
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::bernoulli_distribution &__x)
  {
    double __p;
    __is >> __p;
    __x.::std::bernoulli_distribution::param(::std::bernoulli_distribution::param_type(__p));
    return __is;
  }
  template < typename _IntType = int >
  class  binomial_distribution
  {
      static_assert(std::is_integral<_IntType>::value, "template argument not an integral type");
    public:
      typedef _IntType result_type;
      struct  param_type
      {
          typedef ::std::binomial_distribution<_IntType> distribution_type;
          inline explicit param_type(_IntType __t  = (_IntType(1)), double __p  = (5.00000000000000000000000000000000000000000000000000000e-01))
            : _M_t(__t), _M_p(__p)
          {
            ;
            (*this)._M_initialize();
          }
          inline _IntType t() const 
          {
            return ::std::binomial_distribution<_IntType>::param_type::_M_t;
          }
          inline double p() const 
          {
            return ::std::binomial_distribution<_IntType>::param_type::_M_p;
          }
        private:
          void _M_initialize();
          _IntType _M_t;
          double _M_p;
          double _M_q;
          double _M_d1;
          double _M_d2;
          double _M_s1;
          double _M_s2;
          double _M_c;
          double _M_a1;
          double _M_a123;
          double _M_s;
          double _M_lf;
          double _M_lp1p;
          bool _M_easy;
        friend class ::std::binomial_distribution<_IntType>;
        friend inline bool operator ==(const typename ::std::binomial_distribution<_IntType>::param_type &__p1, const typename ::std::binomial_distribution<_IntType>::param_type &__p2)
        {
          return __p1._M_t == __p2._M_t && __p1._M_p == __p2._M_p;
        }
      };
      inline explicit binomial_distribution(_IntType __t  = (_IntType(1)), double __p  = (5.00000000000000000000000000000000000000000000000000000e-01))
        : _M_param(__t, __p), _M_nd()
      {
      }
      inline explicit binomial_distribution(const typename ::std::binomial_distribution<_IntType>::param_type &__p)
        : _M_param(__p), _M_nd()
      {
      }
      inline void reset()
      {
        ::std::binomial_distribution<_IntType>::_M_nd.reset();
      }
      inline _IntType t() const 
      {
        return ::std::binomial_distribution<_IntType>::_M_param.t();
      }
      inline double p() const 
      {
        return ::std::binomial_distribution<_IntType>::_M_param.p();
      }
      inline typename ::std::binomial_distribution<_IntType>::param_type param() const 
      {
        return ::std::binomial_distribution<_IntType>::_M_param;
      }
      inline void param(const typename ::std::binomial_distribution<_IntType>::param_type &__param)
      {
        ::std::binomial_distribution<_IntType>::_M_param = __param;
      }
      inline typename ::std::binomial_distribution<_IntType>::result_type min() const 
      {
        return 0;
      }
      inline typename ::std::binomial_distribution<_IntType>::result_type max() const 
      {
        return ::std::binomial_distribution<_IntType>::_M_param.t();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::binomial_distribution<_IntType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::binomial_distribution<_IntType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      typename ::std::binomial_distribution<_IntType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::binomial_distribution<_IntType>::param_type &__param);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::binomial_distribution<_IntType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::binomial_distribution<_IntType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::binomial_distribution<_IntType>::result_type *__f, typename ::std::binomial_distribution<_IntType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::binomial_distribution<_IntType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::binomial_distribution<_IntType>::param_type &__param);
      template < typename _UniformRandomNumberGenerator >
      typename ::std::binomial_distribution<_IntType>::result_type _M_waiting(_UniformRandomNumberGenerator &__urng, _IntType __t, double __q);
      typename ::std::binomial_distribution<_IntType>::param_type _M_param;
      ::std::normal_distribution<double> _M_nd;
    friend inline bool operator ==(const ::std::binomial_distribution<_IntType> &__d1, const ::std::binomial_distribution<_IntType> &__d2)
    {
      return __d1._M_param == __d2._M_param && __d1._M_nd == __d2._M_nd;
    }
    template < typename _IntType1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::binomial_distribution<_IntType1> &);
    template < typename _IntType1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::binomial_distribution<_IntType1> &);
  };
  template < typename _IntType >
  inline bool operator !=(const ::std::binomial_distribution<_IntType> &__d1, const ::std::binomial_distribution<_IntType> &__d2);
  template < typename _IntType >
  inline bool operator !=(const ::std::binomial_distribution<_IntType> &__d1, const ::std::binomial_distribution<_IntType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _IntType = int >
  class  geometric_distribution
  {
      static_assert(std::is_integral<_IntType>::value, "template argument not an integral type");
    public:
      typedef _IntType result_type;
      struct  param_type
      {
          typedef ::std::geometric_distribution<_IntType> distribution_type;
          inline explicit param_type(double __p  = (5.00000000000000000000000000000000000000000000000000000e-01))
            : _M_p(__p)
          {
            ;
            (*this)._M_initialize();
          }
          inline double p() const 
          {
            return ::std::geometric_distribution<_IntType>::param_type::_M_p;
          }
        private:
          inline void _M_initialize()
          {
            ::std::geometric_distribution<_IntType>::param_type::_M_log_1_p = std::log(1.00000000000000000000000000000000000000000000000000000e+00 - ::std::geometric_distribution<_IntType>::param_type::_M_p);
          }
          double _M_p;
          double _M_log_1_p;
        friend class ::std::geometric_distribution<_IntType>;
        friend inline bool operator ==(const typename ::std::geometric_distribution<_IntType>::param_type &__p1, const typename ::std::geometric_distribution<_IntType>::param_type &__p2)
        {
          return __p1._M_p == __p2._M_p;
        }
      };
      inline explicit geometric_distribution(double __p  = (5.00000000000000000000000000000000000000000000000000000e-01))
        : _M_param(__p)
      {
      }
      inline explicit geometric_distribution(const typename ::std::geometric_distribution<_IntType>::param_type &__p)
        : _M_param(__p)
      {
      }
      inline void reset()
      {
      }
      inline double p() const 
      {
        return ::std::geometric_distribution<_IntType>::_M_param.p();
      }
      inline typename ::std::geometric_distribution<_IntType>::param_type param() const 
      {
        return ::std::geometric_distribution<_IntType>::_M_param;
      }
      inline void param(const typename ::std::geometric_distribution<_IntType>::param_type &__param)
      {
        ::std::geometric_distribution<_IntType>::_M_param = __param;
      }
      inline typename ::std::geometric_distribution<_IntType>::result_type min() const 
      {
        return 0;
      }
      inline typename ::std::geometric_distribution<_IntType>::result_type max() const 
      {
        return std::numeric_limits<typename ::std::geometric_distribution<_IntType>::result_type>::max();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::geometric_distribution<_IntType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::geometric_distribution<_IntType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      typename ::std::geometric_distribution<_IntType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::geometric_distribution<_IntType>::param_type &__param);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::geometric_distribution<_IntType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::geometric_distribution<_IntType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::geometric_distribution<_IntType>::result_type *__f, typename ::std::geometric_distribution<_IntType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::geometric_distribution<_IntType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::geometric_distribution<_IntType>::param_type &__param);
      typename ::std::geometric_distribution<_IntType>::param_type _M_param;
    friend inline bool operator ==(const ::std::geometric_distribution<_IntType> &__d1, const ::std::geometric_distribution<_IntType> &__d2)
    {
      return __d1._M_param == __d2._M_param;
    }
  };
  template < typename _IntType >
  inline bool operator !=(const ::std::geometric_distribution<_IntType> &__d1, const ::std::geometric_distribution<_IntType> &__d2);
  template < typename _IntType >
  inline bool operator !=(const ::std::geometric_distribution<_IntType> &__d1, const ::std::geometric_distribution<_IntType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::geometric_distribution<_IntType> &__x);
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::geometric_distribution<_IntType> &__x);
  template < typename _IntType = int >
  class  negative_binomial_distribution
  {
      static_assert(std::is_integral<_IntType>::value, "template argument not an integral type");
    public:
      typedef _IntType result_type;
      struct  param_type
      {
          typedef ::std::negative_binomial_distribution<_IntType> distribution_type;
          inline explicit param_type(_IntType __k  = (1), double __p  = (5.00000000000000000000000000000000000000000000000000000e-01))
            : _M_k(__k), _M_p(__p)
          {
            ;
          }
          inline _IntType k() const 
          {
            return ::std::negative_binomial_distribution<_IntType>::param_type::_M_k;
          }
          inline double p() const 
          {
            return ::std::negative_binomial_distribution<_IntType>::param_type::_M_p;
          }
        private:
          _IntType _M_k;
          double _M_p;
        friend inline bool operator ==(const typename ::std::negative_binomial_distribution<_IntType>::param_type &__p1, const typename ::std::negative_binomial_distribution<_IntType>::param_type &__p2)
        {
          return __p1._M_k == __p2._M_k && __p1._M_p == __p2._M_p;
        }
      };
      inline explicit negative_binomial_distribution(_IntType __k  = (1), double __p  = (5.00000000000000000000000000000000000000000000000000000e-01))
        : _M_param(__k, __p), _M_gd(__k, (1.00000000000000000000000000000000000000000000000000000e+00 - __p) / __p)
      {
      }
      inline explicit negative_binomial_distribution(const typename ::std::negative_binomial_distribution<_IntType>::param_type &__p)
        : _M_param(__p), _M_gd(__p.k(), (1.00000000000000000000000000000000000000000000000000000e+00 - __p.p()) / __p.p())
      {
      }
      inline void reset()
      {
        ::std::negative_binomial_distribution<_IntType>::_M_gd.reset();
      }
      inline _IntType k() const 
      {
        return ::std::negative_binomial_distribution<_IntType>::_M_param.k();
      }
      inline double p() const 
      {
        return ::std::negative_binomial_distribution<_IntType>::_M_param.p();
      }
      inline typename ::std::negative_binomial_distribution<_IntType>::param_type param() const 
      {
        return ::std::negative_binomial_distribution<_IntType>::_M_param;
      }
      inline void param(const typename ::std::negative_binomial_distribution<_IntType>::param_type &__param)
      {
        ::std::negative_binomial_distribution<_IntType>::_M_param = __param;
      }
      inline typename ::std::negative_binomial_distribution<_IntType>::result_type min() const 
      {
        return ((typename ::std::negative_binomial_distribution<_IntType>::result_type(0)));
      }
      inline typename ::std::negative_binomial_distribution<_IntType>::result_type max() const 
      {
        return std::numeric_limits<typename ::std::negative_binomial_distribution<_IntType>::result_type>::max();
      }
      template < typename _UniformRandomNumberGenerator >
      typename ::std::negative_binomial_distribution<_IntType>::result_type operator ()(_UniformRandomNumberGenerator &__urng);
      template < typename _UniformRandomNumberGenerator >
      typename ::std::negative_binomial_distribution<_IntType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::negative_binomial_distribution<_IntType>::param_type &__p);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate_impl(__f, __t, __urng);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::negative_binomial_distribution<_IntType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::negative_binomial_distribution<_IntType>::result_type *__f, typename ::std::negative_binomial_distribution<_IntType>::result_type *__t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate_impl(__f, __t, __urng);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::negative_binomial_distribution<_IntType>::result_type *__f, typename ::std::negative_binomial_distribution<_IntType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::negative_binomial_distribution<_IntType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::negative_binomial_distribution<_IntType>::param_type &__p);
      typename ::std::negative_binomial_distribution<_IntType>::param_type _M_param;
      ::std::gamma_distribution<double> _M_gd;
    friend inline bool operator ==(const ::std::negative_binomial_distribution<_IntType> &__d1, const ::std::negative_binomial_distribution<_IntType> &__d2)
    {
      return __d1._M_param == __d2._M_param && __d1._M_gd == __d2._M_gd;
    }
    template < typename _IntType1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::negative_binomial_distribution<_IntType1> &);
    template < typename _IntType1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::negative_binomial_distribution<_IntType1> &);
  };
  template < typename _IntType >
  inline bool operator !=(const ::std::negative_binomial_distribution<_IntType> &__d1, const ::std::negative_binomial_distribution<_IntType> &__d2);
  template < typename _IntType >
  inline bool operator !=(const ::std::negative_binomial_distribution<_IntType> &__d1, const ::std::negative_binomial_distribution<_IntType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _IntType = int >
  class  poisson_distribution
  {
      static_assert(std::is_integral<_IntType>::value, "template argument not an integral type");
    public:
      typedef _IntType result_type;
      struct  param_type
      {
          typedef ::std::poisson_distribution<_IntType> distribution_type;
          inline explicit param_type(double __mean  = (1.00000000000000000000000000000000000000000000000000000e+00))
            : _M_mean(__mean)
          {
            ;
            (*this)._M_initialize();
          }
          inline double mean() const 
          {
            return ::std::poisson_distribution<_IntType>::param_type::_M_mean;
          }
        private:
          void _M_initialize();
          double _M_mean;
          double _M_lm_thr;
          double _M_lfm;
          double _M_sm;
          double _M_d;
          double _M_scx;
          double _M_1cx;
          double _M_c2b;
          double _M_cb;
        friend class ::std::poisson_distribution<_IntType>;
        friend inline bool operator ==(const typename ::std::poisson_distribution<_IntType>::param_type &__p1, const typename ::std::poisson_distribution<_IntType>::param_type &__p2)
        {
          return __p1._M_mean == __p2._M_mean;
        }
      };
      inline explicit poisson_distribution(double __mean  = (1.00000000000000000000000000000000000000000000000000000e+00))
        : _M_param(__mean), _M_nd()
      {
      }
      inline explicit poisson_distribution(const typename ::std::poisson_distribution<_IntType>::param_type &__p)
        : _M_param(__p), _M_nd()
      {
      }
      inline void reset()
      {
        ::std::poisson_distribution<_IntType>::_M_nd.reset();
      }
      inline double mean() const 
      {
        return ::std::poisson_distribution<_IntType>::_M_param.mean();
      }
      inline typename ::std::poisson_distribution<_IntType>::param_type param() const 
      {
        return ::std::poisson_distribution<_IntType>::_M_param;
      }
      inline void param(const typename ::std::poisson_distribution<_IntType>::param_type &__param)
      {
        ::std::poisson_distribution<_IntType>::_M_param = __param;
      }
      inline typename ::std::poisson_distribution<_IntType>::result_type min() const 
      {
        return 0;
      }
      inline typename ::std::poisson_distribution<_IntType>::result_type max() const 
      {
        return std::numeric_limits<typename ::std::poisson_distribution<_IntType>::result_type>::max();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::poisson_distribution<_IntType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::poisson_distribution<_IntType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      typename ::std::poisson_distribution<_IntType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::poisson_distribution<_IntType>::param_type &__param);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::poisson_distribution<_IntType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::poisson_distribution<_IntType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::poisson_distribution<_IntType>::result_type *__f, typename ::std::poisson_distribution<_IntType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::poisson_distribution<_IntType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::poisson_distribution<_IntType>::param_type &__param);
      typename ::std::poisson_distribution<_IntType>::param_type _M_param;
      ::std::normal_distribution<double> _M_nd;
    friend inline bool operator ==(const ::std::poisson_distribution<_IntType> &__d1, const ::std::poisson_distribution<_IntType> &__d2)
    {
      return __d1._M_param == __d2._M_param && __d1._M_nd == __d2._M_nd;
    }
    template < typename _IntType1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::poisson_distribution<_IntType1> &);
    template < typename _IntType1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::poisson_distribution<_IntType1> &);
  };
  template < typename _IntType >
  inline bool operator !=(const ::std::poisson_distribution<_IntType> &__d1, const ::std::poisson_distribution<_IntType> &__d2);
  template < typename _IntType >
  inline bool operator !=(const ::std::poisson_distribution<_IntType> &__d1, const ::std::poisson_distribution<_IntType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _RealType = double >
  class  exponential_distribution
  {
      static_assert(std::is_floating_point<_RealType>::value, "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct  param_type
      {
          typedef ::std::exponential_distribution<_RealType> distribution_type;
          inline explicit param_type(_RealType __lambda  = (_RealType(1)))
            : _M_lambda(__lambda)
          {
            ;
          }
          inline _RealType lambda() const 
          {
            return ::std::exponential_distribution<_RealType>::param_type::_M_lambda;
          }
        private:
          _RealType _M_lambda;
        friend inline bool operator ==(const typename ::std::exponential_distribution<_RealType>::param_type &__p1, const typename ::std::exponential_distribution<_RealType>::param_type &__p2)
        {
          return __p1._M_lambda == __p2._M_lambda;
        }
      };
      inline explicit exponential_distribution(const typename ::std::exponential_distribution<_RealType>::result_type &__lambda  = (((typename ::std::exponential_distribution<_RealType>::result_type(1)))))
        : _M_param(__lambda)
      {
      }
      inline explicit exponential_distribution(const typename ::std::exponential_distribution<_RealType>::param_type &__p)
        : _M_param(__p)
      {
      }
      inline void reset()
      {
      }
      inline _RealType lambda() const 
      {
        return ::std::exponential_distribution<_RealType>::_M_param.lambda();
      }
      inline typename ::std::exponential_distribution<_RealType>::param_type param() const 
      {
        return ::std::exponential_distribution<_RealType>::_M_param;
      }
      inline void param(const typename ::std::exponential_distribution<_RealType>::param_type &__param)
      {
        ::std::exponential_distribution<_RealType>::_M_param = __param;
      }
      inline typename ::std::exponential_distribution<_RealType>::result_type min() const 
      {
        return ((typename ::std::exponential_distribution<_RealType>::result_type(0)));
      }
      inline typename ::std::exponential_distribution<_RealType>::result_type max() const 
      {
        return std::numeric_limits<typename ::std::exponential_distribution<_RealType>::result_type>::max();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::exponential_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::exponential_distribution<_RealType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::exponential_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::exponential_distribution<_RealType>::param_type &__p)
      {
        ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, typename ::std::exponential_distribution<_RealType>::result_type> __aurng(__urng);
        return  -std::log(((typename ::std::exponential_distribution<_RealType>::result_type(1))) - __aurng()) / __p.lambda();
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::exponential_distribution<_RealType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::exponential_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::exponential_distribution<_RealType>::result_type *__f, typename ::std::exponential_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::exponential_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::exponential_distribution<_RealType>::param_type &__p);
      typename ::std::exponential_distribution<_RealType>::param_type _M_param;
    friend inline bool operator ==(const ::std::exponential_distribution<_RealType> &__d1, const ::std::exponential_distribution<_RealType> &__d2)
    {
      return __d1._M_param == __d2._M_param;
    }
  };
  template < typename _RealType >
  inline bool operator !=(const ::std::exponential_distribution<_RealType> &__d1, const ::std::exponential_distribution<_RealType> &__d2);
  template < typename _RealType >
  inline bool operator !=(const ::std::exponential_distribution<_RealType> &__d1, const ::std::exponential_distribution<_RealType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::exponential_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::exponential_distribution<_RealType> &__x);
  template < typename _RealType = double >
  class  weibull_distribution
  {
      static_assert(std::is_floating_point<_RealType>::value, "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct  param_type
      {
          typedef ::std::weibull_distribution<_RealType> distribution_type;
          inline explicit param_type(_RealType __a  = (_RealType(1)), _RealType __b  = (_RealType(1)))
            : _M_a(__a), _M_b(__b)
          {
          }
          inline _RealType a() const 
          {
            return ::std::weibull_distribution<_RealType>::param_type::_M_a;
          }
          inline _RealType b() const 
          {
            return ::std::weibull_distribution<_RealType>::param_type::_M_b;
          }
        private:
          _RealType _M_a;
          _RealType _M_b;
        friend inline bool operator ==(const typename ::std::weibull_distribution<_RealType>::param_type &__p1, const typename ::std::weibull_distribution<_RealType>::param_type &__p2)
        {
          return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b;
        }
      };
      inline explicit weibull_distribution(_RealType __a  = (_RealType(1)), _RealType __b  = (_RealType(1)))
        : _M_param(__a, __b)
      {
      }
      inline explicit weibull_distribution(const typename ::std::weibull_distribution<_RealType>::param_type &__p)
        : _M_param(__p)
      {
      }
      inline void reset()
      {
      }
      inline _RealType a() const 
      {
        return ::std::weibull_distribution<_RealType>::_M_param.a();
      }
      inline _RealType b() const 
      {
        return ::std::weibull_distribution<_RealType>::_M_param.b();
      }
      inline typename ::std::weibull_distribution<_RealType>::param_type param() const 
      {
        return ::std::weibull_distribution<_RealType>::_M_param;
      }
      inline void param(const typename ::std::weibull_distribution<_RealType>::param_type &__param)
      {
        ::std::weibull_distribution<_RealType>::_M_param = __param;
      }
      inline typename ::std::weibull_distribution<_RealType>::result_type min() const 
      {
        return ((typename ::std::weibull_distribution<_RealType>::result_type(0)));
      }
      inline typename ::std::weibull_distribution<_RealType>::result_type max() const 
      {
        return std::numeric_limits<typename ::std::weibull_distribution<_RealType>::result_type>::max();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::weibull_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::weibull_distribution<_RealType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      typename ::std::weibull_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::weibull_distribution<_RealType>::param_type &__p);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::weibull_distribution<_RealType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::weibull_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::weibull_distribution<_RealType>::result_type *__f, typename ::std::weibull_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::weibull_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::weibull_distribution<_RealType>::param_type &__p);
      typename ::std::weibull_distribution<_RealType>::param_type _M_param;
    friend inline bool operator ==(const ::std::weibull_distribution<_RealType> &__d1, const ::std::weibull_distribution<_RealType> &__d2)
    {
      return __d1._M_param == __d2._M_param;
    }
  };
  template < typename _RealType >
  inline bool operator !=(const ::std::weibull_distribution<_RealType> &__d1, const ::std::weibull_distribution<_RealType> &__d2);
  template < typename _RealType >
  inline bool operator !=(const ::std::weibull_distribution<_RealType> &__d1, const ::std::weibull_distribution<_RealType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::weibull_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::weibull_distribution<_RealType> &__x);
  template < typename _RealType = double >
  class  extreme_value_distribution
  {
      static_assert(std::is_floating_point<_RealType>::value, "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct  param_type
      {
          typedef ::std::extreme_value_distribution<_RealType> distribution_type;
          inline explicit param_type(_RealType __a  = (_RealType(0)), _RealType __b  = (_RealType(1)))
            : _M_a(__a), _M_b(__b)
          {
          }
          inline _RealType a() const 
          {
            return ::std::extreme_value_distribution<_RealType>::param_type::_M_a;
          }
          inline _RealType b() const 
          {
            return ::std::extreme_value_distribution<_RealType>::param_type::_M_b;
          }
        private:
          _RealType _M_a;
          _RealType _M_b;
        friend inline bool operator ==(const typename ::std::extreme_value_distribution<_RealType>::param_type &__p1, const typename ::std::extreme_value_distribution<_RealType>::param_type &__p2)
        {
          return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b;
        }
      };
      inline explicit extreme_value_distribution(_RealType __a  = (_RealType(0)), _RealType __b  = (_RealType(1)))
        : _M_param(__a, __b)
      {
      }
      inline explicit extreme_value_distribution(const typename ::std::extreme_value_distribution<_RealType>::param_type &__p)
        : _M_param(__p)
      {
      }
      inline void reset()
      {
      }
      inline _RealType a() const 
      {
        return ::std::extreme_value_distribution<_RealType>::_M_param.a();
      }
      inline _RealType b() const 
      {
        return ::std::extreme_value_distribution<_RealType>::_M_param.b();
      }
      inline typename ::std::extreme_value_distribution<_RealType>::param_type param() const 
      {
        return ::std::extreme_value_distribution<_RealType>::_M_param;
      }
      inline void param(const typename ::std::extreme_value_distribution<_RealType>::param_type &__param)
      {
        ::std::extreme_value_distribution<_RealType>::_M_param = __param;
      }
      inline typename ::std::extreme_value_distribution<_RealType>::result_type min() const 
      {
        return std::numeric_limits<typename ::std::extreme_value_distribution<_RealType>::result_type>::lowest();
      }
      inline typename ::std::extreme_value_distribution<_RealType>::result_type max() const 
      {
        return std::numeric_limits<typename ::std::extreme_value_distribution<_RealType>::result_type>::max();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::extreme_value_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::extreme_value_distribution<_RealType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      typename ::std::extreme_value_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::extreme_value_distribution<_RealType>::param_type &__p);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::extreme_value_distribution<_RealType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::extreme_value_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::extreme_value_distribution<_RealType>::result_type *__f, typename ::std::extreme_value_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::extreme_value_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::extreme_value_distribution<_RealType>::param_type &__p);
      typename ::std::extreme_value_distribution<_RealType>::param_type _M_param;
    friend inline bool operator ==(const ::std::extreme_value_distribution<_RealType> &__d1, const ::std::extreme_value_distribution<_RealType> &__d2)
    {
      return __d1._M_param == __d2._M_param;
    }
  };
  template < typename _RealType >
  inline bool operator !=(const ::std::extreme_value_distribution<_RealType> &__d1, const ::std::extreme_value_distribution<_RealType> &__d2);
  template < typename _RealType >
  inline bool operator !=(const ::std::extreme_value_distribution<_RealType> &__d1, const ::std::extreme_value_distribution<_RealType> &__d2)
  {
    return !(__d1 == __d2);
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::extreme_value_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::extreme_value_distribution<_RealType> &__x);
 /* Instantiation of class template '::std::initializer_list<double>' */ 
 /* Instantiation of template function 'const double *::std::initializer_list<double>::begin() const ' */ 
 /* Instantiation of template function 'unsigned long int ::std::initializer_list<double>::size() const ' */ 
 /* Instantiation of template function 'const double *::std::initializer_list<double>::end() const ' */ 
 /* Instantiation of class template '::__gnu_cxx::new_allocator<double>' */ 
 /* Instantiation of class template '::std::allocator<double>' */ 
 /* Instantiation of class template '::std::remove_volatile<double>' */ 
 /* Instantiation of class template '::std::remove_const<double>' */ 
 /* Instantiation of class template '::std::remove_cv<double>' */ 
 /* Instantiation of class template '::std::__ptrtr_not_void<double, double>' */ 
 /* Instantiation of class template '::std::pointer_traits<double *>' */ 
 /* Instantiation of class template '::std::remove_volatile<long int>' */ 
 /* Instantiation of class template '::std::remove_const<long int>' */ 
 /* Instantiation of class template '::std::remove_cv<long int>' */ 
 /* Instantiation of class template '::std::is_integral<long int>' */ 
 /* Instantiation of class template '::std::is_enum<long int>' */ 
 /* Instantiation of class template '::std::is_const<long int>' */ 
 /* Instantiation of class template '::std::is_volatile<long int>' */ 
 /* Instantiation of class template '::std::__cv_selector<unsigned long int, false, false>' */ 
 /* Instantiation of class template '::std::__match_cv_qualifiers<long int, unsigned long int, false, false>' */ 
 /* Instantiation of class template '::std::__make_unsigned_selector<long int, true, false>' */ 
 /* Instantiation of class template '::std::make_unsigned<long int>' */ 
 /* Instantiation of class template '::std::allocator_traits< ::std::allocator<double> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator<double> >' */ 
 /* Instantiation of class template '::std::allocator<double>::rebind<double>' */ 
 /* Instantiation of template function 'bool ::std::__alloctr_rebind_helper< ::std::allocator<double>, double>::_S_chk< ::std::allocator<double>, double>(::std::allocator<double>::rebind<double>::other *)' */ 
 /* Instantiation of class template '::std::__alloctr_rebind_helper< ::std::allocator<double>, double>' */ 
 /* Instantiation of class template '::std::__alloctr_rebind< ::std::allocator<double>, double, true>' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator<double> >::rebind<double>' */ 
 /* Instantiation of class template '::std::_Vector_base<double, ::std::allocator<double> >::_Vector_impl' */ 
 /* Instantiation of class template '::std::_Vector_base<double, ::std::allocator<double> >' */ 
 /* Instantiation of class template '::std::vector<double>' */ 
 /* Instantiation of template function '::std::allocator<double>::allocator()' */ 
  template < typename _IntType = int >
  class  discrete_distribution
  {
      static_assert(std::is_integral<_IntType>::value, "template argument not an integral type");
    public:
      typedef _IntType result_type;
      struct  param_type
      {
          typedef ::std::discrete_distribution<_IntType> distribution_type;
          inline param_type()
            : _M_prob(), _M_cp()
          {
          }
          template < typename _InputIterator >
          inline param_type(_InputIterator __wbegin, _InputIterator __wend)
            : _M_prob(__wbegin, __wend), _M_cp()
          {
            (*this)._M_initialize();
          }
          inline param_type(::std::initializer_list<double> __wil)
            : _M_prob(__wil.::std::initializer_list<double>::begin(), __wil.::std::initializer_list<double>::end()), _M_cp()
          {
            (*this)._M_initialize();
          }
          template < typename _Func >
          param_type(::std::size_t __nw, double __xmin, double __xmax, _Func __fw);
          param_type(const typename ::std::discrete_distribution<_IntType>::param_type &) = default ;
          typename ::std::discrete_distribution<_IntType>::param_type &operator =(const typename ::std::discrete_distribution<_IntType>::param_type &) = default ;
          inline ::std::vector<double> probabilities() const 
          {
            return ::std::discrete_distribution<_IntType>::param_type::_M_prob.empty() ? ::std::vector<double>(1, 1.00000000000000000000000000000000000000000000000000000e+00 /* , ::std::allocator<double>() */ ) : ::std::discrete_distribution<_IntType>::param_type::_M_prob;
          }
        private:
          void _M_initialize();
          ::std::vector<double> _M_prob;
          ::std::vector<double> _M_cp;
        friend class ::std::discrete_distribution<_IntType>;
        friend inline bool operator ==(const typename ::std::discrete_distribution<_IntType>::param_type &__p1, const typename ::std::discrete_distribution<_IntType>::param_type &__p2)
        {
          return __p1._M_prob == __p2._M_prob;
        }
      };
      inline discrete_distribution()
        : _M_param()
      {
      }
      template < typename _InputIterator >
      inline discrete_distribution(_InputIterator __wbegin, _InputIterator __wend)
        : _M_param(__wbegin, __wend)
      {
      }
      inline discrete_distribution(::std::initializer_list<double> __wl)
        : _M_param(__wl)
      {
      }
      template < typename _Func >
      inline discrete_distribution(::std::size_t __nw, double __xmin, double __xmax, _Func __fw)
        : _M_param(__nw, __xmin, __xmax, __fw)
      {
      }
      inline explicit discrete_distribution(const typename ::std::discrete_distribution<_IntType>::param_type &__p)
        : _M_param(__p)
      {
      }
      inline void reset()
      {
      }
      inline ::std::vector<double> probabilities() const 
      {
        return ::std::discrete_distribution<_IntType>::_M_param._M_prob.empty() ? ::std::vector<double>(1, 1.00000000000000000000000000000000000000000000000000000e+00 /* , ::std::allocator<double>() */ ) : ::std::discrete_distribution<_IntType>::_M_param._M_prob;
      }
      inline typename ::std::discrete_distribution<_IntType>::param_type param() const 
      {
        return ::std::discrete_distribution<_IntType>::_M_param;
      }
      inline void param(const typename ::std::discrete_distribution<_IntType>::param_type &__param)
      {
        ::std::discrete_distribution<_IntType>::_M_param = __param;
      }
      inline typename ::std::discrete_distribution<_IntType>::result_type min() const 
      {
        return ((typename ::std::discrete_distribution<_IntType>::result_type(0)));
      }
      inline typename ::std::discrete_distribution<_IntType>::result_type max() const 
      {
        return ::std::discrete_distribution<_IntType>::_M_param._M_prob.empty() ? ((typename ::std::discrete_distribution<_IntType>::result_type(0))) : ((typename ::std::discrete_distribution<_IntType>::result_type(::std::discrete_distribution<_IntType>::_M_param._M_prob.size() - 1)));
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::discrete_distribution<_IntType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::discrete_distribution<_IntType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      typename ::std::discrete_distribution<_IntType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::discrete_distribution<_IntType>::param_type &__param);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::discrete_distribution<_IntType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::discrete_distribution<_IntType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::discrete_distribution<_IntType>::result_type *__f, typename ::std::discrete_distribution<_IntType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::discrete_distribution<_IntType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::discrete_distribution<_IntType>::param_type &__param);
      typename ::std::discrete_distribution<_IntType>::param_type _M_param;
    friend inline bool operator ==(const ::std::discrete_distribution<_IntType> &__d1, const ::std::discrete_distribution<_IntType> &__d2)
    {
      return __d1._M_param == __d2._M_param;
    }
    template < typename _IntType1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::discrete_distribution<_IntType1> &);
    template < typename _IntType1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::discrete_distribution<_IntType1> &);
  };
  template < typename _IntType >
  inline bool operator !=(const ::std::discrete_distribution<_IntType> &__d1, const ::std::discrete_distribution<_IntType> &__d2);
  template < typename _IntType >
  inline bool operator !=(const ::std::discrete_distribution<_IntType> &__d1, const ::std::discrete_distribution<_IntType> &__d2)
  {
    return !(__d1 == __d2);
  }
 /* Instantiation of template function '::std::allocator<double>::allocator()' */ 
  template < typename _RealType = double >
  class  piecewise_constant_distribution
  {
      static_assert(std::is_floating_point<_RealType>::value, "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct  param_type
      {
          typedef ::std::piecewise_constant_distribution<_RealType> distribution_type;
          inline param_type()
            : _M_int(), _M_den(), _M_cp()
          {
          }
          template < typename _InputIteratorB, typename _InputIteratorW >
          param_type(_InputIteratorB __bbegin, _InputIteratorB __bend, _InputIteratorW __wbegin);
          template < typename _Func >
          param_type(::std::initializer_list<_RealType> __bl, _Func __fw);
          template < typename _Func >
          param_type(::std::size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw);
          param_type(const typename ::std::piecewise_constant_distribution<_RealType>::param_type &) = default ;
          typename ::std::piecewise_constant_distribution<_RealType>::param_type &operator =(const typename ::std::piecewise_constant_distribution<_RealType>::param_type &) = default ;
          inline ::std::vector<_RealType> intervals() const 
          {
            if (::std::piecewise_constant_distribution<_RealType>::param_type::_M_int.empty())
              {
                ::std::vector<_RealType> __tmp(2);
                __tmp[1] = _RealType(1);
                return __tmp;
              }
            else
              {
                return ::std::piecewise_constant_distribution<_RealType>::param_type::_M_int;
              }
          }
          inline ::std::vector<double> densities() const 
          {
            return ::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.empty() ? ::std::vector<double>(1, 1.00000000000000000000000000000000000000000000000000000e+00 /* , ::std::allocator<double>() */ ) : ::std::piecewise_constant_distribution<_RealType>::param_type::_M_den;
          }
        private:
          void _M_initialize();
          ::std::vector<_RealType> _M_int;
          ::std::vector<double> _M_den;
          ::std::vector<double> _M_cp;
        friend class ::std::piecewise_constant_distribution<_RealType>;
        friend inline bool operator ==(const typename ::std::piecewise_constant_distribution<_RealType>::param_type &__p1, const typename ::std::piecewise_constant_distribution<_RealType>::param_type &__p2)
        {
          return __p1._M_int == __p2._M_int && __p1._M_den == __p2._M_den;
        }
      };
      inline explicit piecewise_constant_distribution()
        : _M_param()
      {
      }
      template < typename _InputIteratorB, typename _InputIteratorW >
      inline piecewise_constant_distribution(_InputIteratorB __bfirst, _InputIteratorB __bend, _InputIteratorW __wbegin)
        : _M_param(__bfirst, __bend, __wbegin)
      {
      }
      template < typename _Func >
      inline piecewise_constant_distribution(::std::initializer_list<_RealType> __bl, _Func __fw)
        : _M_param(__bl, __fw)
      {
      }
      template < typename _Func >
      inline piecewise_constant_distribution(::std::size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
        : _M_param(__nw, __xmin, __xmax, __fw)
      {
      }
      inline explicit piecewise_constant_distribution(const typename ::std::piecewise_constant_distribution<_RealType>::param_type &__p)
        : _M_param(__p)
      {
      }
      inline void reset()
      {
      }
      inline ::std::vector<_RealType> intervals() const 
      {
        if (::std::piecewise_constant_distribution<_RealType>::_M_param._M_int.empty())
          {
            ::std::vector<_RealType> __tmp(2);
            __tmp[1] = _RealType(1);
            return __tmp;
          }
        else
          {
            return ::std::piecewise_constant_distribution<_RealType>::_M_param._M_int;
          }
      }
      inline ::std::vector<double> densities() const 
      {
        return ::std::piecewise_constant_distribution<_RealType>::_M_param._M_den.empty() ? ::std::vector<double>(1, 1.00000000000000000000000000000000000000000000000000000e+00 /* , ::std::allocator<double>() */ ) : ::std::piecewise_constant_distribution<_RealType>::_M_param._M_den;
      }
      inline typename ::std::piecewise_constant_distribution<_RealType>::param_type param() const 
      {
        return ::std::piecewise_constant_distribution<_RealType>::_M_param;
      }
      inline void param(const typename ::std::piecewise_constant_distribution<_RealType>::param_type &__param)
      {
        ::std::piecewise_constant_distribution<_RealType>::_M_param = __param;
      }
      inline typename ::std::piecewise_constant_distribution<_RealType>::result_type min() const 
      {
        return ::std::piecewise_constant_distribution<_RealType>::_M_param._M_int.empty() ? ((typename ::std::piecewise_constant_distribution<_RealType>::result_type(0))) : ::std::piecewise_constant_distribution<_RealType>::_M_param._M_int.front();
      }
      inline typename ::std::piecewise_constant_distribution<_RealType>::result_type max() const 
      {
        return ::std::piecewise_constant_distribution<_RealType>::_M_param._M_int.empty() ? ((typename ::std::piecewise_constant_distribution<_RealType>::result_type(1))) : ::std::piecewise_constant_distribution<_RealType>::_M_param._M_int.back();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::piecewise_constant_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::piecewise_constant_distribution<_RealType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      typename ::std::piecewise_constant_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::piecewise_constant_distribution<_RealType>::param_type &__param);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::piecewise_constant_distribution<_RealType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::piecewise_constant_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::piecewise_constant_distribution<_RealType>::result_type *__f, typename ::std::piecewise_constant_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::piecewise_constant_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::piecewise_constant_distribution<_RealType>::param_type &__param);
      typename ::std::piecewise_constant_distribution<_RealType>::param_type _M_param;
    friend inline bool operator ==(const ::std::piecewise_constant_distribution<_RealType> &__d1, const ::std::piecewise_constant_distribution<_RealType> &__d2)
    {
      return __d1._M_param == __d2._M_param;
    }
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::piecewise_constant_distribution<_RealType1> &);
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::piecewise_constant_distribution<_RealType1> &);
  };
  template < typename _RealType >
  inline bool operator !=(const ::std::piecewise_constant_distribution<_RealType> &__d1, const ::std::piecewise_constant_distribution<_RealType> &__d2);
  template < typename _RealType >
  inline bool operator !=(const ::std::piecewise_constant_distribution<_RealType> &__d1, const ::std::piecewise_constant_distribution<_RealType> &__d2)
  {
    return !(__d1 == __d2);
  }
 /* Instantiation of template function '::std::allocator<double>::allocator()' */ 
  template < typename _RealType = double >
  class  piecewise_linear_distribution
  {
      static_assert(std::is_floating_point<_RealType>::value, "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct  param_type
      {
          typedef ::std::piecewise_linear_distribution<_RealType> distribution_type;
          inline param_type()
            : _M_int(), _M_den(), _M_cp(), _M_m()
          {
          }
          template < typename _InputIteratorB, typename _InputIteratorW >
          param_type(_InputIteratorB __bbegin, _InputIteratorB __bend, _InputIteratorW __wbegin);
          template < typename _Func >
          param_type(::std::initializer_list<_RealType> __bl, _Func __fw);
          template < typename _Func >
          param_type(::std::size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw);
          param_type(const typename ::std::piecewise_linear_distribution<_RealType>::param_type &) = default ;
          typename ::std::piecewise_linear_distribution<_RealType>::param_type &operator =(const typename ::std::piecewise_linear_distribution<_RealType>::param_type &) = default ;
          inline ::std::vector<_RealType> intervals() const 
          {
            if (::std::piecewise_linear_distribution<_RealType>::param_type::_M_int.empty())
              {
                ::std::vector<_RealType> __tmp(2);
                __tmp[1] = _RealType(1);
                return __tmp;
              }
            else
              {
                return ::std::piecewise_linear_distribution<_RealType>::param_type::_M_int;
              }
          }
          inline ::std::vector<double> densities() const 
          {
            return ::std::piecewise_linear_distribution<_RealType>::param_type::_M_den.empty() ? ::std::vector<double>(2, 1.00000000000000000000000000000000000000000000000000000e+00 /* , ::std::allocator<double>() */ ) : ::std::piecewise_linear_distribution<_RealType>::param_type::_M_den;
          }
        private:
          void _M_initialize();
          ::std::vector<_RealType> _M_int;
          ::std::vector<double> _M_den;
          ::std::vector<double> _M_cp;
          ::std::vector<double> _M_m;
        friend class ::std::piecewise_linear_distribution<_RealType>;
        friend inline bool operator ==(const typename ::std::piecewise_linear_distribution<_RealType>::param_type &__p1, const typename ::std::piecewise_linear_distribution<_RealType>::param_type &__p2)
        {
          return __p1._M_int == __p2._M_int && __p1._M_den == __p2._M_den;
        }
      };
      inline explicit piecewise_linear_distribution()
        : _M_param()
      {
      }
      template < typename _InputIteratorB, typename _InputIteratorW >
      inline piecewise_linear_distribution(_InputIteratorB __bfirst, _InputIteratorB __bend, _InputIteratorW __wbegin)
        : _M_param(__bfirst, __bend, __wbegin)
      {
      }
      template < typename _Func >
      inline piecewise_linear_distribution(::std::initializer_list<_RealType> __bl, _Func __fw)
        : _M_param(__bl, __fw)
      {
      }
      template < typename _Func >
      inline piecewise_linear_distribution(::std::size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
        : _M_param(__nw, __xmin, __xmax, __fw)
      {
      }
      inline explicit piecewise_linear_distribution(const typename ::std::piecewise_linear_distribution<_RealType>::param_type &__p)
        : _M_param(__p)
      {
      }
      inline void reset()
      {
      }
      inline ::std::vector<_RealType> intervals() const 
      {
        if (::std::piecewise_linear_distribution<_RealType>::_M_param._M_int.empty())
          {
            ::std::vector<_RealType> __tmp(2);
            __tmp[1] = _RealType(1);
            return __tmp;
          }
        else
          {
            return ::std::piecewise_linear_distribution<_RealType>::_M_param._M_int;
          }
      }
      inline ::std::vector<double> densities() const 
      {
        return ::std::piecewise_linear_distribution<_RealType>::_M_param._M_den.empty() ? ::std::vector<double>(2, 1.00000000000000000000000000000000000000000000000000000e+00 /* , ::std::allocator<double>() */ ) : ::std::piecewise_linear_distribution<_RealType>::_M_param._M_den;
      }
      inline typename ::std::piecewise_linear_distribution<_RealType>::param_type param() const 
      {
        return ::std::piecewise_linear_distribution<_RealType>::_M_param;
      }
      inline void param(const typename ::std::piecewise_linear_distribution<_RealType>::param_type &__param)
      {
        ::std::piecewise_linear_distribution<_RealType>::_M_param = __param;
      }
      inline typename ::std::piecewise_linear_distribution<_RealType>::result_type min() const 
      {
        return ::std::piecewise_linear_distribution<_RealType>::_M_param._M_int.empty() ? ((typename ::std::piecewise_linear_distribution<_RealType>::result_type(0))) : ::std::piecewise_linear_distribution<_RealType>::_M_param._M_int.front();
      }
      inline typename ::std::piecewise_linear_distribution<_RealType>::result_type max() const 
      {
        return ::std::piecewise_linear_distribution<_RealType>::_M_param._M_int.empty() ? ((typename ::std::piecewise_linear_distribution<_RealType>::result_type(1))) : ::std::piecewise_linear_distribution<_RealType>::_M_param._M_int.back();
      }
      template < typename _UniformRandomNumberGenerator >
      inline typename ::std::piecewise_linear_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng)
      {
        return this->operator ()(__urng, ::std::piecewise_linear_distribution<_RealType>::_M_param);
      }
      template < typename _UniformRandomNumberGenerator >
      typename ::std::piecewise_linear_distribution<_RealType>::result_type operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::piecewise_linear_distribution<_RealType>::param_type &__param);
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
      {
        this->__generate(__f, __t, __urng, ::std::piecewise_linear_distribution<_RealType>::_M_param);
      }
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      inline void __generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::piecewise_linear_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
      template < typename _UniformRandomNumberGenerator >
      inline void __generate(typename ::std::piecewise_linear_distribution<_RealType>::result_type *__f, typename ::std::piecewise_linear_distribution<_RealType>::result_type *__t, _UniformRandomNumberGenerator &__urng, const typename ::std::piecewise_linear_distribution<_RealType>::param_type &__p)
      {
        this->__generate_impl(__f, __t, __urng, __p);
      }
    private:
      template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
      void __generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::piecewise_linear_distribution<_RealType>::param_type &__param);
      typename ::std::piecewise_linear_distribution<_RealType>::param_type _M_param;
    friend inline bool operator ==(const ::std::piecewise_linear_distribution<_RealType> &__d1, const ::std::piecewise_linear_distribution<_RealType> &__d2)
    {
      return __d1._M_param == __d2._M_param;
    }
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &, const ::std::piecewise_linear_distribution<_RealType1> &);
    template < typename _RealType1, typename _CharT, typename _Traits >
    friend ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &, ::std::piecewise_linear_distribution<_RealType1> &);
  };
  template < typename _RealType >
  inline bool operator !=(const ::std::piecewise_linear_distribution<_RealType> &__d1, const ::std::piecewise_linear_distribution<_RealType> &__d2);
  template < typename _RealType >
  inline bool operator !=(const ::std::piecewise_linear_distribution<_RealType> &__d1, const ::std::piecewise_linear_distribution<_RealType> &__d2)
  {
    return !(__d1 == __d2);
  }
 /* Instantiation of class template '::__gnu_cxx::new_allocator<unsigned int>' */ 
 /* Instantiation of class template '::std::allocator<unsigned int>' */ 
 /* Instantiation of class template '::std::remove_volatile<unsigned int>' */ 
 /* Instantiation of class template '::std::remove_const<unsigned int>' */ 
 /* Instantiation of class template '::std::remove_cv<unsigned int>' */ 
 /* Instantiation of class template '::std::__ptrtr_not_void<unsigned int, unsigned int>' */ 
 /* Instantiation of class template '::std::pointer_traits<unsigned int *>' */ 
 /* Instantiation of class template '::std::allocator_traits< ::std::allocator<unsigned int> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator<unsigned int> >' */ 
 /* Instantiation of class template '::std::allocator<unsigned int>::rebind<unsigned int>' */ 
 /* Instantiation of template function 'bool ::std::__alloctr_rebind_helper< ::std::allocator<unsigned int>, unsigned int>::_S_chk< ::std::allocator<unsigned int>, unsigned int>(::std::allocator<unsigned int>::rebind<unsigned int>::other *)' */ 
 /* Instantiation of class template '::std::__alloctr_rebind_helper< ::std::allocator<unsigned int>, unsigned int>' */ 
 /* Instantiation of class template '::std::__alloctr_rebind< ::std::allocator<unsigned int>, unsigned int, true>' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator<unsigned int> >::rebind<unsigned int>' */ 
 /* Instantiation of class template '::std::_Vector_base<unsigned int, ::std::allocator<unsigned int> >::_Vector_impl' */ 
 /* Instantiation of class template '::std::_Vector_base<unsigned int, ::std::allocator<unsigned int> >' */ 
 /* Instantiation of class template '::std::vector<unsigned int>' */ 
 /* Instantiation of template function '::std::vector<unsigned int>::vector()' */ 
 /* Instantiation of template function 'unsigned long int ::std::vector<unsigned int>::size() const ' */ 
 /* Instantiation of class template '::std::iterator_traits<const unsigned int *>' */ 
 /* Instantiation of class template '::__gnu_cxx::__normal_iterator<const unsigned int *, ::std::vector<unsigned int> >' */ 
  class  seed_seq
  {
    public:
      typedef ::uint_least32_t result_type;
      inline seed_seq()
        : _M_v()
      {
      }
      template < typename _IntType >
      seed_seq(::std::initializer_list<_IntType> __il);
      template < typename _InputIterator >
      seed_seq(_InputIterator __begin, _InputIterator __end);
      template < typename _RandomAccessIterator >
      void generate(_RandomAccessIterator __begin, _RandomAccessIterator __end);
      inline ::std::size_t size() const 
      {
        return (*this)._M_v.::std::vector<unsigned int>::size();
      }
      template < typename OutputIterator >
      inline void param(OutputIterator __dest) const 
      {
        std::copy((*this)._M_v.::std::vector<unsigned int>::begin(), (*this)._M_v.::std::vector<unsigned int>::end(), __dest);
      }
    private:
      ::std::vector<unsigned int> _M_v;
    public:
  };
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int __bsfd(int __X)
{
  return __builtin_ctz(__X);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int __bsrd(int __X)
{
  return __builtin_ia32_bsrsi(__X);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int __bswapd(int __X)
{
  return __builtin_bswap32(__X);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int __popcntd(unsigned int __X)
{
  return __builtin_popcount(__X);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned long long int __rdpmc(int __S)
{
  return __builtin_ia32_rdpmc(__S);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned long long int __rdtsc()
{
  return __builtin_ia32_rdtsc();
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned long long int __rdtscp(unsigned int *__A)
{
  return __builtin_ia32_rdtscp(__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned char __rolb(unsigned char __X, int __C)
{
  return __builtin_ia32_rolqi(__X, __C);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned short int __rolw(unsigned short int __X, int __C)
{
  return __builtin_ia32_rolhi(__X, __C);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned int __rold(unsigned int __X, int __C)
{
  return __X << __C | __X >> (32 - __C);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned char __rorb(unsigned char __X, int __C)
{
  return __builtin_ia32_rorqi(__X, __C);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned short int __rorw(unsigned short int __X, int __C)
{
  return __builtin_ia32_rorhi(__X, __C);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned int __rord(unsigned int __X, int __C)
{
  return __X >> __C | __X << (32 - __C);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void __pause()
{
  __builtin_ia32_pause();
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int __bsfq(long long int __X)
{
  return __builtin_ctzll(__X);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int __bsrq(long long int __X)
{
  return __builtin_ia32_bsrdi(__X);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int __bswapq(long long int __X)
{
  return __builtin_bswap64(__X);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int __popcntq(unsigned long long int __X)
{
  return __builtin_popcountll(__X);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned long long int __rolq(unsigned long long int __X, int __C)
{
  return __X << __C | __X >> (64 - __C);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned long long int __rorq(unsigned long long int __X, int __C)
{
  return __X >> __C | __X << (64 - __C);
}
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) int __m64;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) int __v2si;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) short int __v4hi;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) char __v8qi;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) long long int __v1di;
typedef __attribute__((vector_size(8))) __attribute__((__may_alias__)) float __v2sf;
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_empty()
{
  __builtin_ia32_emms();
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _m_empty()
{
  ::_mm_empty();
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtsi32_si64(int __i)
{
  return (::__m64)__builtin_ia32_vec_init_v2si(__i, 0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_from_int(int __i)
{
  return ::_mm_cvtsi32_si64(__i);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_from_int64(long long int __i)
{
  return (::__m64)__i;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtsi64_m64(long long int __i)
{
  return (::__m64)__i;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtsi64x_si64(long long int __i)
{
  return (::__m64)__i;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_set_pi64x(long long int __i)
{
  return (::__m64)__i;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvtsi64_si32(::__m64 __i)
{
  return __builtin_ia32_vec_ext_v2si((::__v2si)__i, 0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _m_to_int(::__m64 __i)
{
  return ::_mm_cvtsi64_si32(__i);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _m_to_int64(::__m64 __i)
{
  return (long long int)__i;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtm64_si64(::__m64 __i)
{
  return (long long int)__i;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtsi64_si64x(::__m64 __i)
{
  return (long long int)__i;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_packs_pi16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_packsswb((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_packsswb(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_packs_pi16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_packs_pi32(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_packssdw((::__v2si)__m1, (::__v2si)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_packssdw(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_packs_pi32(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_packs_pu16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_packuswb((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_packuswb(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_packs_pu16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_unpackhi_pi8(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_punpckhbw((::__v8qi)__m1, (::__v8qi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_punpckhbw(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_unpackhi_pi8(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_unpackhi_pi16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_punpckhwd((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_punpckhwd(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_unpackhi_pi16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_unpackhi_pi32(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_punpckhdq((::__v2si)__m1, (::__v2si)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_punpckhdq(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_unpackhi_pi32(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_unpacklo_pi8(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_punpcklbw((::__v8qi)__m1, (::__v8qi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_punpcklbw(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_unpacklo_pi8(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_unpacklo_pi16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_punpcklwd((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_punpcklwd(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_unpacklo_pi16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_unpacklo_pi32(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_punpckldq((::__v2si)__m1, (::__v2si)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_punpckldq(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_unpacklo_pi32(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_add_pi8(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_paddb((::__v8qi)__m1, (::__v8qi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_paddb(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_add_pi8(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_add_pi16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_paddw((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_paddw(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_add_pi16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_add_pi32(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_paddd((::__v2si)__m1, (::__v2si)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_paddd(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_add_pi32(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_add_si64(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_paddq((::__v1di)__m1, (::__v1di)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_adds_pi8(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_paddsb((::__v8qi)__m1, (::__v8qi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_paddsb(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_adds_pi8(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_adds_pi16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_paddsw((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_paddsw(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_adds_pi16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_adds_pu8(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_paddusb((::__v8qi)__m1, (::__v8qi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_paddusb(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_adds_pu8(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_adds_pu16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_paddusw((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_paddusw(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_adds_pu16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sub_pi8(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_psubb((::__v8qi)__m1, (::__v8qi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psubb(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_sub_pi8(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sub_pi16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_psubw((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psubw(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_sub_pi16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sub_pi32(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_psubd((::__v2si)__m1, (::__v2si)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psubd(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_sub_pi32(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sub_si64(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_psubq((::__v1di)__m1, (::__v1di)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_subs_pi8(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_psubsb((::__v8qi)__m1, (::__v8qi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psubsb(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_subs_pi8(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_subs_pi16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_psubsw((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psubsw(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_subs_pi16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_subs_pu8(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_psubusb((::__v8qi)__m1, (::__v8qi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psubusb(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_subs_pu8(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_subs_pu16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_psubusw((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psubusw(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_subs_pu16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_madd_pi16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_pmaddwd((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pmaddwd(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_madd_pi16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_mulhi_pi16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_pmulhw((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pmulhw(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_mulhi_pi16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_mullo_pi16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_pmullw((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pmullw(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_mullo_pi16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sll_pi16(::__m64 __m, ::__m64 __count)
{
  return (::__m64)__builtin_ia32_psllw((::__v4hi)__m, (::__v4hi)__count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psllw(::__m64 __m, ::__m64 __count)
{
  return ::_mm_sll_pi16(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_slli_pi16(::__m64 __m, int __count)
{
  return (::__m64)__builtin_ia32_psllwi((::__v4hi)__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psllwi(::__m64 __m, int __count)
{
  return ::_mm_slli_pi16(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sll_pi32(::__m64 __m, ::__m64 __count)
{
  return (::__m64)__builtin_ia32_pslld((::__v2si)__m, (::__v2si)__count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pslld(::__m64 __m, ::__m64 __count)
{
  return ::_mm_sll_pi32(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_slli_pi32(::__m64 __m, int __count)
{
  return (::__m64)__builtin_ia32_pslldi((::__v2si)__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pslldi(::__m64 __m, int __count)
{
  return ::_mm_slli_pi32(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sll_si64(::__m64 __m, ::__m64 __count)
{
  return (::__m64)__builtin_ia32_psllq((::__v1di)__m, (::__v1di)__count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psllq(::__m64 __m, ::__m64 __count)
{
  return ::_mm_sll_si64(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_slli_si64(::__m64 __m, int __count)
{
  return (::__m64)__builtin_ia32_psllqi((::__v1di)__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psllqi(::__m64 __m, int __count)
{
  return ::_mm_slli_si64(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sra_pi16(::__m64 __m, ::__m64 __count)
{
  return (::__m64)__builtin_ia32_psraw((::__v4hi)__m, (::__v4hi)__count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psraw(::__m64 __m, ::__m64 __count)
{
  return ::_mm_sra_pi16(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srai_pi16(::__m64 __m, int __count)
{
  return (::__m64)__builtin_ia32_psrawi((::__v4hi)__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrawi(::__m64 __m, int __count)
{
  return ::_mm_srai_pi16(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sra_pi32(::__m64 __m, ::__m64 __count)
{
  return (::__m64)__builtin_ia32_psrad((::__v2si)__m, (::__v2si)__count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrad(::__m64 __m, ::__m64 __count)
{
  return ::_mm_sra_pi32(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srai_pi32(::__m64 __m, int __count)
{
  return (::__m64)__builtin_ia32_psradi((::__v2si)__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psradi(::__m64 __m, int __count)
{
  return ::_mm_srai_pi32(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srl_pi16(::__m64 __m, ::__m64 __count)
{
  return (::__m64)__builtin_ia32_psrlw((::__v4hi)__m, (::__v4hi)__count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrlw(::__m64 __m, ::__m64 __count)
{
  return ::_mm_srl_pi16(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srli_pi16(::__m64 __m, int __count)
{
  return (::__m64)__builtin_ia32_psrlwi((::__v4hi)__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrlwi(::__m64 __m, int __count)
{
  return ::_mm_srli_pi16(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srl_pi32(::__m64 __m, ::__m64 __count)
{
  return (::__m64)__builtin_ia32_psrld((::__v2si)__m, (::__v2si)__count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrld(::__m64 __m, ::__m64 __count)
{
  return ::_mm_srl_pi32(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srli_pi32(::__m64 __m, int __count)
{
  return (::__m64)__builtin_ia32_psrldi((::__v2si)__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrldi(::__m64 __m, int __count)
{
  return ::_mm_srli_pi32(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srl_si64(::__m64 __m, ::__m64 __count)
{
  return (::__m64)__builtin_ia32_psrlq((::__v1di)__m, (::__v1di)__count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrlq(::__m64 __m, ::__m64 __count)
{
  return ::_mm_srl_si64(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_srli_si64(::__m64 __m, int __count)
{
  return (::__m64)__builtin_ia32_psrlqi((::__v1di)__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psrlqi(::__m64 __m, int __count)
{
  return ::_mm_srli_si64(__m, __count);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_and_si64(::__m64 __m1, ::__m64 __m2)
{
  return __builtin_ia32_pand(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pand(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_and_si64(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_andnot_si64(::__m64 __m1, ::__m64 __m2)
{
  return __builtin_ia32_pandn(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pandn(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_andnot_si64(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_or_si64(::__m64 __m1, ::__m64 __m2)
{
  return __builtin_ia32_por(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_por(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_or_si64(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_xor_si64(::__m64 __m1, ::__m64 __m2)
{
  return __builtin_ia32_pxor(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pxor(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_xor_si64(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cmpeq_pi8(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_pcmpeqb((::__v8qi)__m1, (::__v8qi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pcmpeqb(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_cmpeq_pi8(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cmpgt_pi8(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_pcmpgtb((::__v8qi)__m1, (::__v8qi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pcmpgtb(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_cmpgt_pi8(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cmpeq_pi16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_pcmpeqw((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pcmpeqw(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_cmpeq_pi16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cmpgt_pi16(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_pcmpgtw((::__v4hi)__m1, (::__v4hi)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pcmpgtw(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_cmpgt_pi16(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cmpeq_pi32(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_pcmpeqd((::__v2si)__m1, (::__v2si)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pcmpeqd(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_cmpeq_pi32(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cmpgt_pi32(::__m64 __m1, ::__m64 __m2)
{
  return (::__m64)__builtin_ia32_pcmpgtd((::__v2si)__m1, (::__v2si)__m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pcmpgtd(::__m64 __m1, ::__m64 __m2)
{
  return ::_mm_cmpgt_pi32(__m1, __m2);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_setzero_si64()
{
  return (::__m64)0LL;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_set_pi32(int __i1, int __i0)
{
  return (::__m64)__builtin_ia32_vec_init_v2si(__i0, __i1);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_set_pi16(short int __w3, short int __w2, short int __w1, short int __w0)
{
  return (::__m64)__builtin_ia32_vec_init_v4hi(__w0, __w1, __w2, __w3);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_set_pi8(char __b7, char __b6, char __b5, char __b4, char __b3, char __b2, char __b1, char __b0)
{
  return (::__m64)__builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3, __b4, __b5, __b6, __b7);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_setr_pi32(int __i0, int __i1)
{
  return ::_mm_set_pi32(__i1, __i0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_setr_pi16(short int __w0, short int __w1, short int __w2, short int __w3)
{
  return ::_mm_set_pi16(__w3, __w2, __w1, __w0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_setr_pi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5, char __b6, char __b7)
{
  return ::_mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_set1_pi32(int __i)
{
  return ::_mm_set_pi32(__i, __i);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_set1_pi16(short int __w)
{
  return ::_mm_set_pi16(__w, __w, __w, __w);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_set1_pi8(char __b)
{
  return ::_mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
}
static inline void *_mm_malloc(::size_t size, ::size_t alignment)
{
  void *ptr;
  if (alignment == 1)
    {
      return ::malloc(size);
    }
  if (alignment == 2 || (sizeof(void *) == 8 && alignment == 4))
    {
      alignment = sizeof(void *);
    }
  if (::posix_memalign(&ptr, alignment, size) == 0)
    {
      return ptr;
    }
  else
    {
      return 0L;
    }
}
static inline void _mm_free(void *ptr)
{
  ::free(ptr);
}
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) float __m128;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) float __v4sf;
enum _mm_hint
{
  _MM_HINT_T0 = 3,
  _MM_HINT_T1 = 2,
  _MM_HINT_T2 = 1,
  _MM_HINT_NTA = 0
};
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_setzero_ps()
{
  return (::__m128){0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_add_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_addss((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_sub_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_subss((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_mul_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_mulss((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_div_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_divss((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_sqrt_ss(::__m128 __A)
{
  return (::__m128)__builtin_ia32_sqrtss((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_rcp_ss(::__m128 __A)
{
  return (::__m128)__builtin_ia32_rcpss((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_rsqrt_ss(::__m128 __A)
{
  return (::__m128)__builtin_ia32_rsqrtss((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_min_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_minss((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_max_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_maxss((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_add_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_addps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_sub_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_subps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_mul_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_mulps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_div_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_divps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_sqrt_ps(::__m128 __A)
{
  return (::__m128)__builtin_ia32_sqrtps((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_rcp_ps(::__m128 __A)
{
  return (::__m128)__builtin_ia32_rcpps((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_rsqrt_ps(::__m128 __A)
{
  return (::__m128)__builtin_ia32_rsqrtps((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_min_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_minps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_max_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_maxps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_and_ps(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_andps(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_andnot_ps(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_andnps(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_or_ps(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_orps(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_xor_ps(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_xorps(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpeq_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpeqss((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmplt_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpltss((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmple_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpless((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpgt_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_movss((::__v4sf)__A, (::__v4sf)__builtin_ia32_cmpltss((::__v4sf)__B, (::__v4sf)__A));
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpge_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_movss((::__v4sf)__A, (::__v4sf)__builtin_ia32_cmpless((::__v4sf)__B, (::__v4sf)__A));
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpneq_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpneqss((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpnlt_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpnltss((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpnle_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpnless((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpngt_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_movss((::__v4sf)__A, (::__v4sf)__builtin_ia32_cmpnltss((::__v4sf)__B, (::__v4sf)__A));
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpnge_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_movss((::__v4sf)__A, (::__v4sf)__builtin_ia32_cmpnless((::__v4sf)__B, (::__v4sf)__A));
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpord_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpordss((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpunord_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpunordss((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpeq_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpeqps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmplt_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpltps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmple_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpleps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpgt_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpgtps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpge_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpgeps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpneq_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpneqps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpnlt_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpnltps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpnle_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpnleps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpngt_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpngtps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpnge_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpngeps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpord_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpordps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cmpunord_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_cmpunordps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comieq_ss(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_comieq((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comilt_ss(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_comilt((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comile_ss(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_comile((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comigt_ss(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_comigt((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comige_ss(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_comige((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comineq_ss(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_comineq((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomieq_ss(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_ucomieq((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomilt_ss(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_ucomilt((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomile_ss(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_ucomile((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomigt_ss(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_ucomigt((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomige_ss(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_ucomige((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomineq_ss(::__m128 __A, ::__m128 __B)
{
  return __builtin_ia32_ucomineq((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvtss_si32(::__m128 __A)
{
  return __builtin_ia32_cvtss2si((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvt_ss2si(::__m128 __A)
{
  return ::_mm_cvtss_si32(__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtss_si64(::__m128 __A)
{
  return __builtin_ia32_cvtss2si64((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtss_si64x(::__m128 __A)
{
  return __builtin_ia32_cvtss2si64((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtps_pi32(::__m128 __A)
{
  return (::__m64)__builtin_ia32_cvtps2pi((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvt_ps2pi(::__m128 __A)
{
  return ::_mm_cvtps_pi32(__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvttss_si32(::__m128 __A)
{
  return __builtin_ia32_cvttss2si((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvtt_ss2si(::__m128 __A)
{
  return ::_mm_cvttss_si32(__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvttss_si64(::__m128 __A)
{
  return __builtin_ia32_cvttss2si64((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvttss_si64x(::__m128 __A)
{
  return __builtin_ia32_cvttss2si64((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvttps_pi32(::__m128 __A)
{
  return (::__m64)__builtin_ia32_cvttps2pi((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtt_ps2pi(::__m128 __A)
{
  return ::_mm_cvttps_pi32(__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtsi32_ss(::__m128 __A, int __B)
{
  return (::__m128)__builtin_ia32_cvtsi2ss((::__v4sf)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvt_si2ss(::__m128 __A, int __B)
{
  return ::_mm_cvtsi32_ss(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtsi64_ss(::__m128 __A, long long int __B)
{
  return (::__m128)__builtin_ia32_cvtsi642ss((::__v4sf)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtsi64x_ss(::__m128 __A, long long int __B)
{
  return (::__m128)__builtin_ia32_cvtsi642ss((::__v4sf)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtpi32_ps(::__m128 __A, ::__m64 __B)
{
  return (::__m128)__builtin_ia32_cvtpi2ps((::__v4sf)__A, (::__v2si)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvt_pi2ps(::__m128 __A, ::__m64 __B)
{
  return ::_mm_cvtpi32_ps(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtpi16_ps(::__m64 __A)
{
  ::__v4hi __sign;
  ::__v2si __hisi;
  ::__v2si __losi;
  ::__v4sf __zero;
  ::__v4sf __ra;
  ::__v4sf __rb;
  __sign = __builtin_ia32_pcmpgtw((::__v4hi)0LL, (::__v4hi)__A);
  __losi = (::__v2si)__builtin_ia32_punpcklwd((::__v4hi)__A, __sign);
  __hisi = (::__v2si)__builtin_ia32_punpckhwd((::__v4hi)__A, __sign);
  __zero = (::__v4sf)::_mm_setzero_ps();
  __ra = __builtin_ia32_cvtpi2ps(__zero, __losi);
  __rb = __builtin_ia32_cvtpi2ps(__ra, __hisi);
  return (::__m128)__builtin_ia32_movlhps(__ra, __rb);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtpu16_ps(::__m64 __A)
{
  ::__v2si __hisi;
  ::__v2si __losi;
  ::__v4sf __zero;
  ::__v4sf __ra;
  ::__v4sf __rb;
  __losi = (::__v2si)__builtin_ia32_punpcklwd((::__v4hi)__A, (::__v4hi)0LL);
  __hisi = (::__v2si)__builtin_ia32_punpckhwd((::__v4hi)__A, (::__v4hi)0LL);
  __zero = (::__v4sf)::_mm_setzero_ps();
  __ra = __builtin_ia32_cvtpi2ps(__zero, __losi);
  __rb = __builtin_ia32_cvtpi2ps(__ra, __hisi);
  return (::__m128)__builtin_ia32_movlhps(__ra, __rb);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtpi8_ps(::__m64 __A)
{
  ::__v8qi __sign;
  __sign = __builtin_ia32_pcmpgtb((::__v8qi)0LL, (::__v8qi)__A);
  __A = (::__m64)__builtin_ia32_punpcklbw((::__v8qi)__A, __sign);
  return ::_mm_cvtpi16_ps(__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtpu8_ps(::__m64 __A)
{
  __A = (::__m64)__builtin_ia32_punpcklbw((::__v8qi)__A, (::__v8qi)0LL);
  return ::_mm_cvtpu16_ps(__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtpi32x2_ps(::__m64 __A, ::__m64 __B)
{
  ::__v4sf __zero((::__v4sf)::_mm_setzero_ps());
  ::__v4sf __sfa(__builtin_ia32_cvtpi2ps(__zero, (::__v2si)__A));
  ::__v4sf __sfb(__builtin_ia32_cvtpi2ps(__sfa, (::__v2si)__B));
  return (::__m128)__builtin_ia32_movlhps(__sfa, __sfb);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtps_pi16(::__m128 __A)
{
  ::__v4sf __hisf((::__v4sf)__A);
  ::__v4sf __losf(__builtin_ia32_movhlps(__hisf, __hisf));
  ::__v2si __hisi(__builtin_ia32_cvtps2pi(__hisf));
  ::__v2si __losi(__builtin_ia32_cvtps2pi(__losf));
  return (::__m64)__builtin_ia32_packssdw(__hisi, __losi);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtps_pi8(::__m128 __A)
{
  ::__v4hi __tmp((::__v4hi)::_mm_cvtps_pi16(__A));
  return (::__m64)__builtin_ia32_packsswb(__tmp, (::__v4hi)0LL);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_shuffle_ps(::__m128 __A, ::__m128 __B, const int __mask)
{
  return (::__m128)__builtin_ia32_shufps((::__v4sf)__A, (::__v4sf)__B, __mask);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_unpackhi_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_unpckhps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_unpacklo_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_unpcklps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_loadh_pi(::__m128 __A, const ::__m64 *__P)
{
  return (::__m128)__builtin_ia32_loadhps((::__v4sf)__A, (const ::__v2sf *)__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storeh_pi(::__m64 *__P, ::__m128 __A)
{
  __builtin_ia32_storehps((::__v2sf *)__P, (::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_movehl_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_movhlps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_movelh_ps(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_movlhps((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_loadl_pi(::__m128 __A, const ::__m64 *__P)
{
  return (::__m128)__builtin_ia32_loadlps((::__v4sf)__A, (const ::__v2sf *)__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storel_pi(::__m64 *__P, ::__m128 __A)
{
  __builtin_ia32_storelps((::__v2sf *)__P, (::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_movemask_ps(::__m128 __A)
{
  return __builtin_ia32_movmskps((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned int _mm_getcsr()
{
  return __builtin_ia32_stmxcsr();
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned int _MM_GET_EXCEPTION_STATE()
{
  return ::_mm_getcsr() & 63;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned int _MM_GET_EXCEPTION_MASK()
{
  return ::_mm_getcsr() & 8064;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned int _MM_GET_ROUNDING_MODE()
{
  return ::_mm_getcsr() & 24576;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned int _MM_GET_FLUSH_ZERO_MODE()
{
  return ::_mm_getcsr() & 32768;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_setcsr(unsigned int __I)
{
  __builtin_ia32_ldmxcsr(__I);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _MM_SET_EXCEPTION_STATE(unsigned int __mask)
{
  ::_mm_setcsr((::_mm_getcsr() & ~63) | __mask);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _MM_SET_EXCEPTION_MASK(unsigned int __mask)
{
  ::_mm_setcsr((::_mm_getcsr() & ~8064) | __mask);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _MM_SET_ROUNDING_MODE(unsigned int __mode)
{
  ::_mm_setcsr((::_mm_getcsr() & ~24576) | __mode);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _MM_SET_FLUSH_ZERO_MODE(unsigned int __mode)
{
  ::_mm_setcsr((::_mm_getcsr() & ~32768) | __mode);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_set_ss(float __F)
{
  return (::__m128)(::__v4sf){__F, 0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f, 0.000000000000000000000000e+00f};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_set1_ps(float __F)
{
  return (::__m128)(::__v4sf){__F, __F, __F, __F};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_set_ps1(float __F)
{
  return ::_mm_set1_ps(__F);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_load_ss(const float *__P)
{
  return ::_mm_set_ss(*__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_load1_ps(const float *__P)
{
  return ::_mm_set1_ps(*__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_load_ps1(const float *__P)
{
  return ::_mm_load1_ps(__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_load_ps(const float *__P)
{
  return (::__m128)*((::__v4sf *)__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_loadu_ps(const float *__P)
{
  return (::__m128)__builtin_ia32_loadups(__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_loadr_ps(const float *__P)
{
  ::__v4sf __tmp(*((::__v4sf *)__P));
  return (::__m128)__builtin_ia32_shufps(__tmp, __tmp, ((0 << 6 | 1 << 4) | 2 << 2) | 3);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_set_ps(const float __Z, const float __Y, const float __X, const float __W)
{
  return (::__m128)(::__v4sf){__W, __X, __Y, __Z};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_setr_ps(float __Z, float __Y, float __X, float __W)
{
  return (::__m128)(::__v4sf){__Z, __Y, __X, __W};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store_ss(float *__P, ::__m128 __A)
{
  *__P = __builtin_ia32_vec_ext_v4sf((::__v4sf)__A, 0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) float _mm_cvtss_f32(::__m128 __A)
{
  return __builtin_ia32_vec_ext_v4sf((::__v4sf)__A, 0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store_ps(float *__P, ::__m128 __A)
{
  *((::__v4sf *)__P) = (::__v4sf)__A;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storeu_ps(float *__P, ::__m128 __A)
{
  __builtin_ia32_storeups(__P, (::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store1_ps(float *__P, ::__m128 __A)
{
  ::__v4sf __va((::__v4sf)__A);
  ::__v4sf __tmp(__builtin_ia32_shufps(__va, __va, ((0 << 6 | 0 << 4) | 0 << 2) | 0));
  ::_mm_storeu_ps(__P, __tmp);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store_ps1(float *__P, ::__m128 __A)
{
  ::_mm_store1_ps(__P, __A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storer_ps(float *__P, ::__m128 __A)
{
  ::__v4sf __va((::__v4sf)__A);
  ::__v4sf __tmp(__builtin_ia32_shufps(__va, __va, ((0 << 6 | 1 << 4) | 2 << 2) | 3));
  ::_mm_store_ps(__P, __tmp);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_move_ss(::__m128 __A, ::__m128 __B)
{
  return (::__m128)__builtin_ia32_movss((::__v4sf)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_extract_pi16(const ::__m64 __A, const int __N)
{
  return __builtin_ia32_vec_ext_v4hi((::__v4hi)__A, __N);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _m_pextrw(const ::__m64 __A, const int __N)
{
  return ::_mm_extract_pi16(__A, __N);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_insert_pi16(const ::__m64 __A, const int __D, const int __N)
{
  return (::__m64)__builtin_ia32_vec_set_v4hi((::__v4hi)__A, __D, __N);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pinsrw(const ::__m64 __A, const int __D, const int __N)
{
  return ::_mm_insert_pi16(__A, __D, __N);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_max_pi16(::__m64 __A, ::__m64 __B)
{
  return (::__m64)__builtin_ia32_pmaxsw((::__v4hi)__A, (::__v4hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pmaxsw(::__m64 __A, ::__m64 __B)
{
  return ::_mm_max_pi16(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_max_pu8(::__m64 __A, ::__m64 __B)
{
  return (::__m64)__builtin_ia32_pmaxub((::__v8qi)__A, (::__v8qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pmaxub(::__m64 __A, ::__m64 __B)
{
  return ::_mm_max_pu8(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_min_pi16(::__m64 __A, ::__m64 __B)
{
  return (::__m64)__builtin_ia32_pminsw((::__v4hi)__A, (::__v4hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pminsw(::__m64 __A, ::__m64 __B)
{
  return ::_mm_min_pi16(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_min_pu8(::__m64 __A, ::__m64 __B)
{
  return (::__m64)__builtin_ia32_pminub((::__v8qi)__A, (::__v8qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pminub(::__m64 __A, ::__m64 __B)
{
  return ::_mm_min_pu8(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_movemask_pi8(::__m64 __A)
{
  return __builtin_ia32_pmovmskb((::__v8qi)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _m_pmovmskb(::__m64 __A)
{
  return ::_mm_movemask_pi8(__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_mulhi_pu16(::__m64 __A, ::__m64 __B)
{
  return (::__m64)__builtin_ia32_pmulhuw((::__v4hi)__A, (::__v4hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pmulhuw(::__m64 __A, ::__m64 __B)
{
  return ::_mm_mulhi_pu16(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_shuffle_pi16(::__m64 __A, const int __N)
{
  return (::__m64)__builtin_ia32_pshufw((::__v4hi)__A, __N);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pshufw(::__m64 __A, const int __N)
{
  return ::_mm_shuffle_pi16(__A, __N);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_maskmove_si64(::__m64 __A, ::__m64 __N, char *__P)
{
  __builtin_ia32_maskmovq((::__v8qi)__A, (::__v8qi)__N, __P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _m_maskmovq(::__m64 __A, ::__m64 __N, char *__P)
{
  ::_mm_maskmove_si64(__A, __N, __P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_avg_pu8(::__m64 __A, ::__m64 __B)
{
  return (::__m64)__builtin_ia32_pavgb((::__v8qi)__A, (::__v8qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pavgb(::__m64 __A, ::__m64 __B)
{
  return ::_mm_avg_pu8(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_avg_pu16(::__m64 __A, ::__m64 __B)
{
  return (::__m64)__builtin_ia32_pavgw((::__v4hi)__A, (::__v4hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_pavgw(::__m64 __A, ::__m64 __B)
{
  return ::_mm_avg_pu16(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_sad_pu8(::__m64 __A, ::__m64 __B)
{
  return (::__m64)__builtin_ia32_psadbw((::__v8qi)__A, (::__v8qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _m_psadbw(::__m64 __A, ::__m64 __B)
{
  return ::_mm_sad_pu8(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_prefetch(const void *__P, ::_mm_hint __I)
{
  __builtin_prefetch(__P, 0, __I);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_stream_pi(::__m64 *__P, ::__m64 __A)
{
  __builtin_ia32_movntq((unsigned long long int *)__P, (unsigned long long int)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_stream_ps(float *__P, ::__m128 __A)
{
  __builtin_ia32_movntps(__P, (::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_sfence()
{
  __builtin_ia32_sfence();
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_pause()
{
  __builtin_ia32_pause();
}
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) double __v2df;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) long long int __v2di;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) int __v4si;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) short int __v8hi;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) char __v16qi;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) long long int __m128i;
typedef __attribute__((vector_size(16))) __attribute__((__may_alias__)) double __m128d;
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_set_sd(double __F)
{
  return (::__m128d){__F, 0.00000000000000000000000000000000000000000000000000000e+00};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_set1_pd(double __F)
{
  return (::__m128d){__F, __F};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_set_pd1(double __F)
{
  return ::_mm_set1_pd(__F);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_set_pd(double __W, double __X)
{
  return (::__m128d){__X, __W};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_setr_pd(double __W, double __X)
{
  return (::__m128d){__W, __X};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_setzero_pd()
{
  return (::__m128d){0.00000000000000000000000000000000000000000000000000000e+00, 0.00000000000000000000000000000000000000000000000000000e+00};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_move_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_movsd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_load_pd(const double *__P)
{
  return *((::__m128d *)__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_loadu_pd(const double *__P)
{
  return __builtin_ia32_loadupd(__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_load1_pd(const double *__P)
{
  return ::_mm_set1_pd(*__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_load_sd(const double *__P)
{
  return ::_mm_set_sd(*__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_load_pd1(const double *__P)
{
  return ::_mm_load1_pd(__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_loadr_pd(const double *__P)
{
  ::__m128d __tmp(::_mm_load_pd(__P));
  return __builtin_ia32_shufpd(__tmp, __tmp, 0 << 1 | 1);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store_pd(double *__P, ::__m128d __A)
{
  *((::__m128d *)__P) = __A;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storeu_pd(double *__P, ::__m128d __A)
{
  __builtin_ia32_storeupd(__P, __A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store_sd(double *__P, ::__m128d __A)
{
  *__P = __builtin_ia32_vec_ext_v2df(__A, 0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) double _mm_cvtsd_f64(::__m128d __A)
{
  return __builtin_ia32_vec_ext_v2df(__A, 0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storel_pd(double *__P, ::__m128d __A)
{
  ::_mm_store_sd(__P, __A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storeh_pd(double *__P, ::__m128d __A)
{
  *__P = __builtin_ia32_vec_ext_v2df(__A, 1);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store1_pd(double *__P, ::__m128d __A)
{
  ::_mm_store_pd(__P, __builtin_ia32_shufpd(__A, __A, 0 << 1 | 0));
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store_pd1(double *__P, ::__m128d __A)
{
  ::_mm_store1_pd(__P, __A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storer_pd(double *__P, ::__m128d __A)
{
  ::_mm_store_pd(__P, __builtin_ia32_shufpd(__A, __A, 0 << 1 | 1));
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvtsi128_si32(::__m128i __A)
{
  return __builtin_ia32_vec_ext_v4si((::__v4si)__A, 0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtsi128_si64(::__m128i __A)
{
  return __builtin_ia32_vec_ext_v2di((::__v2di)__A, 0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtsi128_si64x(::__m128i __A)
{
  return __builtin_ia32_vec_ext_v2di((::__v2di)__A, 0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_add_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_addpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_add_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_addsd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_sub_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_subpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_sub_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_subsd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_mul_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_mulpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_mul_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_mulsd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_div_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_divpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_div_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_divsd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_sqrt_pd(::__m128d __A)
{
  return (::__m128d)__builtin_ia32_sqrtpd((::__v2df)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_sqrt_sd(::__m128d __A, ::__m128d __B)
{
  ::__v2df __tmp(__builtin_ia32_movsd((::__v2df)__A, (::__v2df)__B));
  return (::__m128d)__builtin_ia32_sqrtsd((::__v2df)__tmp);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_min_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_minpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_min_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_minsd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_max_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_maxpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_max_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_maxsd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_and_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_andpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_andnot_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_andnpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_or_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_orpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_xor_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_xorpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpeq_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpeqpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmplt_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpltpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmple_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmplepd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpgt_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpgtpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpge_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpgepd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpneq_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpneqpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpnlt_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpnltpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpnle_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpnlepd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpngt_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpngtpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpnge_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpngepd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpord_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpordpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpunord_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpunordpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpeq_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpeqsd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmplt_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpltsd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmple_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmplesd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpgt_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_movsd((::__v2df)__A, (::__v2df)__builtin_ia32_cmpltsd((::__v2df)__B, (::__v2df)__A));
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpge_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_movsd((::__v2df)__A, (::__v2df)__builtin_ia32_cmplesd((::__v2df)__B, (::__v2df)__A));
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpneq_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpneqsd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpnlt_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpnltsd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpnle_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpnlesd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpngt_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_movsd((::__v2df)__A, (::__v2df)__builtin_ia32_cmpnltsd((::__v2df)__B, (::__v2df)__A));
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpnge_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_movsd((::__v2df)__A, (::__v2df)__builtin_ia32_cmpnlesd((::__v2df)__B, (::__v2df)__A));
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpord_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpordsd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cmpunord_sd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_cmpunordsd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comieq_sd(::__m128d __A, ::__m128d __B)
{
  return __builtin_ia32_comisdeq((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comilt_sd(::__m128d __A, ::__m128d __B)
{
  return __builtin_ia32_comisdlt((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comile_sd(::__m128d __A, ::__m128d __B)
{
  return __builtin_ia32_comisdle((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comigt_sd(::__m128d __A, ::__m128d __B)
{
  return __builtin_ia32_comisdgt((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comige_sd(::__m128d __A, ::__m128d __B)
{
  return __builtin_ia32_comisdge((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_comineq_sd(::__m128d __A, ::__m128d __B)
{
  return __builtin_ia32_comisdneq((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomieq_sd(::__m128d __A, ::__m128d __B)
{
  return __builtin_ia32_ucomisdeq((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomilt_sd(::__m128d __A, ::__m128d __B)
{
  return __builtin_ia32_ucomisdlt((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomile_sd(::__m128d __A, ::__m128d __B)
{
  return __builtin_ia32_ucomisdle((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomigt_sd(::__m128d __A, ::__m128d __B)
{
  return __builtin_ia32_ucomisdgt((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomige_sd(::__m128d __A, ::__m128d __B)
{
  return __builtin_ia32_ucomisdge((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_ucomineq_sd(::__m128d __A, ::__m128d __B)
{
  return __builtin_ia32_ucomisdneq((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set_epi64x(long long int __q1, long long int __q0)
{
  return (::__m128i)(::__v2di){__q0, __q1};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set_epi64(::__m64 __q1, ::__m64 __q0)
{
  return ::_mm_set_epi64x((long long int)__q1, (long long int)__q0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set_epi32(int __q3, int __q2, int __q1, int __q0)
{
  return (::__m128i)(::__v4si){__q0, __q1, __q2, __q3};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set_epi16(short int __q7, short int __q6, short int __q5, short int __q4, short int __q3, short int __q2, short int __q1, short int __q0)
{
  return (::__m128i)(::__v8hi){__q0, __q1, __q2, __q3, __q4, __q5, __q6, __q7};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set_epi8(char __q15, char __q14, char __q13, char __q12, char __q11, char __q10, char __q09, char __q08, char __q07, char __q06, char __q05, char __q04, char __q03, char __q02, char __q01, char __q00)
{
  return (::__m128i)(::__v16qi){__q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07, __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set1_epi64x(long long int __A)
{
  return ::_mm_set_epi64x(__A, __A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set1_epi64(::__m64 __A)
{
  return ::_mm_set_epi64(__A, __A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set1_epi32(int __A)
{
  return ::_mm_set_epi32(__A, __A, __A, __A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set1_epi16(short int __A)
{
  return ::_mm_set_epi16(__A, __A, __A, __A, __A, __A, __A, __A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_set1_epi8(char __A)
{
  return ::_mm_set_epi8(__A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_setr_epi64(::__m64 __q0, ::__m64 __q1)
{
  return ::_mm_set_epi64(__q1, __q0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_setr_epi32(int __q0, int __q1, int __q2, int __q3)
{
  return ::_mm_set_epi32(__q3, __q2, __q1, __q0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_setr_epi16(short int __q0, short int __q1, short int __q2, short int __q3, short int __q4, short int __q5, short int __q6, short int __q7)
{
  return ::_mm_set_epi16(__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_setr_epi8(char __q00, char __q01, char __q02, char __q03, char __q04, char __q05, char __q06, char __q07, char __q08, char __q09, char __q10, char __q11, char __q12, char __q13, char __q14, char __q15)
{
  return ::_mm_set_epi8(__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08, __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_load_si128(const ::__m128i *__P)
{
  return *__P;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_loadu_si128(const ::__m128i *__P)
{
  return (::__m128i)__builtin_ia32_loaddqu((const char *)__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_loadl_epi64(const ::__m128i *__P)
{
  return ::_mm_set_epi64((::__m64)0LL, *((::__m64 *)__P));
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_store_si128(::__m128i *__P, ::__m128i __B)
{
  *__P = __B;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storeu_si128(::__m128i *__P, ::__m128i __B)
{
  __builtin_ia32_storedqu((char *)__P, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_storel_epi64(::__m128i *__P, ::__m128i __B)
{
  *((long long int *)__P) = __builtin_ia32_vec_ext_v2di((::__v2di)__B, 0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_movepi64_pi64(::__m128i __B)
{
  return (::__m64)__builtin_ia32_vec_ext_v2di((::__v2di)__B, 0);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_movpi64_epi64(::__m64 __A)
{
  return ::_mm_set_epi64((::__m64)0LL, __A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_move_epi64(::__m128i __A)
{
  return (::__m128i)__builtin_ia32_movq128((::__v2di)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_setzero_si128()
{
  return (::__m128i)(::__v4si){0, 0, 0, 0};
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cvtepi32_pd(::__m128i __A)
{
  return (::__m128d)__builtin_ia32_cvtdq2pd((::__v4si)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtepi32_ps(::__m128i __A)
{
  return (::__m128)__builtin_ia32_cvtdq2ps((::__v4si)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cvtpd_epi32(::__m128d __A)
{
  return (::__m128i)__builtin_ia32_cvtpd2dq((::__v2df)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvtpd_pi32(::__m128d __A)
{
  return (::__m64)__builtin_ia32_cvtpd2pi((::__v2df)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtpd_ps(::__m128d __A)
{
  return (::__m128)__builtin_ia32_cvtpd2ps((::__v2df)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cvttpd_epi32(::__m128d __A)
{
  return (::__m128i)__builtin_ia32_cvttpd2dq((::__v2df)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_cvttpd_pi32(::__m128d __A)
{
  return (::__m64)__builtin_ia32_cvttpd2pi((::__v2df)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cvtpi32_pd(::__m64 __A)
{
  return (::__m128d)__builtin_ia32_cvtpi2pd((::__v2si)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cvtps_epi32(::__m128 __A)
{
  return (::__m128i)__builtin_ia32_cvtps2dq((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cvttps_epi32(::__m128 __A)
{
  return (::__m128i)__builtin_ia32_cvttps2dq((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cvtps_pd(::__m128 __A)
{
  return (::__m128d)__builtin_ia32_cvtps2pd((::__v4sf)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvtsd_si32(::__m128d __A)
{
  return __builtin_ia32_cvtsd2si((::__v2df)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtsd_si64(::__m128d __A)
{
  return __builtin_ia32_cvtsd2si64((::__v2df)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvtsd_si64x(::__m128d __A)
{
  return __builtin_ia32_cvtsd2si64((::__v2df)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_cvttsd_si32(::__m128d __A)
{
  return __builtin_ia32_cvttsd2si((::__v2df)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvttsd_si64(::__m128d __A)
{
  return __builtin_ia32_cvttsd2si64((::__v2df)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) long long int _mm_cvttsd_si64x(::__m128d __A)
{
  return __builtin_ia32_cvttsd2si64((::__v2df)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_cvtsd_ss(::__m128 __A, ::__m128d __B)
{
  return (::__m128)__builtin_ia32_cvtsd2ss((::__v4sf)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cvtsi32_sd(::__m128d __A, int __B)
{
  return (::__m128d)__builtin_ia32_cvtsi2sd((::__v2df)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cvtsi64_sd(::__m128d __A, long long int __B)
{
  return (::__m128d)__builtin_ia32_cvtsi642sd((::__v2df)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cvtsi64x_sd(::__m128d __A, long long int __B)
{
  return (::__m128d)__builtin_ia32_cvtsi642sd((::__v2df)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_cvtss_sd(::__m128d __A, ::__m128 __B)
{
  return (::__m128d)__builtin_ia32_cvtss2sd((::__v2df)__A, (::__v4sf)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_shuffle_pd(::__m128d __A, ::__m128d __B, const int __mask)
{
  return (::__m128d)__builtin_ia32_shufpd((::__v2df)__A, (::__v2df)__B, __mask);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_unpackhi_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_unpckhpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_unpacklo_pd(::__m128d __A, ::__m128d __B)
{
  return (::__m128d)__builtin_ia32_unpcklpd((::__v2df)__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_loadh_pd(::__m128d __A, const double *__B)
{
  return (::__m128d)__builtin_ia32_loadhpd((::__v2df)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_loadl_pd(::__m128d __A, const double *__B)
{
  return (::__m128d)__builtin_ia32_loadlpd((::__v2df)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_movemask_pd(::__m128d __A)
{
  return __builtin_ia32_movmskpd((::__v2df)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_packs_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_packsswb128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_packs_epi32(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_packssdw128((::__v4si)__A, (::__v4si)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_packus_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_packuswb128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpackhi_epi8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_punpckhbw128((::__v16qi)__A, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpackhi_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_punpckhwd128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpackhi_epi32(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_punpckhdq128((::__v4si)__A, (::__v4si)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpackhi_epi64(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_punpckhqdq128((::__v2di)__A, (::__v2di)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpacklo_epi8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_punpcklbw128((::__v16qi)__A, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpacklo_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_punpcklwd128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpacklo_epi32(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_punpckldq128((::__v4si)__A, (::__v4si)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_unpacklo_epi64(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_punpcklqdq128((::__v2di)__A, (::__v2di)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_add_epi8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_paddb128((::__v16qi)__A, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_add_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_paddw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_add_epi32(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_paddd128((::__v4si)__A, (::__v4si)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_add_epi64(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_paddq128((::__v2di)__A, (::__v2di)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_adds_epi8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_paddsb128((::__v16qi)__A, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_adds_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_paddsw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_adds_epu8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_paddusb128((::__v16qi)__A, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_adds_epu16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_paddusw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sub_epi8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psubb128((::__v16qi)__A, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sub_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psubw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sub_epi32(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psubd128((::__v4si)__A, (::__v4si)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sub_epi64(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psubq128((::__v2di)__A, (::__v2di)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_subs_epi8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psubsb128((::__v16qi)__A, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_subs_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psubsw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_subs_epu8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psubusb128((::__v16qi)__A, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_subs_epu16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psubusw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_madd_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pmaddwd128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_mulhi_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pmulhw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_mullo_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pmullw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m64 _mm_mul_su32(::__m64 __A, ::__m64 __B)
{
  return (::__m64)__builtin_ia32_pmuludq((::__v2si)__A, (::__v2si)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_mul_epu32(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pmuludq128((::__v4si)__A, (::__v4si)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_slli_epi16(::__m128i __A, int __B)
{
  return (::__m128i)__builtin_ia32_psllwi128((::__v8hi)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_slli_epi32(::__m128i __A, int __B)
{
  return (::__m128i)__builtin_ia32_pslldi128((::__v4si)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_slli_epi64(::__m128i __A, int __B)
{
  return (::__m128i)__builtin_ia32_psllqi128((::__v2di)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srai_epi16(::__m128i __A, int __B)
{
  return (::__m128i)__builtin_ia32_psrawi128((::__v8hi)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srai_epi32(::__m128i __A, int __B)
{
  return (::__m128i)__builtin_ia32_psradi128((::__v4si)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_bsrli_si128(::__m128i __A, const int __N)
{
  return (::__m128i)__builtin_ia32_psrldqi128(__A, __N * 8);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_bslli_si128(::__m128i __A, const int __N)
{
  return (::__m128i)__builtin_ia32_pslldqi128(__A, __N * 8);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srli_si128(::__m128i __A, const int __N)
{
  return (::__m128i)__builtin_ia32_psrldqi128(__A, __N * 8);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_slli_si128(::__m128i __A, const int __N)
{
  return (::__m128i)__builtin_ia32_pslldqi128(__A, __N * 8);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srli_epi16(::__m128i __A, int __B)
{
  return (::__m128i)__builtin_ia32_psrlwi128((::__v8hi)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srli_epi32(::__m128i __A, int __B)
{
  return (::__m128i)__builtin_ia32_psrldi128((::__v4si)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srli_epi64(::__m128i __A, int __B)
{
  return (::__m128i)__builtin_ia32_psrlqi128((::__v2di)__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sll_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psllw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sll_epi32(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pslld128((::__v4si)__A, (::__v4si)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sll_epi64(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psllq128((::__v2di)__A, (::__v2di)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sra_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psraw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sra_epi32(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psrad128((::__v4si)__A, (::__v4si)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srl_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psrlw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srl_epi32(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psrld128((::__v4si)__A, (::__v4si)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_srl_epi64(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psrlq128((::__v2di)__A, (::__v2di)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_and_si128(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pand128((::__v2di)__A, (::__v2di)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_andnot_si128(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pandn128((::__v2di)__A, (::__v2di)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_or_si128(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_por128((::__v2di)__A, (::__v2di)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_xor_si128(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pxor128((::__v2di)__A, (::__v2di)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmpeq_epi8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pcmpeqb128((::__v16qi)__A, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmpeq_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pcmpeqw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmpeq_epi32(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pcmpeqd128((::__v4si)__A, (::__v4si)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmplt_epi8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pcmpgtb128((::__v16qi)__B, (::__v16qi)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmplt_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pcmpgtw128((::__v8hi)__B, (::__v8hi)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmplt_epi32(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pcmpgtd128((::__v4si)__B, (::__v4si)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmpgt_epi8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pcmpgtb128((::__v16qi)__A, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmpgt_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pcmpgtw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cmpgt_epi32(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pcmpgtd128((::__v4si)__A, (::__v4si)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_extract_epi16(const ::__m128i __A, const int __N)
{
  return (unsigned short int)__builtin_ia32_vec_ext_v8hi((::__v8hi)__A, __N);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_insert_epi16(const ::__m128i __A, const int __D, const int __N)
{
  return (::__m128i)__builtin_ia32_vec_set_v8hi((::__v8hi)__A, __D, __N);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_max_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pmaxsw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_max_epu8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pmaxub128((::__v16qi)__A, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_min_epi16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pminsw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_min_epu8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pminub128((::__v16qi)__A, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) int _mm_movemask_epi8(::__m128i __A)
{
  return __builtin_ia32_pmovmskb128((::__v16qi)__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_mulhi_epu16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pmulhuw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_shufflehi_epi16(::__m128i __A, const int __mask)
{
  return (::__m128i)__builtin_ia32_pshufhw((::__v8hi)__A, __mask);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_shufflelo_epi16(::__m128i __A, const int __mask)
{
  return (::__m128i)__builtin_ia32_pshuflw((::__v8hi)__A, __mask);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_shuffle_epi32(::__m128i __A, const int __mask)
{
  return (::__m128i)__builtin_ia32_pshufd((::__v4si)__A, __mask);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_maskmoveu_si128(::__m128i __A, ::__m128i __B, char *__C)
{
  __builtin_ia32_maskmovdqu((::__v16qi)__A, (::__v16qi)__B, __C);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_avg_epu8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pavgb128((::__v16qi)__A, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_avg_epu16(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_pavgw128((::__v8hi)__A, (::__v8hi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_sad_epu8(::__m128i __A, ::__m128i __B)
{
  return (::__m128i)__builtin_ia32_psadbw128((::__v16qi)__A, (::__v16qi)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_stream_si32(int *__A, int __B)
{
  __builtin_ia32_movnti(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_stream_si64(long long int *__A, long long int __B)
{
  __builtin_ia32_movnti64(__A, __B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_stream_si128(::__m128i *__A, ::__m128i __B)
{
  __builtin_ia32_movntdq((::__m128i *)__A, (::__v2di)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_stream_pd(double *__A, ::__m128d __B)
{
  __builtin_ia32_movntpd(__A, (::__v2df)__B);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_clflush(const void *__A)
{
  __builtin_ia32_clflush(__A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_lfence()
{
  __builtin_ia32_lfence();
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _mm_mfence()
{
  __builtin_ia32_mfence();
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cvtsi32_si128(int __A)
{
  return ::_mm_set_epi32(0, 0, 0, __A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cvtsi64_si128(long long int __A)
{
  return ::_mm_set_epi64x(0, __A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_cvtsi64x_si128(long long int __A)
{
  return ::_mm_set_epi64x(0, __A);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_castpd_ps(::__m128d __A)
{
  return (::__m128)__A;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_castpd_si128(::__m128d __A)
{
  return (::__m128i)__A;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_castps_pd(::__m128 __A)
{
  return (::__m128d)__A;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128i _mm_castps_si128(::__m128 __A)
{
  return (::__m128i)__A;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128 _mm_castsi128_ps(::__m128i __A)
{
  return (::__m128)__A;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) ::__m128d _mm_castsi128_pd(::__m128i __A)
{
  return (::__m128d)__A;
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _fxsave(void *__P)
{
  return __builtin_ia32_fxsave(__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _fxrstor(void *__P)
{
  return __builtin_ia32_fxrstor(__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _fxsave64(void *__P)
{
  return __builtin_ia32_fxsave64(__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) void _fxrstor64(void *__P)
{
  return __builtin_ia32_fxrstor64(__P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned char _addcarryx_u32(unsigned char __CF, unsigned int __X, unsigned int __Y, unsigned int *__P)
{
  return __builtin_ia32_addcarryx_u32(__CF, __X, __Y, __P);
}
extern inline __attribute__((__gnu_inline__)) __attribute__((__always_inline__)) __attribute__((__artificial__)) unsigned char _addcarryx_u64(unsigned char __CF, unsigned long int __X, unsigned long int __Y, unsigned long long int *__P)
{
  return __builtin_ia32_addcarryx_u64(__CF, __X, __Y, __P);
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _ForwardIterator, typename _Tp >
  void iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value);
  template < typename _ForwardIterator, typename _Tp >
  void iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value)
  {
    ;
    for (; __first != __last;  ++__first)
      {
        *__first = __value;
         ++__value;
      }
  }
  template < typename _InputIterator, typename _Tp >
  inline _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init);
  template < typename _InputIterator, typename _Tp >
  inline _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
  {
    ;
    for (; __first != __last;  ++__first)
      {
        __init = __init + *__first;
      }
    return __init;
  }
  template < typename _InputIterator, typename _Tp, typename _BinaryOperation >
  inline _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOperation __binary_op);
  template < typename _InputIterator, typename _Tp, typename _BinaryOperation >
  inline _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOperation __binary_op)
  {
    ;
    for (; __first != __last;  ++__first)
      {
        __init = __binary_op(__init, *__first);
      }
    return __init;
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _Tp >
  inline _Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _Tp __init);
  template < typename _InputIterator1, typename _InputIterator2, typename _Tp >
  inline _Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _Tp __init)
  {
    ;
    for (; __first1 != __last1; ( ++__first1,  ++__first2))
      {
        __init = __init + *__first1 * *__first2;
      }
    return __init;
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _Tp, typename _BinaryOperation1, typename _BinaryOperation2 >
  inline _Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _Tp __init, _BinaryOperation1 __binary_op1, _BinaryOperation2 __binary_op2);
  template < typename _InputIterator1, typename _InputIterator2, typename _Tp, typename _BinaryOperation1, typename _BinaryOperation2 >
  inline _Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _Tp __init, _BinaryOperation1 __binary_op1, _BinaryOperation2 __binary_op2)
  {
    ;
    for (; __first1 != __last1; ( ++__first1,  ++__first2))
      {
        __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
      }
    return __init;
  }
  template < typename _InputIterator, typename _OutputIterator >
  _OutputIterator partial_sum(_InputIterator __first, _InputIterator __last, _OutputIterator __result);
  template < typename _InputIterator, typename _OutputIterator >
  _OutputIterator partial_sum(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator>::value_type _ValueType;
    ;
    if (__first == __last)
      {
        return __result;
      }
    _ValueType __value = *__first;
    *__result = __value;
    while ( ++__first != __last)
      {
        __value = __value + *__first;
        * ++__result = __value;
      }
    return  ++__result;
  }
  template < typename _InputIterator, typename _OutputIterator, typename _BinaryOperation >
  _OutputIterator partial_sum(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryOperation __binary_op);
  template < typename _InputIterator, typename _OutputIterator, typename _BinaryOperation >
  _OutputIterator partial_sum(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryOperation __binary_op)
  {
    typedef typename ::std::iterator_traits<_InputIterator>::value_type _ValueType;
    ;
    if (__first == __last)
      {
        return __result;
      }
    _ValueType __value = *__first;
    *__result = __value;
    while ( ++__first != __last)
      {
        __value = __binary_op(__value, *__first);
        * ++__result = __value;
      }
    return  ++__result;
  }
  template < typename _InputIterator, typename _OutputIterator >
  _OutputIterator adjacent_difference(_InputIterator __first, _InputIterator __last, _OutputIterator __result);
  template < typename _InputIterator, typename _OutputIterator >
  _OutputIterator adjacent_difference(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator>::value_type _ValueType;
    ;
    if (__first == __last)
      {
        return __result;
      }
    _ValueType __value = *__first;
    *__result = __value;
    while ( ++__first != __last)
      {
        _ValueType __tmp = *__first;
        * ++__result = __tmp - __value;
        __value = std::move(__tmp);
      }
    return  ++__result;
  }
  template < typename _InputIterator, typename _OutputIterator, typename _BinaryOperation >
  _OutputIterator adjacent_difference(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryOperation __binary_op);
  template < typename _InputIterator, typename _OutputIterator, typename _BinaryOperation >
  _OutputIterator adjacent_difference(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryOperation __binary_op)
  {
    typedef typename ::std::iterator_traits<_InputIterator>::value_type _ValueType;
    ;
    if (__first == __last)
      {
        return __result;
      }
    _ValueType __value = *__first;
    *__result = __value;
    while ( ++__first != __last)
      {
        _ValueType __tmp = *__first;
        * ++__result = __binary_op(__tmp, __value);
        __value = std::move(__tmp);
      }
    return  ++__result;
  }
  namespace __detail {
    template < typename _Tp, _Tp __m, _Tp __a, _Tp __c >
    _Tp _Mod<_Tp, __m, __a, __c, false, true>::__calc(_Tp __x)
    {
      if (__a == 1)
        {
          __x %= __m;
        }
      else
        {
          static const _Tp __q = __m / __a;
          static const _Tp __r = __m % __a;
          _Tp __t1 = __a * (__x % __q);
          _Tp __t2 = __r * (__x / __q);
          if (__t1 >= __t2)
            {
              __x = __t1 - __t2;
            }
          else
            {
              __x = __m - __t2 + __t1;
            }
        }
      if (__c != 0)
        {
          const _Tp __d = __m - __x;
          if (__d > __c)
            {
              __x += __c;
            }
          else
            {
              __x = __c - __d;
            }
        }
      return __x;
    }
    template < typename _InputIterator, typename _OutputIterator, typename _Tp >
    _OutputIterator __normalize(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__factor);
    template < typename _InputIterator, typename _OutputIterator, typename _Tp >
    _OutputIterator __normalize(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__factor)
    {
      for (; __first != __last; ( ++__first,  ++__result))
        {
          *__result = *__first / __factor;
        }
      return __result;
    }
  }
  template < typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m >
  void linear_congruential_engine<_UIntType, __a, __c, __m>::seed(typename ::std::linear_congruential_engine<_UIntType, __a, __c, __m>::result_type __s)
  {
    if (__detail::__mod<_UIntType, __m>(__c) == 0 && __detail::__mod<_UIntType, __m>(__s) == 0)
      {
        ::std::linear_congruential_engine<_UIntType, __a, __c, __m>::_M_x = 1;
      }
    else
      {
        ::std::linear_congruential_engine<_UIntType, __a, __c, __m>::_M_x = __detail::__mod<_UIntType, __m>(__s);
      }
  }
  template < typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m >
  template < typename _Sseq >
  typename ::std::enable_if<std::is_class<_Sseq>::value>::type linear_congruential_engine<_UIntType, __a, __c, __m>::seed(_Sseq &__q)
  {
    const _UIntType __k0 = __m == 0 ? std::numeric_limits<_UIntType>::digits : std::__lg(__m);
    const _UIntType __k = (__k0 + 31) / 32;
    ::uint_least32_t __arr[__k + 3];
    __q.generate(__arr + 0, __arr + __k + 3);
    _UIntType __factor = 1U;
    _UIntType __sum = 0U;
    for (::std::size_t __j(0); __j < __k;  ++__j)
      {
        __sum += __arr[__j + 3] * __factor;
        __factor *= __detail::_Shift<_UIntType, 32>::__value;
      }
    (*this).seed(__sum);
  }
  template < typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::linear_congruential_engine<_UIntType, __a, __c, __m> &__lcr);
  template < typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::linear_congruential_engine<_UIntType, __a, __c, __m> &__lcr)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    __os.flags((__ios_base::dec | __ios_base::fixed) | __ios_base::left);
    __os.fill(__os.widen(' '));
    __os << __lcr._M_x;
    __os.flags(__flags);
    __os.fill(__fill);
    return __os;
  }
  template < typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::linear_congruential_engine<_UIntType, __a, __c, __m> &__lcr);
  template < typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::linear_congruential_engine<_UIntType, __a, __c, __m> &__lcr)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec);
    __is >> __lcr._M_x;
    __is.flags(__flags);
    return __is;
  }
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __n, ::std::size_t __m, ::std::size_t __r, _UIntType __a, ::std::size_t __u, _UIntType __d, ::std::size_t __s, _UIntType __b, ::std::size_t __t, _UIntType __c, ::std::size_t __l, _UIntType __f >
  void mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::seed(typename ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type __sd)
  {
    ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[0] = __detail::__mod<_UIntType, __detail::_Shift<_UIntType, __w>::__value>(__sd);
    for (::std::size_t __i(1); __i < ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::state_size;  ++__i)
      {
        _UIntType __x = ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__i - 1];
        __x ^= __x >> (__w - 2);
        __x *= __f;
        __x += __detail::__mod<_UIntType, __n>(__i);
        ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__i] = __detail::__mod<_UIntType, __detail::_Shift<_UIntType, __w>::__value>(__x);
      }
    ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_p = ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::state_size;
  }
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __n, ::std::size_t __m, ::std::size_t __r, _UIntType __a, ::std::size_t __u, _UIntType __d, ::std::size_t __s, _UIntType __b, ::std::size_t __t, _UIntType __c, ::std::size_t __l, _UIntType __f >
  template < typename _Sseq >
  typename ::std::enable_if<std::is_class<_Sseq>::value>::type mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::seed(_Sseq &__q)
  {
    const _UIntType __upper_mask = ~_UIntType() << __r;
    const ::std::size_t __k = (__w + 31) / 32;
    ::uint_least32_t __arr[__n * __k];
    __q.generate(__arr + 0, __arr + __n * __k);
    bool __zero(true);
    for (::std::size_t __i(0); __i < ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::state_size;  ++__i)
      {
        _UIntType __factor = 1U;
        _UIntType __sum = 0U;
        for (::std::size_t __j(0); __j < __k;  ++__j)
          {
            __sum += __arr[__k * __i + __j] * __factor;
            __factor *= __detail::_Shift<_UIntType, 32>::__value;
          }
        ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__i] = __detail::__mod<_UIntType, __detail::_Shift<_UIntType, __w>::__value>(__sum);
        if (__zero)
          {
            if (__i == 0)
              {
                if ((::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[0] & __upper_mask) != 0U)
                  {
                    __zero = false;
                  }
              }
            else
              {
                if (::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__i] != 0U)
                  {
                    __zero = false;
                  }
              }
          }
      }
    if (__zero)
      {
        ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[0] = __detail::_Shift<_UIntType, __w - 1>::__value;
      }
    ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_p = ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::state_size;
  }
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __n, ::std::size_t __m, ::std::size_t __r, _UIntType __a, ::std::size_t __u, _UIntType __d, ::std::size_t __s, _UIntType __b, ::std::size_t __t, _UIntType __c, ::std::size_t __l, _UIntType __f >
  void mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_gen_rand()
  {
    const _UIntType __upper_mask = ~_UIntType() << __r;
    const _UIntType __lower_mask = ~__upper_mask;
    for (::std::size_t __k(0); __k < __n - __m;  ++__k)
      {
        _UIntType __y = (::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__k] & __upper_mask) | (::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__k + 1] & __lower_mask);
        ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__k] = (::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__k + __m] ^ __y >> 1) ^ (__y & 1 ? __a : 0);
      }
    for (::std::size_t __k = __n - __m; __k < __n - 1;  ++__k)
      {
        _UIntType __y = (::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__k] & __upper_mask) | (::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__k + 1] & __lower_mask);
        ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__k] = (::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__k + (__m - __n)] ^ __y >> 1) ^ (__y & 1 ? __a : 0);
      }
    _UIntType __y = (::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__n - 1] & __upper_mask) | (::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[0] & __lower_mask);
    ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__n - 1] = (::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[__m - 1] ^ __y >> 1) ^ (__y & 1 ? __a : 0);
    ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_p = 0;
  }
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __n, ::std::size_t __m, ::std::size_t __r, _UIntType __a, ::std::size_t __u, _UIntType __d, ::std::size_t __s, _UIntType __b, ::std::size_t __t, _UIntType __c, ::std::size_t __l, _UIntType __f >
  void mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::discard(unsigned long long int __z)
  {
    while (__z > ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::state_size - ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_p)
      {
        __z -= ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::state_size - ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_p;
        (*this)._M_gen_rand();
      }
    ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_p += __z;
  }
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __n, ::std::size_t __m, ::std::size_t __r, _UIntType __a, ::std::size_t __u, _UIntType __d, ::std::size_t __s, _UIntType __b, ::std::size_t __t, _UIntType __c, ::std::size_t __l, _UIntType __f >
  typename ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::operator ()()
  {
    if (::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_p >= ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::state_size)
      {
        (*this)._M_gen_rand();
      }
    typename ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type __z = ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_x[::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::_M_p++];
    __z ^= __z >> __u & __d;
    __z ^= __z << __s & __b;
    __z ^= __z << __t & __c;
    __z ^= __z >> __l;
    return __z;
  }
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __n, ::std::size_t __m, ::std::size_t __r, _UIntType __a, ::std::size_t __u, _UIntType __d, ::std::size_t __s, _UIntType __b, ::std::size_t __t, _UIntType __c, ::std::size_t __l, _UIntType __f, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> &__x);
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __n, ::std::size_t __m, ::std::size_t __r, _UIntType __a, ::std::size_t __u, _UIntType __d, ::std::size_t __s, _UIntType __b, ::std::size_t __t, _UIntType __c, ::std::size_t __l, _UIntType __f, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const _CharT __space = __os.widen(' ');
    __os.flags((__ios_base::dec | __ios_base::fixed) | __ios_base::left);
    __os.fill(__space);
    for (::std::size_t __i(0); __i < __n;  ++__i)
      {
        __os << __x._M_x[__i] << __space;
      }
    __os << __x._M_p;
    __os.flags(__flags);
    __os.fill(__fill);
    return __os;
  }
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __n, ::std::size_t __m, ::std::size_t __r, _UIntType __a, ::std::size_t __u, _UIntType __d, ::std::size_t __s, _UIntType __b, ::std::size_t __t, _UIntType __c, ::std::size_t __l, _UIntType __f, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> &__x);
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __n, ::std::size_t __m, ::std::size_t __r, _UIntType __a, ::std::size_t __u, _UIntType __d, ::std::size_t __s, _UIntType __b, ::std::size_t __t, _UIntType __c, ::std::size_t __l, _UIntType __f, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    for (::std::size_t __i(0); __i < __n;  ++__i)
      {
        __is >> __x._M_x[__i];
      }
    __is >> __x._M_p;
    __is.flags(__flags);
    return __is;
  }
 /* Instantiation of class template '::std::__detail::_Shift<unsigned int, 32LU>' */ 
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __s, ::std::size_t __r >
  void subtract_with_carry_engine<_UIntType, __w, __s, __r>::seed(typename ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::result_type __value)
  {
    ::std::linear_congruential_engine<typename ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::result_type, 40014U, 0U, 2147483563U> __lcg(__value == 0U ? ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::default_seed : __value);
    const ::std::size_t __n = (__w + 31) / 32;
    for (::std::size_t __i(0); __i < ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag;  ++__i)
      {
        _UIntType __sum = 0U;
        _UIntType __factor = 1U;
        for (::std::size_t __j(0); __j < __n;  ++__j)
          {
            __sum += __detail::__mod< ::uint_least32_t, ::std::__detail::_Shift<unsigned int, 32LU>::__value>(__lcg()) * __factor;
            __factor *= __detail::_Shift<_UIntType, 32>::__value;
          }
        ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_x[__i] = __detail::__mod<_UIntType, __detail::_Shift<_UIntType, __w>::__value>(__sum);
      }
    ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_carry = ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_x[::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag - 1] == 0 ? 1 : 0;
    ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_p = 0;
  }
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __s, ::std::size_t __r >
  template < typename _Sseq >
  typename ::std::enable_if<std::is_class<_Sseq>::value>::type subtract_with_carry_engine<_UIntType, __w, __s, __r>::seed(_Sseq &__q)
  {
    const ::std::size_t __k = (__w + 31) / 32;
    ::uint_least32_t __arr[__r * __k];
    __q.generate(__arr + 0, __arr + __r * __k);
    for (::std::size_t __i(0); __i < ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag;  ++__i)
      {
        _UIntType __sum = 0U;
        _UIntType __factor = 1U;
        for (::std::size_t __j(0); __j < __k;  ++__j)
          {
            __sum += __arr[__k * __i + __j] * __factor;
            __factor *= __detail::_Shift<_UIntType, 32>::__value;
          }
        ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_x[__i] = __detail::__mod<_UIntType, __detail::_Shift<_UIntType, __w>::__value>(__sum);
      }
    ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_carry = ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_x[::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag - 1] == 0 ? 1 : 0;
    ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_p = 0;
  }
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __s, ::std::size_t __r >
  typename ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::result_type subtract_with_carry_engine<_UIntType, __w, __s, __r>::operator ()()
  {
    long int __ps = ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_p - ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::short_lag;
    if (__ps < 0)
      {
        __ps += ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag;
      }
    _UIntType __xi;
    if (::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_x[__ps] >= ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_x[::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_p] + ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_carry)
      {
        __xi = ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_x[__ps] - ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_x[::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_p] - ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_carry;
        ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_carry = 0;
      }
    else
      {
        __xi = __detail::_Shift<_UIntType, __w>::__value - ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_x[::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_p] - ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_carry + ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_x[__ps];
        ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_carry = 1;
      }
    ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_x[::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_p] = __xi;
    if ( ++::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_p >= ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag)
      {
        ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r>::_M_p = 0;
      }
    return __xi;
  }
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __s, ::std::size_t __r, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r> &__x);
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __s, ::std::size_t __r, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const _CharT __space = __os.widen(' ');
    __os.flags((__ios_base::dec | __ios_base::fixed) | __ios_base::left);
    __os.fill(__space);
    for (::std::size_t __i(0); __i < __r;  ++__i)
      {
        __os << __x._M_x[__i] << __space;
      }
    __os << __x._M_carry << __space << __x._M_p;
    __os.flags(__flags);
    __os.fill(__fill);
    return __os;
  }
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __s, ::std::size_t __r, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r> &__x);
  template < typename _UIntType, ::std::size_t __w, ::std::size_t __s, ::std::size_t __r, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::subtract_with_carry_engine<_UIntType, __w, __s, __r> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    for (::std::size_t __i(0); __i < __r;  ++__i)
      {
        __is >> __x._M_x[__i];
      }
    __is >> __x._M_carry;
    __is >> __x._M_p;
    __is.flags(__flags);
    return __is;
  }
  template < typename _RandomNumberEngine, ::std::size_t __p, ::std::size_t __r >
  typename ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::result_type discard_block_engine<_RandomNumberEngine, __p, __r>::operator ()()
  {
    if (::std::discard_block_engine<_RandomNumberEngine, __p, __r>::_M_n >= ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::used_block)
      {
        ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::_M_b.discard(::std::discard_block_engine<_RandomNumberEngine, __p, __r>::block_size - ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::_M_n);
        ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::_M_n = 0;
      }
     ++::std::discard_block_engine<_RandomNumberEngine, __p, __r>::_M_n;
    return ::std::discard_block_engine<_RandomNumberEngine, __p, __r>::_M_b();
  }
  template < typename _RandomNumberEngine, ::std::size_t __p, ::std::size_t __r, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::discard_block_engine<_RandomNumberEngine, __p, __r> &__x);
  template < typename _RandomNumberEngine, ::std::size_t __p, ::std::size_t __r, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::discard_block_engine<_RandomNumberEngine, __p, __r> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const _CharT __space = __os.widen(' ');
    __os.flags((__ios_base::dec | __ios_base::fixed) | __ios_base::left);
    __os.fill(__space);
    __os << __x.base() << __space << __x._M_n;
    __os.flags(__flags);
    __os.fill(__fill);
    return __os;
  }
  template < typename _RandomNumberEngine, ::std::size_t __p, ::std::size_t __r, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::discard_block_engine<_RandomNumberEngine, __p, __r> &__x);
  template < typename _RandomNumberEngine, ::std::size_t __p, ::std::size_t __r, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::discard_block_engine<_RandomNumberEngine, __p, __r> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    __is >> __x._M_b >> __x._M_n;
    __is.flags(__flags);
    return __is;
  }
  template < typename _RandomNumberEngine, ::std::size_t __w, typename _UIntType >
  typename ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::result_type independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::operator ()()
  {
    typedef typename _RandomNumberEngine::result_type _Eresult_type;
    const _Eresult_type __r = ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::_M_b.max() - ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::_M_b.min() < std::numeric_limits<_Eresult_type>::max() ? ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::_M_b.max() - ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::_M_b.min() + 1 : 0;
    const unsigned int __edig = std::numeric_limits<_Eresult_type>::digits;
    const unsigned int __m = __r ? std::__lg(__r) : __edig;
    typedef typename ::std::common_type<_Eresult_type, typename ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::result_type>::type __ctype;
    const unsigned int __cdig = std::numeric_limits<__ctype>::digits;
    unsigned int __n;
    unsigned int __n0;
    __ctype __s0;
    __ctype __s1;
    __ctype __y0;
    __ctype __y1;
    for (::std::size_t __i(0); __i < 2;  ++__i)
      {
        __n = (__w + __m - 1) / __m + __i;
        __n0 = __n - __w % __n;
        const unsigned int __w0 = __w / __n;
        __s0 = 0;
        __s1 = 0;
        if (__w0 < __cdig)
          {
            __s0 = __ctype(1) << __w0;
            __s1 = __s0 << 1;
          }
        __y0 = 0;
        __y1 = 0;
        if (__r)
          {
            __y0 = __s0 * (__r / __s0);
            if (__s1)
              {
                __y1 = __s1 * (__r / __s1);
              }
            if (__r - __y0 <= __y0 / __n)
              {
                break;
              }
          }
        else
          {
            break;
          }
      }
    typename ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::result_type __sum = 0;
    for (::std::size_t __k(0); __k < __n0;  ++__k)
      {
        __ctype __u;
        do
          {
            __u = ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::_M_b() - ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::_M_b.min();
          }
        while (__y0 && __u >= __y0);
        __sum = __s0 * __sum + (__s0 ? __u % __s0 : __u);
      }
    for (::std::size_t __k(__n0); __k < __n;  ++__k)
      {
        __ctype __u;
        do
          {
            __u = ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::_M_b() - ::std::independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::_M_b.min();
          }
        while (__y1 && __u >= __y1);
        __sum = __s1 * __sum + (__s1 ? __u % __s1 : __u);
      }
    return __sum;
  }
  template < typename _RandomNumberEngine, ::std::size_t __k >
  typename ::std::shuffle_order_engine<_RandomNumberEngine, __k>::result_type shuffle_order_engine<_RandomNumberEngine, __k>::operator ()()
  {
    ::std::size_t __j = __k * ((::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_y - ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_b.min()) / (::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_b.max() - ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_b.min() + 1.0000000000000000000000000000000000000000000000000000000000000000e+00L));
    ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_y = ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_v[__j];
    ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_v[__j] = ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_b();
    return ::std::shuffle_order_engine<_RandomNumberEngine, __k>::_M_y;
  }
  template < typename _RandomNumberEngine, ::std::size_t __k, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::shuffle_order_engine<_RandomNumberEngine, __k> &__x);
  template < typename _RandomNumberEngine, ::std::size_t __k, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::shuffle_order_engine<_RandomNumberEngine, __k> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const _CharT __space = __os.widen(' ');
    __os.flags((__ios_base::dec | __ios_base::fixed) | __ios_base::left);
    __os.fill(__space);
    __os << __x.base();
    for (::std::size_t __i(0); __i < __k;  ++__i)
      {
        __os << __space << __x._M_v[__i];
      }
    __os << __space << __x._M_y;
    __os.flags(__flags);
    __os.fill(__fill);
    return __os;
  }
  template < typename _RandomNumberEngine, ::std::size_t __k, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::shuffle_order_engine<_RandomNumberEngine, __k> &__x);
  template < typename _RandomNumberEngine, ::std::size_t __k, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::shuffle_order_engine<_RandomNumberEngine, __k> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    __is >> __x._M_b;
    for (::std::size_t __i(0); __i < __k;  ++__i)
      {
        __is >> __x._M_v[__i];
      }
    __is >> __x._M_y;
    __is.flags(__flags);
    return __is;
  }
  template < typename _IntType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::uniform_int_distribution<_IntType>::result_type uniform_int_distribution<_IntType>::operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::uniform_int_distribution<_IntType>::param_type &__param)
  {
    typedef typename _UniformRandomNumberGenerator::result_type _Gresult_type;
    typedef typename ::std::make_unsigned<typename ::std::uniform_int_distribution<_IntType>::result_type>::type __utype;
    typedef typename ::std::common_type<_Gresult_type, __utype>::type __uctype;
    const __uctype __urngmin = __urng.min();
    const __uctype __urngmax = __urng.max();
    const __uctype __urngrange = __urngmax - __urngmin;
    const __uctype __urange = __uctype(__param.b()) - __uctype(__param.a());
    __uctype __ret;
    if (__urngrange > __urange)
      {
        const __uctype __uerange = __urange + 1;
        const __uctype __scaling = __urngrange / __uerange;
        const __uctype __past = __uerange * __scaling;
        do
          {
            __ret = __uctype(__urng()) - __urngmin;
          }
        while (__ret >= __past);
        __ret /= __scaling;
      }
    else
      {
        if (__urngrange < __urange)
          {
            __uctype __tmp;
            do
              {
                const __uctype __uerngrange = __urngrange + 1;
                __tmp = __uerngrange * (*this).operator ()(__urng, ((typename ::std::uniform_int_distribution<_IntType>::param_type(0, __urange / __uerngrange))));
                __ret = __tmp + (__uctype(__urng()) - __urngmin);
              }
            while (__ret > __urange || __ret < __tmp);
          }
        else
          {
            __ret = __uctype(__urng()) - __urngmin;
          }
      }
    return __ret + __param.a();
  }
  template < typename _IntType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void uniform_int_distribution<_IntType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::uniform_int_distribution<_IntType>::param_type &__param)
  {
    typedef typename _UniformRandomNumberGenerator::result_type _Gresult_type;
    typedef typename ::std::make_unsigned<typename ::std::uniform_int_distribution<_IntType>::result_type>::type __utype;
    typedef typename ::std::common_type<_Gresult_type, __utype>::type __uctype;
    const __uctype __urngmin = __urng.min();
    const __uctype __urngmax = __urng.max();
    const __uctype __urngrange = __urngmax - __urngmin;
    const __uctype __urange = __uctype(__param.b()) - __uctype(__param.a());
    __uctype __ret;
    if (__urngrange > __urange)
      {
        if (__detail::_Power_of_2(__urngrange + 1) && __detail::_Power_of_2(__urange + 1))
          {
            while (__f != __t)
              {
                __ret = __uctype(__urng()) - __urngmin;
                *__f++ = (__ret & __urange) + __param.a();
              }
          }
        else
          {
            const __uctype __uerange = __urange + 1;
            const __uctype __scaling = __urngrange / __uerange;
            const __uctype __past = __uerange * __scaling;
            while (__f != __t)
              {
                do
                  {
                    __ret = __uctype(__urng()) - __urngmin;
                  }
                while (__ret >= __past);
                *__f++ = __ret / __scaling + __param.a();
              }
          }
      }
    else
      {
        if (__urngrange < __urange)
          {
            __uctype __tmp;
            while (__f != __t)
              {
                do
                  {
                    const __uctype __uerngrange = __urngrange + 1;
                    __tmp = __uerngrange * (*this).operator ()(__urng, ((typename ::std::uniform_int_distribution<_IntType>::param_type(0, __urange / __uerngrange))));
                    __ret = __tmp + (__uctype(__urng()) - __urngmin);
                  }
                while (__ret > __urange || __ret < __tmp);
                *__f++ = __ret;
              }
          }
        else
          {
            while (__f != __t)
              {
                *__f++ = __uctype(__urng()) - __urngmin + __param.a();
              }
          }
      }
  }
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::uniform_int_distribution<_IntType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os << __x.a() << __space << __x.b();
    __os.flags(__flags);
    __os.fill(__fill);
    return __os;
  }
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::uniform_int_distribution<_IntType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    _IntType __a;
    _IntType __b;
    __is >> __a >> __b;
    __x.param(typename ::std::uniform_int_distribution<_IntType>::param_type(__a, __b));
    __is.flags(__flags);
    return __is;
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void uniform_real_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::uniform_real_distribution<_RealType>::param_type &__p)
  {
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, typename ::std::uniform_real_distribution<_RealType>::result_type> __aurng(__urng);
    auto __range = __p.b() - __p.a();
    while (__f != __t)
      {
        *__f++ = __aurng() * __range + __p.a();
      }
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::uniform_real_distribution<_RealType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(std::numeric_limits<_RealType>::max_digits10);
    __os << __x.a() << __space << __x.b();
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::uniform_real_distribution<_RealType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::skipws);
    _RealType __a;
    _RealType __b;
    __is >> __a >> __b;
    __x.param(typename ::std::uniform_real_distribution<_RealType>::param_type(__a, __b));
    __is.flags(__flags);
    return __is;
  }
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void bernoulli_distribution::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const ::std::bernoulli_distribution::param_type &__p)
  {
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, double> __aurng(__urng);
    auto __limit = __p.::std::bernoulli_distribution::param_type::p() * (__aurng.max() - __aurng.min());
    while (__f != __t)
      {
        *__f++ = __aurng() - __aurng.min() < __limit;
      }
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::bernoulli_distribution &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__os.widen(' '));
    __os.precision(::std::numeric_limits<double>::max_digits10);
    __os << __x.::std::bernoulli_distribution::p();
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _IntType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::geometric_distribution<_IntType>::result_type geometric_distribution<_IntType>::operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::geometric_distribution<_IntType>::param_type &__param)
  {
    const double __naf = (1 - std::numeric_limits<double>::epsilon()) / 2;
    const double __thr = std::numeric_limits<_IntType>::max() + __naf;
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, double> __aurng(__urng);
    double __cand;
    do
      {
        __cand = std::floor(std::log(1.00000000000000000000000000000000000000000000000000000e+00 - __aurng()) / __param._M_log_1_p);
      }
    while (__cand >= __thr);
    return ((typename ::std::geometric_distribution<_IntType>::result_type(__cand + __naf)));
  }
  template < typename _IntType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void geometric_distribution<_IntType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::geometric_distribution<_IntType>::param_type &__param)
  {
    const double __naf = (1 - std::numeric_limits<double>::epsilon()) / 2;
    const double __thr = std::numeric_limits<_IntType>::max() + __naf;
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, double> __aurng(__urng);
    while (__f != __t)
      {
        double __cand;
        do
          {
            __cand = std::floor(std::log(1.00000000000000000000000000000000000000000000000000000e+00 - __aurng()) / __param._M_log_1_p);
          }
        while (__cand >= __thr);
        *__f++ = __cand + __naf;
      }
  }
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::geometric_distribution<_IntType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__os.widen(' '));
    __os.precision(::std::numeric_limits<double>::max_digits10);
    __os << __x.p();
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::geometric_distribution<_IntType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::skipws);
    double __p;
    __is >> __p;
    __x.param(typename ::std::geometric_distribution<_IntType>::param_type(__p));
    __is.flags(__flags);
    return __is;
  }
  template < typename _IntType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::negative_binomial_distribution<_IntType>::result_type negative_binomial_distribution<_IntType>::operator ()(_UniformRandomNumberGenerator &__urng)
  {
    const double __y = ::std::negative_binomial_distribution<_IntType>::_M_gd(__urng);
    ::std::poisson_distribution<typename ::std::negative_binomial_distribution<_IntType>::result_type> __poisson(__y);
    return __poisson(__urng);
  }
 /* Instantiation of class template '::std::is_floating_point<double>' */ 
 /* Instantiation of class template '::std::gamma_distribution<double>::param_type' */ 
 /* Instantiation of class template '::std::normal_distribution<double>::param_type' */ 
 /* Instantiation of class template '::std::normal_distribution<double>' */ 
 /* Instantiation of class template '::std::gamma_distribution<double>' */ 
  template < typename _IntType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::negative_binomial_distribution<_IntType>::result_type negative_binomial_distribution<_IntType>::operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::negative_binomial_distribution<_IntType>::param_type &__p)
  {
    typedef ::std::gamma_distribution<double>::param_type param_type;
    const double __y = ::std::negative_binomial_distribution<_IntType>::_M_gd(__urng, param_type(__p.k(), (1.00000000000000000000000000000000000000000000000000000e+00 - __p.p()) / __p.p()));
    ::std::poisson_distribution<typename ::std::negative_binomial_distribution<_IntType>::result_type> __poisson(__y);
    return __poisson(__urng);
  }
  template < typename _IntType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void negative_binomial_distribution<_IntType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
  {
    while (__f != __t)
      {
        const double __y = ::std::negative_binomial_distribution<_IntType>::_M_gd(__urng);
        ::std::poisson_distribution<typename ::std::negative_binomial_distribution<_IntType>::result_type> __poisson(__y);
        *__f++ = __poisson(__urng);
      }
  }
  template < typename _IntType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void negative_binomial_distribution<_IntType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::negative_binomial_distribution<_IntType>::param_type &__p)
  {
    typename ::std::gamma_distribution<typename ::std::negative_binomial_distribution<_IntType>::result_type>::param_type __p2(__p.k(), (1.00000000000000000000000000000000000000000000000000000e+00 - __p.p()) / __p.p());
    while (__f != __t)
      {
        const double __y = ::std::negative_binomial_distribution<_IntType>::_M_gd(__urng, __p2);
        ::std::poisson_distribution<typename ::std::negative_binomial_distribution<_IntType>::result_type> __poisson(__y);
        *__f++ = __poisson(__urng);
      }
  }
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::negative_binomial_distribution<_IntType> &__x);
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::negative_binomial_distribution<_IntType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__os.widen(' '));
    __os.precision(::std::numeric_limits<double>::max_digits10);
    __os << __x.k() << __space << __x.p() << __space << __x._M_gd;
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::negative_binomial_distribution<_IntType> &__x);
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::negative_binomial_distribution<_IntType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::skipws);
    _IntType __k;
    double __p;
    __is >> __k >> __p >> __x._M_gd;
    __x.param(typename ::std::negative_binomial_distribution<_IntType>::param_type(__k, __p));
    __is.flags(__flags);
    return __is;
  }
 /* Instantiation of class template '::__gnu_cxx::__enable_if<false, double>' */ 
  template < typename _IntType >
  void poisson_distribution<_IntType>::param_type::_M_initialize()
  {
    if (::std::poisson_distribution<_IntType>::param_type::_M_mean >= 12)
      {
        const double __m = std::floor(::std::poisson_distribution<_IntType>::param_type::_M_mean);
        ::std::poisson_distribution<_IntType>::param_type::_M_lm_thr = std::log(::std::poisson_distribution<_IntType>::param_type::_M_mean);
        ::std::poisson_distribution<_IntType>::param_type::_M_lfm = ::std::lgamma(__m + 1);
        ::std::poisson_distribution<_IntType>::param_type::_M_sm = ::std::sqrt(__m);
        const double __pi_4(7.8539816339744830962820223985154655110818566754460334777832031250e-01L);
        const double __dx(::std::sqrt(2 * __m * ::std::log(32 * __m / __pi_4)));
        ::std::poisson_distribution<_IntType>::param_type::_M_d = ::std::round(std::max(6.00000000000000000000000000000000000000000000000000000e+00, std::min(__m, __dx)));
        const double __cx = 2 * __m + ::std::poisson_distribution<_IntType>::param_type::_M_d;
        ::std::poisson_distribution<_IntType>::param_type::_M_scx = ::std::sqrt(__cx / 2);
        ::std::poisson_distribution<_IntType>::param_type::_M_1cx = 1 / __cx;
        ::std::poisson_distribution<_IntType>::param_type::_M_c2b = ::std::sqrt(__pi_4 * __cx) * std::exp(::std::poisson_distribution<_IntType>::param_type::_M_1cx);
        ::std::poisson_distribution<_IntType>::param_type::_M_cb = 2 * __cx * std::exp( -::std::poisson_distribution<_IntType>::param_type::_M_d * ::std::poisson_distribution<_IntType>::param_type::_M_1cx * (1 + ::std::poisson_distribution<_IntType>::param_type::_M_d / 2)) / ::std::poisson_distribution<_IntType>::param_type::_M_d;
      }
    else
      {
        ::std::poisson_distribution<_IntType>::param_type::_M_lm_thr = std::exp( -::std::poisson_distribution<_IntType>::param_type::_M_mean);
      }
  }
  template < typename _IntType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::poisson_distribution<_IntType>::result_type poisson_distribution<_IntType>::operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::poisson_distribution<_IntType>::param_type &__param)
  {
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, double> __aurng(__urng);
    if (__param.mean() >= 12)
      {
        double __x;
        const double __naf = (1 - std::numeric_limits<double>::epsilon()) / 2;
        const double __thr = std::numeric_limits<_IntType>::max() + __naf;
        const double __m = std::floor(__param.mean());
        const double __spi_2(1.2533141373155002512356989696762354924430837854743003845214843750e+00L);
        const double __c1 = __param._M_sm * __spi_2;
        const double __c2 = __param._M_c2b + __c1;
        const double __c3(__c2 + 1);
        const double __c4(__c3 + 1);
        const double __e178(1.0129030479320018583470550121994335768249584361910820007324218750e+00L);
        const double __c5(__c4 + __e178);
        const double __c = __param._M_cb + __c5;
        const double __2cx = 2 * (2 * __m + __param._M_d);
        bool __reject(true);
        do
          {
            const double __u = __c * __aurng();
            const double __e =  -std::log(1.00000000000000000000000000000000000000000000000000000e+00 - __aurng());
            double __w(0.00000000000000000000000000000000000000000000000000000e+00);
            if (__u <= __c1)
              {
                const double __n = ::std::poisson_distribution<_IntType>::_M_nd(__urng);
                const double __y =  -std::abs(__n) * __param._M_sm - 1;
                __x = ::std::floor(__y);
                __w =  -__n * __n / 2;
                if (__x <  -__m)
                  {
                    continue;
                  }
              }
            else
              {
                if (__u <= __c2)
                  {
                    const double __n = ::std::poisson_distribution<_IntType>::_M_nd(__urng);
                    const double __y = 1 + std::abs(__n) * __param._M_scx;
                    __x = ::std::ceil(__y);
                    __w = __y * (2 - __y) * __param._M_1cx;
                    if (__x > __param._M_d)
                      {
                        continue;
                      }
                  }
                else
                  {
                    if (__u <= __c3)
                      {
                        __x =  -1;
                      }
                    else
                      {
                        if (__u <= __c4)
                          {
                            __x = 0;
                          }
                        else
                          {
                            if (__u <= __c5)
                              {
                                __x = 1;
                              }
                            else
                              {
                                const double __v =  -std::log(1.00000000000000000000000000000000000000000000000000000e+00 - __aurng());
                                const double __y = __param._M_d + __v * __2cx / __param._M_d;
                                __x = ::std::ceil(__y);
                                __w =  -__param._M_d * __param._M_1cx * (1 + __y / 2);
                              }
                          }
                      }
                  }
              }
            __reject = __w - __e - __x * __param._M_lm_thr > __param._M_lfm - ::std::lgamma(__x + __m + 1);
            __reject |= __x + __m >= __thr;
          }
        while (__reject);
        return ((typename ::std::poisson_distribution<_IntType>::result_type(__x + __m + __naf)));
      }
    else
      {
        _IntType __x = 0;
        double __prod(1.00000000000000000000000000000000000000000000000000000e+00);
        do
          {
            __prod *= __aurng();
            __x += 1;
          }
        while (__prod > __param._M_lm_thr);
        return __x - 1;
      }
  }
  template < typename _IntType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void poisson_distribution<_IntType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::poisson_distribution<_IntType>::param_type &__param)
  {
    while (__f != __t)
      {
        *__f++ = this->operator ()(__urng, __param);
      }
  }
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::poisson_distribution<_IntType> &__x);
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::poisson_distribution<_IntType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(::std::numeric_limits<double>::max_digits10);
    __os << __x.mean() << __space << __x._M_nd;
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::poisson_distribution<_IntType> &__x);
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::poisson_distribution<_IntType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::skipws);
    double __mean;
    __is >> __mean >> __x._M_nd;
    __x.param(typename ::std::poisson_distribution<_IntType>::param_type(__mean));
    __is.flags(__flags);
    return __is;
  }
  template < typename _IntType >
  void binomial_distribution<_IntType>::param_type::_M_initialize()
  {
    const double __p12 = ::std::binomial_distribution<_IntType>::param_type::_M_p <= 5.00000000000000000000000000000000000000000000000000000e-01 ? ::std::binomial_distribution<_IntType>::param_type::_M_p : 1.00000000000000000000000000000000000000000000000000000e+00 - ::std::binomial_distribution<_IntType>::param_type::_M_p;
    ::std::binomial_distribution<_IntType>::param_type::_M_easy = true;
    if (::std::binomial_distribution<_IntType>::param_type::_M_t * __p12 >= 8)
      {
        ::std::binomial_distribution<_IntType>::param_type::_M_easy = false;
        const double __np = std::floor(::std::binomial_distribution<_IntType>::param_type::_M_t * __p12);
        const double __pa = __np / ::std::binomial_distribution<_IntType>::param_type::_M_t;
        const double __1p(1 - __pa);
        const double __pi_4(7.8539816339744830962820223985154655110818566754460334777832031250e-01L);
        const double __d1x(::std::sqrt(__np * __1p * ::std::log(32 * __np / (81 * __pi_4 * __1p))));
        ::std::binomial_distribution<_IntType>::param_type::_M_d1 = ::std::round(std::max(1.00000000000000000000000000000000000000000000000000000e+00, __d1x));
        const double __d2x = std::sqrt(__np * __1p * std::log(32 * ::std::binomial_distribution<_IntType>::param_type::_M_t * __1p / (__pi_4 * __pa)));
        ::std::binomial_distribution<_IntType>::param_type::_M_d2 = ::std::round(std::max(1.00000000000000000000000000000000000000000000000000000e+00, __d2x));
        const double __spi_2(1.2533141373155002512356989696762354924430837854743003845214843750e+00L);
        ::std::binomial_distribution<_IntType>::param_type::_M_s1 = ::std::sqrt(__np * __1p) * (1 + ::std::binomial_distribution<_IntType>::param_type::_M_d1 / (4 * __np));
        ::std::binomial_distribution<_IntType>::param_type::_M_s2 = ::std::sqrt(__np * __1p) * (1 + ::std::binomial_distribution<_IntType>::param_type::_M_d2 / (4 * ::std::binomial_distribution<_IntType>::param_type::_M_t * __1p));
        ::std::binomial_distribution<_IntType>::param_type::_M_c = 2 * ::std::binomial_distribution<_IntType>::param_type::_M_d1 / __np;
        ::std::binomial_distribution<_IntType>::param_type::_M_a1 = std::exp(::std::binomial_distribution<_IntType>::param_type::_M_c) * ::std::binomial_distribution<_IntType>::param_type::_M_s1 * __spi_2;
        const double __a12 = ::std::binomial_distribution<_IntType>::param_type::_M_a1 + ::std::binomial_distribution<_IntType>::param_type::_M_s2 * __spi_2;
        const double __s1s = ::std::binomial_distribution<_IntType>::param_type::_M_s1 * ::std::binomial_distribution<_IntType>::param_type::_M_s1;
        ::std::binomial_distribution<_IntType>::param_type::_M_a123 = __a12 + std::exp(::std::binomial_distribution<_IntType>::param_type::_M_d1 / (::std::binomial_distribution<_IntType>::param_type::_M_t * __1p)) * 2 * __s1s / ::std::binomial_distribution<_IntType>::param_type::_M_d1 * std::exp( -::std::binomial_distribution<_IntType>::param_type::_M_d1 * ::std::binomial_distribution<_IntType>::param_type::_M_d1 / (2 * __s1s));
        const double __s2s = ::std::binomial_distribution<_IntType>::param_type::_M_s2 * ::std::binomial_distribution<_IntType>::param_type::_M_s2;
        ::std::binomial_distribution<_IntType>::param_type::_M_s = ::std::binomial_distribution<_IntType>::param_type::_M_a123 + 2 * __s2s / ::std::binomial_distribution<_IntType>::param_type::_M_d2 * std::exp( -::std::binomial_distribution<_IntType>::param_type::_M_d2 * ::std::binomial_distribution<_IntType>::param_type::_M_d2 / (2 * __s2s));
        ::std::binomial_distribution<_IntType>::param_type::_M_lf = ::std::lgamma(__np + 1) + std::lgamma(::std::binomial_distribution<_IntType>::param_type::_M_t - __np + 1);
        ::std::binomial_distribution<_IntType>::param_type::_M_lp1p = ::std::log(__pa / __1p);
        ::std::binomial_distribution<_IntType>::param_type::_M_q =  -::std::log(1 - (__p12 - __pa) / __1p);
      }
    else
      {
        ::std::binomial_distribution<_IntType>::param_type::_M_q =  -::std::log(1 - __p12);
      }
  }
  template < typename _IntType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::binomial_distribution<_IntType>::result_type binomial_distribution<_IntType>::_M_waiting(_UniformRandomNumberGenerator &__urng, _IntType __t, double __q)
  {
    _IntType __x = 0;
    double __sum(0.00000000000000000000000000000000000000000000000000000e+00);
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, double> __aurng(__urng);
    do
      {
        if (__t == __x)
          {
            return __x;
          }
        const double __e =  -std::log(1.00000000000000000000000000000000000000000000000000000e+00 - __aurng());
        __sum += __e / (__t - __x);
        __x += 1;
      }
    while (__sum <= __q);
    return __x - 1;
  }
  template < typename _IntType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::binomial_distribution<_IntType>::result_type binomial_distribution<_IntType>::operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::binomial_distribution<_IntType>::param_type &__param)
  {
    typename ::std::binomial_distribution<_IntType>::result_type __ret;
    const _IntType __t = __param.t();
    const double __p = __param.p();
    const double __p12(__p <= 5.00000000000000000000000000000000000000000000000000000e-01 ? __p : 1.00000000000000000000000000000000000000000000000000000e+00 - __p);
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, double> __aurng(__urng);
    if (!__param._M_easy)
      {
        double __x;
        const double __naf = (1 - std::numeric_limits<double>::epsilon()) / 2;
        const double __thr = std::numeric_limits<_IntType>::max() + __naf;
        const double __np = std::floor(__t * __p12);
        const double __spi_2(1.2533141373155002512356989696762354924430837854743003845214843750e+00L);
        const double __a1 = __param._M_a1;
        const double __a12 = __a1 + __param._M_s2 * __spi_2;
        const double __a123 = __param._M_a123;
        const double __s1s = __param._M_s1 * __param._M_s1;
        const double __s2s = __param._M_s2 * __param._M_s2;
        bool __reject;
        do
          {
            const double __u = __param._M_s * __aurng();
            double __v;
            if (__u <= __a1)
              {
                const double __n = ::std::binomial_distribution<_IntType>::_M_nd(__urng);
                const double __y = __param._M_s1 * std::abs(__n);
                __reject = __y >= __param._M_d1;
                if (!__reject)
                  {
                    const double __e =  -std::log(1.00000000000000000000000000000000000000000000000000000e+00 - __aurng());
                    __x = ::std::floor(__y);
                    __v =  -__e - __n * __n / 2 + __param._M_c;
                  }
              }
            else
              {
                if (__u <= __a12)
                  {
                    const double __n = ::std::binomial_distribution<_IntType>::_M_nd(__urng);
                    const double __y = __param._M_s2 * std::abs(__n);
                    __reject = __y >= __param._M_d2;
                    if (!__reject)
                      {
                        const double __e =  -std::log(1.00000000000000000000000000000000000000000000000000000e+00 - __aurng());
                        __x = ::std::floor( -__y);
                        __v =  -__e - __n * __n / 2;
                      }
                  }
                else
                  {
                    if (__u <= __a123)
                      {
                        const double __e1 =  -std::log(1.00000000000000000000000000000000000000000000000000000e+00 - __aurng());
                        const double __e2 =  -std::log(1.00000000000000000000000000000000000000000000000000000e+00 - __aurng());
                        const double __y = __param._M_d1 + 2 * __s1s * __e1 / __param._M_d1;
                        __x = ::std::floor(__y);
                        __v =  -__e2 + __param._M_d1 * (1 / (__t - __np) - __y / (2 * __s1s));
                        __reject = false;
                      }
                    else
                      {
                        const double __e1 =  -std::log(1.00000000000000000000000000000000000000000000000000000e+00 - __aurng());
                        const double __e2 =  -std::log(1.00000000000000000000000000000000000000000000000000000e+00 - __aurng());
                        const double __y = __param._M_d2 + 2 * __s2s * __e1 / __param._M_d2;
                        __x = ::std::floor( -__y);
                        __v =  -__e2 - __param._M_d2 * __y / (2 * __s2s);
                        __reject = false;
                      }
                  }
              }
            __reject = (__reject || __x <  -__np) || __x > __t - __np;
            if (!__reject)
              {
                const double __lfx = ::std::lgamma(__np + __x + 1) + std::lgamma(__t - (__np + __x) + 1);
                __reject = __v > __param._M_lf - __lfx + __x * __param._M_lp1p;
              }
            __reject |= __x + __np >= __thr;
          }
        while (__reject);
        __x += __np + __naf;
        const _IntType __z = (*this)._M_waiting(__urng, __t - _IntType(__x), __param._M_q);
        __ret = _IntType(__x) + __z;
      }
    else
      {
        __ret = (*this)._M_waiting(__urng, __t, __param._M_q);
      }
    if (__p12 != __p)
      {
        __ret = __t - __ret;
      }
    return __ret;
  }
  template < typename _IntType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void binomial_distribution<_IntType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::binomial_distribution<_IntType>::param_type &__param)
  {
    while (__f != __t)
      {
        *__f++ = this->operator ()(__urng, __param);
      }
  }
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::binomial_distribution<_IntType> &__x);
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::binomial_distribution<_IntType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(::std::numeric_limits<double>::max_digits10);
    __os << __x.t() << __space << __x.p() << __space << __x._M_nd;
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::binomial_distribution<_IntType> &__x);
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::binomial_distribution<_IntType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    _IntType __t;
    double __p;
    __is >> __t >> __p >> __x._M_nd;
    __x.param(typename ::std::binomial_distribution<_IntType>::param_type(__t, __p));
    __is.flags(__flags);
    return __is;
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void exponential_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::exponential_distribution<_RealType>::param_type &__p)
  {
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, typename ::std::exponential_distribution<_RealType>::result_type> __aurng(__urng);
    while (__f != __t)
      {
        *__f++ =  -std::log(((typename ::std::exponential_distribution<_RealType>::result_type(1))) - __aurng()) / __p.lambda();
      }
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::exponential_distribution<_RealType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__os.widen(' '));
    __os.precision(std::numeric_limits<_RealType>::max_digits10);
    __os << __x.lambda();
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::exponential_distribution<_RealType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    _RealType __lambda;
    __is >> __lambda;
    __x.param(typename ::std::exponential_distribution<_RealType>::param_type(__lambda));
    __is.flags(__flags);
    return __is;
  }
  template < typename _RealType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::normal_distribution<_RealType>::result_type normal_distribution<_RealType>::operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::normal_distribution<_RealType>::param_type &__param)
  {
    typename ::std::normal_distribution<_RealType>::result_type __ret;
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, typename ::std::normal_distribution<_RealType>::result_type> __aurng(__urng);
    if (::std::normal_distribution<_RealType>::_M_saved_available)
      {
        ::std::normal_distribution<_RealType>::_M_saved_available = false;
        __ret = ::std::normal_distribution<_RealType>::_M_saved;
      }
    else
      {
        typename ::std::normal_distribution<_RealType>::result_type __x;
        typename ::std::normal_distribution<_RealType>::result_type __y;
        typename ::std::normal_distribution<_RealType>::result_type __r2;
        do
          {
            __x = ((typename ::std::normal_distribution<_RealType>::result_type(2.00000000000000000000000000000000000000000000000000000e+00))) * __aurng() - 1.00000000000000000000000000000000000000000000000000000e+00;
            __y = ((typename ::std::normal_distribution<_RealType>::result_type(2.00000000000000000000000000000000000000000000000000000e+00))) * __aurng() - 1.00000000000000000000000000000000000000000000000000000e+00;
            __r2 = __x * __x + __y * __y;
          }
        while (__r2 > 1.00000000000000000000000000000000000000000000000000000e+00 || __r2 == 0.00000000000000000000000000000000000000000000000000000e+00);
        const typename ::std::normal_distribution<_RealType>::result_type __mult = std::sqrt( -2 * std::log(__r2) / __r2);
        ::std::normal_distribution<_RealType>::_M_saved = __x * __mult;
        ::std::normal_distribution<_RealType>::_M_saved_available = true;
        __ret = __y * __mult;
      }
    __ret = __ret * __param.stddev() + __param.mean();
    return __ret;
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void normal_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::normal_distribution<_RealType>::param_type &__param)
  {
    if (__f == __t)
      {
        return ;
      }
    if (::std::normal_distribution<_RealType>::_M_saved_available)
      {
        ::std::normal_distribution<_RealType>::_M_saved_available = false;
        *__f++ = ::std::normal_distribution<_RealType>::_M_saved * __param.stddev() + __param.mean();
        if (__f == __t)
          {
            return ;
          }
      }
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, typename ::std::normal_distribution<_RealType>::result_type> __aurng(__urng);
    while (__f + 1 < __t)
      {
        typename ::std::normal_distribution<_RealType>::result_type __x;
        typename ::std::normal_distribution<_RealType>::result_type __y;
        typename ::std::normal_distribution<_RealType>::result_type __r2;
        do
          {
            __x = ((typename ::std::normal_distribution<_RealType>::result_type(2.00000000000000000000000000000000000000000000000000000e+00))) * __aurng() - 1.00000000000000000000000000000000000000000000000000000e+00;
            __y = ((typename ::std::normal_distribution<_RealType>::result_type(2.00000000000000000000000000000000000000000000000000000e+00))) * __aurng() - 1.00000000000000000000000000000000000000000000000000000e+00;
            __r2 = __x * __x + __y * __y;
          }
        while (__r2 > 1.00000000000000000000000000000000000000000000000000000e+00 || __r2 == 0.00000000000000000000000000000000000000000000000000000e+00);
        const typename ::std::normal_distribution<_RealType>::result_type __mult = std::sqrt( -2 * std::log(__r2) / __r2);
        *__f++ = __y * __mult * __param.stddev() + __param.mean();
        *__f++ = __x * __mult * __param.stddev() + __param.mean();
      }
    if (__f != __t)
      {
        typename ::std::normal_distribution<_RealType>::result_type __x;
        typename ::std::normal_distribution<_RealType>::result_type __y;
        typename ::std::normal_distribution<_RealType>::result_type __r2;
        do
          {
            __x = ((typename ::std::normal_distribution<_RealType>::result_type(2.00000000000000000000000000000000000000000000000000000e+00))) * __aurng() - 1.00000000000000000000000000000000000000000000000000000e+00;
            __y = ((typename ::std::normal_distribution<_RealType>::result_type(2.00000000000000000000000000000000000000000000000000000e+00))) * __aurng() - 1.00000000000000000000000000000000000000000000000000000e+00;
            __r2 = __x * __x + __y * __y;
          }
        while (__r2 > 1.00000000000000000000000000000000000000000000000000000e+00 || __r2 == 0.00000000000000000000000000000000000000000000000000000e+00);
        const typename ::std::normal_distribution<_RealType>::result_type __mult = std::sqrt( -2 * std::log(__r2) / __r2);
        ::std::normal_distribution<_RealType>::_M_saved = __x * __mult;
        ::std::normal_distribution<_RealType>::_M_saved_available = true;
        *__f = __y * __mult * __param.stddev() + __param.mean();
      }
  }
  template < typename _RealType1 >
  bool operator ==(const ::std::normal_distribution<_RealType1> &__d1, const ::std::normal_distribution<_RealType1> &__d2);
  template < typename _RealType >
  bool operator ==(const ::std::normal_distribution<_RealType> &__d1, const ::std::normal_distribution<_RealType> &__d2)
  {
    if (__d1._M_param == __d2._M_param && __d1._M_saved_available == __d2._M_saved_available)
      {
        if (__d1._M_saved_available && __d1._M_saved == __d2._M_saved)
          {
            return true;
          }
        else
          {
            if (!__d1._M_saved_available)
              {
                return true;
              }
            else
              {
                return false;
              }
          }
      }
    else
      {
        return false;
      }
  }
  template < typename _RealType1, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::normal_distribution<_RealType1> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::normal_distribution<_RealType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(std::numeric_limits<_RealType>::max_digits10);
    __os << __x.mean() << __space << __x.stddev() << __space << __x._M_saved_available;
    if (__x._M_saved_available)
      {
        __os << __space << __x._M_saved;
      }
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _RealType1, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::normal_distribution<_RealType1> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::normal_distribution<_RealType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    double __mean;
    double __stddev;
    __is >> __mean >> __stddev >> __x._M_saved_available;
    if (__x._M_saved_available)
      {
        __is >> __x._M_saved;
      }
    __x.param(typename ::std::normal_distribution<_RealType>::param_type(__mean, __stddev));
    __is.flags(__flags);
    return __is;
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void lognormal_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::lognormal_distribution<_RealType>::param_type &__p)
  {
    while (__f != __t)
      {
        *__f++ = std::exp(__p.s() * ::std::lognormal_distribution<_RealType>::_M_nd(__urng) + __p.m());
      }
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::lognormal_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::lognormal_distribution<_RealType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(std::numeric_limits<_RealType>::max_digits10);
    __os << __x.m() << __space << __x.s() << __space << __x._M_nd;
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::lognormal_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::lognormal_distribution<_RealType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    _RealType __m;
    _RealType __s;
    __is >> __m >> __s >> __x._M_nd;
    __x.param(typename ::std::lognormal_distribution<_RealType>::param_type(__m, __s));
    __is.flags(__flags);
    return __is;
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void chi_squared_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
  {
    while (__f != __t)
      {
        *__f++ = 2 * ::std::chi_squared_distribution<_RealType>::_M_gd(__urng);
      }
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void chi_squared_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::gamma_distribution<typename ::std::chi_squared_distribution<_RealType>::result_type>::param_type &__p)
  {
    while (__f != __t)
      {
        *__f++ = 2 * ::std::chi_squared_distribution<_RealType>::_M_gd(__urng, __p);
      }
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::chi_squared_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::chi_squared_distribution<_RealType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(std::numeric_limits<_RealType>::max_digits10);
    __os << __x.n() << __space << __x._M_gd;
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::chi_squared_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::chi_squared_distribution<_RealType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    _RealType __n;
    __is >> __n >> __x._M_gd;
    __x.param(typename ::std::chi_squared_distribution<_RealType>::param_type(__n));
    __is.flags(__flags);
    return __is;
  }
  template < typename _RealType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::cauchy_distribution<_RealType>::result_type cauchy_distribution<_RealType>::operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::cauchy_distribution<_RealType>::param_type &__p)
  {
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, typename ::std::cauchy_distribution<_RealType>::result_type> __aurng(__urng);
    _RealType __u;
    do
      {
        __u = __aurng();
      }
    while (__u == 5.00000000000000000000000000000000000000000000000000000e-01);
    const _RealType __pi = 3.1415926535897932385128089594061862044327426701784133911132812500e+00L;
    return __p.a() + __p.b() * std::tan(__pi * __u);
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void cauchy_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::cauchy_distribution<_RealType>::param_type &__p)
  {
    const _RealType __pi = 3.1415926535897932385128089594061862044327426701784133911132812500e+00L;
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, typename ::std::cauchy_distribution<_RealType>::result_type> __aurng(__urng);
    while (__f != __t)
      {
        _RealType __u;
        do
          {
            __u = __aurng();
          }
        while (__u == 5.00000000000000000000000000000000000000000000000000000e-01);
        *__f++ = __p.a() + __p.b() * std::tan(__pi * __u);
      }
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::cauchy_distribution<_RealType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(std::numeric_limits<_RealType>::max_digits10);
    __os << __x.a() << __space << __x.b();
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::cauchy_distribution<_RealType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    _RealType __a;
    _RealType __b;
    __is >> __a >> __b;
    __x.param(typename ::std::cauchy_distribution<_RealType>::param_type(__a, __b));
    __is.flags(__flags);
    return __is;
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void fisher_f_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
  {
    while (__f != __t)
      {
        *__f++ = ::std::fisher_f_distribution<_RealType>::_M_gd_x(__urng) * (*this).n() / (::std::fisher_f_distribution<_RealType>::_M_gd_y(__urng) * (*this).m());
      }
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void fisher_f_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::fisher_f_distribution<_RealType>::param_type &__p)
  {
    typedef typename ::std::gamma_distribution<typename ::std::fisher_f_distribution<_RealType>::result_type>::param_type param_type;
    param_type __p1(__p.m() / 2);
    param_type __p2(__p.n() / 2);
    while (__f != __t)
      {
        *__f++ = ::std::fisher_f_distribution<_RealType>::_M_gd_x(__urng, __p1) * (*this).n() / (::std::fisher_f_distribution<_RealType>::_M_gd_y(__urng, __p2) * (*this).m());
      }
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::fisher_f_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::fisher_f_distribution<_RealType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(std::numeric_limits<_RealType>::max_digits10);
    __os << __x.m() << __space << __x.n() << __space << __x._M_gd_x << __space << __x._M_gd_y;
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::fisher_f_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::fisher_f_distribution<_RealType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    _RealType __m;
    _RealType __n;
    __is >> __m >> __n >> __x._M_gd_x >> __x._M_gd_y;
    __x.param(typename ::std::fisher_f_distribution<_RealType>::param_type(__m, __n));
    __is.flags(__flags);
    return __is;
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void student_t_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng)
  {
    while (__f != __t)
      {
        *__f++ = ::std::student_t_distribution<_RealType>::_M_nd(__urng) * std::sqrt((*this).n() / ::std::student_t_distribution<_RealType>::_M_gd(__urng));
      }
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void student_t_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::student_t_distribution<_RealType>::param_type &__p)
  {
    typename ::std::gamma_distribution<typename ::std::student_t_distribution<_RealType>::result_type>::param_type __p2(__p.n() / 2, 2);
    while (__f != __t)
      {
        *__f++ = ::std::student_t_distribution<_RealType>::_M_nd(__urng) * std::sqrt(__p.n() / ::std::student_t_distribution<_RealType>::_M_gd(__urng, __p2));
      }
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::student_t_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::student_t_distribution<_RealType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(std::numeric_limits<_RealType>::max_digits10);
    __os << __x.n() << __space << __x._M_nd << __space << __x._M_gd;
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::student_t_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::student_t_distribution<_RealType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    _RealType __n;
    __is >> __n >> __x._M_nd >> __x._M_gd;
    __x.param(typename ::std::student_t_distribution<_RealType>::param_type(__n));
    __is.flags(__flags);
    return __is;
  }
  template < typename _RealType >
  void gamma_distribution<_RealType>::param_type::_M_initialize()
  {
    ::std::gamma_distribution<_RealType>::param_type::_M_malpha = ::std::gamma_distribution<_RealType>::param_type::_M_alpha < 1.00000000000000000000000000000000000000000000000000000e+00 ? ::std::gamma_distribution<_RealType>::param_type::_M_alpha + _RealType(1.00000000000000000000000000000000000000000000000000000e+00) : ::std::gamma_distribution<_RealType>::param_type::_M_alpha;
    const _RealType __a1 = ::std::gamma_distribution<_RealType>::param_type::_M_malpha - _RealType(1.00000000000000000000000000000000000000000000000000000e+00) / _RealType(3.00000000000000000000000000000000000000000000000000000e+00);
    ::std::gamma_distribution<_RealType>::param_type::_M_a2 = _RealType(1.00000000000000000000000000000000000000000000000000000e+00) / std::sqrt(_RealType(9.00000000000000000000000000000000000000000000000000000e+00) * __a1);
  }
  template < typename _RealType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::gamma_distribution<_RealType>::result_type gamma_distribution<_RealType>::operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::gamma_distribution<_RealType>::param_type &__param)
  {
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, typename ::std::gamma_distribution<_RealType>::result_type> __aurng(__urng);
    typename ::std::gamma_distribution<_RealType>::result_type __u;
    typename ::std::gamma_distribution<_RealType>::result_type __v;
    typename ::std::gamma_distribution<_RealType>::result_type __n;
    const typename ::std::gamma_distribution<_RealType>::result_type __a1 = __param._M_malpha - _RealType(1.00000000000000000000000000000000000000000000000000000e+00) / _RealType(3.00000000000000000000000000000000000000000000000000000e+00);
    do
      {
        do
          {
            __n = ::std::gamma_distribution<_RealType>::_M_nd(__urng);
            __v = ((typename ::std::gamma_distribution<_RealType>::result_type(1.00000000000000000000000000000000000000000000000000000e+00))) + __param._M_a2 * __n;
          }
        while (__v <= 0.00000000000000000000000000000000000000000000000000000e+00);
        __v = __v * __v * __v;
        __u = __aurng();
      }
    while (__u > ((typename ::std::gamma_distribution<_RealType>::result_type(1.00000000000000000000000000000000000000000000000000000e+00))) - 3.31000000000000016431300764452316798269748687744140625e-01 * __n * __n * __n * __n && std::log(__u) > 5.00000000000000000000000000000000000000000000000000000e-01 * __n * __n + __a1 * (1.00000000000000000000000000000000000000000000000000000e+00 - __v + std::log(__v)));
    if (__param.alpha() == __param._M_malpha)
      {
        return __a1 * __v * __param.beta();
      }
    else
      {
        do
          {
            __u = __aurng();
          }
        while (__u == 0.00000000000000000000000000000000000000000000000000000e+00);
        return std::pow(__u, ((typename ::std::gamma_distribution<_RealType>::result_type(1.00000000000000000000000000000000000000000000000000000e+00))) / __param.alpha()) * __a1 * __v * __param.beta();
      }
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void gamma_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::gamma_distribution<_RealType>::param_type &__param)
  {
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, typename ::std::gamma_distribution<_RealType>::result_type> __aurng(__urng);
    typename ::std::gamma_distribution<_RealType>::result_type __u;
    typename ::std::gamma_distribution<_RealType>::result_type __v;
    typename ::std::gamma_distribution<_RealType>::result_type __n;
    const typename ::std::gamma_distribution<_RealType>::result_type __a1 = __param._M_malpha - _RealType(1.00000000000000000000000000000000000000000000000000000e+00) / _RealType(3.00000000000000000000000000000000000000000000000000000e+00);
    if (__param.alpha() == __param._M_malpha)
      {
        while (__f != __t)
          {
            do
              {
                do
                  {
                    __n = ::std::gamma_distribution<_RealType>::_M_nd(__urng);
                    __v = ((typename ::std::gamma_distribution<_RealType>::result_type(1.00000000000000000000000000000000000000000000000000000e+00))) + __param._M_a2 * __n;
                  }
                while (__v <= 0.00000000000000000000000000000000000000000000000000000e+00);
                __v = __v * __v * __v;
                __u = __aurng();
              }
            while (__u > ((typename ::std::gamma_distribution<_RealType>::result_type(1.00000000000000000000000000000000000000000000000000000e+00))) - 3.31000000000000016431300764452316798269748687744140625e-01 * __n * __n * __n * __n && std::log(__u) > 5.00000000000000000000000000000000000000000000000000000e-01 * __n * __n + __a1 * (1.00000000000000000000000000000000000000000000000000000e+00 - __v + std::log(__v)));
            *__f++ = __a1 * __v * __param.beta();
          }
      }
    else
      {
        while (__f != __t)
          {
            do
              {
                do
                  {
                    __n = ::std::gamma_distribution<_RealType>::_M_nd(__urng);
                    __v = ((typename ::std::gamma_distribution<_RealType>::result_type(1.00000000000000000000000000000000000000000000000000000e+00))) + __param._M_a2 * __n;
                  }
                while (__v <= 0.00000000000000000000000000000000000000000000000000000e+00);
                __v = __v * __v * __v;
                __u = __aurng();
              }
            while (__u > ((typename ::std::gamma_distribution<_RealType>::result_type(1.00000000000000000000000000000000000000000000000000000e+00))) - 3.31000000000000016431300764452316798269748687744140625e-01 * __n * __n * __n * __n && std::log(__u) > 5.00000000000000000000000000000000000000000000000000000e-01 * __n * __n + __a1 * (1.00000000000000000000000000000000000000000000000000000e+00 - __v + std::log(__v)));
            do
              {
                __u = __aurng();
              }
            while (__u == 0.00000000000000000000000000000000000000000000000000000e+00);
            *__f++ = std::pow(__u, ((typename ::std::gamma_distribution<_RealType>::result_type(1.00000000000000000000000000000000000000000000000000000e+00))) / __param.alpha()) * __a1 * __v * __param.beta();
          }
      }
  }
  template < typename _RealType1, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::gamma_distribution<_RealType1> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::gamma_distribution<_RealType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(std::numeric_limits<_RealType>::max_digits10);
    __os << __x.alpha() << __space << __x.beta() << __space << __x._M_nd;
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _RealType1, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::gamma_distribution<_RealType1> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::gamma_distribution<_RealType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    _RealType __alpha_val;
    _RealType __beta_val;
    __is >> __alpha_val >> __beta_val >> __x._M_nd;
    __x.param(typename ::std::gamma_distribution<_RealType>::param_type(__alpha_val, __beta_val));
    __is.flags(__flags);
    return __is;
  }
  template < typename _RealType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::weibull_distribution<_RealType>::result_type weibull_distribution<_RealType>::operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::weibull_distribution<_RealType>::param_type &__p)
  {
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, typename ::std::weibull_distribution<_RealType>::result_type> __aurng(__urng);
    return __p.b() * std::pow( -std::log(((typename ::std::weibull_distribution<_RealType>::result_type(1))) - __aurng()), ((typename ::std::weibull_distribution<_RealType>::result_type(1))) / __p.a());
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void weibull_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::weibull_distribution<_RealType>::param_type &__p)
  {
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, typename ::std::weibull_distribution<_RealType>::result_type> __aurng(__urng);
    auto __inv_a = ((typename ::std::weibull_distribution<_RealType>::result_type(1))) / __p.a();
    while (__f != __t)
      {
        *__f++ = __p.b() * std::pow( -std::log(((typename ::std::weibull_distribution<_RealType>::result_type(1))) - __aurng()), __inv_a);
      }
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::weibull_distribution<_RealType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(std::numeric_limits<_RealType>::max_digits10);
    __os << __x.a() << __space << __x.b();
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::weibull_distribution<_RealType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    _RealType __a;
    _RealType __b;
    __is >> __a >> __b;
    __x.param(typename ::std::weibull_distribution<_RealType>::param_type(__a, __b));
    __is.flags(__flags);
    return __is;
  }
  template < typename _RealType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::extreme_value_distribution<_RealType>::result_type extreme_value_distribution<_RealType>::operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::extreme_value_distribution<_RealType>::param_type &__p)
  {
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, typename ::std::extreme_value_distribution<_RealType>::result_type> __aurng(__urng);
    return __p.a() - __p.b() * std::log( -std::log(((typename ::std::extreme_value_distribution<_RealType>::result_type(1))) - __aurng()));
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void extreme_value_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::extreme_value_distribution<_RealType>::param_type &__p)
  {
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, typename ::std::extreme_value_distribution<_RealType>::result_type> __aurng(__urng);
    while (__f != __t)
      {
        *__f++ = __p.a() - __p.b() * std::log( -std::log(((typename ::std::extreme_value_distribution<_RealType>::result_type(1))) - __aurng()));
      }
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::extreme_value_distribution<_RealType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(std::numeric_limits<_RealType>::max_digits10);
    __os << __x.a() << __space << __x.b();
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::extreme_value_distribution<_RealType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    _RealType __a;
    _RealType __b;
    __is >> __a >> __b;
    __x.param(typename ::std::extreme_value_distribution<_RealType>::param_type(__a, __b));
    __is.flags(__flags);
    return __is;
  }
  template < typename _IntType >
  void discrete_distribution<_IntType>::param_type::_M_initialize()
  {
    if (::std::discrete_distribution<_IntType>::param_type::_M_prob.size() < 2)
      {
        ::std::discrete_distribution<_IntType>::param_type::_M_prob.clear();
        return ;
      }
    const double __sum = std::accumulate(::std::discrete_distribution<_IntType>::param_type::_M_prob.begin(), ::std::discrete_distribution<_IntType>::param_type::_M_prob.end(), 0.00000000000000000000000000000000000000000000000000000e+00);
    __detail::__normalize(::std::discrete_distribution<_IntType>::param_type::_M_prob.begin(), ::std::discrete_distribution<_IntType>::param_type::_M_prob.end(), ::std::discrete_distribution<_IntType>::param_type::_M_prob.begin(), __sum);
    ::std::discrete_distribution<_IntType>::param_type::_M_cp.reserve(::std::discrete_distribution<_IntType>::param_type::_M_prob.size());
    std::partial_sum(::std::discrete_distribution<_IntType>::param_type::_M_prob.begin(), ::std::discrete_distribution<_IntType>::param_type::_M_prob.end(), std::back_inserter(::std::discrete_distribution<_IntType>::param_type::_M_cp));
    ::std::discrete_distribution<_IntType>::param_type::_M_cp[::std::discrete_distribution<_IntType>::param_type::_M_cp.size() - 1] = 1.00000000000000000000000000000000000000000000000000000e+00;
  }
  template < typename _IntType >
  template < typename _Func >
  discrete_distribution<_IntType>::param_type::param_type(::std::size_t __nw, double __xmin, double __xmax, _Func __fw)
    : _M_prob(), _M_cp()
  {
    const ::std::size_t __n(__nw == 0 ? 1 : __nw);
    const double __delta((__xmax - __xmin) / __n);
    ::std::discrete_distribution<_IntType>::param_type::_M_prob.reserve(__n);
    for (::std::size_t __k(0); __k < __nw;  ++__k)
      {
        ::std::discrete_distribution<_IntType>::param_type::_M_prob.push_back(__fw(__xmin + __k * __delta + 5.00000000000000000000000000000000000000000000000000000e-01 * __delta));
      }
    (*this)._M_initialize();
  }
  template < typename _IntType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::discrete_distribution<_IntType>::result_type discrete_distribution<_IntType>::operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::discrete_distribution<_IntType>::param_type &__param)
  {
    if (__param._M_cp.empty())
      {
        return ((typename ::std::discrete_distribution<_IntType>::result_type(0)));
      }
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, double> __aurng(__urng);
    const double __p = __aurng();
    auto __pos = std::lower_bound(__param._M_cp.begin(), __param._M_cp.end(), __p);
    return __pos - __param._M_cp.begin();
  }
  template < typename _IntType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void discrete_distribution<_IntType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::discrete_distribution<_IntType>::param_type &__param)
  {
    if (__param._M_cp.empty())
      {
        while (__f != __t)
          {
            *__f++ = ((typename ::std::discrete_distribution<_IntType>::result_type(0)));
          }
        return ;
      }
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, double> __aurng(__urng);
    while (__f != __t)
      {
        const double __p = __aurng();
        auto __pos = std::lower_bound(__param._M_cp.begin(), __param._M_cp.end(), __p);
        *__f++ = __pos - __param._M_cp.begin();
      }
  }
 /* Instantiation of class template '::std::iterator_traits<double *>' */ 
 /* Instantiation of class template '::__gnu_cxx::__normal_iterator<double *, ::std::vector<double> >' */ 
 /* Instantiation of class template '::std::__are_same<double *, double *>' */ 
 /* Instantiation of class template '::__gnu_cxx::__enable_if<true, ::std::vector<double> >' */ 
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::discrete_distribution<_IntType> &__x);
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::discrete_distribution<_IntType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(::std::numeric_limits<double>::max_digits10);
    ::std::vector<double> __prob = __x.probabilities();
    __os << __prob.::std::vector<double>::size();
    for (::__gnu_cxx::__normal_iterator<double *, ::std::vector<double> > __dit((__prob.::std::vector<double>::begin())); __dit != __prob.::std::vector<double>::end();  ++__dit)
      {
        __os << __space <<  *__dit;
      }
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::discrete_distribution<_IntType> &__x);
  template < typename _IntType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::discrete_distribution<_IntType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    ::std::size_t __n;
    __is >> __n;
    ::std::vector<double> __prob_vec /* () */ ;
    __prob_vec.::std::vector<double>::reserve(__n);
    for (; __n != 0;  --__n)
      {
        double __prob;
        __is >> __prob;
        __prob_vec.::std::vector<double>::push_back(__prob);
      }
    __x.param(typename ::std::discrete_distribution<_IntType>::param_type(__prob_vec.::std::vector<double>::begin(), __prob_vec.::std::vector<double>::end()));
    __is.flags(__flags);
    return __is;
  }
  template < typename _RealType >
  void piecewise_constant_distribution<_RealType>::param_type::_M_initialize()
  {
    if (::std::piecewise_constant_distribution<_RealType>::param_type::_M_int.size() < 2 || ((::std::piecewise_constant_distribution<_RealType>::param_type::_M_int.size() == 2 && ::std::piecewise_constant_distribution<_RealType>::param_type::_M_int[0] == _RealType(0)) && ::std::piecewise_constant_distribution<_RealType>::param_type::_M_int[1] == _RealType(1)))
      {
        ::std::piecewise_constant_distribution<_RealType>::param_type::_M_int.clear();
        ::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.clear();
        return ;
      }
    const double __sum = std::accumulate(::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.begin(), ::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.end(), 0.00000000000000000000000000000000000000000000000000000e+00);
    __detail::__normalize(::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.begin(), ::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.end(), ::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.begin(), __sum);
    ::std::piecewise_constant_distribution<_RealType>::param_type::_M_cp.reserve(::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.size());
    std::partial_sum(::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.begin(), ::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.end(), std::back_inserter(::std::piecewise_constant_distribution<_RealType>::param_type::_M_cp));
    ::std::piecewise_constant_distribution<_RealType>::param_type::_M_cp[::std::piecewise_constant_distribution<_RealType>::param_type::_M_cp.size() - 1] = 1.00000000000000000000000000000000000000000000000000000e+00;
    for (::std::size_t __k(0); __k < ::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.size();  ++__k)
      {
        ::std::piecewise_constant_distribution<_RealType>::param_type::_M_den[__k] /= ::std::piecewise_constant_distribution<_RealType>::param_type::_M_int[__k + 1] - ::std::piecewise_constant_distribution<_RealType>::param_type::_M_int[__k];
      }
  }
  template < typename _RealType >
  template < typename _InputIteratorB, typename _InputIteratorW >
  piecewise_constant_distribution<_RealType>::param_type::param_type(_InputIteratorB __bbegin, _InputIteratorB __bend, _InputIteratorW __wbegin)
    : _M_int(), _M_den(), _M_cp()
  {
    if (__bbegin != __bend)
      {
        for (; ; )
          {
            ::std::piecewise_constant_distribution<_RealType>::param_type::_M_int.push_back(*__bbegin);
             ++__bbegin;
            if (__bbegin == __bend)
              {
                break;
              }
            ::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.push_back(*__wbegin);
             ++__wbegin;
          }
      }
    (*this)._M_initialize();
  }
  template < typename _RealType >
  template < typename _Func >
  piecewise_constant_distribution<_RealType>::param_type::param_type(::std::initializer_list<_RealType> __bl, _Func __fw)
    : _M_int(), _M_den(), _M_cp()
  {
    ::std::piecewise_constant_distribution<_RealType>::param_type::_M_int.reserve(__bl.size());
    for (auto __biter = __bl.begin(); __biter != __bl.end();  ++__biter)
      {
        ::std::piecewise_constant_distribution<_RealType>::param_type::_M_int.push_back(*__biter);
      }
    ::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.reserve(::std::piecewise_constant_distribution<_RealType>::param_type::_M_int.size() - 1);
    for (::std::size_t __k(0); __k < ::std::piecewise_constant_distribution<_RealType>::param_type::_M_int.size() - 1;  ++__k)
      {
        ::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.push_back(__fw(5.00000000000000000000000000000000000000000000000000000e-01 * (::std::piecewise_constant_distribution<_RealType>::param_type::_M_int[__k + 1] + ::std::piecewise_constant_distribution<_RealType>::param_type::_M_int[__k])));
      }
    (*this)._M_initialize();
  }
  template < typename _RealType >
  template < typename _Func >
  piecewise_constant_distribution<_RealType>::param_type::param_type(::std::size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
    : _M_int(), _M_den(), _M_cp()
  {
    const ::std::size_t __n(__nw == 0 ? 1 : __nw);
    const _RealType __delta = (__xmax - __xmin) / __n;
    ::std::piecewise_constant_distribution<_RealType>::param_type::_M_int.reserve(__n + 1);
    for (::std::size_t __k(0); __k <= __nw;  ++__k)
      {
        ::std::piecewise_constant_distribution<_RealType>::param_type::_M_int.push_back(__xmin + __k * __delta);
      }
    ::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.reserve(__n);
    for (::std::size_t __k(0); __k < __nw;  ++__k)
      {
        ::std::piecewise_constant_distribution<_RealType>::param_type::_M_den.push_back(__fw(::std::piecewise_constant_distribution<_RealType>::param_type::_M_int[__k] + 5.00000000000000000000000000000000000000000000000000000e-01 * __delta));
      }
    (*this)._M_initialize();
  }
  template < typename _RealType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::piecewise_constant_distribution<_RealType>::result_type piecewise_constant_distribution<_RealType>::operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::piecewise_constant_distribution<_RealType>::param_type &__param)
  {
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, double> __aurng(__urng);
    const double __p = __aurng();
    if (__param._M_cp.empty())
      {
        return __p;
      }
    auto __pos = std::lower_bound(__param._M_cp.begin(), __param._M_cp.end(), __p);
    const ::std::size_t __i = __pos - __param._M_cp.begin();
    const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.00000000000000000000000000000000000000000000000000000e+00;
    return __param._M_int[__i] + (__p - __pref) / __param._M_den[__i];
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void piecewise_constant_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::piecewise_constant_distribution<_RealType>::param_type &__param)
  {
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, double> __aurng(__urng);
    if (__param._M_cp.empty())
      {
        while (__f != __t)
          {
            *__f++ = __aurng();
          }
        return ;
      }
    while (__f != __t)
      {
        const double __p = __aurng();
        auto __pos = std::lower_bound(__param._M_cp.begin(), __param._M_cp.end(), __p);
        const ::std::size_t __i = __pos - __param._M_cp.begin();
        const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.00000000000000000000000000000000000000000000000000000e+00;
        *__f++ = __param._M_int[__i] + (__p - __pref) / __param._M_den[__i];
      }
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::piecewise_constant_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::piecewise_constant_distribution<_RealType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(std::numeric_limits<_RealType>::max_digits10);
    ::std::vector<_RealType> __int = __x.intervals();
    __os << (__int.size() - 1);
    for (auto __xit = __int.begin(); __xit != __int.end();  ++__xit)
      {
        __os << __space << *__xit;
      }
    ::std::vector<double> __den = __x.densities();
    for (::__gnu_cxx::__normal_iterator<double *, ::std::vector<double> > __dit((__den.::std::vector<double>::begin())); __dit != __den.::std::vector<double>::end();  ++__dit)
      {
        __os << __space <<  *__dit;
      }
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::piecewise_constant_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::piecewise_constant_distribution<_RealType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    ::std::size_t __n;
    __is >> __n;
    ::std::vector<_RealType> __int_vec;
    __int_vec.reserve(__n + 1);
    for (::std::size_t __i(0); __i <= __n;  ++__i)
      {
        _RealType __int;
        __is >> __int;
        __int_vec.push_back(__int);
      }
    ::std::vector<double> __den_vec /* () */ ;
    __den_vec.::std::vector<double>::reserve(__n);
    for (::std::size_t __i(0); __i < __n;  ++__i)
      {
        double __den;
        __is >> __den;
        __den_vec.::std::vector<double>::push_back(__den);
      }
    __x.param(typename ::std::piecewise_constant_distribution<_RealType>::param_type(__int_vec.begin(), __int_vec.end(), __den_vec.::std::vector<double>::begin()));
    __is.flags(__flags);
    return __is;
  }
  template < typename _RealType >
  void piecewise_linear_distribution<_RealType>::param_type::_M_initialize()
  {
    if (::std::piecewise_linear_distribution<_RealType>::param_type::_M_int.size() < 2 || (((::std::piecewise_linear_distribution<_RealType>::param_type::_M_int.size() == 2 && ::std::piecewise_linear_distribution<_RealType>::param_type::_M_int[0] == _RealType(0)) && ::std::piecewise_linear_distribution<_RealType>::param_type::_M_int[1] == _RealType(1)) && ::std::piecewise_linear_distribution<_RealType>::param_type::_M_den[0] == ::std::piecewise_linear_distribution<_RealType>::param_type::_M_den[1]))
      {
        ::std::piecewise_linear_distribution<_RealType>::param_type::_M_int.clear();
        ::std::piecewise_linear_distribution<_RealType>::param_type::_M_den.clear();
        return ;
      }
    double __sum(0.00000000000000000000000000000000000000000000000000000e+00);
    ::std::piecewise_linear_distribution<_RealType>::param_type::_M_cp.reserve(::std::piecewise_linear_distribution<_RealType>::param_type::_M_int.size() - 1);
    ::std::piecewise_linear_distribution<_RealType>::param_type::_M_m.reserve(::std::piecewise_linear_distribution<_RealType>::param_type::_M_int.size() - 1);
    for (::std::size_t __k(0); __k < ::std::piecewise_linear_distribution<_RealType>::param_type::_M_int.size() - 1;  ++__k)
      {
        const _RealType __delta = ::std::piecewise_linear_distribution<_RealType>::param_type::_M_int[__k + 1] - ::std::piecewise_linear_distribution<_RealType>::param_type::_M_int[__k];
        __sum += 5.00000000000000000000000000000000000000000000000000000e-01 * (::std::piecewise_linear_distribution<_RealType>::param_type::_M_den[__k + 1] + ::std::piecewise_linear_distribution<_RealType>::param_type::_M_den[__k]) * __delta;
        ::std::piecewise_linear_distribution<_RealType>::param_type::_M_cp.push_back(__sum);
        ::std::piecewise_linear_distribution<_RealType>::param_type::_M_m.push_back((::std::piecewise_linear_distribution<_RealType>::param_type::_M_den[__k + 1] - ::std::piecewise_linear_distribution<_RealType>::param_type::_M_den[__k]) / __delta);
      }
    __detail::__normalize(::std::piecewise_linear_distribution<_RealType>::param_type::_M_den.begin(), ::std::piecewise_linear_distribution<_RealType>::param_type::_M_den.end(), ::std::piecewise_linear_distribution<_RealType>::param_type::_M_den.begin(), __sum);
    __detail::__normalize(::std::piecewise_linear_distribution<_RealType>::param_type::_M_cp.begin(), ::std::piecewise_linear_distribution<_RealType>::param_type::_M_cp.end(), ::std::piecewise_linear_distribution<_RealType>::param_type::_M_cp.begin(), __sum);
    __detail::__normalize(::std::piecewise_linear_distribution<_RealType>::param_type::_M_m.begin(), ::std::piecewise_linear_distribution<_RealType>::param_type::_M_m.end(), ::std::piecewise_linear_distribution<_RealType>::param_type::_M_m.begin(), __sum);
    ::std::piecewise_linear_distribution<_RealType>::param_type::_M_cp[::std::piecewise_linear_distribution<_RealType>::param_type::_M_cp.size() - 1] = 1.00000000000000000000000000000000000000000000000000000e+00;
  }
  template < typename _RealType >
  template < typename _InputIteratorB, typename _InputIteratorW >
  piecewise_linear_distribution<_RealType>::param_type::param_type(_InputIteratorB __bbegin, _InputIteratorB __bend, _InputIteratorW __wbegin)
    : _M_int(), _M_den(), _M_cp(), _M_m()
  {
    for (; __bbegin != __bend; ( ++__bbegin,  ++__wbegin))
      {
        ::std::piecewise_linear_distribution<_RealType>::param_type::_M_int.push_back(*__bbegin);
        ::std::piecewise_linear_distribution<_RealType>::param_type::_M_den.push_back(*__wbegin);
      }
    (*this)._M_initialize();
  }
  template < typename _RealType >
  template < typename _Func >
  piecewise_linear_distribution<_RealType>::param_type::param_type(::std::initializer_list<_RealType> __bl, _Func __fw)
    : _M_int(), _M_den(), _M_cp(), _M_m()
  {
    ::std::piecewise_linear_distribution<_RealType>::param_type::_M_int.reserve(__bl.size());
    ::std::piecewise_linear_distribution<_RealType>::param_type::_M_den.reserve(__bl.size());
    for (auto __biter = __bl.begin(); __biter != __bl.end();  ++__biter)
      {
        ::std::piecewise_linear_distribution<_RealType>::param_type::_M_int.push_back(*__biter);
        ::std::piecewise_linear_distribution<_RealType>::param_type::_M_den.push_back(__fw(*__biter));
      }
    (*this)._M_initialize();
  }
  template < typename _RealType >
  template < typename _Func >
  piecewise_linear_distribution<_RealType>::param_type::param_type(::std::size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
    : _M_int(), _M_den(), _M_cp(), _M_m()
  {
    const ::std::size_t __n(__nw == 0 ? 1 : __nw);
    const _RealType __delta = (__xmax - __xmin) / __n;
    ::std::piecewise_linear_distribution<_RealType>::param_type::_M_int.reserve(__n + 1);
    ::std::piecewise_linear_distribution<_RealType>::param_type::_M_den.reserve(__n + 1);
    for (::std::size_t __k(0); __k <= __nw;  ++__k)
      {
        ::std::piecewise_linear_distribution<_RealType>::param_type::_M_int.push_back(__xmin + __k * __delta);
        ::std::piecewise_linear_distribution<_RealType>::param_type::_M_den.push_back(__fw(::std::piecewise_linear_distribution<_RealType>::param_type::_M_int[__k] + __delta));
      }
    (*this)._M_initialize();
  }
  template < typename _RealType >
  template < typename _UniformRandomNumberGenerator >
  typename ::std::piecewise_linear_distribution<_RealType>::result_type piecewise_linear_distribution<_RealType>::operator ()(_UniformRandomNumberGenerator &__urng, const typename ::std::piecewise_linear_distribution<_RealType>::param_type &__param)
  {
    ::std::__detail::_Adaptor<_UniformRandomNumberGenerator, double> __aurng(__urng);
    const double __p = __aurng();
    if (__param._M_cp.empty())
      {
        return __p;
      }
    auto __pos = std::lower_bound(__param._M_cp.begin(), __param._M_cp.end(), __p);
    const ::std::size_t __i = __pos - __param._M_cp.begin();
    const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.00000000000000000000000000000000000000000000000000000e+00;
    const double __a = 5.00000000000000000000000000000000000000000000000000000e-01 * __param._M_m[__i];
    const double __b = __param._M_den[__i];
    const double __cm(__p - __pref);
    _RealType __x = __param._M_int[__i];
    if (__a == 0)
      {
        __x += __cm / __b;
      }
    else
      {
        const double __d(__b * __b + 4.00000000000000000000000000000000000000000000000000000e+00 * __a * __cm);
        __x += 5.00000000000000000000000000000000000000000000000000000e-01 * (::std::sqrt(__d) - __b) / __a;
      }
    return __x;
  }
  template < typename _RealType >
  template < typename _ForwardIterator, typename _UniformRandomNumberGenerator >
  void piecewise_linear_distribution<_RealType>::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &__urng, const typename ::std::piecewise_linear_distribution<_RealType>::param_type &__param)
  {
    while (__f != __t)
      {
        *__f++ = this->operator ()(__urng, __param);
      }
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::piecewise_linear_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::piecewise_linear_distribution<_RealType> &__x)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_ostream<_CharT, _Traits>::ios_base::fmtflags __flags = __os.flags();
    const _CharT __fill = __os.fill();
    const ::std::streamsize __precision = __os.precision();
    const _CharT __space = __os.widen(' ');
    __os.flags(__ios_base::scientific | __ios_base::left);
    __os.fill(__space);
    __os.precision(std::numeric_limits<_RealType>::max_digits10);
    ::std::vector<_RealType> __int = __x.intervals();
    __os << (__int.size() - 1);
    for (auto __xit = __int.begin(); __xit != __int.end();  ++__xit)
      {
        __os << __space << *__xit;
      }
    ::std::vector<double> __den = __x.densities();
    for (::__gnu_cxx::__normal_iterator<double *, ::std::vector<double> > __dit((__den.::std::vector<double>::begin())); __dit != __den.::std::vector<double>::end();  ++__dit)
      {
        __os << __space <<  *__dit;
      }
    __os.flags(__flags);
    __os.fill(__fill);
    __os.precision(__precision);
    return __os;
  }
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::piecewise_linear_distribution<_RealType> &__x);
  template < typename _RealType, typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::piecewise_linear_distribution<_RealType> &__x)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    const typename ::std::basic_istream<_CharT, _Traits>::ios_base::fmtflags __flags = __is.flags();
    __is.flags(__ios_base::dec | __ios_base::skipws);
    ::std::size_t __n;
    __is >> __n;
    ::std::vector<_RealType> __int_vec;
    __int_vec.reserve(__n + 1);
    for (::std::size_t __i(0); __i <= __n;  ++__i)
      {
        _RealType __int;
        __is >> __int;
        __int_vec.push_back(__int);
      }
    ::std::vector<double> __den_vec /* () */ ;
    __den_vec.::std::vector<double>::reserve(__n + 1);
    for (::std::size_t __i(0); __i <= __n;  ++__i)
      {
        double __den;
        __is >> __den;
        __den_vec.::std::vector<double>::push_back(__den);
      }
    __x.param(typename ::std::piecewise_linear_distribution<_RealType>::param_type(__int_vec.begin(), __int_vec.end(), __den_vec.::std::vector<double>::begin()));
    __is.flags(__flags);
    return __is;
  }
  template < typename _IntType >
  seed_seq::seed_seq(::std::initializer_list<_IntType> __il)
  {
    for (auto __iter = __il.begin(); __iter != __il.end();  ++__iter)
      {
        (*this)._M_v.push_back(__detail::__mod< ::std::seed_seq::result_type, ::std::__detail::_Shift<unsigned int, 32LU>::__value>(*__iter));
      }
  }
  template < typename _InputIterator >
  seed_seq::seed_seq(_InputIterator __begin, _InputIterator __end)
  {
    for (_InputIterator __iter = __begin; __iter != __end;  ++__iter)
      {
        (*this)._M_v.push_back(__detail::__mod< ::std::seed_seq::result_type, ::std::__detail::_Shift<unsigned int, 32LU>::__value>(*__iter));
      }
  }
  template < typename _RandomAccessIterator >
  void seed_seq::generate(_RandomAccessIterator __begin, _RandomAccessIterator __end)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _Type;
    if (__begin == __end)
      {
        return ;
      }
    std::fill(__begin, __end, _Type(2341178251U));
    const ::std::size_t __n = __end - __begin;
    const ::std::size_t __s((*this)._M_v.::std::vector<unsigned int>::size());
    const ::std::size_t __t = __n >= 623 ? 11 : __n >= 68 ? 7 : __n >= 39 ? 5 : __n >= 7 ? 3 : (__n - 1) / 2;
    const ::std::size_t __p = (__n - __t) / 2;
    const ::std::size_t __q = __p + __t;
    const ::std::size_t __m = std::max((::std::size_t)(__s + 1), __n);
    for (::std::size_t __k(0); __k < __m;  ++__k)
      {
        _Type __arg = (__begin[__k % __n] ^ __begin[(__k + __p) % __n]) ^ __begin[(__k - 1) % __n];
        _Type __r1 = __arg ^ __arg >> 27;
        __r1 = __detail::__mod<_Type, __detail::_Shift<_Type, 32>::__value>(1664525U * __r1);
        _Type __r2 = __r1;
        if (__k == 0)
          {
            __r2 += __s;
          }
        else
          {
            if (__k <= __s)
              {
                __r2 += __k % __n + (*this)._M_v.::std::vector<unsigned int>::operator [](__k - 1);
              }
            else
              {
                __r2 += __k % __n;
              }
          }
        __r2 = __detail::__mod<_Type, __detail::_Shift<_Type, 32>::__value>(__r2);
        __begin[(__k + __p) % __n] += __r1;
        __begin[(__k + __q) % __n] += __r2;
        __begin[__k % __n] = __r2;
      }
    for (::std::size_t __k = __m; __k < __m + __n;  ++__k)
      {
        _Type __arg = __begin[__k % __n] + __begin[(__k + __p) % __n] + __begin[(__k - 1) % __n];
        _Type __r3 = __arg ^ __arg >> 27;
        __r3 = __detail::__mod<_Type, __detail::_Shift<_Type, 32>::__value>(1566083941U * __r3);
        _Type __r4 = __r3 - __k % __n;
        __r4 = __detail::__mod<_Type, __detail::_Shift<_Type, 32>::__value>(__r4);
        __begin[(__k + __p) % __n] ^= __r3;
        __begin[(__k + __q) % __n] ^= __r4;
        __begin[__k % __n] = __r4;
      }
  }
 /* Instantiation of class template '::std::initializer_list<unsigned long int>' */ 
  template < typename _RealType, ::std::size_t __bits, typename _UniformRandomNumberGenerator >
  _RealType generate_canonical(_UniformRandomNumberGenerator &__urng)
  {
    const ::std::size_t __b = std::min(static_cast< ::std::size_t>(std::numeric_limits<_RealType>::digits), __bits);
    const long double __r(static_cast<long double>(__urng.max()) - static_cast<long double>(__urng.min()) + 1.0000000000000000000000000000000000000000000000000000000000000000e+00L);
    const ::std::size_t __log2r(std::log(__r) / std::log(2.0000000000000000000000000000000000000000000000000000000000000000e+00L));
    ::std::size_t __k = std::max< ::std::size_t>(1LU, (__b + __log2r - 1LU) / __log2r);
    _RealType __sum = _RealType(0);
    _RealType __tmp = _RealType(1);
    for (; __k != 0;  --__k)
      {
        __sum += _RealType(__urng() - __urng.min()) * __tmp;
        __tmp *= __r;
      }
    return __sum / __tmp;
  }
  template < typename _Iterator >
  void __move_median_to_first(_Iterator __result, _Iterator __a, _Iterator __b, _Iterator __c);
  template < typename _Iterator >
  void __move_median_to_first(_Iterator __result, _Iterator __a, _Iterator __b, _Iterator __c)
  {
    if (*__a < *__b)
      {
        if (*__b < *__c)
          {
            std::iter_swap(__result, __b);
          }
        else
          {
            if (*__a < *__c)
              {
                std::iter_swap(__result, __c);
              }
            else
              {
                std::iter_swap(__result, __a);
              }
          }
      }
    else
      {
        if (*__a < *__c)
          {
            std::iter_swap(__result, __a);
          }
        else
          {
            if (*__b < *__c)
              {
                std::iter_swap(__result, __c);
              }
            else
              {
                std::iter_swap(__result, __b);
              }
          }
      }
  }
  template < typename _Iterator, typename _Compare >
  void __move_median_to_first(_Iterator __result, _Iterator __a, _Iterator __b, _Iterator __c, _Compare __comp);
  template < typename _Iterator, typename _Compare >
  void __move_median_to_first(_Iterator __result, _Iterator __a, _Iterator __b, _Iterator __c, _Compare __comp)
  {
    if (__comp(*__a, *__b))
      {
        if (__comp(*__b, *__c))
          {
            std::iter_swap(__result, __b);
          }
        else
          {
            if (__comp(*__a, *__c))
              {
                std::iter_swap(__result, __c);
              }
            else
              {
                std::iter_swap(__result, __a);
              }
          }
      }
    else
      {
        if (__comp(*__a, *__c))
          {
            std::iter_swap(__result, __a);
          }
        else
          {
            if (__comp(*__b, *__c))
              {
                std::iter_swap(__result, __c);
              }
            else
              {
                std::iter_swap(__result, __b);
              }
          }
      }
  }
  template < typename _InputIterator, typename _Tp >
  inline _InputIterator __find(_InputIterator __first, _InputIterator __last, const _Tp &__val, ::std::input_iterator_tag);
  template < typename _InputIterator, typename _Tp >
  inline _InputIterator __find(_InputIterator __first, _InputIterator __last, const _Tp &__val, ::std::input_iterator_tag)
  {
    while (__first != __last && !(*__first == __val))
      {
         ++__first;
      }
    return __first;
  }
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator __find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred, ::std::input_iterator_tag);
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator __find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred, ::std::input_iterator_tag)
  {
    while (__first != __last && !bool(__pred(*__first)))
      {
         ++__first;
      }
    return __first;
  }
  template < typename _RandomAccessIterator, typename _Tp >
  _RandomAccessIterator __find(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__val, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator, typename _Tp >
  _RandomAccessIterator __find(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__val, ::std::random_access_iterator_tag)
  {
    typename ::std::iterator_traits<_RandomAccessIterator>::difference_type __trip_count = (__last - __first) >> 2;
    for (; __trip_count > 0;  --__trip_count)
      {
        if (*__first == __val)
          {
            return __first;
          }
         ++__first;
        if (*__first == __val)
          {
            return __first;
          }
         ++__first;
        if (*__first == __val)
          {
            return __first;
          }
         ++__first;
        if (*__first == __val)
          {
            return __first;
          }
         ++__first;
      }
    switch (__last - __first)
        {
          case 3 :
          if (*__first == __val)
            {
              return __first;
            }
           ++__first;
          case 2 :
          if (*__first == __val)
            {
              return __first;
            }
           ++__first;
          case 1 :
          if (*__first == __val)
            {
              return __first;
            }
           ++__first;
          case 0 :
          default :
          return __last;
        }
  }
  template < typename _RandomAccessIterator, typename _Predicate >
  _RandomAccessIterator __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator, typename _Predicate >
  _RandomAccessIterator __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, ::std::random_access_iterator_tag)
  {
    typename ::std::iterator_traits<_RandomAccessIterator>::difference_type __trip_count = (__last - __first) >> 2;
    for (; __trip_count > 0;  --__trip_count)
      {
        if (__pred(*__first))
          {
            return __first;
          }
         ++__first;
        if (__pred(*__first))
          {
            return __first;
          }
         ++__first;
        if (__pred(*__first))
          {
            return __first;
          }
         ++__first;
        if (__pred(*__first))
          {
            return __first;
          }
         ++__first;
      }
    switch (__last - __first)
        {
          case 3 :
          if (__pred(*__first))
            {
              return __first;
            }
           ++__first;
          case 2 :
          if (__pred(*__first))
            {
              return __first;
            }
           ++__first;
          case 1 :
          if (__pred(*__first))
            {
              return __first;
            }
           ++__first;
          case 0 :
          default :
          return __last;
        }
  }
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator __find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred, ::std::input_iterator_tag);
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator __find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred, ::std::input_iterator_tag)
  {
    while (__first != __last && bool(__pred(*__first)))
      {
         ++__first;
      }
    return __first;
  }
  template < typename _RandomAccessIterator, typename _Predicate >
  _RandomAccessIterator __find_if_not(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator, typename _Predicate >
  _RandomAccessIterator __find_if_not(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, ::std::random_access_iterator_tag)
  {
    typename ::std::iterator_traits<_RandomAccessIterator>::difference_type __trip_count = (__last - __first) >> 2;
    for (; __trip_count > 0;  --__trip_count)
      {
        if (!bool(__pred(*__first)))
          {
            return __first;
          }
         ++__first;
        if (!bool(__pred(*__first)))
          {
            return __first;
          }
         ++__first;
        if (!bool(__pred(*__first)))
          {
            return __first;
          }
         ++__first;
        if (!bool(__pred(*__first)))
          {
            return __first;
          }
         ++__first;
      }
    switch (__last - __first)
        {
          case 3 :
          if (!bool(__pred(*__first)))
            {
              return __first;
            }
           ++__first;
          case 2 :
          if (!bool(__pred(*__first)))
            {
              return __first;
            }
           ++__first;
          case 1 :
          if (!bool(__pred(*__first)))
            {
              return __first;
            }
           ++__first;
          case 0 :
          default :
          return __last;
        }
  }
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator __find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred);
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator __find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)
  {
    return std::__find_if_not(__first, __last, __pred, std::__iterator_category(__first));
  }
  template < typename _InputIterator, typename _Predicate, typename _Distance >
  _InputIterator __find_if_not_n(_InputIterator __first, _Distance &__len, _Predicate __pred);
  template < typename _InputIterator, typename _Predicate, typename _Distance >
  _InputIterator __find_if_not_n(_InputIterator __first, _Distance &__len, _Predicate __pred)
  {
    for (; __len; ( --__len,  ++__first))
      {
        if (!bool(__pred(*__first)))
          {
            break;
          }
      }
    return __first;
  }
  template < typename _ForwardIterator, typename _Integer, typename _Tp >
  _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, ::std::forward_iterator_tag);
  template < typename _ForwardIterator, typename _Integer, typename _Tp >
  _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, ::std::forward_iterator_tag)
  {
    __first = std::find(__first, __last, __val);
    while (__first != __last)
      {
        typename ::std::iterator_traits<_ForwardIterator>::difference_type __n = __count;
        _ForwardIterator __i = __first;
         ++__i;
        while ((__i != __last && __n != 1) && *__i == __val)
          {
             ++__i;
             --__n;
          }
        if (__n == 1)
          {
            return __first;
          }
        if (__i == __last)
          {
            return __last;
          }
        __first = std::find( ++__i, __last, __val);
      }
    return __last;
  }
  template < typename _RandomAccessIter, typename _Integer, typename _Tp >
  _RandomAccessIter __search_n(_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, const _Tp &__val, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIter, typename _Integer, typename _Tp >
  _RandomAccessIter __search_n(_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, const _Tp &__val, ::std::random_access_iterator_tag)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIter>::difference_type _DistanceType;
    _DistanceType __tailSize = __last - __first;
    _DistanceType __remainder = __count;
    while (__remainder <= __tailSize)
      {
        __first += __remainder;
        __tailSize -= __remainder;
        _RandomAccessIter __backTrack = __first;
        while (* --__backTrack == __val)
          {
            if ( --__remainder == 0)
              {
                return __first - __count;
              }
          }
        __remainder = __count + 1 - (__first - __backTrack);
      }
    return __last;
  }
  template < typename _ForwardIterator, typename _Integer, typename _Tp, typename _BinaryPredicate >
  _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred, ::std::forward_iterator_tag);
  template < typename _ForwardIterator, typename _Integer, typename _Tp, typename _BinaryPredicate >
  _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred, ::std::forward_iterator_tag)
  {
    while (__first != __last && !bool(__binary_pred(*__first, __val)))
      {
         ++__first;
      }
    while (__first != __last)
      {
        typename ::std::iterator_traits<_ForwardIterator>::difference_type __n = __count;
        _ForwardIterator __i = __first;
         ++__i;
        while ((__i != __last && __n != 1) && bool(__binary_pred(*__i, __val)))
          {
             ++__i;
             --__n;
          }
        if (__n == 1)
          {
            return __first;
          }
        if (__i == __last)
          {
            return __last;
          }
        __first =  ++__i;
        while (__first != __last && !bool(__binary_pred(*__first, __val)))
          {
             ++__first;
          }
      }
    return __last;
  }
  template < typename _RandomAccessIter, typename _Integer, typename _Tp, typename _BinaryPredicate >
  _RandomAccessIter __search_n(_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIter, typename _Integer, typename _Tp, typename _BinaryPredicate >
  _RandomAccessIter __search_n(_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred, ::std::random_access_iterator_tag)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIter>::difference_type _DistanceType;
    _DistanceType __tailSize = __last - __first;
    _DistanceType __remainder = __count;
    while (__remainder <= __tailSize)
      {
        __first += __remainder;
        __tailSize -= __remainder;
        _RandomAccessIter __backTrack = __first;
        while (__binary_pred(* --__backTrack, __val))
          {
            if ( --__remainder == 0)
              {
                return __first - __count;
              }
          }
        __remainder = __count + 1 - (__first - __backTrack);
      }
    return __last;
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, ::std::forward_iterator_tag, ::std::forward_iterator_tag);
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, ::std::forward_iterator_tag, ::std::forward_iterator_tag)
  {
    if (__first2 == __last2)
      {
        return __last1;
      }
    else
      {
        _ForwardIterator1 __result = __last1;
        while (1)
          {
            _ForwardIterator1 __new_result = std::search(__first1, __last1, __first2, __last2);
            if (__new_result == __last1)
              {
                return __result;
              }
            else
              {
                __result = __new_result;
                __first1 = __new_result;
                 ++__first1;
              }
          }
      }
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate >
  _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, ::std::forward_iterator_tag, ::std::forward_iterator_tag, _BinaryPredicate __comp);
  template < typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate >
  _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, ::std::forward_iterator_tag, ::std::forward_iterator_tag, _BinaryPredicate __comp)
  {
    if (__first2 == __last2)
      {
        return __last1;
      }
    else
      {
        _ForwardIterator1 __result = __last1;
        while (1)
          {
            _ForwardIterator1 __new_result = std::search(__first1, __last1, __first2, __last2, __comp);
            if (__new_result == __last1)
              {
                return __result;
              }
            else
              {
                __result = __new_result;
                __first1 = __new_result;
                 ++__first1;
              }
          }
      }
  }
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2 >
  _BidirectionalIterator1 __find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, ::std::bidirectional_iterator_tag, ::std::bidirectional_iterator_tag);
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2 >
  _BidirectionalIterator1 __find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, ::std::bidirectional_iterator_tag, ::std::bidirectional_iterator_tag)
  {
    typedef ::std::reverse_iterator<_BidirectionalIterator1> _RevIterator1;
    typedef ::std::reverse_iterator<_BidirectionalIterator2> _RevIterator2;
    _RevIterator1 __rlast1(__first1);
    _RevIterator2 __rlast2(__first2);
    _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1, _RevIterator2(__last2), __rlast2);
    if (__rresult == __rlast1)
      {
        return __last1;
      }
    else
      {
        _BidirectionalIterator1 __result = __rresult.base();
        std::advance(__result,  -std::distance(__first2, __last2));
        return __result;
      }
  }
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BinaryPredicate >
  _BidirectionalIterator1 __find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, ::std::bidirectional_iterator_tag, ::std::bidirectional_iterator_tag, _BinaryPredicate __comp);
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BinaryPredicate >
  _BidirectionalIterator1 __find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, ::std::bidirectional_iterator_tag, ::std::bidirectional_iterator_tag, _BinaryPredicate __comp)
  {
    typedef ::std::reverse_iterator<_BidirectionalIterator1> _RevIterator1;
    typedef ::std::reverse_iterator<_BidirectionalIterator2> _RevIterator2;
    _RevIterator1 __rlast1(__first1);
    _RevIterator2 __rlast2(__first2);
    _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1, _RevIterator2(__last2), __rlast2, __comp);
    if (__rresult == __rlast1)
      {
        return __last1;
      }
    else
      {
        _BidirectionalIterator1 __result = __rresult.base();
        std::advance(__result,  -std::distance(__first2, __last2));
        return __result;
      }
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  inline _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)
  {
    ;
    ;
    return std::__find_end(__first1, __last1, __first2, __last2, std::__iterator_category(__first1), std::__iterator_category(__first2));
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate >
  inline _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __comp)
  {
    ;
    ;
    return std::__find_end(__first1, __last1, __first2, __last2, std::__iterator_category(__first1), std::__iterator_category(__first2), __comp);
  }
  template < typename _InputIterator, typename _Predicate >
  inline bool all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
  {
    return __last == std::find_if_not(__first, __last, __pred);
  }
  template < typename _InputIterator, typename _Predicate >
  inline bool none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
  {
    return __last == std::find_if(__first, __last, __pred);
  }
  template < typename _InputIterator, typename _Predicate >
  inline bool any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
  {
    return !std::none_of(__first, __last, __pred);
  }
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)
  {
    ;
    return std::__find_if_not(__first, __last, __pred);
  }
  template < typename _InputIterator, typename _Predicate >
  inline bool is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
  {
    __first = std::find_if_not(__first, __last, __pred);
    return std::none_of(__first, __last, __pred);
  }
  template < typename _ForwardIterator, typename _Predicate >
  _ForwardIterator partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
  {
    ;
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    _DistanceType __len = std::distance(__first, __last);
    _DistanceType __half;
    _ForwardIterator __middle;
    while (__len > 0)
      {
        __half = __len >> 1;
        __middle = __first;
        std::advance(__middle, __half);
        if (__pred(*__middle))
          {
            __first = __middle;
             ++__first;
            __len = __len - __half - 1;
          }
        else
          {
            __len = __half;
          }
      }
    return __first;
  }
  template < typename _InputIterator, typename _OutputIterator, typename _Tp >
  _OutputIterator remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__value)
  {
    ;
    for (; __first != __last;  ++__first)
      {
        if (!(*__first == __value))
          {
            *__result = *__first;
             ++__result;
          }
      }
    return __result;
  }
  template < typename _InputIterator, typename _OutputIterator, typename _Predicate >
  _OutputIterator remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
  {
    ;
    for (; __first != __last;  ++__first)
      {
        if (!bool(__pred(*__first)))
          {
            *__result = *__first;
             ++__result;
          }
      }
    return __result;
  }
  template < typename _InputIterator, typename _OutputIterator, typename _Predicate >
  _OutputIterator copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
  {
    ;
    for (; __first != __last;  ++__first)
      {
        if (__pred(*__first))
          {
            *__result = *__first;
             ++__result;
          }
      }
    return __result;
  }
  template < typename _InputIterator, typename _Size, typename _OutputIterator >
  _OutputIterator __copy_n(_InputIterator __first, _Size __n, _OutputIterator __result, ::std::input_iterator_tag);
  template < typename _InputIterator, typename _Size, typename _OutputIterator >
  _OutputIterator __copy_n(_InputIterator __first, _Size __n, _OutputIterator __result, ::std::input_iterator_tag)
  {
    if (__n > 0)
      {
        while (true)
          {
            *__result = *__first;
             ++__result;
            if ( --__n > 0)
              {
                 ++__first;
              }
            else
              {
                break;
              }
          }
      }
    return __result;
  }
  template < typename _RandomAccessIterator, typename _Size, typename _OutputIterator >
  inline _OutputIterator __copy_n(_RandomAccessIterator __first, _Size __n, _OutputIterator __result, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator, typename _Size, typename _OutputIterator >
  inline _OutputIterator __copy_n(_RandomAccessIterator __first, _Size __n, _OutputIterator __result, ::std::random_access_iterator_tag)
  {
    return std::copy(__first, __first + __n, __result);
  }
  template < typename _InputIterator, typename _Size, typename _OutputIterator >
  inline _OutputIterator copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
  {
    return std::__copy_n(__first, __n, __result, std::__iterator_category(__first));
  }
  template < typename _InputIterator, typename _OutputIterator1, typename _OutputIterator2, typename _Predicate >
  ::std::pair<_OutputIterator1, _OutputIterator2> partition_copy(_InputIterator __first, _InputIterator __last, _OutputIterator1 __out_true, _OutputIterator2 __out_false, _Predicate __pred)
  {
    ;
    for (; __first != __last;  ++__first)
      {
        if (__pred(*__first))
          {
            *__out_true = *__first;
             ++__out_true;
          }
        else
          {
            *__out_false = *__first;
             ++__out_false;
          }
      }
    return ::std::pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
  }
  template < typename _ForwardIterator, typename _Tp >
  _ForwardIterator remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
  {
    ;
    __first = std::find(__first, __last, __value);
    if (__first == __last)
      {
        return __first;
      }
    _ForwardIterator __result = __first;
     ++__first;
    for (; __first != __last;  ++__first)
      {
        if (!(*__first == __value))
          {
            *__result = std::move(*__first);
             ++__result;
          }
      }
    return __result;
  }
  template < typename _ForwardIterator, typename _Predicate >
  _ForwardIterator remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
  {
    ;
    __first = std::find_if(__first, __last, __pred);
    if (__first == __last)
      {
        return __first;
      }
    _ForwardIterator __result = __first;
     ++__first;
    for (; __first != __last;  ++__first)
      {
        if (!bool(__pred(*__first)))
          {
            *__result = std::move(*__first);
             ++__result;
          }
      }
    return __result;
  }
  template < typename _ForwardIterator >
  _ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last)
  {
    ;
    __first = std::adjacent_find(__first, __last);
    if (__first == __last)
      {
        return __last;
      }
    _ForwardIterator __dest = __first;
     ++__first;
    while ( ++__first != __last)
      {
        if (!(*__dest == *__first))
          {
            * ++__dest = std::move(*__first);
          }
      }
    return  ++__dest;
  }
  template < typename _ForwardIterator, typename _BinaryPredicate >
  _ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)
  {
    ;
    __first = std::adjacent_find(__first, __last, __binary_pred);
    if (__first == __last)
      {
        return __last;
      }
    _ForwardIterator __dest = __first;
     ++__first;
    while ( ++__first != __last)
      {
        if (!bool(__binary_pred(*__dest, *__first)))
          {
            * ++__dest = std::move(*__first);
          }
      }
    return  ++__dest;
  }
  template < typename _ForwardIterator, typename _OutputIterator >
  _OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, ::std::forward_iterator_tag, ::std::output_iterator_tag);
  template < typename _ForwardIterator, typename _OutputIterator >
  _OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, ::std::forward_iterator_tag, ::std::output_iterator_tag)
  {
    _ForwardIterator __next = __first;
    *__result = *__first;
    while ( ++__next != __last)
      {
        if (!(*__first == *__next))
          {
            __first = __next;
            * ++__result = *__first;
          }
      }
    return  ++__result;
  }
  template < typename _InputIterator, typename _OutputIterator >
  _OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, ::std::input_iterator_tag, ::std::output_iterator_tag);
  template < typename _InputIterator, typename _OutputIterator >
  _OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, ::std::input_iterator_tag, ::std::output_iterator_tag)
  {
    typename ::std::iterator_traits<_InputIterator>::value_type __value = *__first;
    *__result = __value;
    while ( ++__first != __last)
      {
        if (!(__value == *__first))
          {
            __value = *__first;
            * ++__result = __value;
          }
      }
    return  ++__result;
  }
  template < typename _InputIterator, typename _ForwardIterator >
  _ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, ::std::input_iterator_tag, ::std::forward_iterator_tag);
  template < typename _InputIterator, typename _ForwardIterator >
  _ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, ::std::input_iterator_tag, ::std::forward_iterator_tag)
  {
    *__result = *__first;
    while ( ++__first != __last)
      {
        if (!(*__result == *__first))
          {
            * ++__result = *__first;
          }
      }
    return  ++__result;
  }
  template < typename _ForwardIterator, typename _OutputIterator, typename _BinaryPredicate >
  _OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, ::std::forward_iterator_tag, ::std::output_iterator_tag);
  template < typename _ForwardIterator, typename _OutputIterator, typename _BinaryPredicate >
  _OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, ::std::forward_iterator_tag, ::std::output_iterator_tag)
  {
    _ForwardIterator __next = __first;
    *__result = *__first;
    while ( ++__next != __last)
      {
        if (!bool(__binary_pred(*__first, *__next)))
          {
            __first = __next;
            * ++__result = *__first;
          }
      }
    return  ++__result;
  }
  template < typename _InputIterator, typename _OutputIterator, typename _BinaryPredicate >
  _OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, ::std::input_iterator_tag, ::std::output_iterator_tag);
  template < typename _InputIterator, typename _OutputIterator, typename _BinaryPredicate >
  _OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, ::std::input_iterator_tag, ::std::output_iterator_tag)
  {
    typename ::std::iterator_traits<_InputIterator>::value_type __value = *__first;
    *__result = __value;
    while ( ++__first != __last)
      {
        if (!bool(__binary_pred(__value, *__first)))
          {
            __value = *__first;
            * ++__result = __value;
          }
      }
    return  ++__result;
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _BinaryPredicate >
  _ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __binary_pred, ::std::input_iterator_tag, ::std::forward_iterator_tag);
  template < typename _InputIterator, typename _ForwardIterator, typename _BinaryPredicate >
  _ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __binary_pred, ::std::input_iterator_tag, ::std::forward_iterator_tag)
  {
    *__result = *__first;
    while ( ++__first != __last)
      {
        if (!bool(__binary_pred(*__result, *__first)))
          {
            * ++__result = *__first;
          }
      }
    return  ++__result;
  }
  template < typename _BidirectionalIterator >
  void __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, ::std::bidirectional_iterator_tag);
  template < typename _BidirectionalIterator >
  void __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, ::std::bidirectional_iterator_tag)
  {
    while (true)
      {
        if (__first == __last || __first ==  --__last)
          {
            return ;
          }
        else
          {
            std::iter_swap(__first, __last);
             ++__first;
          }
      }
  }
  template < typename _RandomAccessIterator >
  void __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator >
  void __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, ::std::random_access_iterator_tag)
  {
    if (__first == __last)
      {
        return ;
      }
     --__last;
    while (__first < __last)
      {
        std::iter_swap(__first, __last);
         ++__first;
         --__last;
      }
  }
  template < typename _BidirectionalIterator >
  inline void reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
  {
    ;
    std::__reverse(__first, __last, std::__iterator_category(__first));
  }
  template < typename _BidirectionalIterator, typename _OutputIterator >
  _OutputIterator reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
  {
    ;
    while (__first != __last)
      {
         --__last;
        *__result = *__last;
         ++__result;
      }
    return __result;
  }
  template < typename _EuclideanRingElement >
  _EuclideanRingElement __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n);
  template < typename _EuclideanRingElement >
  _EuclideanRingElement __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
  {
    while (__n != 0)
      {
        _EuclideanRingElement __t = __m % __n;
        __m = __n;
        __n = __t;
      }
    return __m;
  }
  template < typename _ForwardIterator >
  void __rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, ::std::forward_iterator_tag);
  template < typename _ForwardIterator >
  void __rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, ::std::forward_iterator_tag)
  {
    if (__first == __middle || __last == __middle)
      {
        return ;
      }
    _ForwardIterator __first2 = __middle;
    do
      {
        std::iter_swap(__first, __first2);
         ++__first;
         ++__first2;
        if (__first == __middle)
          {
            __middle = __first2;
          }
      }
    while (__first2 != __last);
    __first2 = __middle;
    while (__first2 != __last)
      {
        std::iter_swap(__first, __first2);
         ++__first;
         ++__first2;
        if (__first == __middle)
          {
            __middle = __first2;
          }
        else
          {
            if (__first2 == __last)
              {
                __first2 = __middle;
              }
          }
      }
  }
  template < typename _BidirectionalIterator >
  void __rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, ::std::bidirectional_iterator_tag);
  template < typename _BidirectionalIterator >
  void __rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, ::std::bidirectional_iterator_tag)
  {
    if (__first == __middle || __last == __middle)
      {
        return ;
      }
    std::__reverse(__first, __middle, ::std::bidirectional_iterator_tag());
    std::__reverse(__middle, __last, ::std::bidirectional_iterator_tag());
    while (__first != __middle && __middle != __last)
      {
        std::iter_swap(__first,  --__last);
         ++__first;
      }
    if (__first == __middle)
      {
        std::__reverse(__middle, __last, ::std::bidirectional_iterator_tag());
      }
    else
      {
        std::__reverse(__first, __middle, ::std::bidirectional_iterator_tag());
      }
  }
  template < typename _RandomAccessIterator >
  void __rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator >
  void __rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, ::std::random_access_iterator_tag)
  {
    if (__first == __middle || __last == __middle)
      {
        return ;
      }
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _Distance;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    _Distance __n = __last - __first;
    _Distance __k = __middle - __first;
    if (__k == __n - __k)
      {
        std::swap_ranges(__first, __middle, __middle);
        return ;
      }
    _RandomAccessIterator __p = __first;
    for (; ; )
      {
        if (__k < __n - __k)
          {
            if ((__is_pod(_ValueType)) && __k == 1)
              {
                _ValueType __t = std::move(*__p);
                std::move(__p + 1, __p + __n, __p);
                *(__p + __n - 1) = std::move(__t);
                return ;
              }
            _RandomAccessIterator __q = __p + __k;
            for (_Distance __i = 0; __i < __n - __k;  ++__i)
              {
                std::iter_swap(__p, __q);
                 ++__p;
                 ++__q;
              }
            __n %= __k;
            if (__n == 0)
              {
                return ;
              }
            std::swap(__n, __k);
            __k = __n - __k;
          }
        else
          {
            __k = __n - __k;
            if ((__is_pod(_ValueType)) && __k == 1)
              {
                _ValueType __t = std::move(*(__p + __n - 1));
                std::move_backward(__p, __p + __n - 1, __p + __n);
                *__p = std::move(__t);
                return ;
              }
            _RandomAccessIterator __q = __p + __n;
            __p = __q - __k;
            for (_Distance __i = 0; __i < __n - __k;  ++__i)
              {
                 --__p;
                 --__q;
                std::iter_swap(__p, __q);
              }
            __n %= __k;
            if (__n == 0)
              {
                return ;
              }
            std::swap(__n, __k);
          }
      }
  }
  template < typename _ForwardIterator >
  inline void rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
  {
    ;
    ;
    typedef typename ::std::iterator_traits<_ForwardIterator>::iterator_category _IterType;
    std::__rotate(__first, __middle, __last, _IterType());
  }
  template < typename _ForwardIterator, typename _OutputIterator >
  _OutputIterator rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
  {
    ;
    ;
    return std::copy(__first, __middle, std::copy(__middle, __last, __result));
  }
  template < typename _ForwardIterator, typename _Predicate >
  _ForwardIterator __partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, ::std::forward_iterator_tag);
  template < typename _ForwardIterator, typename _Predicate >
  _ForwardIterator __partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, ::std::forward_iterator_tag)
  {
    if (__first == __last)
      {
        return __first;
      }
    while (__pred(*__first))
      {
        if ( ++__first == __last)
          {
            return __first;
          }
      }
    _ForwardIterator __next = __first;
    while ( ++__next != __last)
      {
        if (__pred(*__next))
          {
            std::iter_swap(__first, __next);
             ++__first;
          }
      }
    return __first;
  }
  template < typename _BidirectionalIterator, typename _Predicate >
  _BidirectionalIterator __partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, ::std::bidirectional_iterator_tag);
  template < typename _BidirectionalIterator, typename _Predicate >
  _BidirectionalIterator __partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, ::std::bidirectional_iterator_tag)
  {
    while (true)
      {
        while (true)
          {
            if (__first == __last)
              {
                return __first;
              }
            else
              {
                if (__pred(*__first))
                  {
                     ++__first;
                  }
                else
                  {
                    break;
                  }
              }
          }
         --__last;
        while (true)
          {
            if (__first == __last)
              {
                return __first;
              }
            else
              {
                if (!bool(__pred(*__last)))
                  {
                     --__last;
                  }
                else
                  {
                    break;
                  }
              }
          }
        std::iter_swap(__first, __last);
         ++__first;
      }
  }
  template < typename _ForwardIterator, typename _Predicate, typename _Distance >
  _ForwardIterator __inplace_stable_partition(_ForwardIterator __first, _Predicate __pred, _Distance __len);
  template < typename _ForwardIterator, typename _Predicate, typename _Distance >
  _ForwardIterator __inplace_stable_partition(_ForwardIterator __first, _Predicate __pred, _Distance __len)
  {
    if (__len == 1)
      {
        return __first;
      }
    _ForwardIterator __middle = __first;
    std::advance(__middle, __len / 2);
    _ForwardIterator __left_split = std::__inplace_stable_partition(__first, __pred, __len / 2);
    _Distance __right_len = __len - __len / 2;
    _ForwardIterator __right_split = std::__find_if_not_n(__middle, __right_len, __pred);
    if (__right_len)
      {
        __right_split = std::__inplace_stable_partition(__middle, __pred, __right_len);
      }
    std::rotate(__left_split, __middle, __right_split);
    std::advance(__left_split, std::distance(__middle, __right_split));
    return __left_split;
  }
  template < typename _ForwardIterator, typename _Pointer, typename _Predicate, typename _Distance >
  _ForwardIterator __stable_partition_adaptive(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, _Distance __len, _Pointer __buffer, _Distance __buffer_size);
  template < typename _ForwardIterator, typename _Pointer, typename _Predicate, typename _Distance >
  _ForwardIterator __stable_partition_adaptive(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, _Distance __len, _Pointer __buffer, _Distance __buffer_size)
  {
    if (__len <= __buffer_size)
      {
        _ForwardIterator __result1 = __first;
        _Pointer __result2 = __buffer;
        *__result2 = std::move(*__first);
         ++__result2;
         ++__first;
        for (; __first != __last;  ++__first)
          {
            if (__pred(*__first))
              {
                *__result1 = std::move(*__first);
                 ++__result1;
              }
            else
              {
                *__result2 = std::move(*__first);
                 ++__result2;
              }
          }
        std::move(__buffer, __result2, __result1);
        return __result1;
      }
    else
      {
        _ForwardIterator __middle = __first;
        std::advance(__middle, __len / 2);
        _ForwardIterator __left_split = std::__stable_partition_adaptive(__first, __middle, __pred, __len / 2, __buffer, __buffer_size);
        _Distance __right_len = __len - __len / 2;
        _ForwardIterator __right_split = std::__find_if_not_n(__middle, __right_len, __pred);
        if (__right_len)
          {
            __right_split = std::__stable_partition_adaptive(__right_split, __last, __pred, __right_len, __buffer, __buffer_size);
          }
        std::rotate(__left_split, __middle, __right_split);
        std::advance(__left_split, std::distance(__middle, __right_split));
        return __left_split;
      }
  }
  template < typename _ForwardIterator, typename _Predicate >
  _ForwardIterator stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
  {
    ;
    __first = std::__find_if_not(__first, __last, __pred);
    if (__first == __last)
      {
        return __first;
      }
    else
      {
        typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
        typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
        ::std::_Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
        if (__buf.size() > 0)
          {
            return std::__stable_partition_adaptive(__first, __last, __pred, _DistanceType(__buf.requested_size()), __buf.begin(), _DistanceType(__buf.size()));
          }
        else
          {
            return std::__inplace_stable_partition(__first, __pred, _DistanceType(__buf.requested_size()));
          }
      }
  }
  template < typename _RandomAccessIterator >
  void __heap_select(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  void __heap_select(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
  {
    std::make_heap(__first, __middle);
    for (_RandomAccessIterator __i = __middle; __i < __last;  ++__i)
      {
        if (*__i < *__first)
          {
            std::__pop_heap(__first, __middle, __i);
          }
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void __heap_select(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  void __heap_select(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)
  {
    std::make_heap(__first, __middle, __comp);
    for (_RandomAccessIterator __i = __middle; __i < __last;  ++__i)
      {
        if (__comp(*__i, *__first))
          {
            std::__pop_heap(__first, __middle, __i, __comp);
          }
      }
  }
  template < typename _InputIterator, typename _RandomAccessIterator >
  _RandomAccessIterator partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
  {
    typedef typename ::std::iterator_traits<_InputIterator>::value_type _InputValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _OutputValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    ;
    if (__result_first == __result_last)
      {
        return __result_last;
      }
    _RandomAccessIterator __result_real_last = __result_first;
    while (__first != __last && __result_real_last != __result_last)
      {
        *__result_real_last = *__first;
         ++__result_real_last;
         ++__first;
      }
    std::make_heap(__result_first, __result_real_last);
    while (__first != __last)
      {
        if (*__first < *__result_first)
          {
            std::__adjust_heap(__result_first, _DistanceType(0), _DistanceType(__result_real_last - __result_first), _InputValueType(*__first));
          }
         ++__first;
      }
    std::sort_heap(__result_first, __result_real_last);
    return __result_real_last;
  }
  template < typename _InputIterator, typename _RandomAccessIterator, typename _Compare >
  _RandomAccessIterator partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_InputIterator>::value_type _InputValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _OutputValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    ;
    if (__result_first == __result_last)
      {
        return __result_last;
      }
    _RandomAccessIterator __result_real_last = __result_first;
    while (__first != __last && __result_real_last != __result_last)
      {
        *__result_real_last = *__first;
         ++__result_real_last;
         ++__first;
      }
    std::make_heap(__result_first, __result_real_last, __comp);
    while (__first != __last)
      {
        if (__comp(*__first, *__result_first))
          {
            std::__adjust_heap(__result_first, _DistanceType(0), _DistanceType(__result_real_last - __result_first), _InputValueType(*__first), __comp);
          }
         ++__first;
      }
    std::sort_heap(__result_first, __result_real_last, __comp);
    return __result_real_last;
  }
  template < typename _RandomAccessIterator >
  void __unguarded_linear_insert(_RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  void __unguarded_linear_insert(_RandomAccessIterator __last)
  {
    typename ::std::iterator_traits<_RandomAccessIterator>::value_type __val = std::move(*__last);
    _RandomAccessIterator __next = __last;
     --__next;
    while (__val < *__next)
      {
        *__last = std::move(*__next);
        __last = __next;
         --__next;
      }
    *__last = std::move(__val);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void __unguarded_linear_insert(_RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  void __unguarded_linear_insert(_RandomAccessIterator __last, _Compare __comp)
  {
    typename ::std::iterator_traits<_RandomAccessIterator>::value_type __val = std::move(*__last);
    _RandomAccessIterator __next = __last;
     --__next;
    while (__comp(__val, *__next))
      {
        *__last = std::move(*__next);
        __last = __next;
         --__next;
      }
    *__last = std::move(__val);
  }
  template < typename _RandomAccessIterator >
  void __insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  void __insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    if (__first == __last)
      {
        return ;
      }
    for (_RandomAccessIterator __i = __first + 1; __i != __last;  ++__i)
      {
        if (*__i < *__first)
          {
            typename ::std::iterator_traits<_RandomAccessIterator>::value_type __val = std::move(*__i);
            std::move_backward(__first, __i, __i + 1);
            *__first = std::move(__val);
          }
        else
          {
            std::__unguarded_linear_insert(__i);
          }
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void __insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  void __insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    if (__first == __last)
      {
        return ;
      }
    for (_RandomAccessIterator __i = __first + 1; __i != __last;  ++__i)
      {
        if (__comp(*__i, *__first))
          {
            typename ::std::iterator_traits<_RandomAccessIterator>::value_type __val = std::move(*__i);
            std::move_backward(__first, __i, __i + 1);
            *__first = std::move(__val);
          }
        else
          {
            std::__unguarded_linear_insert(__i, __comp);
          }
      }
  }
  template < typename _RandomAccessIterator >
  inline void __unguarded_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  inline void __unguarded_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    for (_RandomAccessIterator __i = __first; __i != __last;  ++__i)
      {
        std::__unguarded_linear_insert(__i);
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void __unguarded_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  inline void __unguarded_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    for (_RandomAccessIterator __i = __first; __i != __last;  ++__i)
      {
        std::__unguarded_linear_insert(__i, __comp);
      }
  }
  enum mcc_enum_anon_80
  {
    _S_threshold = 16
  };
  template < typename _RandomAccessIterator >
  void __final_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  void __final_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    if (__last - __first > (int)::std::_S_threshold)
      {
        std::__insertion_sort(__first, __first + (int)::std::_S_threshold);
        std::__unguarded_insertion_sort(__first + (int)::std::_S_threshold, __last);
      }
    else
      {
        std::__insertion_sort(__first, __last);
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void __final_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  void __final_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    if (__last - __first > (int)::std::_S_threshold)
      {
        std::__insertion_sort(__first, __first + (int)::std::_S_threshold, __comp);
        std::__unguarded_insertion_sort(__first + (int)::std::_S_threshold, __last, __comp);
      }
    else
      {
        std::__insertion_sort(__first, __last, __comp);
      }
  }
  template < typename _RandomAccessIterator, typename _Tp >
  _RandomAccessIterator __unguarded_partition(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__pivot);
  template < typename _RandomAccessIterator, typename _Tp >
  _RandomAccessIterator __unguarded_partition(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__pivot)
  {
    while (true)
      {
        while (*__first < __pivot)
          {
             ++__first;
          }
         --__last;
        while (__pivot < *__last)
          {
             --__last;
          }
        if (!(__first < __last))
          {
            return __first;
          }
        std::iter_swap(__first, __last);
         ++__first;
      }
  }
  template < typename _RandomAccessIterator, typename _Tp, typename _Compare >
  _RandomAccessIterator __unguarded_partition(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__pivot, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Tp, typename _Compare >
  _RandomAccessIterator __unguarded_partition(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__pivot, _Compare __comp)
  {
    while (true)
      {
        while (__comp(*__first, __pivot))
          {
             ++__first;
          }
         --__last;
        while (__comp(__pivot, *__last))
          {
             --__last;
          }
        if (!(__first < __last))
          {
            return __first;
          }
        std::iter_swap(__first, __last);
         ++__first;
      }
  }
  template < typename _RandomAccessIterator >
  inline _RandomAccessIterator __unguarded_partition_pivot(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  inline _RandomAccessIterator __unguarded_partition_pivot(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    _RandomAccessIterator __mid = __first + (__last - __first) / 2;
    std::__move_median_to_first(__first, __first + 1, __mid, __last - 1);
    return std::__unguarded_partition(__first + 1, __last, *__first);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline _RandomAccessIterator __unguarded_partition_pivot(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  inline _RandomAccessIterator __unguarded_partition_pivot(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    _RandomAccessIterator __mid = __first + (__last - __first) / 2;
    std::__move_median_to_first(__first, __first + 1, __mid, __last - 1, __comp);
    return std::__unguarded_partition(__first + 1, __last, *__first, __comp);
  }
  template < typename _RandomAccessIterator, typename _Size >
  void __introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit);
  template < typename _RandomAccessIterator, typename _Size >
  void __introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit)
  {
    while (__last - __first > (int)::std::_S_threshold)
      {
        if (__depth_limit == 0)
          {
            std::partial_sort(__first, __last, __last);
            return ;
          }
         --__depth_limit;
        _RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last);
        std::__introsort_loop(__cut, __last, __depth_limit);
        __last = __cut;
      }
  }
  template < typename _RandomAccessIterator, typename _Size, typename _Compare >
  void __introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Size, typename _Compare >
  void __introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp)
  {
    while (__last - __first > (int)::std::_S_threshold)
      {
        if (__depth_limit == 0)
          {
            std::partial_sort(__first, __last, __last, __comp);
            return ;
          }
         --__depth_limit;
        _RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last, __comp);
        std::__introsort_loop(__cut, __last, __depth_limit, __comp);
        __last = __cut;
      }
  }
  template < typename _RandomAccessIterator, typename _Size >
  void __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Size __depth_limit);
  template < typename _RandomAccessIterator, typename _Size >
  void __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Size __depth_limit)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    while (__last - __first > 3)
      {
        if (__depth_limit == 0)
          {
            std::__heap_select(__first, __nth + 1, __last);
            std::iter_swap(__first, __nth);
            return ;
          }
         --__depth_limit;
        _RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last);
        if (__cut <= __nth)
          {
            __first = __cut;
          }
        else
          {
            __last = __cut;
          }
      }
    std::__insertion_sort(__first, __last);
  }
  template < typename _RandomAccessIterator, typename _Size, typename _Compare >
  void __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Size, typename _Compare >
  void __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    while (__last - __first > 3)
      {
        if (__depth_limit == 0)
          {
            std::__heap_select(__first, __nth + 1, __last, __comp);
            std::iter_swap(__first, __nth);
            return ;
          }
         --__depth_limit;
        _RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last, __comp);
        if (__cut <= __nth)
          {
            __first = __cut;
          }
        else
          {
            __last = __cut;
          }
      }
    std::__insertion_sort(__first, __last, __comp);
  }
  template < typename _ForwardIterator, typename _Tp, typename _Compare >
  _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    ;
    _DistanceType __len = std::distance(__first, __last);
    while (__len > 0)
      {
        _DistanceType __half = __len >> 1;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __half);
        if (__comp(*__middle, __val))
          {
            __first = __middle;
             ++__first;
            __len = __len - __half - 1;
          }
        else
          {
            __len = __half;
          }
      }
    return __first;
  }
  template < typename _ForwardIterator, typename _Tp >
  _ForwardIterator upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    ;
    _DistanceType __len = std::distance(__first, __last);
    while (__len > 0)
      {
        _DistanceType __half = __len >> 1;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __half);
        if (__val < *__middle)
          {
            __len = __half;
          }
        else
          {
            __first = __middle;
             ++__first;
            __len = __len - __half - 1;
          }
      }
    return __first;
  }
  template < typename _ForwardIterator, typename _Tp, typename _Compare >
  _ForwardIterator upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    ;
    _DistanceType __len = std::distance(__first, __last);
    while (__len > 0)
      {
        _DistanceType __half = __len >> 1;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __half);
        if (__comp(__val, *__middle))
          {
            __len = __half;
          }
        else
          {
            __first = __middle;
             ++__first;
            __len = __len - __half - 1;
          }
      }
    return __first;
  }
  template < typename _ForwardIterator, typename _Tp >
  ::std::pair<_ForwardIterator, _ForwardIterator> equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    ;
    ;
    _DistanceType __len = std::distance(__first, __last);
    while (__len > 0)
      {
        _DistanceType __half = __len >> 1;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __half);
        if (*__middle < __val)
          {
            __first = __middle;
             ++__first;
            __len = __len - __half - 1;
          }
        else
          {
            if (__val < *__middle)
              {
                __len = __half;
              }
            else
              {
                _ForwardIterator __left = std::lower_bound(__first, __middle, __val);
                std::advance(__first, __len);
                _ForwardIterator __right = std::upper_bound( ++__middle, __first, __val);
                return ::std::pair<_ForwardIterator, _ForwardIterator>(__left, __right);
              }
          }
      }
    return ::std::pair<_ForwardIterator, _ForwardIterator>(__first, __first);
  }
  template < typename _ForwardIterator, typename _Tp, typename _Compare >
  ::std::pair<_ForwardIterator, _ForwardIterator> equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    ;
    ;
    _DistanceType __len = std::distance(__first, __last);
    while (__len > 0)
      {
        _DistanceType __half = __len >> 1;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __half);
        if (__comp(*__middle, __val))
          {
            __first = __middle;
             ++__first;
            __len = __len - __half - 1;
          }
        else
          {
            if (__comp(__val, *__middle))
              {
                __len = __half;
              }
            else
              {
                _ForwardIterator __left = std::lower_bound(__first, __middle, __val, __comp);
                std::advance(__first, __len);
                _ForwardIterator __right = std::upper_bound( ++__middle, __first, __val, __comp);
                return ::std::pair<_ForwardIterator, _ForwardIterator>(__left, __right);
              }
          }
      }
    return ::std::pair<_ForwardIterator, _ForwardIterator>(__first, __first);
  }
  template < typename _ForwardIterator, typename _Tp >
  bool binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    ;
    ;
    _ForwardIterator __i = std::lower_bound(__first, __last, __val);
    return __i != __last && !(__val < *__i);
  }
  template < typename _ForwardIterator, typename _Tp, typename _Compare >
  bool binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::value_type _ValueType;
    ;
    ;
    _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
    return __i != __last && !bool(__comp(__val, *__i));
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  void __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result);
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  void __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
  {
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first2 < *__first1)
          {
            *__result = std::move(*__first2);
             ++__first2;
          }
        else
          {
            *__result = std::move(*__first1);
             ++__first1;
          }
         ++__result;
      }
    if (__first1 != __last1)
      {
        std::move(__first1, __last1, __result);
      }
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  void __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp);
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  void __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
  {
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first2, *__first1))
          {
            *__result = std::move(*__first2);
             ++__first2;
          }
        else
          {
            *__result = std::move(*__first1);
             ++__first1;
          }
         ++__result;
      }
    if (__first1 != __last1)
      {
        std::move(__first1, __last1, __result);
      }
  }
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BidirectionalIterator3 >
  void __move_merge_adaptive_backward(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result);
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BidirectionalIterator3 >
  void __move_merge_adaptive_backward(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result)
  {
    if (__first1 == __last1)
      {
        std::move_backward(__first2, __last2, __result);
        return ;
      }
    else
      {
        if (__first2 == __last2)
          {
            return ;
          }
      }
     --__last1;
     --__last2;
    while (true)
      {
        if (*__last2 < *__last1)
          {
            * --__result = std::move(*__last1);
            if (__first1 == __last1)
              {
                std::move_backward(__first2,  ++__last2, __result);
                return ;
              }
             --__last1;
          }
        else
          {
            * --__result = std::move(*__last2);
            if (__first2 == __last2)
              {
                return ;
              }
             --__last2;
          }
      }
  }
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BidirectionalIterator3, typename _Compare >
  void __move_merge_adaptive_backward(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result, _Compare __comp);
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BidirectionalIterator3, typename _Compare >
  void __move_merge_adaptive_backward(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result, _Compare __comp)
  {
    if (__first1 == __last1)
      {
        std::move_backward(__first2, __last2, __result);
        return ;
      }
    else
      {
        if (__first2 == __last2)
          {
            return ;
          }
      }
     --__last1;
     --__last2;
    while (true)
      {
        if (__comp(*__last2, *__last1))
          {
            * --__result = std::move(*__last1);
            if (__first1 == __last1)
              {
                std::move_backward(__first2,  ++__last2, __result);
                return ;
              }
             --__last1;
          }
        else
          {
            * --__result = std::move(*__last2);
            if (__first2 == __last2)
              {
                return ;
              }
             --__last2;
          }
      }
  }
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _Distance >
  _BidirectionalIterator1 __rotate_adaptive(_BidirectionalIterator1 __first, _BidirectionalIterator1 __middle, _BidirectionalIterator1 __last, _Distance __len1, _Distance __len2, _BidirectionalIterator2 __buffer, _Distance __buffer_size);
  template < typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _Distance >
  _BidirectionalIterator1 __rotate_adaptive(_BidirectionalIterator1 __first, _BidirectionalIterator1 __middle, _BidirectionalIterator1 __last, _Distance __len1, _Distance __len2, _BidirectionalIterator2 __buffer, _Distance __buffer_size)
  {
    _BidirectionalIterator2 __buffer_end;
    if (__len1 > __len2 && __len2 <= __buffer_size)
      {
        if (__len2)
          {
            __buffer_end = std::move(__middle, __last, __buffer);
            std::move_backward(__first, __middle, __last);
            return std::move(__buffer, __buffer_end, __first);
          }
        else
          {
            return __first;
          }
      }
    else
      {
        if (__len1 <= __buffer_size)
          {
            if (__len1)
              {
                __buffer_end = std::move(__first, __middle, __buffer);
                std::move(__middle, __last, __first);
                return std::move_backward(__buffer, __buffer_end, __last);
              }
            else
              {
                return __last;
              }
          }
        else
          {
            std::rotate(__first, __middle, __last);
            std::advance(__first, std::distance(__middle, __last));
            return __first;
          }
      }
  }
  template < typename _BidirectionalIterator, typename _Distance, typename _Pointer >
  void __merge_adaptive(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size);
  template < typename _BidirectionalIterator, typename _Distance, typename _Pointer >
  void __merge_adaptive(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size)
  {
    if (__len1 <= __len2 && __len1 <= __buffer_size)
      {
        _Pointer __buffer_end = std::move(__first, __middle, __buffer);
        std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last, __first);
      }
    else
      {
        if (__len2 <= __buffer_size)
          {
            _Pointer __buffer_end = std::move(__middle, __last, __buffer);
            std::__move_merge_adaptive_backward(__first, __middle, __buffer, __buffer_end, __last);
          }
        else
          {
            _BidirectionalIterator __first_cut = __first;
            _BidirectionalIterator __second_cut = __middle;
            _Distance __len11 = 0;
            _Distance __len22 = 0;
            if (__len1 > __len2)
              {
                __len11 = __len1 / 2;
                std::advance(__first_cut, __len11);
                __second_cut = std::lower_bound(__middle, __last, *__first_cut);
                __len22 = std::distance(__middle, __second_cut);
              }
            else
              {
                __len22 = __len2 / 2;
                std::advance(__second_cut, __len22);
                __first_cut = std::upper_bound(__first, __middle, *__second_cut);
                __len11 = std::distance(__first, __first_cut);
              }
            _BidirectionalIterator __new_middle = std::__rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11, __len22, __buffer, __buffer_size);
            std::__merge_adaptive(__first, __first_cut, __new_middle, __len11, __len22, __buffer, __buffer_size);
            std::__merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __buffer, __buffer_size);
          }
      }
  }
  template < typename _BidirectionalIterator, typename _Distance, typename _Pointer, typename _Compare >
  void __merge_adaptive(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size, _Compare __comp);
  template < typename _BidirectionalIterator, typename _Distance, typename _Pointer, typename _Compare >
  void __merge_adaptive(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)
  {
    if (__len1 <= __len2 && __len1 <= __buffer_size)
      {
        _Pointer __buffer_end = std::move(__first, __middle, __buffer);
        std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last, __first, __comp);
      }
    else
      {
        if (__len2 <= __buffer_size)
          {
            _Pointer __buffer_end = std::move(__middle, __last, __buffer);
            std::__move_merge_adaptive_backward(__first, __middle, __buffer, __buffer_end, __last, __comp);
          }
        else
          {
            _BidirectionalIterator __first_cut = __first;
            _BidirectionalIterator __second_cut = __middle;
            _Distance __len11 = 0;
            _Distance __len22 = 0;
            if (__len1 > __len2)
              {
                __len11 = __len1 / 2;
                std::advance(__first_cut, __len11);
                __second_cut = std::lower_bound(__middle, __last, *__first_cut, __comp);
                __len22 = std::distance(__middle, __second_cut);
              }
            else
              {
                __len22 = __len2 / 2;
                std::advance(__second_cut, __len22);
                __first_cut = std::upper_bound(__first, __middle, *__second_cut, __comp);
                __len11 = std::distance(__first, __first_cut);
              }
            _BidirectionalIterator __new_middle = std::__rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11, __len22, __buffer, __buffer_size);
            std::__merge_adaptive(__first, __first_cut, __new_middle, __len11, __len22, __buffer, __buffer_size, __comp);
            std::__merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __buffer, __buffer_size, __comp);
          }
      }
  }
  template < typename _BidirectionalIterator, typename _Distance >
  void __merge_without_buffer(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2);
  template < typename _BidirectionalIterator, typename _Distance >
  void __merge_without_buffer(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2)
  {
    if (__len1 == 0 || __len2 == 0)
      {
        return ;
      }
    if (__len1 + __len2 == 2)
      {
        if (*__middle < *__first)
          {
            std::iter_swap(__first, __middle);
          }
        return ;
      }
    _BidirectionalIterator __first_cut = __first;
    _BidirectionalIterator __second_cut = __middle;
    _Distance __len11 = 0;
    _Distance __len22 = 0;
    if (__len1 > __len2)
      {
        __len11 = __len1 / 2;
        std::advance(__first_cut, __len11);
        __second_cut = std::lower_bound(__middle, __last, *__first_cut);
        __len22 = std::distance(__middle, __second_cut);
      }
    else
      {
        __len22 = __len2 / 2;
        std::advance(__second_cut, __len22);
        __first_cut = std::upper_bound(__first, __middle, *__second_cut);
        __len11 = std::distance(__first, __first_cut);
      }
    std::rotate(__first_cut, __middle, __second_cut);
    _BidirectionalIterator __new_middle = __first_cut;
    std::advance(__new_middle, std::distance(__middle, __second_cut));
    std::__merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22);
    std::__merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22);
  }
  template < typename _BidirectionalIterator, typename _Distance, typename _Compare >
  void __merge_without_buffer(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Compare __comp);
  template < typename _BidirectionalIterator, typename _Distance, typename _Compare >
  void __merge_without_buffer(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Compare __comp)
  {
    if (__len1 == 0 || __len2 == 0)
      {
        return ;
      }
    if (__len1 + __len2 == 2)
      {
        if (__comp(*__middle, *__first))
          {
            std::iter_swap(__first, __middle);
          }
        return ;
      }
    _BidirectionalIterator __first_cut = __first;
    _BidirectionalIterator __second_cut = __middle;
    _Distance __len11 = 0;
    _Distance __len22 = 0;
    if (__len1 > __len2)
      {
        __len11 = __len1 / 2;
        std::advance(__first_cut, __len11);
        __second_cut = std::lower_bound(__middle, __last, *__first_cut, __comp);
        __len22 = std::distance(__middle, __second_cut);
      }
    else
      {
        __len22 = __len2 / 2;
        std::advance(__second_cut, __len22);
        __first_cut = std::upper_bound(__first, __middle, *__second_cut, __comp);
        __len11 = std::distance(__first, __first_cut);
      }
    std::rotate(__first_cut, __middle, __second_cut);
    _BidirectionalIterator __new_middle = __first_cut;
    std::advance(__new_middle, std::distance(__middle, __second_cut));
    std::__merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22, __comp);
    std::__merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __comp);
  }
  template < typename _BidirectionalIterator >
  void inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
  {
    typedef typename ::std::iterator_traits<_BidirectionalIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_BidirectionalIterator>::difference_type _DistanceType;
    ;
    ;
    if (__first == __middle || __middle == __last)
      {
        return ;
      }
    _DistanceType __len1 = std::distance(__first, __middle);
    _DistanceType __len2 = std::distance(__middle, __last);
    ::std::_Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first, __last);
    if (__buf.begin() == 0)
      {
        std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      }
    else
      {
        std::__merge_adaptive(__first, __middle, __last, __len1, __len2, __buf.begin(), _DistanceType(__buf.size()));
      }
  }
  template < typename _BidirectionalIterator, typename _Compare >
  void inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_BidirectionalIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_BidirectionalIterator>::difference_type _DistanceType;
    ;
    ;
    if (__first == __middle || __middle == __last)
      {
        return ;
      }
    const _DistanceType __len1 = std::distance(__first, __middle);
    const _DistanceType __len2 = std::distance(__middle, __last);
    ::std::_Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first, __last);
    if (__buf.begin() == 0)
      {
        std::__merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);
      }
    else
      {
        std::__merge_adaptive(__first, __middle, __last, __len1, __len2, __buf.begin(), _DistanceType(__buf.size()), __comp);
      }
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  _OutputIterator __move_merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result);
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  _OutputIterator __move_merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
  {
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first2 < *__first1)
          {
            *__result = std::move(*__first2);
             ++__first2;
          }
        else
          {
            *__result = std::move(*__first1);
             ++__first1;
          }
         ++__result;
      }
    return std::move(__first2, __last2, std::move(__first1, __last1, __result));
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  _OutputIterator __move_merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp);
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  _OutputIterator __move_merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
  {
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first2, *__first1))
          {
            *__result = std::move(*__first2);
             ++__first2;
          }
        else
          {
            *__result = std::move(*__first1);
             ++__first1;
          }
         ++__result;
      }
    return std::move(__first2, __last2, std::move(__first1, __last1, __result));
  }
  template < typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Distance >
  void __merge_sort_loop(_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _RandomAccessIterator2 __result, _Distance __step_size);
  template < typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Distance >
  void __merge_sort_loop(_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _RandomAccessIterator2 __result, _Distance __step_size)
  {
    const _Distance __two_step = 2 * __step_size;
    while (__last - __first >= __two_step)
      {
        __result = std::__move_merge(__first, __first + __step_size, __first + __step_size, __first + __two_step, __result);
        __first += __two_step;
      }
    __step_size = std::min(_Distance(__last - __first), __step_size);
    std::__move_merge(__first, __first + __step_size, __first + __step_size, __last, __result);
  }
  template < typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Distance, typename _Compare >
  void __merge_sort_loop(_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _RandomAccessIterator2 __result, _Distance __step_size, _Compare __comp);
  template < typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Distance, typename _Compare >
  void __merge_sort_loop(_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _RandomAccessIterator2 __result, _Distance __step_size, _Compare __comp)
  {
    const _Distance __two_step = 2 * __step_size;
    while (__last - __first >= __two_step)
      {
        __result = std::__move_merge(__first, __first + __step_size, __first + __step_size, __first + __two_step, __result, __comp);
        __first += __two_step;
      }
    __step_size = std::min(_Distance(__last - __first), __step_size);
    std::__move_merge(__first, __first + __step_size, __first + __step_size, __last, __result, __comp);
  }
  template < typename _RandomAccessIterator, typename _Distance >
  void __chunk_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance __chunk_size);
  template < typename _RandomAccessIterator, typename _Distance >
  void __chunk_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance __chunk_size)
  {
    while (__last - __first >= __chunk_size)
      {
        std::__insertion_sort(__first, __first + __chunk_size);
        __first += __chunk_size;
      }
    std::__insertion_sort(__first, __last);
  }
  template < typename _RandomAccessIterator, typename _Distance, typename _Compare >
  void __chunk_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance __chunk_size, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Distance, typename _Compare >
  void __chunk_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance __chunk_size, _Compare __comp)
  {
    while (__last - __first >= __chunk_size)
      {
        std::__insertion_sort(__first, __first + __chunk_size, __comp);
        __first += __chunk_size;
      }
    std::__insertion_sort(__first, __last, __comp);
  }
  enum mcc_enum_anon_81
  {
    _S_chunk_size = 7
  };
  template < typename _RandomAccessIterator, typename _Pointer >
  void __merge_sort_with_buffer(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer);
  template < typename _RandomAccessIterator, typename _Pointer >
  void __merge_sort_with_buffer(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _Distance;
    const _Distance __len = __last - __first;
    const _Pointer __buffer_last = __buffer + __len;
    _Distance __step_size = ::std::_S_chunk_size;
    std::__chunk_insertion_sort(__first, __last, __step_size);
    while (__step_size < __len)
      {
        std::__merge_sort_loop(__first, __last, __buffer, __step_size);
        __step_size *= 2;
        std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
        __step_size *= 2;
      }
  }
  template < typename _RandomAccessIterator, typename _Pointer, typename _Compare >
  void __merge_sort_with_buffer(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Pointer, typename _Compare >
  void __merge_sort_with_buffer(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _Distance;
    const _Distance __len = __last - __first;
    const _Pointer __buffer_last = __buffer + __len;
    _Distance __step_size = ::std::_S_chunk_size;
    std::__chunk_insertion_sort(__first, __last, __step_size, __comp);
    while (__step_size < __len)
      {
        std::__merge_sort_loop(__first, __last, __buffer, __step_size, __comp);
        __step_size *= 2;
        std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);
        __step_size *= 2;
      }
  }
  template < typename _RandomAccessIterator, typename _Pointer, typename _Distance >
  void __stable_sort_adaptive(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Distance __buffer_size);
  template < typename _RandomAccessIterator, typename _Pointer, typename _Distance >
  void __stable_sort_adaptive(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Distance __buffer_size)
  {
    const _Distance __len = (__last - __first + 1) / 2;
    const _RandomAccessIterator __middle = __first + __len;
    if (__len > __buffer_size)
      {
        std::__stable_sort_adaptive(__first, __middle, __buffer, __buffer_size);
        std::__stable_sort_adaptive(__middle, __last, __buffer, __buffer_size);
      }
    else
      {
        std::__merge_sort_with_buffer(__first, __middle, __buffer);
        std::__merge_sort_with_buffer(__middle, __last, __buffer);
      }
    std::__merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), _Distance(__last - __middle), __buffer, __buffer_size);
  }
  template < typename _RandomAccessIterator, typename _Pointer, typename _Distance, typename _Compare >
  void __stable_sort_adaptive(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Distance __buffer_size, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Pointer, typename _Distance, typename _Compare >
  void __stable_sort_adaptive(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)
  {
    const _Distance __len = (__last - __first + 1) / 2;
    const _RandomAccessIterator __middle = __first + __len;
    if (__len > __buffer_size)
      {
        std::__stable_sort_adaptive(__first, __middle, __buffer, __buffer_size, __comp);
        std::__stable_sort_adaptive(__middle, __last, __buffer, __buffer_size, __comp);
      }
    else
      {
        std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
        std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
      }
    std::__merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), _Distance(__last - __middle), __buffer, __buffer_size, __comp);
  }
  template < typename _RandomAccessIterator >
  void __inplace_stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last);
  template < typename _RandomAccessIterator >
  void __inplace_stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    if (__last - __first < 15)
      {
        std::__insertion_sort(__first, __last);
        return ;
      }
    _RandomAccessIterator __middle = __first + (__last - __first) / 2;
    std::__inplace_stable_sort(__first, __middle);
    std::__inplace_stable_sort(__middle, __last);
    std::__merge_without_buffer(__first, __middle, __last, __middle - __first, __last - __middle);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  void __inplace_stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);
  template < typename _RandomAccessIterator, typename _Compare >
  void __inplace_stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    if (__last - __first < 15)
      {
        std::__insertion_sort(__first, __last, __comp);
        return ;
      }
    _RandomAccessIterator __middle = __first + (__last - __first) / 2;
    std::__inplace_stable_sort(__first, __middle, __comp);
    std::__inplace_stable_sort(__middle, __last, __comp);
    std::__merge_without_buffer(__first, __middle, __last, __middle - __first, __last - __middle, __comp);
  }
  template < typename _InputIterator1, typename _InputIterator2 >
  bool includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first2 < *__first1)
          {
            return false;
          }
        else
          {
            if (*__first1 < *__first2)
              {
                 ++__first1;
              }
            else
              {
                ( ++__first1,  ++__first2);
              }
          }
      }
    return __first2 == __last2;
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _Compare >
  bool includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first2, *__first1))
          {
            return false;
          }
        else
          {
            if (__comp(*__first1, *__first2))
              {
                 ++__first1;
              }
            else
              {
                ( ++__first1,  ++__first2);
              }
          }
      }
    return __first2 == __last2;
  }
  template < typename _BidirectionalIterator >
  bool next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
  {
    ;
    if (__first == __last)
      {
        return false;
      }
    _BidirectionalIterator __i = __first;
     ++__i;
    if (__i == __last)
      {
        return false;
      }
    __i = __last;
     --__i;
    for (; ; )
      {
        _BidirectionalIterator __ii = __i;
         --__i;
        if (*__i < *__ii)
          {
            _BidirectionalIterator __j = __last;
            while (!(*__i < * --__j))
              {
              }
            std::iter_swap(__i, __j);
            std::reverse(__ii, __last);
            return true;
          }
        if (__i == __first)
          {
            std::reverse(__first, __last);
            return false;
          }
      }
  }
  template < typename _BidirectionalIterator, typename _Compare >
  bool next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
  {
    ;
    if (__first == __last)
      {
        return false;
      }
    _BidirectionalIterator __i = __first;
     ++__i;
    if (__i == __last)
      {
        return false;
      }
    __i = __last;
     --__i;
    for (; ; )
      {
        _BidirectionalIterator __ii = __i;
         --__i;
        if (__comp(*__i, *__ii))
          {
            _BidirectionalIterator __j = __last;
            while (!bool(__comp(*__i, * --__j)))
              {
              }
            std::iter_swap(__i, __j);
            std::reverse(__ii, __last);
            return true;
          }
        if (__i == __first)
          {
            std::reverse(__first, __last);
            return false;
          }
      }
  }
  template < typename _BidirectionalIterator >
  bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
  {
    ;
    if (__first == __last)
      {
        return false;
      }
    _BidirectionalIterator __i = __first;
     ++__i;
    if (__i == __last)
      {
        return false;
      }
    __i = __last;
     --__i;
    for (; ; )
      {
        _BidirectionalIterator __ii = __i;
         --__i;
        if (*__ii < *__i)
          {
            _BidirectionalIterator __j = __last;
            while (!(* --__j < *__i))
              {
              }
            std::iter_swap(__i, __j);
            std::reverse(__ii, __last);
            return true;
          }
        if (__i == __first)
          {
            std::reverse(__first, __last);
            return false;
          }
      }
  }
  template < typename _BidirectionalIterator, typename _Compare >
  bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
  {
    ;
    if (__first == __last)
      {
        return false;
      }
    _BidirectionalIterator __i = __first;
     ++__i;
    if (__i == __last)
      {
        return false;
      }
    __i = __last;
     --__i;
    for (; ; )
      {
        _BidirectionalIterator __ii = __i;
         --__i;
        if (__comp(*__ii, *__i))
          {
            _BidirectionalIterator __j = __last;
            while (!bool(__comp(* --__j, *__i)))
              {
              }
            std::iter_swap(__i, __j);
            std::reverse(__ii, __last);
            return true;
          }
        if (__i == __first)
          {
            std::reverse(__first, __last);
            return false;
          }
      }
  }
  template < typename _InputIterator, typename _OutputIterator, typename _Tp >
  _OutputIterator replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__old_value, const _Tp &__new_value)
  {
    ;
    for (; __first != __last; ( ++__first,  ++__result))
      {
        if (*__first == __old_value)
          {
            *__result = __new_value;
          }
        else
          {
            *__result = *__first;
          }
      }
    return __result;
  }
  template < typename _InputIterator, typename _OutputIterator, typename _Predicate, typename _Tp >
  _OutputIterator replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred, const _Tp &__new_value)
  {
    ;
    for (; __first != __last; ( ++__first,  ++__result))
      {
        if (__pred(*__first))
          {
            *__result = __new_value;
          }
        else
          {
            *__result = *__first;
          }
      }
    return __result;
  }
  template < typename _ForwardIterator >
  inline bool is_sorted(_ForwardIterator __first, _ForwardIterator __last)
  {
    return std::is_sorted_until(__first, __last) == __last;
  }
  template < typename _ForwardIterator, typename _Compare >
  inline bool is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
  {
    return std::is_sorted_until(__first, __last, __comp) == __last;
  }
  template < typename _ForwardIterator >
  _ForwardIterator is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
  {
    ;
    if (__first == __last)
      {
        return __last;
      }
    _ForwardIterator __next = __first;
    for ( ++__next; __next != __last; (__first = __next,  ++__next))
      {
        if (*__next < *__first)
          {
            return __next;
          }
      }
    return __next;
  }
  template < typename _ForwardIterator, typename _Compare >
  _ForwardIterator is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
  {
    ;
    if (__first == __last)
      {
        return __last;
      }
    _ForwardIterator __next = __first;
    for ( ++__next; __next != __last; (__first = __next,  ++__next))
      {
        if (__comp(*__next, *__first))
          {
            return __next;
          }
      }
    return __next;
  }
  template < typename _Tp >
  inline ::std::pair<const _Tp &, const _Tp &> minmax(const _Tp &__a, const _Tp &__b)
  {
    return __b < __a ? ::std::pair<const _Tp &, const _Tp &>(__b, __a) : ::std::pair<const _Tp &, const _Tp &>(__a, __b);
  }
  template < typename _Tp, typename _Compare >
  inline ::std::pair<const _Tp &, const _Tp &> minmax(const _Tp &__a, const _Tp &__b, _Compare __comp)
  {
    return __comp(__b, __a) ? ::std::pair<const _Tp &, const _Tp &>(__b, __a) : ::std::pair<const _Tp &, const _Tp &>(__a, __b);
  }
  template < typename _ForwardIterator >
  ::std::pair<_ForwardIterator, _ForwardIterator> minmax_element(_ForwardIterator __first, _ForwardIterator __last)
  {
    ;
    _ForwardIterator __next = __first;
    if (__first == __last ||  ++__next == __last)
      {
        return std::make_pair(__first, __first);
      }
    _ForwardIterator __min;
    _ForwardIterator __max;
    if (*__next < *__first)
      {
        __min = __next;
        __max = __first;
      }
    else
      {
        __min = __first;
        __max = __next;
      }
    __first = __next;
     ++__first;
    while (__first != __last)
      {
        __next = __first;
        if ( ++__next == __last)
          {
            if (*__first < *__min)
              {
                __min = __first;
              }
            else
              {
                if (!(*__first < *__max))
                  {
                    __max = __first;
                  }
              }
            break;
          }
        if (*__next < *__first)
          {
            if (*__next < *__min)
              {
                __min = __next;
              }
            if (!(*__first < *__max))
              {
                __max = __first;
              }
          }
        else
          {
            if (*__first < *__min)
              {
                __min = __first;
              }
            if (!(*__next < *__max))
              {
                __max = __next;
              }
          }
        __first = __next;
         ++__first;
      }
    return std::make_pair(__min, __max);
  }
  template < typename _ForwardIterator, typename _Compare >
  ::std::pair<_ForwardIterator, _ForwardIterator> minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
  {
    ;
    _ForwardIterator __next = __first;
    if (__first == __last ||  ++__next == __last)
      {
        return std::make_pair(__first, __first);
      }
    _ForwardIterator __min;
    _ForwardIterator __max;
    if (__comp(*__next, *__first))
      {
        __min = __next;
        __max = __first;
      }
    else
      {
        __min = __first;
        __max = __next;
      }
    __first = __next;
     ++__first;
    while (__first != __last)
      {
        __next = __first;
        if ( ++__next == __last)
          {
            if (__comp(*__first, *__min))
              {
                __min = __first;
              }
            else
              {
                if (!__comp(*__first, *__max))
                  {
                    __max = __first;
                  }
              }
            break;
          }
        if (__comp(*__next, *__first))
          {
            if (__comp(*__next, *__min))
              {
                __min = __next;
              }
            if (!__comp(*__first, *__max))
              {
                __max = __first;
              }
          }
        else
          {
            if (__comp(*__first, *__min))
              {
                __min = __first;
              }
            if (!__comp(*__next, *__max))
              {
                __max = __next;
              }
          }
        __first = __next;
         ++__first;
      }
    return std::make_pair(__min, __max);
  }
  template < typename _Tp >
  inline _Tp min(::std::initializer_list<_Tp> __l)
  {
    return *std::min_element(__l.begin(), __l.end());
  }
  template < typename _Tp, typename _Compare >
  inline _Tp min(::std::initializer_list<_Tp> __l, _Compare __comp)
  {
    return *std::min_element(__l.begin(), __l.end(), __comp);
  }
  template < typename _Tp >
  inline _Tp max(::std::initializer_list<_Tp> __l)
  {
    return *std::max_element(__l.begin(), __l.end());
  }
  template < typename _Tp, typename _Compare >
  inline _Tp max(::std::initializer_list<_Tp> __l, _Compare __comp)
  {
    return *std::max_element(__l.begin(), __l.end(), __comp);
  }
  template < typename _Tp >
  inline ::std::pair<_Tp, _Tp> minmax(::std::initializer_list<_Tp> __l)
  {
    ::std::pair<const _Tp *, const _Tp *> __p = std::minmax_element(__l.begin(), __l.end());
    return std::make_pair(*__p.first, *__p.second);
  }
  template < typename _Tp, typename _Compare >
  inline ::std::pair<_Tp, _Tp> minmax(::std::initializer_list<_Tp> __l, _Compare __comp)
  {
    ::std::pair<const _Tp *, const _Tp *> __p = std::minmax_element(__l.begin(), __l.end(), __comp);
    return std::make_pair(*__p.first, *__p.second);
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
  {
    for (; __first1 != __last1; ( ++__first1,  ++__first2))
      {
        if (!(*__first1 == *__first2))
          {
            break;
          }
      }
    if (__first1 == __last1)
      {
        return true;
      }
    _ForwardIterator2 __last2 = __first2;
    std::advance(__last2, std::distance(__first1, __last1));
    for (_ForwardIterator1 __scan = __first1; __scan != __last1;  ++__scan)
      {
        if (__scan != std::find(__first1, __scan, *__scan))
          {
            continue;
          }
        auto __matches = std::count(__first2, __last2, *__scan);
        if (0 == __matches || std::count(__scan, __last1, *__scan) != __matches)
          {
            return false;
          }
      }
    return true;
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate >
  bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred)
  {
    for (; __first1 != __last1; ( ++__first1,  ++__first2))
      {
        if (!bool(__pred(*__first1, *__first2)))
          {
            break;
          }
      }
    if (__first1 == __last1)
      {
        return true;
      }
    _ForwardIterator2 __last2 = __first2;
    std::advance(__last2, std::distance(__first1, __last1));
    for (_ForwardIterator1 __scan = __first1; __scan != __last1;  ++__scan)
      {
        using ::std::placeholders::_1;
        if (__scan != std::find_if(__first1, __scan, std::bind(__pred, ::std::placeholders::_1, *__scan)))
          {
            continue;
          }
        auto __matches = std::count_if(__first2, __last2, std::bind(__pred, ::std::placeholders::_1, *__scan));
        if (0 == __matches || std::count_if(__scan, __last1, std::bind(__pred, ::std::placeholders::_1, *__scan)) != __matches)
          {
            return false;
          }
      }
    return true;
  }
  template < typename _RandomAccessIterator, typename _UniformRandomNumberGenerator >
  void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _UniformRandomNumberGenerator &&__g)
  {
    ;
    if (__first == __last)
      {
        return ;
      }
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    typedef typename ::std::make_unsigned<_DistanceType>::type __ud_type;
    typedef ::std::uniform_int_distribution<__ud_type> __distr_type;
    typedef typename ::std::uniform_int_distribution<__ud_type>::param_type __p_type;
    __distr_type __d;
    for (_RandomAccessIterator __i = __first + 1; __i != __last;  ++__i)
      {
        std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
      }
  }
  template < typename _InputIterator, typename _Function >
  _Function for_each(_InputIterator __first, _InputIterator __last, _Function __f)
  {
    ;
    for (; __first != __last;  ++__first)
      {
        __f(*__first);
      }
    return std::move(__f);
  }
  template < typename _InputIterator, typename _Tp >
  inline _InputIterator find(_InputIterator __first, _InputIterator __last, const _Tp &__val)
  {
    ;
    return std::__find(__first, __last, __val, std::__iterator_category(__first));
  }
  template < typename _InputIterator, typename _Predicate >
  inline _InputIterator find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
  {
    ;
    return std::__find_if(__first, __last, __pred, std::__iterator_category(__first));
  }
  template < typename _InputIterator, typename _ForwardIterator >
  _InputIterator find_first_of(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2)
  {
    ;
    ;
    for (; __first1 != __last1;  ++__first1)
      {
        for (_ForwardIterator __iter = __first2; __iter != __last2;  ++__iter)
          {
            if (*__first1 == *__iter)
              {
                return __first1;
              }
          }
      }
    return __last1;
  }
  template < typename _InputIterator, typename _ForwardIterator, typename _BinaryPredicate >
  _InputIterator find_first_of(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, _BinaryPredicate __comp)
  {
    ;
    ;
    for (; __first1 != __last1;  ++__first1)
      {
        for (_ForwardIterator __iter = __first2; __iter != __last2;  ++__iter)
          {
            if (__comp(*__first1, *__iter))
              {
                return __first1;
              }
          }
      }
    return __last1;
  }
  template < typename _ForwardIterator >
  _ForwardIterator adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
  {
    ;
    if (__first == __last)
      {
        return __last;
      }
    _ForwardIterator __next = __first;
    while ( ++__next != __last)
      {
        if (*__first == *__next)
          {
            return __first;
          }
        __first = __next;
      }
    return __last;
  }
  template < typename _ForwardIterator, typename _BinaryPredicate >
  _ForwardIterator adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)
  {
    ;
    if (__first == __last)
      {
        return __last;
      }
    _ForwardIterator __next = __first;
    while ( ++__next != __last)
      {
        if (__binary_pred(*__first, *__next))
          {
            return __first;
          }
        __first = __next;
      }
    return __last;
  }
  template < typename _InputIterator, typename _Tp >
  typename ::std::iterator_traits<_InputIterator>::difference_type count(_InputIterator __first, _InputIterator __last, const _Tp &__value)
  {
    ;
    typename ::std::iterator_traits<_InputIterator>::difference_type __n = 0;
    for (; __first != __last;  ++__first)
      {
        if (*__first == __value)
          {
             ++__n;
          }
      }
    return __n;
  }
  template < typename _InputIterator, typename _Predicate >
  typename ::std::iterator_traits<_InputIterator>::difference_type count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
  {
    ;
    typename ::std::iterator_traits<_InputIterator>::difference_type __n = 0;
    for (; __first != __last;  ++__first)
      {
        if (__pred(*__first))
          {
             ++__n;
          }
      }
    return __n;
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)
  {
    ;
    ;
    if (__first1 == __last1 || __first2 == __last2)
      {
        return __first1;
      }
    _ForwardIterator2 __p1(__first2);
    if ( ++__p1 == __last2)
      {
        return std::find(__first1, __last1, *__first2);
      }
    _ForwardIterator2 __p;
    _ForwardIterator1 __current = __first1;
    for (; ; )
      {
        __first1 = std::find(__first1, __last1, *__first2);
        if (__first1 == __last1)
          {
            return __last1;
          }
        __p = __p1;
        __current = __first1;
        if ( ++__current == __last1)
          {
            return __last1;
          }
        while (*__current == *__p)
          {
            if ( ++__p == __last2)
              {
                return __first1;
              }
            if ( ++__current == __last1)
              {
                return __last1;
              }
          }
         ++__first1;
      }
    return __first1;
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate >
  _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __predicate)
  {
    ;
    ;
    if (__first1 == __last1 || __first2 == __last2)
      {
        return __first1;
      }
    _ForwardIterator2 __p1(__first2);
    if ( ++__p1 == __last2)
      {
        while (__first1 != __last1 && !bool(__predicate(*__first1, *__first2)))
          {
             ++__first1;
          }
        return __first1;
      }
    _ForwardIterator2 __p;
    _ForwardIterator1 __current = __first1;
    for (; ; )
      {
        while (__first1 != __last1 && !bool(__predicate(*__first1, *__first2)))
          {
             ++__first1;
          }
        if (__first1 == __last1)
          {
            return __last1;
          }
        __p = __p1;
        __current = __first1;
        if ( ++__current == __last1)
          {
            return __last1;
          }
        while (__predicate(*__current, *__p))
          {
            if ( ++__p == __last2)
              {
                return __first1;
              }
            if ( ++__current == __last1)
              {
                return __last1;
              }
          }
         ++__first1;
      }
    return __first1;
  }
  template < typename _ForwardIterator, typename _Integer, typename _Tp >
  _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val)
  {
    ;
    if (__count <= 0)
      {
        return __first;
      }
    if (__count == 1)
      {
        return std::find(__first, __last, __val);
      }
    return std::__search_n(__first, __last, __count, __val, std::__iterator_category(__first));
  }
  template < typename _ForwardIterator, typename _Integer, typename _Tp, typename _BinaryPredicate >
  _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred)
  {
    ;
    if (__count <= 0)
      {
        return __first;
      }
    if (__count == 1)
      {
        while (__first != __last && !bool(__binary_pred(*__first, __val)))
          {
             ++__first;
          }
        return __first;
      }
    return std::__search_n(__first, __last, __count, __val, __binary_pred, std::__iterator_category(__first));
  }
  template < typename _InputIterator, typename _OutputIterator, typename _UnaryOperation >
  _OutputIterator transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __unary_op)
  {
    ;
    for (; __first != __last; ( ++__first,  ++__result))
      {
        *__result = __unary_op(*__first);
      }
    return __result;
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _BinaryOperation >
  _OutputIterator transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _OutputIterator __result, _BinaryOperation __binary_op)
  {
    ;
    for (; __first1 != __last1; ((( ++__first1,  ++__first2)),  ++__result))
      {
        *__result = __binary_op(*__first1, *__first2);
      }
    return __result;
  }
  template < typename _ForwardIterator, typename _Tp >
  void replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__old_value, const _Tp &__new_value)
  {
    ;
    for (; __first != __last;  ++__first)
      {
        if (*__first == __old_value)
          {
            *__first = __new_value;
          }
      }
  }
  template < typename _ForwardIterator, typename _Predicate, typename _Tp >
  void replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp &__new_value)
  {
    ;
    for (; __first != __last;  ++__first)
      {
        if (__pred(*__first))
          {
            *__first = __new_value;
          }
      }
  }
  template < typename _ForwardIterator, typename _Generator >
  void generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
  {
    ;
    for (; __first != __last;  ++__first)
      {
        *__first = __gen();
      }
  }
  template < typename _OutputIterator, typename _Size, typename _Generator >
  _OutputIterator generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
  {
    for (decltype(__n + 0) __niter = __n; __niter > 0; ( --__niter,  ++__first))
      {
        *__first = __gen();
      }
    return __first;
  }
  template < typename _InputIterator, typename _OutputIterator >
  inline _OutputIterator unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
  {
    ;
    if (__first == __last)
      {
        return __result;
      }
    return std::__unique_copy(__first, __last, __result, std::__iterator_category(__first), std::__iterator_category(__result));
  }
  template < typename _InputIterator, typename _OutputIterator, typename _BinaryPredicate >
  inline _OutputIterator unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred)
  {
    ;
    if (__first == __last)
      {
        return __result;
      }
    return std::__unique_copy(__first, __last, __result, __binary_pred, std::__iterator_category(__first), std::__iterator_category(__result));
  }
  template < typename _RandomAccessIterator >
  inline void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    ;
    if (__first != __last)
      {
        for (_RandomAccessIterator __i = __first + 1; __i != __last;  ++__i)
          {
            _RandomAccessIterator __j = __first + ::std::rand() % (__i - __first + 1);
            if (__i != __j)
              {
                std::iter_swap(__i, __j);
              }
          }
      }
  }
  template < typename _RandomAccessIterator, typename _RandomNumberGenerator >
  void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomNumberGenerator &&__rand)
  {
    ;
    if (__first == __last)
      {
        return ;
      }
    for (_RandomAccessIterator __i = __first + 1; __i != __last;  ++__i)
      {
        _RandomAccessIterator __j = __first + __rand(__i - __first + 1);
        if (__i != __j)
          {
            std::iter_swap(__i, __j);
          }
      }
  }
  template < typename _ForwardIterator, typename _Predicate >
  inline _ForwardIterator partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
  {
    ;
    return std::__partition(__first, __last, __pred, std::__iterator_category(__first));
  }
  template < typename _RandomAccessIterator >
  inline void partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    ;
    ;
    std::__heap_select(__first, __middle, __last);
    std::sort_heap(__first, __middle);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    ;
    ;
    std::__heap_select(__first, __middle, __last, __comp);
    std::sort_heap(__first, __middle, __comp);
  }
  template < typename _RandomAccessIterator >
  inline void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    ;
    ;
    if (__first == __last || __nth == __last)
      {
        return ;
      }
    std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2);
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    ;
    ;
    if (__first == __last || __nth == __last)
      {
        return ;
      }
    std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2, __comp);
  }
  template < typename _RandomAccessIterator >
  inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    ;
    if (__first != __last)
      {
        std::__introsort_loop(__first, __last, std::__lg(__last - __first) * 2);
        std::__final_insertion_sort(__first, __last);
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    ;
    if (__first != __last)
      {
        std::__introsort_loop(__first, __last, std::__lg(__last - __first) * 2, __comp);
        std::__final_insertion_sort(__first, __last, __comp);
      }
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  _OutputIterator merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first2 < *__first1)
          {
            *__result = *__first2;
             ++__first2;
          }
        else
          {
            *__result = *__first1;
             ++__first1;
          }
         ++__result;
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  _OutputIterator merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first2, *__first1))
          {
            *__result = *__first2;
             ++__first2;
          }
        else
          {
            *__result = *__first1;
             ++__first1;
          }
         ++__result;
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
  template < typename _RandomAccessIterator >
  inline void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    ::std::_Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first, __last);
    if (__buf.begin() == 0)
      {
        std::__inplace_stable_sort(__first, __last);
      }
    else
      {
        std::__stable_sort_adaptive(__first, __last, __buf.begin(), _DistanceType(__buf.size()));
      }
  }
  template < typename _RandomAccessIterator, typename _Compare >
  inline void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename ::std::iterator_traits<_RandomAccessIterator>::difference_type _DistanceType;
    ;
    ::std::_Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first, __last);
    if (__buf.begin() == 0)
      {
        std::__inplace_stable_sort(__first, __last, __comp);
      }
    else
      {
        std::__stable_sort_adaptive(__first, __last, __buf.begin(), _DistanceType(__buf.size()), __comp);
      }
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first1 < *__first2)
          {
            *__result = *__first1;
             ++__first1;
          }
        else
          {
            if (*__first2 < *__first1)
              {
                *__result = *__first2;
                 ++__first2;
              }
            else
              {
                *__result = *__first1;
                 ++__first1;
                 ++__first2;
              }
          }
         ++__result;
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first1, *__first2))
          {
            *__result = *__first1;
             ++__first1;
          }
        else
          {
            if (__comp(*__first2, *__first1))
              {
                *__result = *__first2;
                 ++__first2;
              }
            else
              {
                *__result = *__first1;
                 ++__first1;
                 ++__first2;
              }
          }
         ++__result;
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first1 < *__first2)
          {
             ++__first1;
          }
        else
          {
            if (*__first2 < *__first1)
              {
                 ++__first2;
              }
            else
              {
                *__result = *__first1;
                 ++__first1;
                 ++__first2;
                 ++__result;
              }
          }
      }
    return __result;
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first1, *__first2))
          {
             ++__first1;
          }
        else
          {
            if (__comp(*__first2, *__first1))
              {
                 ++__first2;
              }
            else
              {
                *__result = *__first1;
                 ++__first1;
                 ++__first2;
                 ++__result;
              }
          }
      }
    return __result;
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  _OutputIterator set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first1 < *__first2)
          {
            *__result = *__first1;
             ++__first1;
             ++__result;
          }
        else
          {
            if (*__first2 < *__first1)
              {
                 ++__first2;
              }
            else
              {
                 ++__first1;
                 ++__first2;
              }
          }
      }
    return std::copy(__first1, __last1, __result);
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  _OutputIterator set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first1, *__first2))
          {
            *__result = *__first1;
             ++__first1;
             ++__result;
          }
        else
          {
            if (__comp(*__first2, *__first1))
              {
                 ++__first2;
              }
            else
              {
                 ++__first1;
                 ++__first2;
              }
          }
      }
    return std::copy(__first1, __last1, __result);
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
  _OutputIterator set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (*__first1 < *__first2)
          {
            *__result = *__first1;
             ++__first1;
             ++__result;
          }
        else
          {
            if (*__first2 < *__first1)
              {
                *__result = *__first2;
                 ++__first2;
                 ++__result;
              }
            else
              {
                 ++__first1;
                 ++__first2;
              }
          }
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
  _OutputIterator set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_InputIterator1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_InputIterator2>::value_type _ValueType2;
    ;
    ;
    while (__first1 != __last1 && __first2 != __last2)
      {
        if (__comp(*__first1, *__first2))
          {
            *__result = *__first1;
             ++__first1;
             ++__result;
          }
        else
          {
            if (__comp(*__first2, *__first1))
              {
                *__result = *__first2;
                 ++__first2;
                 ++__result;
              }
            else
              {
                 ++__first1;
                 ++__first2;
              }
          }
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
  template < typename _ForwardIterator >
  _ForwardIterator min_element(_ForwardIterator __first, _ForwardIterator __last)
  {
    ;
    if (__first == __last)
      {
        return __first;
      }
    _ForwardIterator __result = __first;
    while ( ++__first != __last)
      {
        if (*__first < *__result)
          {
            __result = __first;
          }
      }
    return __result;
  }
  template < typename _ForwardIterator, typename _Compare >
  _ForwardIterator min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
  {
    ;
    if (__first == __last)
      {
        return __first;
      }
    _ForwardIterator __result = __first;
    while ( ++__first != __last)
      {
        if (__comp(*__first, *__result))
          {
            __result = __first;
          }
      }
    return __result;
  }
  template < typename _ForwardIterator >
  _ForwardIterator max_element(_ForwardIterator __first, _ForwardIterator __last)
  {
    ;
    if (__first == __last)
      {
        return __first;
      }
    _ForwardIterator __result = __first;
    while ( ++__first != __last)
      {
        if (*__result < *__first)
          {
            __result = __first;
          }
      }
    return __result;
  }
  template < typename _ForwardIterator, typename _Compare >
  _ForwardIterator max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
  {
    ;
    if (__first == __last)
      {
        return __first;
      }
    _ForwardIterator __result = __first;
    while ( ++__first != __last)
      {
        if (__comp(*__result, *__first))
          {
            __result = __first;
          }
      }
    return __result;
  }
}
namespace boost_swap_impl {
  template < typename T >
  void swap_impl(T &left, T &right);
  template < typename T >
  void swap_impl(T &left, T &right)
  {
    using namespace ::std;
    swap(left, right);
  }
  template < typename T, ::std::size_t N >
  void swap_impl(T (&left)[N], T (&right)[N]);
  template < typename T, ::std::size_t N >
  void swap_impl(T (&left)[N], T (&right)[N])
  {
    for (::std::size_t i(0); i < N;  ++i)
      {
        ::boost_swap_impl::swap_impl(left[i], right[i]);
      }
  }
}
namespace boost {
  template < typename T1, typename T2 >
  void swap(T1 &left, T2 &right);
  template < typename T1, typename T2 >
  void swap(T1 &left, T2 &right)
  {
    ::boost_swap_impl::swap_impl(left, right);
  }
  namespace detail {
    template < typename Iterator >
    struct  iterator_traits : ::std::iterator_traits<Iterator>
    {
    };
    using ::std::distance;
  }
  namespace exception_detail {
    template < typename T >
    class  refcount_ptr
    {
      public:
        inline refcount_ptr()
          : px_(0)
        {
        }
        inline ~refcount_ptr()
        {
          (*this).release();
        }
        inline refcount_ptr(const ::boost::exception_detail::refcount_ptr<T> &x)
          : px_(x.px_)
        {
          (*this).add_ref();
        }
        inline ::boost::exception_detail::refcount_ptr<T> &operator =(const ::boost::exception_detail::refcount_ptr<T> &x)
        {
          (*this).adopt(x.px_);
          return *this;
        }
        inline void adopt(T *px)
        {
          (*this).release();
          ::boost::exception_detail::refcount_ptr<T>::px_ = px;
          (*this).add_ref();
        }
        inline T *get() const 
        {
          return ::boost::exception_detail::refcount_ptr<T>::px_;
        }
      private:
        T *px_;
        inline void add_ref()
        {
          if (::boost::exception_detail::refcount_ptr<T>::px_)
            {
              ::boost::exception_detail::refcount_ptr<T>::px_->add_ref();
            }
        }
        inline void release()
        {
          if (::boost::exception_detail::refcount_ptr<T>::px_ && ::boost::exception_detail::refcount_ptr<T>::px_->release())
            {
              ::boost::exception_detail::refcount_ptr<T>::px_ = 0;
            }
        }
    };
  }
  template < typename Tag, typename T >
  class error_info;
  typedef ::boost::error_info<struct throw_function_, const char *> throw_function;
  typedef ::boost::error_info<struct throw_file_, const char *> throw_file;
  typedef ::boost::error_info<struct throw_line_, int> throw_line;
  template <>
  class  error_info< ::boost::throw_function_, const char *>
  {
    public:
      typedef const char *value_type;
      ::boost::error_info<struct throw_function_, const char *>::value_type v_;
      inline explicit error_info(::boost::error_info<struct throw_function_, const char *>::value_type v)
        : v_(v)
      {
      }
  };
  template <>
  class  error_info< ::boost::throw_file_, const char *>
  {
    public:
      typedef const char *value_type;
      ::boost::error_info<struct throw_file_, const char *>::value_type v_;
      inline explicit error_info(::boost::error_info<struct throw_file_, const char *>::value_type v)
        : v_(v)
      {
      }
  };
  template <>
  class  error_info< ::boost::throw_line_, int>
  {
    public:
      typedef int value_type;
      ::boost::error_info<struct throw_line_, int>::value_type v_;
      inline explicit error_info(::boost::error_info<struct throw_line_, int>::value_type v)
        : v_(v)
      {
      }
  };
}
#pragma GCC visibility push (default)
namespace boost {
  class exception;
}
#pragma GCC visibility pop
namespace boost {
  template < typename T >
  class shared_ptr;
  namespace exception_detail {
    class error_info_base;
    struct type_info_;
    struct  error_info_container
    {
        virtual const char *diagnostic_information(const char *) const  = 0 ;
        virtual ::boost::shared_ptr< ::boost::exception_detail::error_info_base> get(const ::boost::exception_detail::type_info_ &) const  = 0 ;
        virtual void set(const ::boost::shared_ptr< ::boost::exception_detail::error_info_base> &, const ::boost::exception_detail::type_info_ &) = 0 ;
        virtual void add_ref() const  = 0 ;
        virtual bool release() const  = 0 ;
        virtual ::boost::exception_detail::refcount_ptr< ::boost::exception_detail::error_info_container> clone() const  = 0 ;
      protected:
        inline ~error_info_container() throw()
        {
        }
      public:
    };
    template < typename __type_tpl__param_1_0__ >
    struct get_info;
    template <>
    struct get_info< ::boost::error_info< ::boost::throw_function_, const char *> >;
    template <>
    struct get_info< ::boost::error_info< ::boost::throw_file_, const char *> >;
    template <>
    struct get_info< ::boost::error_info< ::boost::throw_line_, int> >;
    const char *get_diagnostic_information(const ::boost::exception &, const char *);
    inline void copy_boost_exception(::boost::exception *a, const ::boost::exception *b);
    template < typename E, typename Tag, typename T >
    const E &set_info(const E &, const ::boost::error_info<Tag, T> &);
    template < typename E >
    const E &set_info(const E &x, const ::boost::throw_function &y);
    template < typename E >
    const E &set_info(const E &x, const ::boost::throw_file &y);
    template < typename E >
    const E &set_info(const E &x, const ::boost::throw_line &y);
  }
}
#pragma GCC visibility push (default)
 /* Instantiation of class template '::boost::exception_detail::refcount_ptr< ::boost::exception_detail::error_info_container>' */ 
 /* Instantiation of template function '::boost::exception_detail::refcount_ptr< ::boost::exception_detail::error_info_container>::refcount_ptr()' */ 
namespace boost {
  class  exception
  {
    protected:
      inline exception()
        : throw_function_(0), throw_file_(0), throw_line_( -1)
      {
      }
      virtual inline ~exception() throw() = 0 ;
    private:
      mutable ::boost::exception_detail::refcount_ptr< ::boost::exception_detail::error_info_container> data_;
      mutable const char *throw_function_;
      mutable const char *throw_file_;
      mutable int throw_line_;
    public:
    template < typename E >
    friend const E &(::boost::exception_detail::set_info)(const E &, const ::boost::throw_function &);
    template < typename E >
    friend const E &(::boost::exception_detail::set_info)(const E &, const ::boost::throw_file &);
    template < typename E >
    friend const E &(::boost::exception_detail::set_info)(const E &, const ::boost::throw_line &);
    template < typename E, typename Tag, typename T >
    friend const E &(::boost::exception_detail::set_info)(const E &, const ::boost::error_info<Tag, T> &);
    friend const char *(::boost::exception_detail::get_diagnostic_information)(const ::boost::exception &, const char *);
    template < typename __type_tpl__param_1_0__ >
    friend struct ::boost::exception_detail::get_info;
    friend struct ::boost::exception_detail::get_info< ::boost::error_info<struct throw_function_, const char *> >;
    friend struct ::boost::exception_detail::get_info< ::boost::error_info<struct throw_file_, const char *> >;
    friend struct ::boost::exception_detail::get_info< ::boost::error_info<struct throw_line_, int> >;
    friend void (::boost::exception_detail::copy_boost_exception)(::boost::exception *, const ::boost::exception *);
  };
}
#pragma GCC visibility pop
namespace boost {
  inline exception::~exception() throw()
  {
  }
  namespace exception_detail {
    template < typename E >
    const E &set_info(const E &x, const ::boost::throw_function &y)
    {
      x.throw_function_ = y.v_;
      return x;
    }
    template < typename E >
    const E &set_info(const E &x, const ::boost::throw_file &y)
    {
      x.throw_file_ = y.v_;
      return x;
    }
    template < typename E >
    const E &set_info(const E &x, const ::boost::throw_line &y)
    {
      x.throw_line_ = y.v_;
      return x;
    }
  }
}
#pragma GCC visibility push (default)
namespace boost {
  namespace exception_detail {
    template < typename T >
    struct  error_info_injector : T, ::boost::exception
    {
        inline explicit error_info_injector(const T &x)
          : T(x)
        {
        }
        inline virtual ~error_info_injector() throw()
        {
        }
    };
  }
}
#pragma GCC visibility pop
namespace boost {
  namespace exception_detail {
    struct  large_size
    {
        char c[256L];
    };
    ::boost::exception_detail::large_size dispatch_boost_exception(const ::boost::exception *);
    struct  small_size
    {
    };
    ::boost::exception_detail::small_size dispatch_boost_exception(const void *);
    template < typename __type_tpl__param_1_0__, int __nontype_tpl_param_1_1__ >
    struct enable_error_info_helper;
    template < typename T >
    struct  enable_error_info_helper<T, 256>
    {
        typedef T type;
    };
    template < typename T >
    struct  enable_error_info_helper<T, 1>
    {
        typedef ::boost::exception_detail::error_info_injector<T> type;
    };
    template < typename T >
    struct  enable_error_info_return_type
    {
        typedef typename ::boost::exception_detail::enable_error_info_helper<T, sizeof(exception_detail::dispatch_boost_exception(static_cast<T *>(0)))>::type type;
    };
  }
  template < typename T >
  inline typename ::boost::exception_detail::enable_error_info_return_type<T>::type enable_error_info(const T &x);
  template < typename T >
  inline typename ::boost::exception_detail::enable_error_info_return_type<T>::type enable_error_info(const T &x)
  {
    typedef typename ::boost::exception_detail::enable_error_info_return_type<T>::type rt;
    return rt(x);
  }
}
#pragma GCC visibility push (default)
namespace boost {
  namespace exception_detail {
    class  clone_base
    {
      public:
        virtual const ::boost::exception_detail::clone_base *clone() const  = 0 ;
        virtual void rethrow() const  = 0 ;
        virtual inline ~clone_base() throw()
        {
        }
    };
  }
}
#pragma GCC visibility pop
 /* Instantiation of template function '::boost::exception_detail::refcount_ptr< ::boost::exception_detail::error_info_container>::refcount_ptr()' */ 
 /* Instantiation of template function 'void ::boost::exception_detail::refcount_ptr< ::boost::exception_detail::error_info_container>::~refcount_ptr() const ' */ 
 /* Instantiation of template function '::boost::exception_detail::error_info_container *::boost::exception_detail::refcount_ptr< ::boost::exception_detail::error_info_container>::get() const ' */ 
 /* Instantiation of template function '::boost::exception_detail::refcount_ptr< ::boost::exception_detail::error_info_container> &::boost::exception_detail::refcount_ptr< ::boost::exception_detail::error_info_container>::operator =(const ::boost::exception_detail::refcount_ptr< ::boost::exception_detail::error_info_container> &)' */ 
namespace boost {
  namespace exception_detail {
    inline void copy_boost_exception(::boost::exception *a, const ::boost::exception *b)
    {
      ::boost::exception_detail::refcount_ptr< ::boost::exception_detail::error_info_container> data /* () */ ;
      if (::boost::exception_detail::error_info_container *d = (*b).data_.::boost::exception_detail::refcount_ptr< ::boost::exception_detail::error_info_container>::get())
        {
          data = (*d).clone();
        }
      (*a).throw_file_ = (*b).throw_file_;
      (*a).throw_line_ = (*b).throw_line_;
      (*a).throw_function_ = (*b).throw_function_;
      (*a).data_ = data;
    }
    inline void copy_boost_exception(void *, const void *)
    {
    }
    template < typename T >
    class  clone_impl : public T, virtual public ::boost::exception_detail::clone_base
    {
        struct  clone_tag
        {
        };
        inline clone_impl(const ::boost::exception_detail::clone_impl<T> &x, typename ::boost::exception_detail::clone_impl<T>::clone_tag)
          : T(x)
        {
          copy_boost_exception(this, &x);
        }
      public:
        inline explicit clone_impl(const T &x)
          : T(x)
        {
          copy_boost_exception(this, &x);
        }
        inline virtual ~clone_impl() throw()
        {
        }
      private:
        inline const ::boost::exception_detail::clone_base *clone() const 
        {
          return new ::boost::exception_detail::clone_impl<T>(*this, ((typename ::boost::exception_detail::clone_impl<T>::clone_tag())));
        }
        inline void rethrow() const 
        {
          throw *this;
        }
    };
  }
  template < typename T >
  inline ::boost::exception_detail::clone_impl<T> enable_current_exception(const T &x);
  template < typename T >
  inline ::boost::exception_detail::clone_impl<T> enable_current_exception(const T &x)
  {
    return ::boost::exception_detail::clone_impl<T>(x);
  }
  inline void throw_exception_assert_compatibility(const ::std::exception &)
  {
  }
  template < typename E >
  inline void throw_exception(const E &e) __attribute__((__noreturn__));
  template < typename E >
  inline __attribute__((__noreturn__)) void throw_exception(const E &e)
  {
    throw_exception_assert_compatibility(e);
    throw enable_current_exception(enable_error_info(e));
  }
  namespace exception_detail {
    template < typename E >
    void throw_exception_(const E &x, const char *current_function, const char *file, int line) __attribute__((__noreturn__));
    template < typename E >
    __attribute__((__noreturn__)) void throw_exception_(const E &x, const char *current_function, const char *file, int line)
    {
      boost::throw_exception(set_info(set_info(set_info(enable_error_info(x), ::boost::error_info<struct throw_function_, const char *>(current_function)), ::boost::error_info<struct throw_file_, const char *>(file)), ::boost::error_info<struct throw_line_, int>(line)));
    }
  }
  template < typename T >
  struct hash;
  template < typename T >
  void hash_combine(::std::size_t &seed, const T &v);
  template < typename It >
  ::std::size_t hash_range(It, It);
  template < typename It >
  void hash_range(::std::size_t &, It, It);
 /* Instantiation of template function '::std::allocator<char>::allocator()' */ 
  template < typename T, ::std::size_t N >
  class  array
  {
    public:
      T elems[N];
      typedef T value_type;
      typedef T *iterator;
      typedef const T *const_iterator;
      typedef T &reference;
      typedef const T &const_reference;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      inline typename ::boost::array<T, N>::iterator begin()
      {
        return ::boost::array<T, N>::elems;
      }
      inline typename ::boost::array<T, N>::const_iterator begin() const 
      {
        return ::boost::array<T, N>::elems;
      }
      inline typename ::boost::array<T, N>::const_iterator cbegin() const 
      {
        return ::boost::array<T, N>::elems;
      }
      inline typename ::boost::array<T, N>::iterator end()
      {
        return ::boost::array<T, N>::elems + N;
      }
      inline typename ::boost::array<T, N>::const_iterator end() const 
      {
        return ::boost::array<T, N>::elems + N;
      }
      inline typename ::boost::array<T, N>::const_iterator cend() const 
      {
        return ::boost::array<T, N>::elems + N;
      }
      typedef ::std::reverse_iterator<typename ::boost::array<T, N>::iterator> reverse_iterator;
      typedef ::std::reverse_iterator<typename ::boost::array<T, N>::const_iterator> const_reverse_iterator;
      inline typename ::boost::array<T, N>::reverse_iterator rbegin()
      {
        return ((typename ::boost::array<T, N>::reverse_iterator((*this).end())));
      }
      inline typename ::boost::array<T, N>::const_reverse_iterator rbegin() const 
      {
        return ((typename ::boost::array<T, N>::const_reverse_iterator((*this).end())));
      }
      inline typename ::boost::array<T, N>::const_reverse_iterator crbegin() const 
      {
        return ((typename ::boost::array<T, N>::const_reverse_iterator((*this).end())));
      }
      inline typename ::boost::array<T, N>::reverse_iterator rend()
      {
        return ((typename ::boost::array<T, N>::reverse_iterator((*this).begin())));
      }
      inline typename ::boost::array<T, N>::const_reverse_iterator rend() const 
      {
        return ((typename ::boost::array<T, N>::const_reverse_iterator((*this).begin())));
      }
      inline typename ::boost::array<T, N>::const_reverse_iterator crend() const 
      {
        return ((typename ::boost::array<T, N>::const_reverse_iterator((*this).begin())));
      }
      inline typename ::boost::array<T, N>::reference operator [](typename ::boost::array<T, N>::size_type i)
      {
        i < N ? (void)0 : ::boost::assertion::detail::assertion_failed_msg("i < N", "out of range", __PRETTY_FUNCTION__, "/usr/include/boost/array.hpp", 123);
        return ::boost::array<T, N>::elems[i];
      }
      inline typename ::boost::array<T, N>::const_reference operator [](typename ::boost::array<T, N>::size_type i) const 
      {
        i < N ? (void)0 : ::boost::assertion::detail::assertion_failed_msg("i < N", "out of range", __PRETTY_FUNCTION__, "/usr/include/boost/array.hpp", 129);
        return ::boost::array<T, N>::elems[i];
      }
      inline typename ::boost::array<T, N>::reference at(typename ::boost::array<T, N>::size_type i)
      {
        rangecheck(i);
        return ::boost::array<T, N>::elems[i];
      }
      inline typename ::boost::array<T, N>::const_reference at(typename ::boost::array<T, N>::size_type i) const 
      {
        rangecheck(i);
        return ::boost::array<T, N>::elems[i];
      }
      inline typename ::boost::array<T, N>::reference front()
      {
        return ::boost::array<T, N>::elems[0];
      }
      inline typename ::boost::array<T, N>::const_reference front() const 
      {
        return ::boost::array<T, N>::elems[0];
      }
      inline typename ::boost::array<T, N>::reference back()
      {
        return ::boost::array<T, N>::elems[N - 1];
      }
      inline typename ::boost::array<T, N>::const_reference back() const 
      {
        return ::boost::array<T, N>::elems[N - 1];
      }
      static inline typename ::boost::array<T, N>::size_type size()
      {
        return N;
      }
      static inline bool empty()
      {
        return false;
      }
      static inline typename ::boost::array<T, N>::size_type max_size()
      {
        return N;
      }
      enum mcc_enum_anon_82
      {
        static_size = N
      };
      inline void swap(::boost::array<T, N> &y)
      {
        for (typename ::boost::array<T, N>::size_type i(0); i < N;  ++i)
          {
            boost::swap(::boost::array<T, N>::elems[i], y.elems[i]);
          }
      }
      inline const T *data() const 
      {
        return ::boost::array<T, N>::elems;
      }
      inline T *data()
      {
        return ::boost::array<T, N>::elems;
      }
      inline T *c_array()
      {
        return ::boost::array<T, N>::elems;
      }
      template < typename T2 >
      inline ::boost::array<T, N> &operator =(const ::boost::array<T2, N> &rhs)
      {
        std::copy(rhs.begin(), rhs.end(), (*this).begin());
        return *this;
      }
      inline void assign(const T &value)
      {
        (*this).fill(value);
      }
      inline void fill(const T &value)
      {
        std::fill_n((*this).begin(), size(), value);
      }
      static inline void rangecheck(typename ::boost::array<T, N>::size_type i)
      {
        if (i >= size())
          {
            ::std::out_of_range e(("array<>: index out of range"));
            boost::throw_exception(e);
          }
      }
  };
 /* Instantiation of template function '::std::allocator<char>::allocator()' */ 
  template < typename T >
  class  array<T, 0LU>
  {
    public:
      typedef T value_type;
      typedef T *iterator;
      typedef const T *const_iterator;
      typedef T &reference;
      typedef const T &const_reference;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      inline typename ::boost::array<T, 0LU>::iterator begin()
      {
        return ((typename ::boost::array<T, 0LU>::iterator(reinterpret_cast<T *>(this))));
      }
      inline typename ::boost::array<T, 0LU>::const_iterator begin() const 
      {
        return ((typename ::boost::array<T, 0LU>::const_iterator(reinterpret_cast<const T *>(this))));
      }
      inline typename ::boost::array<T, 0LU>::const_iterator cbegin() const 
      {
        return ((typename ::boost::array<T, 0LU>::const_iterator(reinterpret_cast<const T *>(this))));
      }
      inline typename ::boost::array<T, 0LU>::iterator end()
      {
        return (*this).begin();
      }
      inline typename ::boost::array<T, 0LU>::const_iterator end() const 
      {
        return (*this).begin();
      }
      inline typename ::boost::array<T, 0LU>::const_iterator cend() const 
      {
        return (*this).cbegin();
      }
      typedef ::std::reverse_iterator<typename ::boost::array<T, 0LU>::iterator> reverse_iterator;
      typedef ::std::reverse_iterator<typename ::boost::array<T, 0LU>::const_iterator> const_reverse_iterator;
      inline typename ::boost::array<T, 0LU>::reverse_iterator rbegin()
      {
        return ((typename ::boost::array<T, 0LU>::reverse_iterator((*this).end())));
      }
      inline typename ::boost::array<T, 0LU>::const_reverse_iterator rbegin() const 
      {
        return ((typename ::boost::array<T, 0LU>::const_reverse_iterator((*this).end())));
      }
      inline typename ::boost::array<T, 0LU>::const_reverse_iterator crbegin() const 
      {
        return ((typename ::boost::array<T, 0LU>::const_reverse_iterator((*this).end())));
      }
      inline typename ::boost::array<T, 0LU>::reverse_iterator rend()
      {
        return ((typename ::boost::array<T, 0LU>::reverse_iterator((*this).begin())));
      }
      inline typename ::boost::array<T, 0LU>::const_reverse_iterator rend() const 
      {
        return ((typename ::boost::array<T, 0LU>::const_reverse_iterator((*this).begin())));
      }
      inline typename ::boost::array<T, 0LU>::const_reverse_iterator crend() const 
      {
        return ((typename ::boost::array<T, 0LU>::const_reverse_iterator((*this).begin())));
      }
      inline typename ::boost::array<T, 0LU>::reference operator [](typename ::boost::array<T, 0LU>::size_type)
      {
        return failed_rangecheck();
      }
      inline typename ::boost::array<T, 0LU>::const_reference operator [](typename ::boost::array<T, 0LU>::size_type) const 
      {
        return failed_rangecheck();
      }
      inline typename ::boost::array<T, 0LU>::reference at(typename ::boost::array<T, 0LU>::size_type)
      {
        return failed_rangecheck();
      }
      inline typename ::boost::array<T, 0LU>::const_reference at(typename ::boost::array<T, 0LU>::size_type) const 
      {
        return failed_rangecheck();
      }
      inline typename ::boost::array<T, 0LU>::reference front()
      {
        return failed_rangecheck();
      }
      inline typename ::boost::array<T, 0LU>::const_reference front() const 
      {
        return failed_rangecheck();
      }
      inline typename ::boost::array<T, 0LU>::reference back()
      {
        return failed_rangecheck();
      }
      inline typename ::boost::array<T, 0LU>::const_reference back() const 
      {
        return failed_rangecheck();
      }
      static inline typename ::boost::array<T, 0LU>::size_type size()
      {
        return 0;
      }
      static inline bool empty()
      {
        return true;
      }
      static inline typename ::boost::array<T, 0LU>::size_type max_size()
      {
        return 0;
      }
      enum mcc_enum_anon_83
      {
        static_size = 0
      };
      inline void swap(::boost::array<T, 0LU> &)
      {
      }
      inline const T *data() const 
      {
        return 0;
      }
      inline T *data()
      {
        return 0;
      }
      inline T *c_array()
      {
        return 0;
      }
      template < typename T2 >
      inline ::boost::array<T, 0LU> &operator =(const ::boost::array<T2, 0LU> &)
      {
        return *this;
      }
      inline void assign(const T &value)
      {
        (*this).fill(value);
      }
      inline void fill(const T &)
      {
      }
      static inline typename ::boost::array<T, 0LU>::reference failed_rangecheck()
      {
        ::std::out_of_range e(("attempt to access element of an empty array"));
        boost::throw_exception(e);
        static T placeholder;
        return placeholder;
      }
  };
  template < typename T, ::std::size_t N >
  bool operator ==(const ::boost::array<T, N> &x, const ::boost::array<T, N> &y);
  template < typename T, ::std::size_t N >
  bool operator ==(const ::boost::array<T, N> &x, const ::boost::array<T, N> &y)
  {
    return std::equal(x.begin(), x.end(), y.begin());
  }
  template < typename T, ::std::size_t N >
  bool operator <(const ::boost::array<T, N> &x, const ::boost::array<T, N> &y);
  template < typename T, ::std::size_t N >
  bool operator <(const ::boost::array<T, N> &x, const ::boost::array<T, N> &y)
  {
    return std::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
  }
  template < typename T, ::std::size_t N >
  bool operator !=(const ::boost::array<T, N> &x, const ::boost::array<T, N> &y);
  template < typename T, ::std::size_t N >
  bool operator !=(const ::boost::array<T, N> &x, const ::boost::array<T, N> &y)
  {
    return !(x == y);
  }
  template < typename T, ::std::size_t N >
  bool operator >(const ::boost::array<T, N> &x, const ::boost::array<T, N> &y);
  template < typename T, ::std::size_t N >
  bool operator >(const ::boost::array<T, N> &x, const ::boost::array<T, N> &y)
  {
    return y < x;
  }
  template < typename T, ::std::size_t N >
  bool operator <=(const ::boost::array<T, N> &x, const ::boost::array<T, N> &y);
  template < typename T, ::std::size_t N >
  bool operator <=(const ::boost::array<T, N> &x, const ::boost::array<T, N> &y)
  {
    return !(y < x);
  }
  template < typename T, ::std::size_t N >
  bool operator >=(const ::boost::array<T, N> &x, const ::boost::array<T, N> &y);
  template < typename T, ::std::size_t N >
  bool operator >=(const ::boost::array<T, N> &x, const ::boost::array<T, N> &y)
  {
    return !(x < y);
  }
  template < typename T, ::std::size_t N >
  inline void swap(::boost::array<T, N> &x, ::boost::array<T, N> &y);
  template < typename T, ::std::size_t N >
  inline void swap(::boost::array<T, N> &x, ::boost::array<T, N> &y)
  {
    x.swap(y);
  }
  template < typename T, ::std::size_t N >
  T (&get_c_array(::boost::array<T, N> &arg))[N];
  template < typename T, ::std::size_t N >
  T (&get_c_array(::boost::array<T, N> &arg))[N]
  {
    return arg.elems;
  }
  template < typename T, ::std::size_t N >
  const T (&get_c_array(const ::boost::array<T, N> &arg))[N];
  template < typename T, ::std::size_t N >
  const T (&get_c_array(const ::boost::array<T, N> &arg))[N]
  {
    return arg.elems;
  }
  template < typename T, ::std::size_t N >
  ::std::size_t hash_value(const ::boost::array<T, N> &arr);
  template < typename T, ::std::size_t N >
  ::std::size_t hash_value(const ::boost::array<T, N> &arr)
  {
    return boost::hash_range(arr.begin(), arr.end());
  }
 /* Instantiation of class template '::boost::mpl::always< ::mpl_::bool_<false> >' */ 
  namespace serialization {
    template < typename Archive >
    struct  use_array_optimization : ::boost::mpl::always< ::mpl_::bool_<false> >
    {
    };
    template < typename T >
    class  array : public ::boost::serialization::wrapper_traits<const ::boost::serialization::array<T> >
    {
      public:
        typedef T value_type;
        inline array(typename ::boost::serialization::array<T>::value_type *t, ::std::size_t s)
          : m_t(t), m_element_count(s)
        {
        }
        inline array(const ::boost::serialization::array<T> &rhs)
          : m_t(rhs.m_t), m_element_count(rhs.m_element_count)
        {
        }
        inline ::boost::serialization::array<T> &operator =(const ::boost::serialization::array<T> &rhs)
        {
          ::boost::serialization::array<T>::m_t = rhs.m_t;
          ::boost::serialization::array<T>::m_element_count = rhs.m_element_count;
        }
        template < typename Archive >
        inline void serialize_optimized(Archive &ar, const unsigned int, ::mpl_::false_) const 
        {
          ::std::size_t c = (*this).count();
          typename ::boost::serialization::array<T>::value_type *t = (*this).address();
          while (0 < c--)
            {
              ar & boost::serialization::make_nvp("item", *t++);
            }
        }
        template < typename Archive >
        inline void serialize_optimized(Archive &ar, const unsigned int version, ::mpl_::true_)
        {
          boost::serialization::split_member(ar, *this, version);
        }
        template < typename Archive >
        inline void save(Archive &ar, const unsigned int version) const 
        {
          ar.save_array(*this, version);
        }
        template < typename Archive >
        inline void load(Archive &ar, const unsigned int version)
        {
          ar.load_array(*this, version);
        }
        template < typename Archive >
        inline void serialize(Archive &ar, const unsigned int version)
        {
          typedef typename ::boost::serialization::use_array_optimization<Archive>::template apply< typename ::boost::remove_const<T>::type>::type use_optimized;
          (*this).serialize_optimized(ar, version, use_optimized());
        }
        inline typename ::boost::serialization::array<T>::value_type *address() const 
        {
          return ::boost::serialization::array<T>::m_t;
        }
        inline ::std::size_t count() const 
        {
          return ::boost::serialization::array<T>::m_element_count;
        }
      private:
        typename ::boost::serialization::array<T>::value_type *m_t;
        ::std::size_t m_element_count;
    };
    template < typename T >
    inline const ::boost::serialization::array<T> make_array(T *t, ::std::size_t s);
    template < typename T >
    inline const ::boost::serialization::array<T> make_array(T *t, ::std::size_t s)
    {
      return ::boost::serialization::array<T>(t, s);
    }
    template < typename Archive, typename T, ::std::size_t N >
    void serialize(Archive &ar, ::boost::array<T, N> &a, const unsigned int);
    template < typename Archive, typename T, ::std::size_t N >
    void serialize(Archive &ar, ::boost::array<T, N> &a, const unsigned int)
    {
      ar & boost::serialization::make_nvp("elems", a.elems);
    }
  }
  namespace archive {
    namespace detail {
      template < typename Archive >
      class interface_oarchive;
      template < typename Archive >
      class interface_iarchive;
    }
  }
  namespace serialization {
     template < typename Archive, typename T >
    struct  free_saver
    {
        static inline void invoke(Archive &ar, const T &t, const unsigned int file_version)
        {
          const ::boost::serialization::version_type v((file_version));
          save(ar, t, v);
        }
    };
    template < typename Archive, typename T >
    struct  free_loader
    {
        static inline void invoke(Archive &ar, T &t, const unsigned int file_version)
        {
          const ::boost::serialization::version_type v((file_version));
          load(ar, t, v);
        }
    };
    template < typename Archive, typename T >
    inline void split_free(Archive &ar, T &t, const unsigned int file_version);
    template < typename Archive, typename T >
    inline void split_free(Archive &ar, T &t, const unsigned int file_version)
    {
      typedef typename ::boost::mpl::eval_if<typename Archive::is_saving, ::boost::mpl::identity< ::boost::serialization::free_saver<Archive, T> >, ::boost::mpl::identity< ::boost::serialization::free_loader<Archive, T> > >::type typex;
      typex::invoke(ar, t, file_version);
    }
    class  collection_size_type
    {
        typedef ::std::size_t base_type;
        ::boost::serialization::collection_size_type::base_type t;
      public:
        inline collection_size_type()
          : t(0)
        {
        }
        inline explicit collection_size_type(const ::std::size_t &t_)
          : t(t_)
        {
        }
        inline collection_size_type(const ::boost::serialization::collection_size_type &t_)
          : t(t_.t)
        {
        }
        inline ::boost::serialization::collection_size_type &operator =(const ::boost::serialization::collection_size_type &rhs)
        {
          (*this).t = rhs.t;
          return *this;
        }
        inline ::boost::serialization::collection_size_type &operator =(const unsigned int &rhs)
        {
          (*this).t = rhs;
          return *this;
        }
        inline operator ::boost::serialization::collection_size_type::base_type() const 
        {
          return (*this).t;
        }
        inline operator ::boost::serialization::collection_size_type::base_type &()
        {
          return (*this).t;
        }
        inline bool operator ==(const ::boost::serialization::collection_size_type &rhs) const 
        {
          return (*this).t == rhs.t;
        }
        inline bool operator <(const ::boost::serialization::collection_size_type &rhs) const 
        {
          return (*this).t < rhs.t;
        }
    };
    template <>
    struct  implementation_level_impl<const ::boost::serialization::collection_size_type>
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<1> type;
        static const int value = ::mpl_::int_<1>::value;
    };
    template <>
    struct  is_bitwise_serializable< ::boost::serialization::collection_size_type> : ::mpl_::bool_<true>
    {
    };
  }
  namespace archive {
    namespace detail {
      class  basic_iserializer : public ::boost::archive::detail::basic_serializer
      {
          ::boost::archive::detail::basic_pointer_iserializer *m_bpis;
        protected:
          explicit basic_iserializer(const ::boost::serialization::extended_type_info &type);
          virtual ~basic_iserializer();
        public:
          inline bool serialized_as_pointer() const 
          {
            return (*this).m_bpis != 0L;
          }
          inline void set_bpis(::boost::archive::detail::basic_pointer_iserializer *bpis)
          {
            (*this).m_bpis = bpis;
          }
          inline const ::boost::archive::detail::basic_pointer_iserializer *get_bpis_ptr() const 
          {
            return (*this).m_bpis;
          }
          virtual void load_object_data(::boost::archive::detail::basic_iarchive &ar, void *x, const unsigned int file_version) const  = 0 ;
          virtual bool class_info() const  = 0 ;
          virtual bool tracking(const unsigned int) const  = 0 ;
          virtual ::boost::archive::version_type version() const  = 0 ;
          virtual bool is_polymorphic() const  = 0 ;
          virtual void destroy(void *address) const  = 0 ;
      };
      template < typename Archive >
      class  archive_serializer_map
      {
        public:
          static bool insert(const ::boost::archive::detail::basic_serializer *bs);
          static void erase(const ::boost::archive::detail::basic_serializer *bs);
          static const ::boost::archive::detail::basic_serializer *find(const ::boost::serialization::extended_type_info &type_);
      };
      template < typename T >
      inline void check_object_level();
      template < typename T >
      inline void check_object_level()
      {
        typedef typename ::boost::mpl::greater_equal< ::boost::serialization::implementation_level<T>, ::mpl_::int_<1> >::type typex;
        static_assert(typex::value, "typex::value");
      }
      template < typename T >
      inline void check_object_versioning();
      template < typename T >
      inline void check_object_versioning()
      {
        typedef ::boost::mpl::or_< ::boost::mpl::greater< ::boost::serialization::implementation_level<T>, ::mpl_::int_<2> >, ::boost::mpl::equal_to< ::boost::serialization::version<T>, ::mpl_::int_<0> > > typex;
        static_assert(typex::value, "typex::value");
      }
      template < typename T >
      inline void check_object_tracking();
      template < typename T >
      inline void check_object_tracking()
      {
        static_assert(!boost::is_const<T>::value, "! boost::is_const< T >::value");
        typedef typename ::boost::mpl::equal_to< ::boost::serialization::tracking_level<T>, ::mpl_::int_<0> >::type typex;
        typedef ::boost::serialization::BOOST_SERIALIZATION_SS<sizeof(::boost::serialization::static_warning_test<typex::value, 98>)> STATIC_WARNING_LINE98;
        ;
      }
      template < typename T >
      inline void check_pointer_level();
      template < typename T >
      inline void check_pointer_level()
      {
        typedef ::boost::mpl::or_< ::boost::mpl::greater< ::boost::serialization::implementation_level<T>, ::mpl_::int_<2> >, ::boost::mpl::not_< ::boost::mpl::equal_to< ::boost::serialization::tracking_level<T>, ::mpl_::int_<1> > > > typex;
        typedef ::boost::serialization::BOOST_SERIALIZATION_SS<sizeof(::boost::serialization::static_warning_test<typex::value, 137>)> STATIC_WARNING_LINE137;
        ;
      }
      template < typename T >
      inline void check_pointer_tracking();
      template < typename T >
      inline void check_pointer_tracking()
      {
        typedef typename ::boost::mpl::greater< ::boost::serialization::tracking_level<T>, ::mpl_::int_<0> >::type typex;
        typedef ::boost::serialization::BOOST_SERIALIZATION_SS<sizeof(::boost::serialization::static_warning_test<typex::value, 148>)> STATIC_WARNING_LINE148;
        ;
      }
      template < typename T >
      inline void check_const_loading();
      template < typename T >
      inline void check_const_loading()
      {
        typedef typename ::boost::mpl::or_< ::boost::serialization::is_wrapper<T>, ::boost::mpl::not_< ::boost::is_const<T> > >::type typex;
        static_assert(typex::value, "typex::value");
      }
    }
    class  load_access
    {
      public:
        template < typename Archive, typename T >
        static inline void load_primitive(Archive &ar, T &t)
        {
          ar.load(t);
        }
    };
    namespace detail {
      template < typename Archive, typename T >
      class  iserializer : public ::boost::archive::detail::basic_iserializer
      {
          inline virtual void destroy(void *address) const 
          {
            boost::serialization::access::destroy(static_cast<T *>(address));
          }
        protected:
          inline explicit iserializer()
            : basic_iserializer(boost::serialization::singleton<typename ::boost::serialization::type_info_implementation<T>::type>::get_const_instance())
          {
          }
        public:
          virtual void load_object_data(::boost::archive::detail::basic_iarchive &ar, void *x, const unsigned int file_version) const  __attribute__((__used__));
          inline virtual bool class_info() const 
          {
            return boost::serialization::implementation_level<T>::value >= ::boost::serialization::object_class_info;
          }
          inline virtual bool tracking(const unsigned int) const 
          {
            return boost::serialization::tracking_level<T>::value == ::boost::serialization::track_always || (boost::serialization::tracking_level<T>::value == ::boost::serialization::track_selectively && (*this).serialized_as_pointer());
          }
          inline virtual ::boost::archive::version_type version() const 
          {
            return ::boost::archive::version_type(::boost::serialization::version<T>::value);
          }
          inline virtual bool is_polymorphic() const 
          {
            return boost::is_polymorphic<T>::value;
          }
          inline virtual ~iserializer()
          {
          }
      };
      template < typename Archive, typename T >
      __attribute__((__used__)) void iserializer<Archive, T>::load_object_data(::boost::archive::detail::basic_iarchive &ar, void *x, const unsigned int file_version) const 
      {
        boost::serialization::serialize_adl(boost::serialization::smart_cast_reference<Archive &>(ar), *static_cast<T *>(x), file_version);
      }
      template < typename Archive, typename T >
      class  pointer_iserializer : public ::boost::archive::detail::basic_pointer_iserializer
      {
          inline virtual const ::boost::archive::detail::basic_iserializer &get_basic_serializer() const 
          {
            return boost::serialization::singleton< ::boost::archive::detail::iserializer<Archive, T> >::get_const_instance();
          }
          virtual void load_object_ptr(::boost::archive::detail::basic_iarchive &ar, void *&x, const unsigned int file_version) const  __attribute__((__used__));
        protected:
          pointer_iserializer();
          virtual ~pointer_iserializer();
      };
      template < typename T >
      struct  heap_allocator
      {
          struct  has_new_operator
          {
              static inline T *invoke()
              {
                return static_cast<T *>(T::operator new(sizeof(T)));
              }
          };
          struct  doesnt_have_new_operator
          {
              static inline T *invoke()
              {
                return static_cast<T *>(::operator new(sizeof(T)));
              }
          };
          static inline T *invoke()
          {
            typedef typename ::boost::mpl::eval_if< ::boost::has_new_operator<T>, ::boost::mpl::identity<typename ::boost::archive::detail::heap_allocator<T>::has_new_operator>, ::boost::mpl::identity<typename ::boost::archive::detail::heap_allocator<T>::doesnt_have_new_operator> >::type typex;
            return typex::invoke();
          }
      };
      template < typename T >
      class  auto_ptr_with_deleter
      {
        public:
          inline explicit auto_ptr_with_deleter(T *p)
            : m_p(p)
          {
          }
          inline ~auto_ptr_with_deleter()
          {
            if (::boost::archive::detail::auto_ptr_with_deleter<T>::m_p)
              {
                boost::serialization::access::destroy(::boost::archive::detail::auto_ptr_with_deleter<T>::m_p);
              }
          }
          inline T *get() const 
          {
            return ::boost::archive::detail::auto_ptr_with_deleter<T>::m_p;
          }
          inline T *release()
          {
            T *p = ::boost::archive::detail::auto_ptr_with_deleter<T>::m_p;
            ::boost::archive::detail::auto_ptr_with_deleter<T>::m_p = 0L;
            return p;
          }
        private:
          T *m_p;
      };
      template < typename Archive, typename T >
      __attribute__((__used__)) void pointer_iserializer<Archive, T>::load_object_ptr(::boost::archive::detail::basic_iarchive &ar, void *&x, const unsigned int file_version) const 
      {
        Archive &ar_impl = boost::serialization::smart_cast_reference<Archive &>(ar);
        ::boost::archive::detail::auto_ptr_with_deleter<T> ap(heap_allocator<T>::invoke());
        if (0L == ap.get())
          {
            boost::serialization::throw_exception(::std::bad_alloc());
          }
        T *t = ap.get();
        x = t;
        {
          try
          {
            ar.next_object_pointer(t);
            boost::serialization::load_construct_data_adl<Archive, T>(ar_impl, t, file_version);
          }
          catch (...)
          {
            ap.release();
            throw;
            ;
          }
        }
        ar_impl >> boost::serialization::make_nvp(0L, *t);
        ap.release();
      }
      template < typename Archive, typename T >
      pointer_iserializer<Archive, T>::pointer_iserializer()
        : basic_pointer_iserializer(boost::serialization::singleton<typename ::boost::serialization::type_info_implementation<T>::type>::get_const_instance())
      {
        boost::serialization::singleton< ::boost::archive::detail::iserializer<Archive, T> >::get_mutable_instance().set_bpis(this);
        archive_serializer_map<Archive>::insert(this);
      }
      template < typename Archive, typename T >
      pointer_iserializer<Archive, T>::~pointer_iserializer()
      {
        archive_serializer_map<Archive>::erase(this);
      }
      template < typename Archive >
      struct  load_non_pointer_type
      {
          struct  load_primitive
          {
              template < typename T >
              static inline void invoke(Archive &ar, T &t)
              {
                load_access::load_primitive(ar, t);
              }
          };
          struct  load_only
          {
              template < typename T >
              static inline void invoke(Archive &ar, const T &t)
              {
                boost::serialization::serialize_adl(ar, const_cast<T &>(t), boost::serialization::version<T>::value);
              }
          };
          struct  load_standard
          {
              template < typename T >
              static inline void invoke(Archive &ar, const T &t)
              {
                void *x = &const_cast<T &>(t);
                ar.load_object(x, boost::serialization::singleton< ::boost::archive::detail::iserializer<Archive, T> >::get_const_instance());
              }
          };
          struct  load_conditional
          {
              template < typename T >
              static inline void invoke(Archive &ar, T &t)
              {
                load_standard::invoke(ar, t);
              }
          };
          template < typename T >
          static inline void invoke(Archive &ar, T &t)
          {
            typedef typename ::boost::mpl::eval_if< ::boost::mpl::equal_to< ::boost::serialization::implementation_level<T>, ::mpl_::int_<1> >, ::boost::mpl::identity<typename ::boost::archive::detail::load_non_pointer_type<Archive>::load_primitive>, ::boost::mpl::eval_if< ::boost::mpl::greater_equal< ::boost::serialization::implementation_level<T>, ::mpl_::int_<3> >, ::boost::mpl::identity<typename ::boost::archive::detail::load_non_pointer_type<Archive>::load_standard>, ::boost::mpl::eval_if< ::boost::mpl::equal_to< ::boost::serialization::tracking_level<T>, ::mpl_::int_<0> >, ::boost::mpl::identity<typename ::boost::archive::detail::load_non_pointer_type<Archive>::load_only>, ::boost::mpl::identity<typename ::boost::archive::detail::load_non_pointer_type<Archive>::load_conditional> > > >::type typex;
            check_object_versioning<T>();
            check_object_level<T>();
            typex::invoke(ar, t);
          }
      };
      template < typename Archive >
      struct  load_pointer_type
      {
          struct  abstract
          {
              template < typename T >
              static inline const ::boost::archive::detail::basic_pointer_iserializer *register_type(Archive &)
              {
                static_assert(boost::is_polymorphic<T>::value, "boost::is_polymorphic< T >::value");
                return static_cast< ::boost::archive::detail::basic_pointer_iserializer *>(0L);
              }
          };
          struct  non_abstract
          {
              template < typename T >
              static inline const ::boost::archive::detail::basic_pointer_iserializer *register_type(Archive &ar)
              {
                return ar.register_type(static_cast<T *>(0L));
              }
          };
          template < typename T >
          static inline const ::boost::archive::detail::basic_pointer_iserializer *register_type(Archive &ar, const T &)
          {
            typedef typename ::boost::mpl::eval_if< ::boost::serialization::is_abstract<const T>, ::boost::mpl::identity<typename ::boost::archive::detail::load_pointer_type<Archive>::abstract>, ::boost::mpl::identity<typename ::boost::archive::detail::load_pointer_type<Archive>::non_abstract> >::type typex;
            return typex::template register_type<T>(ar);
          }
          template < typename T >
          static inline T *pointer_tweak(const ::boost::serialization::extended_type_info &eti, const void *const t, const T &)
          {
            return static_cast<T *>(const_cast<void *>(boost::serialization::void_upcast(eti, boost::serialization::singleton<typename ::boost::serialization::type_info_implementation<T>::type>::get_const_instance(), t)));
          }
          template < typename T >
          static inline void check_load(T &)
          {
            check_pointer_level<T>();
            check_pointer_tracking<T>();
          }
          static inline const ::boost::archive::detail::basic_pointer_iserializer *find(const ::boost::serialization::extended_type_info &type)
          {
            return static_cast<const ::boost::archive::detail::basic_pointer_iserializer *>(archive_serializer_map<Archive>::find(type));
          }
          template < typename Tptr >
          static inline void invoke(Archive &ar, Tptr &t)
          {
            check_load(*t);
            const ::boost::archive::detail::basic_pointer_iserializer *bpis_ptr = register_type(ar, *t);
            const ::boost::archive::detail::basic_pointer_iserializer *newbpis_ptr = ar.load_pointer((void *&)t, bpis_ptr, find);
            if (newbpis_ptr != bpis_ptr)
              {
                t = pointer_tweak((*newbpis_ptr).::boost::archive::detail::basic_serializer::get_eti(), t, *t);
              }
          }
      };
 /* Instantiation of class template '::std::pair<const char *, int *>' */ 
 /* Instantiation of class template '::boost::serialization::traits<const ::boost::serialization::nvp<int>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp<int> >, ::mpl_::bool_<true> >' */ 
 /* Instantiation of class template '::boost::serialization::wrapper_traits<const ::boost::serialization::nvp<int>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp<int> > >' */ 
 /* Instantiation of class template '::boost::serialization::nvp<int>' */ 
      template < typename Archive >
      struct  load_enum_type
      {
          template < typename T >
          static inline void invoke(Archive &ar, T &t)
          {
            int i;
            ar >> boost::serialization::make_nvp(0L, i);
            t = static_cast<T>(i);
          }
      };
 /* Instantiation of class template '::std::pair<const char *, ::boost::serialization::collection_size_type *>' */ 
 /* Instantiation of class template '::boost::serialization::traits<const ::boost::serialization::nvp< ::boost::serialization::collection_size_type>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp< ::boost::serialization::collection_size_type> >, ::mpl_::bool_<true> >' */ 
 /* Instantiation of class template '::boost::serialization::wrapper_traits<const ::boost::serialization::nvp< ::boost::serialization::collection_size_type>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp< ::boost::serialization::collection_size_type> > >' */ 
 /* Instantiation of class template '::boost::serialization::nvp< ::boost::serialization::collection_size_type>' */ 
      template < typename Archive >
      struct  load_array_type
      {
          template < typename T >
          static inline void invoke(Archive &ar, T &t)
          {
            typedef typename ::boost::remove_extent<T>::type value_type;
            ::std::size_t current_count = sizeof(t) / (static_cast<char *>(static_cast<void *>(&t[1])) - static_cast<char *>(static_cast<void *>(&t[0])));
            ::boost::serialization::collection_size_type count /* () */ ;
            ar >> boost::serialization::make_nvp("count", count);
            if (static_cast< ::std::size_t>(count) > current_count)
              {
                boost::serialization::throw_exception(::boost::archive::archive_exception(::boost::archive::archive_exception::array_size_too_short /* , 0L, 0L */ ));
              }
            ar >> serialization::make_array(static_cast<value_type *>(&t[0]), count);
          }
      };
    }
    template < typename Archive, typename T >
    inline void load(Archive &ar, T &t);
    template < typename Archive, typename T >
    inline void load(Archive &ar, T &t)
    {
      detail::check_const_loading<T>();
      typedef typename ::boost::mpl::eval_if< ::boost::is_pointer<T>, ::boost::mpl::identity< ::boost::archive::detail::load_pointer_type<Archive> >, ::boost::mpl::eval_if< ::boost::is_array<T>, ::boost::mpl::identity< ::boost::archive::detail::load_array_type<Archive> >, ::boost::mpl::eval_if< ::boost::is_enum<T>, ::boost::mpl::identity< ::boost::archive::detail::load_enum_type<Archive> >, ::boost::mpl::identity< ::boost::archive::detail::load_non_pointer_type<Archive> > > > >::type typex;
      typex::invoke(ar, t);
    }
    namespace detail {
      template < typename Archive >
      class  interface_iarchive
      {
        protected:
          inline interface_iarchive()
          {
          }
        public:
          typedef ::mpl_::bool_<true> is_loading;
          typedef ::mpl_::bool_<false> is_saving;
          inline Archive *This()
          {
            return static_cast<Archive *>(this);
          }
          template < typename T >
          inline const ::boost::archive::detail::basic_pointer_iserializer *register_type(T *  = (0L))
          {
            const ::boost::archive::detail::basic_pointer_iserializer &bpis = boost::serialization::singleton< ::boost::archive::detail::pointer_iserializer<Archive, T> >::get_const_instance();
            this->This()->register_basic_serializer(bpis.get_basic_serializer());
            return &bpis;
          }
          template < typename T >
          inline Archive &operator >>(T &t)
          {
            this->This()->load_override(t, 0);
            return *this->This();
          }
          template < typename T >
          inline Archive &operator &(T &t)
          {
            return *this->This() >> t;
          }
      };
      class extended_type_info;
      template < typename Archive >
      class  common_iarchive : public ::boost::archive::detail::basic_iarchive, public ::boost::archive::detail::interface_iarchive<Archive>
      {
          inline virtual void vload(::boost::archive::version_type &t)
          {
            *this->This() >> t;
          }
          inline virtual void vload(::boost::archive::object_id_type &t)
          {
            *this->This() >> t;
          }
          inline virtual void vload(::boost::archive::class_id_type &t)
          {
            *this->This() >> t;
          }
          inline virtual void vload(::boost::archive::class_id_optional_type &t)
          {
            *this->This() >> t;
          }
          inline virtual void vload(::boost::archive::tracking_type &t)
          {
            *this->This() >> t;
          }
          inline virtual void vload(::boost::archive::class_name_type &s)
          {
            *this->This() >> s;
          }
        protected:
          template < typename T >
          inline void load_override(T &t, int)
          {
            archive::load(*this->This(), t);
          }
          inline void load_start(const char *)
          {
          }
          inline void load_end(const char *)
          {
          }
          inline common_iarchive(unsigned int flags  = (0))
            : basic_iarchive(flags), interface_iarchive<Archive>()
          {
          }
        friend class ::boost::archive::detail::interface_iarchive<Archive>;
      };
    }
    template < typename Archive >
    class  basic_text_iarchive : public ::boost::archive::detail::common_iarchive<Archive>
    {
      protected:
        typedef ::boost::archive::detail::common_iarchive<Archive> detail_common_iarchive;
        template < typename T >
        inline void load_override(T &t, int)
        {
          this->detail_common_iarchive::load_override(t, 0);
        }
        inline void load_override(::boost::archive::class_id_optional_type &, int)
        {
        }
        void load_override(::boost::archive::class_name_type &t, int);
        void init();
        inline basic_text_iarchive(unsigned int flags)
          : detail::common_iarchive<Archive>(flags)
        {
        }
        inline ~basic_text_iarchive()
        {
        }
      friend class ::boost::archive::detail::interface_iarchive<Archive>;
    };
    namespace detail {
      struct  adl_tag
      {
      };
      template < typename Archive, typename Serializable >
      struct ptr_serialization_support;
      template < typename Archive, typename Serializable >
      struct  _ptr_serialization_support : ::boost::archive::detail::ptr_serialization_support<Archive, Serializable>
      {
          typedef int type;
      };
      template < typename Serializable >
      void instantiate_ptr_serialization(Serializable *, int, ::boost::archive::detail::adl_tag);
      template < typename Serializable >
      void instantiate_ptr_serialization(Serializable *, int, ::boost::archive::detail::adl_tag)
      {
      }
    }
  }
  namespace serialization {
     class  item_version_type
    {
        typedef unsigned int base_type;
        ::boost::serialization::item_version_type::base_type t;
      public:
        inline item_version_type()
          : t(0)
        {
        }
        inline explicit item_version_type(const unsigned int t_)
          : t(t_)
        {
          static const char __MERCURIUM_PRETTY_FUNCTION__[81L] = "::boost::serialization::item_version_type::item_version_type(const unsigned int)";
          t_ <= ::boost::detail::integer_traits_base<unsigned int, 0, 2147483647 * 2U + 1U>::const_max ? static_cast<void>(0) : ::__assert_fail("t_ <= boost::integer_traits<base_type>::const_max", "/usr/include/boost/serialization/item_version_type.hpp", 33, __MERCURIUM_PRETTY_FUNCTION__);
        }
        inline item_version_type(const ::boost::serialization::item_version_type &t_)
          : t(t_.t)
        {
        }
        inline ::boost::serialization::item_version_type &operator =(::boost::serialization::item_version_type rhs)
        {
          (*this).t = rhs.t;
          return *this;
        }
        inline operator ::boost::serialization::item_version_type::base_type() const 
        {
          return (*this).t;
        }
        inline operator ::boost::serialization::item_version_type::base_type &()
        {
          return (*this).t;
        }
        inline bool operator ==(const ::boost::serialization::item_version_type &rhs) const 
        {
          return (*this).t == rhs.t;
        }
        inline bool operator <(const ::boost::serialization::item_version_type &rhs) const 
        {
          return (*this).t < rhs.t;
        }
    };
    template <>
    struct  is_bitwise_serializable< ::boost::serialization::item_version_type> : ::mpl_::bool_<true>
    {
    };
    template <>
    struct  implementation_level_impl<const ::boost::serialization::item_version_type>
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<1> type;
        static const int value = ::mpl_::int_<1>::value;
    };
 /* Instantiation of class template '::boost::scoped_ptr< ::std::locale>' */ 
 /* Instantiation of class template '::std::basic_streambuf<char>' */ 
 /* Instantiation of class template '::boost::archive::basic_streambuf_locale_saver<char, ::std::char_traits<char> >' */ 
 /* Instantiation of class template '::boost::archive::basic_text_iprimitive< ::std::basic_istream<char> >' */ 
  }
  namespace archive {
    template < typename Archive >
    class  text_iarchive_impl : public ::boost::archive::basic_text_iprimitive< ::std::basic_istream<char> >, public ::boost::archive::basic_text_iarchive<Archive>
    {
      protected:
        template < typename T >
        inline void load(T &t)
        {
          basic_text_iprimitive< ::std::istream>::load(t);
        }
        inline void load(::boost::archive::version_type &t)
        {
          unsigned int v;
          (*this).load(v);
          t = ::boost::archive::version_type(v);
        }
        inline void load(::boost::serialization::item_version_type &t)
        {
          unsigned int v;
          (*this).load(v);
          t = ::boost::serialization::item_version_type(v);
        }
        void load(char *t);
        void load(wchar_t *t);
        void load(::std::string &s);
        void load(::std::wstring &ws);
        template < typename T >
        inline void load_override(T &t, int)
        {
          basic_text_iarchive<Archive>::load_override(t, 0);
        }
        void load_override(::boost::archive::class_name_type &t, int);
        void init();
        text_iarchive_impl(::std::istream &is, unsigned int flags);
        inline ~text_iarchive_impl()
        {
        }
      friend class ::boost::archive::detail::interface_iarchive<Archive>;
      friend class ::boost::archive::basic_text_iarchive<Archive>;
      friend class load_access;
    };
 /* Instantiation of class template '::boost::archive::detail::interface_iarchive<class naked_text_iarchive>' */ 
 /* Instantiation of class template '::boost::archive::detail::common_iarchive<class naked_text_iarchive>' */ 
 /* Instantiation of class template '::boost::archive::basic_text_iarchive<class naked_text_iarchive>' */ 
 /* Instantiation of class template '::boost::archive::text_iarchive_impl<class naked_text_iarchive>' */ 
    class  naked_text_iarchive : public ::boost::archive::text_iarchive_impl< ::boost::archive::naked_text_iarchive>
    {
      public:
        inline naked_text_iarchive(::std::istream &is_, unsigned int flags  = (0))
          : ::boost::archive::text_iarchive_impl< ::boost::archive::naked_text_iarchive>(is_, flags)
        {
        }
        inline ~naked_text_iarchive()
        {
        }
    };
  }
}
namespace std __attribute__((__visibility__("default"))) {
   enum _Rb_tree_color
  {
    _S_red = false,
    _S_black = true
  };
  struct  _Rb_tree_node_base
  {
      typedef ::std::_Rb_tree_node_base *_Base_ptr;
      typedef const ::std::_Rb_tree_node_base *_Const_Base_ptr;
      ::std::_Rb_tree_color _M_color;
      ::std::_Rb_tree_node_base::_Base_ptr _M_parent;
      ::std::_Rb_tree_node_base::_Base_ptr _M_left;
      ::std::_Rb_tree_node_base::_Base_ptr _M_right;
      static inline ::std::_Rb_tree_node_base::_Base_ptr _S_minimum(::std::_Rb_tree_node_base::_Base_ptr __x)
      {
        while ((*__x)._M_left != 0)
          {
            __x = (*__x)._M_left;
          }
        return __x;
      }
      static inline ::std::_Rb_tree_node_base::_Const_Base_ptr _S_minimum(::std::_Rb_tree_node_base::_Const_Base_ptr __x)
      {
        while ((*__x)._M_left != 0)
          {
            __x = (*__x)._M_left;
          }
        return __x;
      }
      static inline ::std::_Rb_tree_node_base::_Base_ptr _S_maximum(::std::_Rb_tree_node_base::_Base_ptr __x)
      {
        while ((*__x)._M_right != 0)
          {
            __x = (*__x)._M_right;
          }
        return __x;
      }
      static inline ::std::_Rb_tree_node_base::_Const_Base_ptr _S_maximum(::std::_Rb_tree_node_base::_Const_Base_ptr __x)
      {
        while ((*__x)._M_right != 0)
          {
            __x = (*__x)._M_right;
          }
        return __x;
      }
  };
  template < typename _Val >
  struct  _Rb_tree_node : ::std::_Rb_tree_node_base
  {
      typedef ::std::_Rb_tree_node<_Val> *_Link_type;
      _Val _M_value_field;
      template < typename ..._Args >
      inline _Rb_tree_node(_Args &&...__args)
        : _Rb_tree_node_base(), _M_value_field(std::forward<_Args>(__args) ...)
      {
      }
  };
  ::std::_Rb_tree_node_base *_Rb_tree_increment(::std::_Rb_tree_node_base *__x) throw() __attribute__((__pure__));
  const ::std::_Rb_tree_node_base *_Rb_tree_increment(const ::std::_Rb_tree_node_base *__x) throw() __attribute__((__pure__));
  ::std::_Rb_tree_node_base *_Rb_tree_decrement(::std::_Rb_tree_node_base *__x) throw() __attribute__((__pure__));
  const ::std::_Rb_tree_node_base *_Rb_tree_decrement(const ::std::_Rb_tree_node_base *__x) throw() __attribute__((__pure__));
  template < typename _Tp >
  struct  _Rb_tree_iterator
  {
      typedef _Tp value_type;
      typedef _Tp &reference;
      typedef _Tp *pointer;
      typedef ::std::bidirectional_iterator_tag iterator_category;
      typedef ::std::ptrdiff_t difference_type;
      typedef ::std::_Rb_tree_iterator<_Tp> _Self;
      typedef ::std::_Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef ::std::_Rb_tree_node<_Tp> *_Link_type;
      inline _Rb_tree_iterator()
        : _M_node()
      {
      }
      inline explicit _Rb_tree_iterator(typename ::std::_Rb_tree_iterator<_Tp>::_Link_type __x)
        : _M_node(__x)
      {
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::reference operator *() const 
      {
        return static_cast<typename ::std::_Rb_tree_iterator<_Tp>::_Link_type>(::std::_Rb_tree_iterator<_Tp>::_M_node)->_M_value_field;
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::pointer operator ->() const 
      {
        return std::__addressof(static_cast<typename ::std::_Rb_tree_iterator<_Tp>::_Link_type>(::std::_Rb_tree_iterator<_Tp>::_M_node)->_M_value_field);
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::_Self &operator ++()
      {
        ::std::_Rb_tree_iterator<_Tp>::_M_node = _Rb_tree_increment(::std::_Rb_tree_iterator<_Tp>::_M_node);
        return *this;
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::_Self operator ++(int)
      {
        typename ::std::_Rb_tree_iterator<_Tp>::_Self __tmp = *this;
        ::std::_Rb_tree_iterator<_Tp>::_M_node = _Rb_tree_increment(::std::_Rb_tree_iterator<_Tp>::_M_node);
        return __tmp;
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::_Self &operator --()
      {
        ::std::_Rb_tree_iterator<_Tp>::_M_node = _Rb_tree_decrement(::std::_Rb_tree_iterator<_Tp>::_M_node);
        return *this;
      }
      inline typename ::std::_Rb_tree_iterator<_Tp>::_Self operator --(int)
      {
        typename ::std::_Rb_tree_iterator<_Tp>::_Self __tmp = *this;
        ::std::_Rb_tree_iterator<_Tp>::_M_node = _Rb_tree_decrement(::std::_Rb_tree_iterator<_Tp>::_M_node);
        return __tmp;
      }
      inline bool operator ==(const typename ::std::_Rb_tree_iterator<_Tp>::_Self &__x) const 
      {
        return ::std::_Rb_tree_iterator<_Tp>::_M_node == __x._M_node;
      }
      inline bool operator !=(const typename ::std::_Rb_tree_iterator<_Tp>::_Self &__x) const 
      {
        return ::std::_Rb_tree_iterator<_Tp>::_M_node != __x._M_node;
      }
      typename ::std::_Rb_tree_iterator<_Tp>::_Base_ptr _M_node;
  };
  template < typename _Tp >
  struct  _Rb_tree_const_iterator
  {
      typedef _Tp value_type;
      typedef const _Tp &reference;
      typedef const _Tp *pointer;
      typedef ::std::_Rb_tree_iterator<_Tp> iterator;
      typedef ::std::bidirectional_iterator_tag iterator_category;
      typedef ::std::ptrdiff_t difference_type;
      typedef ::std::_Rb_tree_const_iterator<_Tp> _Self;
      typedef ::std::_Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const ::std::_Rb_tree_node<_Tp> *_Link_type;
      inline _Rb_tree_const_iterator()
        : _M_node()
      {
      }
      inline explicit _Rb_tree_const_iterator(typename ::std::_Rb_tree_const_iterator<_Tp>::_Link_type __x)
        : _M_node(__x)
      {
      }
      inline _Rb_tree_const_iterator(const typename ::std::_Rb_tree_const_iterator<_Tp>::iterator &__it)
        : _M_node(__it._M_node)
      {
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::iterator _M_const_cast() const 
      {
        return ((typename ::std::_Rb_tree_const_iterator<_Tp>::iterator(static_cast<typename ::std::_Rb_tree_iterator<_Tp>::_Link_type>(const_cast<typename ::std::_Rb_tree_iterator<_Tp>::_Base_ptr>(::std::_Rb_tree_const_iterator<_Tp>::_M_node)))));
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::reference operator *() const 
      {
        return static_cast<typename ::std::_Rb_tree_const_iterator<_Tp>::_Link_type>(::std::_Rb_tree_const_iterator<_Tp>::_M_node)->_M_value_field;
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::pointer operator ->() const 
      {
        return std::__addressof(static_cast<typename ::std::_Rb_tree_const_iterator<_Tp>::_Link_type>(::std::_Rb_tree_const_iterator<_Tp>::_M_node)->_M_value_field);
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::_Self &operator ++()
      {
        ::std::_Rb_tree_const_iterator<_Tp>::_M_node = _Rb_tree_increment(::std::_Rb_tree_const_iterator<_Tp>::_M_node);
        return *this;
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::_Self operator ++(int)
      {
        typename ::std::_Rb_tree_const_iterator<_Tp>::_Self __tmp = *this;
        ::std::_Rb_tree_const_iterator<_Tp>::_M_node = _Rb_tree_increment(::std::_Rb_tree_const_iterator<_Tp>::_M_node);
        return __tmp;
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::_Self &operator --()
      {
        ::std::_Rb_tree_const_iterator<_Tp>::_M_node = _Rb_tree_decrement(::std::_Rb_tree_const_iterator<_Tp>::_M_node);
        return *this;
      }
      inline typename ::std::_Rb_tree_const_iterator<_Tp>::_Self operator --(int)
      {
        typename ::std::_Rb_tree_const_iterator<_Tp>::_Self __tmp = *this;
        ::std::_Rb_tree_const_iterator<_Tp>::_M_node = _Rb_tree_decrement(::std::_Rb_tree_const_iterator<_Tp>::_M_node);
        return __tmp;
      }
      inline bool operator ==(const typename ::std::_Rb_tree_const_iterator<_Tp>::_Self &__x) const 
      {
        return ::std::_Rb_tree_const_iterator<_Tp>::_M_node == __x._M_node;
      }
      inline bool operator !=(const typename ::std::_Rb_tree_const_iterator<_Tp>::_Self &__x) const 
      {
        return ::std::_Rb_tree_const_iterator<_Tp>::_M_node != __x._M_node;
      }
      typename ::std::_Rb_tree_const_iterator<_Tp>::_Base_ptr _M_node;
  };
  template < typename _Val >
  inline bool operator ==(const ::std::_Rb_tree_iterator<_Val> &__x, const ::std::_Rb_tree_const_iterator<_Val> &__y);
  template < typename _Val >
  inline bool operator ==(const ::std::_Rb_tree_iterator<_Val> &__x, const ::std::_Rb_tree_const_iterator<_Val> &__y)
  {
    return __x._M_node == __y._M_node;
  }
  template < typename _Val >
  inline bool operator !=(const ::std::_Rb_tree_iterator<_Val> &__x, const ::std::_Rb_tree_const_iterator<_Val> &__y);
  template < typename _Val >
  inline bool operator !=(const ::std::_Rb_tree_iterator<_Val> &__x, const ::std::_Rb_tree_const_iterator<_Val> &__y)
  {
    return __x._M_node != __y._M_node;
  }
  void _Rb_tree_insert_and_rebalance(const bool __insert_left, ::std::_Rb_tree_node_base *__x, ::std::_Rb_tree_node_base *__p, ::std::_Rb_tree_node_base &__header) throw();
  ::std::_Rb_tree_node_base *_Rb_tree_rebalance_for_erase(::std::_Rb_tree_node_base *const __z, ::std::_Rb_tree_node_base &__header) throw();
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc = ::std::allocator<_Val> >
  class  _Rb_tree
  {
      typedef typename _Alloc::template rebind< ::std::_Rb_tree_node<_Val> >::other _Node_allocator;
    protected:
      typedef ::std::_Rb_tree_node_base *_Base_ptr;
      typedef const ::std::_Rb_tree_node_base *_Const_Base_ptr;
    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type *pointer;
      typedef const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type *const_pointer;
      typedef typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &reference;
      typedef const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type &const_reference;
      typedef ::std::_Rb_tree_node<_Val> *_Link_type;
      typedef const ::std::_Rb_tree_node<_Val> *_Const_Link_type;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator &_M_get_Node_allocator() noexcept(true)
      {
        return *static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator *>(&this->_M_impl);
      }
      inline const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator &_M_get_Node_allocator() const  noexcept(true)
      {
        return *static_cast<const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator *>(&this->_M_impl);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::allocator_type get_allocator() const  noexcept(true)
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::allocator_type((*this)._M_get_Node_allocator())));
      }
    protected:
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_get_node()
      {
        return ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._Node_allocator::allocate(1);
      }
      inline void _M_put_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __p)
      {
        ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._Node_allocator::deallocate(__p, 1);
      }
      template < typename ..._Args >
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_create_node(_Args &&...__args)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __tmp = (*this)._M_get_node();
        try
        {
          allocator_traits<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator>::construct((*this)._M_get_Node_allocator(), __tmp, std::forward<_Args>(__args) ...);
        }
        catch (...)
        {
          (*this)._M_put_node(__tmp);
          throw;
        }
        return __tmp;
      }
      inline void _M_destroy_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __p)
      {
        (*this)._M_get_Node_allocator().destroy(__p);
        (*this)._M_put_node(__p);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_clone_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __tmp = (*this)._M_create_node(__x->_M_value_field);
        __tmp->_M_color = __x->_M_color;
        __tmp->_M_left = 0;
        __tmp->_M_right = 0;
        return __tmp;
      }
      template < typename _Key_compare, bool _Is_pod_comparator = __is_pod(_Key_compare) >
      struct  _Rb_tree_impl : ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator
      {
          _Key_compare _M_key_compare;
          ::std::_Rb_tree_node_base _M_header;
          typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type _M_node_count;
          inline _Rb_tree_impl()
            : _Node_allocator(), _M_key_compare(), _M_header(), _M_node_count(0)
          {
            (*this)._M_initialize();
          }
          inline _Rb_tree_impl(const _Key_compare &__comp, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator &__a)
            : _Node_allocator(__a), _M_key_compare(__comp), _M_header(), _M_node_count(0)
          {
            (*this)._M_initialize();
          }
          inline _Rb_tree_impl(const _Key_compare &__comp, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator &&__a)
            : _Node_allocator(std::move(__a)), _M_key_compare(__comp), _M_header(), _M_node_count(0)
          {
            (*this)._M_initialize();
          }
        private:
          inline void _M_initialize()
          {
            this->_M_header._M_color = ::std::_S_red;
            this->_M_header._M_parent = 0;
            this->_M_header._M_left = &this->_M_header;
            this->_M_header._M_right = &this->_M_header;
          }
      };
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::template _Rb_tree_impl<_Compare> _M_impl;
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr &_M_root()
      {
        return this->_M_impl._M_header._M_parent;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _M_root() const 
      {
        return this->_M_impl._M_header._M_parent;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr &_M_leftmost()
      {
        return this->_M_impl._M_header._M_left;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _M_leftmost() const 
      {
        return this->_M_impl._M_header._M_left;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr &_M_rightmost()
      {
        return this->_M_impl._M_header._M_right;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _M_rightmost() const 
      {
        return this->_M_impl._M_header._M_right;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_begin()
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(this->_M_impl._M_header._M_parent);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type _M_begin() const 
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(this->_M_impl._M_header._M_parent);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_end()
      {
        return reinterpret_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(&this->_M_impl._M_header);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type _M_end() const 
      {
        return reinterpret_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(&this->_M_impl._M_header);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reference _S_value(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x)
      {
        return __x->_M_value_field;
      }
      static inline const _Key &_S_key(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x)
      {
        return _KeyOfValue()(_S_value(__x));
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _S_left(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x)
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>((*__x)._M_left);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type _S_left(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>((*__x)._M_left);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _S_right(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x)
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>((*__x)._M_right);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type _S_right(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>((*__x)._M_right);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reference _S_value(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(__x)->_M_value_field;
      }
      static inline const _Key &_S_key(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return _KeyOfValue()(_S_value(__x));
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr _S_minimum(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x)
      {
        return _Rb_tree_node_base::_S_minimum(__x);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _S_minimum(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return _Rb_tree_node_base::_S_minimum(__x);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr _S_maximum(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x)
      {
        return _Rb_tree_node_base::_S_maximum(__x);
      }
      static inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr _S_maximum(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Base_ptr __x)
      {
        return _Rb_tree_node_base::_S_maximum(__x);
      }
    public:
      typedef ::std::_Rb_tree_iterator<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type> iterator;
      typedef ::std::_Rb_tree_const_iterator<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::value_type> const_iterator;
      typedef ::std::reverse_iterator<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator> reverse_iterator;
      typedef ::std::reverse_iterator<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator> const_reverse_iterator;
    private:
      ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _M_get_insert_unique_pos(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k);
      ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _M_get_insert_equal_pos(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k);
      ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _M_get_insert_hint_unique_pos(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k);
      ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _M_get_insert_hint_equal_pos(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k);
      template < typename _Arg >
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, _Arg &&__v);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z);
      template < typename _Arg >
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_lower(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, _Arg &&__v);
      template < typename _Arg >
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_equal_lower(_Arg &&__v);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_lower_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_equal_lower_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type _M_copy(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __p);
      void _M_erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_lower_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y, const _Key &__k);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _M_lower_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __y, const _Key &__k) const ;
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_upper_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y, const _Key &__k);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _M_upper_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __y, const _Key &__k) const ;
    public:
      inline _Rb_tree()
      {
      }
      inline _Rb_tree(const _Compare &__comp, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::allocator_type &__a  = (((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::allocator_type()))))
        : _M_impl(__comp, ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator(__a))))
      {
      }
      inline _Rb_tree(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x)
        : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
        if (__x._M_root() != 0)
          {
            (*this)._M_root() = (*this)._M_copy(__x._M_begin(), (*this)._M_end());
            (*this)._M_leftmost() = _S_minimum((*this)._M_root());
            (*this)._M_rightmost() = _S_maximum((*this)._M_root());
            ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count = __x._M_impl._M_node_count;
          }
      }
      _Rb_tree(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &&__x);
      inline ~_Rb_tree() noexcept(true)
      {
        (*this)._M_erase((*this)._M_begin());
      }
      ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &operator =(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x);
      inline _Compare key_comp() const 
      {
        return ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator begin() noexcept(true)
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(this->_M_impl._M_header._M_left))));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator begin() const  noexcept(true)
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(this->_M_impl._M_header._M_left))));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator end() noexcept(true)
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(&this->_M_impl._M_header))));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator end() const  noexcept(true)
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(&this->_M_impl._M_header))));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::reverse_iterator rbegin() noexcept(true)
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::reverse_iterator((*this).end())));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reverse_iterator rbegin() const  noexcept(true)
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reverse_iterator((*this).end())));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::reverse_iterator rend() noexcept(true)
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::reverse_iterator((*this).begin())));
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reverse_iterator rend() const  noexcept(true)
      {
        return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_reverse_iterator((*this).begin())));
      }
      inline bool empty() const  noexcept(true)
      {
        return ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count == 0;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type size() const  noexcept(true)
      {
        return ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count;
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type max_size() const  noexcept(true)
      {
        return (*this)._M_get_Node_allocator().max_size();
      }
      void swap(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__t);
      template < typename _Arg >
      ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, bool> _M_insert_unique(_Arg &&__v);
      template < typename _Arg >
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_equal(_Arg &&__v);
      template < typename _Arg >
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_unique_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, _Arg &&__v);
      template < typename _Arg >
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_insert_equal_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, _Arg &&__v);
      template < typename ..._Args >
      ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, bool> _M_emplace_unique(_Args &&...__args);
      template < typename ..._Args >
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_emplace_equal(_Args &&...__args);
      template < typename ..._Args >
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_emplace_hint_unique(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __pos, _Args &&...__args);
      template < typename ..._Args >
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _M_emplace_hint_equal(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __pos, _Args &&...__args);
      template < typename _InputIterator >
      void _M_insert_unique(_InputIterator __first, _InputIterator __last);
      template < typename _InputIterator >
      void _M_insert_equal(_InputIterator __first, _InputIterator __last);
    private:
      void _M_erase_aux(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position);
      void _M_erase_aux(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __first, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __last);
    public:
      inline __attribute__((__abi_tag__("cxx11"))) typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __result = __position;
         ++__result;
        (*this)._M_erase_aux(__position);
        return __result._M_const_cast();
      }
      inline __attribute__((__abi_tag__("cxx11"))) typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __position)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __result = __position;
         ++__result;
        (*this)._M_erase_aux(__position);
        return __result;
      }
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type erase(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__x);
      inline __attribute__((__abi_tag__("cxx11"))) typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __first, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __last)
      {
        (*this)._M_erase_aux(__first, __last);
        return __last._M_const_cast();
      }
      void erase(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type *__first, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type *__last);
      inline void clear() noexcept(true)
      {
        (*this)._M_erase((*this)._M_begin());
        (*this)._M_leftmost() = (*this)._M_end();
        (*this)._M_root() = 0;
        (*this)._M_rightmost() = (*this)._M_end();
        ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count = 0;
      }
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator find(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k);
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator find(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const ;
      typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type count(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const ;
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator lower_bound(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k)
      {
        return (*this)._M_lower_bound((*this)._M_begin(), (*this)._M_end(), __k);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator lower_bound(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const 
      {
        return (*this)._M_lower_bound((*this)._M_begin(), (*this)._M_end(), __k);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator upper_bound(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k)
      {
        return (*this)._M_upper_bound((*this)._M_begin(), (*this)._M_end(), __k);
      }
      inline typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator upper_bound(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const 
      {
        return (*this)._M_upper_bound((*this)._M_begin(), (*this)._M_end(), __k);
      }
      ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator> equal_range(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k);
      ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator> equal_range(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k) const ;
      bool __rb_verify() const ;
  };
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline void swap(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  inline void swap(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x, ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__y)
  {
    __x.swap(__y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Rb_tree(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &&__x)
    : _M_impl(__x._M_impl._M_key_compare, std::move(__x._M_get_Node_allocator()))
  {
    if (__x._M_root() != 0)
      {
        (*this)._M_root() = __x._M_root();
        (*this)._M_leftmost() = __x._M_leftmost();
        (*this)._M_rightmost() = __x._M_rightmost();
        (*this)._M_root()->_M_parent = (*this)._M_end();
        __x._M_root() = 0;
        __x._M_leftmost() = __x._M_end();
        __x._M_rightmost() = __x._M_end();
        this->_M_impl._M_node_count = __x._M_impl._M_node_count;
        __x._M_impl._M_node_count = 0;
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::operator =(const ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__x)
  {
    if (this != &__x)
      {
        (*this).clear();
        ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare = __x._M_impl._M_key_compare;
        if (__x._M_root() != 0)
          {
            (*this)._M_root() = (*this)._M_copy(__x._M_begin(), (*this)._M_end());
            (*this)._M_leftmost() = _S_minimum((*this)._M_root());
            (*this)._M_rightmost() = _S_maximum((*this)._M_root());
            ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count = __x._M_impl._M_node_count;
          }
      }
    return *this;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  template < typename _Arg >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, _Arg &&__v)
  {
    bool __insert_left = (__x != 0 || __p == (*this)._M_end()) || ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__p));
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z = (*this)._M_create_node(std::forward<_Arg>(__v));
    _Rb_tree_insert_and_rebalance(__insert_left, __z, __p, this->_M_impl._M_header);
     ++::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count;
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__z)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  template < typename _Arg >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_lower(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, _Arg &&__v)
  {
    bool __insert_left = __p == (*this)._M_end() || !::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__p), _KeyOfValue()(__v));
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z = (*this)._M_create_node(std::forward<_Arg>(__v));
    _Rb_tree_insert_and_rebalance(__insert_left, __z, __p, this->_M_impl._M_header);
     ++::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count;
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__z)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  template < typename _Arg >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_equal_lower(_Arg &&__v)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x = (*this)._M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = (*this)._M_end();
    while (__x != 0)
      {
        __y = __x;
        __x = !::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ? _S_left(__x) : _S_right(__x);
      }
    return (*this)._M_insert_lower(__y, std::forward<_Arg>(__v));
  }
  template < typename _Key, typename _Val, typename _KoV, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_M_copy(typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type __p)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type __top = (*this)._M_clone_node(__x);
    __top->_M_parent = __p;
    try
    {
      if (__x->_M_right)
        {
          __top->_M_right = (*this)._M_copy(_S_right(__x), __top);
        }
      __p = __top;
      __x = _S_left(__x);
      while (__x != 0)
        {
          typename ::std::_Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type __y = (*this)._M_clone_node(__x);
          __p->_M_left = __y;
          __y->_M_parent = __p;
          if (__x->_M_right)
            {
              __y->_M_right = (*this)._M_copy(_S_right(__x), __y);
            }
          __p = __y;
          __x = _S_left(__x);
        }
    }
    catch (...)
    {
      (*this)._M_erase(__top);
      throw;
    }
    return __top;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_erase(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x)
  {
    while (__x != 0)
      {
        (*this)._M_erase(_S_right(__x));
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = _S_left(__x);
        (*this)._M_destroy_node(__x);
        __x = __y;
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_lower_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y, const _Key &__k)
  {
    while (__x != 0)
      {
        if (!::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__x), __k))
          {
            (__y = __x, __x = _S_left(__x));
          }
        else
          {
            __x = _S_right(__x);
          }
      }
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_lower_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __y, const _Key &__k) const 
  {
    while (__x != 0)
      {
        if (!::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__x), __k))
          {
            (__y = __x, __x = _S_left(__x));
          }
        else
          {
            __x = _S_right(__x);
          }
      }
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(__y)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_upper_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y, const _Key &__k)
  {
    while (__x != 0)
      {
        if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__x)))
          {
            (__y = __x, __x = _S_left(__x));
          }
        else
          {
            __x = _S_right(__x);
          }
      }
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_upper_bound(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __y, const _Key &__k) const 
  {
    while (__x != 0)
      {
        if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__x)))
          {
            (__y = __x, __x = _S_left(__x));
          }
        else
          {
            __x = _S_right(__x);
          }
      }
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(__y)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::equal_range(const _Key &__k)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x = (*this)._M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = (*this)._M_end();
    while (__x != 0)
      {
        if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__x), __k))
          {
            __x = _S_right(__x);
          }
        else
          {
            if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__x)))
              {
                (__y = __x, __x = _S_left(__x));
              }
            else
              {
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __xu(__x);
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __yu(__y);
                (__y = __x, __x = _S_left(__x));
                __xu = _S_right(__xu);
                return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>((*this)._M_lower_bound(__x, __y, __k), (*this)._M_upper_bound(__xu, __yu, __k));
              }
          }
      }
    return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>(((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y))), ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y))));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::equal_range(const _Key &__k) const 
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x = (*this)._M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __y = (*this)._M_end();
    while (__x != 0)
      {
        if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__x), __k))
          {
            __x = _S_right(__x);
          }
        else
          {
            if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__x)))
              {
                (__y = __x, __x = _S_left(__x));
              }
            else
              {
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __xu(__x);
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __yu(__y);
                (__y = __x, __x = _S_left(__x));
                __xu = _S_right(__xu);
                return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator>((*this)._M_lower_bound(__x, __y, __k), (*this)._M_upper_bound(__xu, __yu, __k));
              }
          }
      }
    return ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator>(((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(__y))), ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator(__y))));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::swap(::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &__t)
  {
    if ((*this)._M_root() == 0)
      {
        if (__t._M_root() != 0)
          {
            (*this)._M_root() = __t._M_root();
            (*this)._M_leftmost() = __t._M_leftmost();
            (*this)._M_rightmost() = __t._M_rightmost();
            (*this)._M_root()->_M_parent = (*this)._M_end();
            __t._M_root() = 0;
            __t._M_leftmost() = __t._M_end();
            __t._M_rightmost() = __t._M_end();
          }
      }
    else
      {
        if (__t._M_root() == 0)
          {
            __t._M_root() = (*this)._M_root();
            __t._M_leftmost() = (*this)._M_leftmost();
            __t._M_rightmost() = (*this)._M_rightmost();
            __t._M_root()->_M_parent = __t._M_end();
            (*this)._M_root() = 0;
            (*this)._M_leftmost() = (*this)._M_end();
            (*this)._M_rightmost() = (*this)._M_end();
          }
        else
          {
            std::swap((*this)._M_root(), __t._M_root());
            std::swap((*this)._M_leftmost(), __t._M_leftmost());
            std::swap((*this)._M_rightmost(), __t._M_rightmost());
            (*this)._M_root()->_M_parent = (*this)._M_end();
            __t._M_root()->_M_parent = __t._M_end();
          }
      }
    std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
    std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
    std::__alloc_swap<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Node_allocator>::_S_do_it((*this)._M_get_Node_allocator(), __t._M_get_Node_allocator());
  }
 /* Instantiation of class template '::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::remove_volatile< ::std::_Rb_tree_node_base *const &>' */ 
 /* Instantiation of class template '::std::remove_const< ::std::_Rb_tree_node_base *const &>' */ 
 /* Instantiation of class template '::std::remove_cv< ::std::_Rb_tree_node_base *const &>' */ 
 /* Instantiation of class template '::std::__is_void_helper< ::std::_Rb_tree_node_base *const &>' */ 
 /* Instantiation of class template '::std::is_void< ::std::_Rb_tree_node_base *const &>' */ 
 /* Instantiation of class template '::std::conditional<false, ::std::is_void< ::std::_Rb_tree_node_base *const &>, ::std::__or_< ::std::is_function< ::std::_Rb_tree_node_base *>, ::std::is_array< ::std::_Rb_tree_node_base *> > >' */ 
 /* Instantiation of class template '::std::is_function< ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::conditional<false, ::std::is_function< ::std::_Rb_tree_node_base *>, ::std::is_array< ::std::_Rb_tree_node_base *> >' */ 
 /* Instantiation of class template '::std::is_array< ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::__or_< ::std::is_function< ::std::_Rb_tree_node_base *>, ::std::is_array< ::std::_Rb_tree_node_base *> >' */ 
 /* Instantiation of class template '::std::__or_< ::std::is_void< ::std::_Rb_tree_node_base *const &>, ::std::is_function< ::std::_Rb_tree_node_base *>, ::std::is_array< ::std::_Rb_tree_node_base *> >' */ 
 /* Instantiation of class template '::std::is_lvalue_reference< ::std::_Rb_tree_node_base *const &>' */ 
 /* Instantiation of class template '::std::conditional<true, ::std::is_lvalue_reference< ::std::_Rb_tree_node_base *const &>, ::std::is_rvalue_reference< ::std::_Rb_tree_node_base *const &> >' */ 
 /* Instantiation of class template '::std::__or_< ::std::is_lvalue_reference< ::std::_Rb_tree_node_base *const &>, ::std::is_rvalue_reference< ::std::_Rb_tree_node_base *const &> >' */ 
 /* Instantiation of class template '::std::is_reference< ::std::_Rb_tree_node_base *const &>' */ 
 /* Instantiation of class template '::std::__not_< ::std::is_reference< ::std::_Rb_tree_node_base *const &> >' */ 
 /* Instantiation of class template '::std::conditional<false, ::std::__not_< ::std::is_void< ::std::_Rb_tree_node_base *const &> >, ::std::__not_< ::std::is_reference< ::std::_Rb_tree_node_base *const &> > >' */ 
 /* Instantiation of class template '::std::__and_< ::std::__not_< ::std::is_reference< ::std::_Rb_tree_node_base *const &> >, ::std::__not_< ::std::is_void< ::std::_Rb_tree_node_base *const &> > >' */ 
 /* Instantiation of class template '::std::__add_rvalue_reference_helper< ::std::_Rb_tree_node_base *const &, false>' */ 
 /* Instantiation of class template '::std::add_rvalue_reference< ::std::_Rb_tree_node_base *const &>' */ 
 /* Instantiation of class template '::std::__is_convertible_helper< ::std::_Rb_tree_node_base *const &, ::std::_Rb_tree_node_base *, false>' */ 
 /* Instantiation of class template '::std::is_convertible< ::std::_Rb_tree_node_base *const &, ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::conditional<true, ::std::is_convertible< ::std::_Rb_tree_node_base *const &, ::std::_Rb_tree_node_base *>, ::std::is_convertible< ::std::_Rb_tree_node_base *const &, ::std::_Rb_tree_node_base *> >' */ 
 /* Instantiation of class template '::std::__and_< ::std::is_convertible< ::std::_Rb_tree_node_base *const &, ::std::_Rb_tree_node_base *>, ::std::is_convertible< ::std::_Rb_tree_node_base *const &, ::std::_Rb_tree_node_base *> >' */ 
 /* Instantiation of class template '::std::enable_if<true, void>' */ 
 /* Instantiation of class template '::std::remove_volatile< ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::remove_const< ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::remove_cv< ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::__is_void_helper< ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::is_void< ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::conditional<false, ::std::is_void< ::std::_Rb_tree_node_base *>, ::std::__or_< ::std::is_function< ::std::_Rb_tree_node_base *>, ::std::is_array< ::std::_Rb_tree_node_base *> > >' */ 
 /* Instantiation of class template '::std::__or_< ::std::is_void< ::std::_Rb_tree_node_base *>, ::std::is_function< ::std::_Rb_tree_node_base *>, ::std::is_array< ::std::_Rb_tree_node_base *> >' */ 
 /* Instantiation of class template '::std::is_lvalue_reference< ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::conditional<false, ::std::is_lvalue_reference< ::std::_Rb_tree_node_base *>, ::std::is_rvalue_reference< ::std::_Rb_tree_node_base *> >' */ 
 /* Instantiation of class template '::std::is_rvalue_reference< ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::__or_< ::std::is_lvalue_reference< ::std::_Rb_tree_node_base *>, ::std::is_rvalue_reference< ::std::_Rb_tree_node_base *> >' */ 
 /* Instantiation of class template '::std::is_reference< ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::__not_< ::std::is_reference< ::std::_Rb_tree_node_base *> >' */ 
 /* Instantiation of class template '::std::conditional<true, ::std::__not_< ::std::is_void< ::std::_Rb_tree_node_base *> >, ::std::__not_< ::std::is_reference< ::std::_Rb_tree_node_base *> > >' */ 
 /* Instantiation of class template '::std::__not_< ::std::is_void< ::std::_Rb_tree_node_base *> >' */ 
 /* Instantiation of class template '::std::__and_< ::std::__not_< ::std::is_reference< ::std::_Rb_tree_node_base *> >, ::std::__not_< ::std::is_void< ::std::_Rb_tree_node_base *> > >' */ 
 /* Instantiation of class template '::std::__add_rvalue_reference_helper< ::std::_Rb_tree_node_base *, true>' */ 
 /* Instantiation of class template '::std::add_rvalue_reference< ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::__is_convertible_helper< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *, false>' */ 
 /* Instantiation of class template '::std::is_convertible< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::conditional<true, ::std::is_convertible< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *>, ::std::is_convertible< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> >' */ 
 /* Instantiation of class template '::std::__and_< ::std::is_convertible< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *>, ::std::is_convertible< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> >' */ 
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_unique_pos(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k)
  {
    typedef ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Res;
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x = (*this)._M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = (*this)._M_end();
    bool __comp(true);
    while (__x != 0)
      {
        __y = __x;
        __comp = ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__x));
        __x = __comp ? _S_left(__x) : _S_right(__x);
      }
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __j = ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__y)));
    if (__comp)
      {
        if (__j == (*this).begin())
          {
            return _Res(__x, __y);
          }
        else
          {
             --__j;
          }
      }
    if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__j._M_node), __k))
      {
        return _Res(__x, __y);
      }
    return _Res(__j._M_node, 0);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_equal_pos(const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k)
  {
    typedef ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Res;
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x = (*this)._M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = (*this)._M_end();
    while (__x != 0)
      {
        __y = __x;
        __x = ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__x)) ? _S_left(__x) : _S_right(__x);
      }
    return _Res(__x, __y);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  template < typename _Arg >
  ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, bool> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_unique(_Arg &&__v)
  {
    typedef ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, bool> _Res;
    ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> __res = (*this)._M_get_insert_unique_pos(_KeyOfValue()(__v));
    if (__res.second)
      {
        return _Res((*this)._M_insert_(__res.first, __res.second, std::forward<_Arg>(__v)), true);
      }
    return _Res(((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(__res.first)))), false);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  template < typename _Arg >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_equal(_Arg &&__v)
  {
    ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> __res = (*this)._M_get_insert_equal_pos(_KeyOfValue()(__v));
    return (*this)._M_insert_(__res.first, __res.second, std::forward<_Arg>(__v));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_hint_unique_pos(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __pos = __position._M_const_cast();
    typedef ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Res;
    if (__pos._M_node == (*this)._M_end())
      {
        if ((*this).size() > 0 && ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key((*this)._M_rightmost()), __k))
          {
            return _Res(0, (*this)._M_rightmost());
          }
        else
          {
            return (*this)._M_get_insert_unique_pos(__k);
          }
      }
    else
      {
        if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
          {
            typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __before = __pos;
            if (__pos._M_node == (*this)._M_leftmost())
              {
                return _Res((*this)._M_leftmost(), (*this)._M_leftmost());
              }
            else
              {
                if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(( --__before)._M_node), __k))
                  {
                    if (_S_right(__before._M_node) == 0)
                      {
                        return _Res(0, __before._M_node);
                      }
                    else
                      {
                        return _Res(__pos._M_node, __pos._M_node);
                      }
                  }
                else
                  {
                    return (*this)._M_get_insert_unique_pos(__k);
                  }
              }
          }
        else
          {
            if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
              {
                typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __after = __pos;
                if (__pos._M_node == (*this)._M_rightmost())
                  {
                    return _Res(0, (*this)._M_rightmost());
                  }
                else
                  {
                    if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(( ++__after)._M_node)))
                      {
                        if (_S_right(__pos._M_node) == 0)
                          {
                            return _Res(0, __pos._M_node);
                          }
                        else
                          {
                            return _Res(__after._M_node, __after._M_node);
                          }
                      }
                    else
                      {
                        return (*this)._M_get_insert_unique_pos(__k);
                      }
                  }
              }
            else
              {
                return _Res(__pos._M_node, 0);
              }
          }
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  template < typename _Arg >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_unique_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, _Arg &&__v)
  {
    ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> __res = (*this)._M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));
    if (__res.second)
      {
        return (*this)._M_insert_(__res.first, __res.second, std::forward<_Arg>(__v));
      }
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(__res.first))));
  }
 /* Instantiation of class template '::std::remove_volatile<int>' */ 
 /* Instantiation of class template '::std::remove_const<int>' */ 
 /* Instantiation of class template '::std::remove_cv<int>' */ 
 /* Instantiation of class template '::std::__is_void_helper<int>' */ 
 /* Instantiation of class template '::std::is_void<int>' */ 
 /* Instantiation of class template '::std::conditional<false, ::std::is_void<int>, ::std::__or_< ::std::is_function< ::std::_Rb_tree_node_base *>, ::std::is_array< ::std::_Rb_tree_node_base *> > >' */ 
 /* Instantiation of class template '::std::__or_< ::std::is_void<int>, ::std::is_function< ::std::_Rb_tree_node_base *>, ::std::is_array< ::std::_Rb_tree_node_base *> >' */ 
 /* Instantiation of class template '::std::is_lvalue_reference<int>' */ 
 /* Instantiation of class template '::std::conditional<false, ::std::is_lvalue_reference<int>, ::std::is_rvalue_reference<int> >' */ 
 /* Instantiation of class template '::std::is_rvalue_reference<int>' */ 
 /* Instantiation of class template '::std::__or_< ::std::is_lvalue_reference<int>, ::std::is_rvalue_reference<int> >' */ 
 /* Instantiation of class template '::std::is_reference<int>' */ 
 /* Instantiation of class template '::std::__not_< ::std::is_reference<int> >' */ 
 /* Instantiation of class template '::std::conditional<true, ::std::__not_< ::std::is_void<int> >, ::std::__not_< ::std::is_reference<int> > >' */ 
 /* Instantiation of class template '::std::__not_< ::std::is_void<int> >' */ 
 /* Instantiation of class template '::std::__and_< ::std::__not_< ::std::is_reference<int> >, ::std::__not_< ::std::is_void<int> > >' */ 
 /* Instantiation of class template '::std::__add_rvalue_reference_helper<int, true>' */ 
 /* Instantiation of class template '::std::add_rvalue_reference<int>' */ 
 /* Instantiation of class template '::std::__is_convertible_helper<int, ::std::_Rb_tree_node_base *, false>' */ 
 /* Instantiation of class template '::std::is_convertible<int, ::std::_Rb_tree_node_base *>' */ 
 /* Instantiation of class template '::std::enable_if<false, void>' */ 
 /* Instantiation of class template '::std::conditional<false, ::std::is_convertible<int, ::std::_Rb_tree_node_base *>, ::std::is_convertible<int, ::std::_Rb_tree_node_base *> >' */ 
 /* Instantiation of class template '::std::__and_< ::std::is_convertible<int, ::std::_Rb_tree_node_base *>, ::std::is_convertible<int, ::std::_Rb_tree_node_base *> >' */ 
 /* Instantiation of template function '::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *>::pair(::std::_Rb_tree_node_base *const &, ::std::_Rb_tree_node_base *const &)' */ 
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_hint_equal_pos(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type &__k)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __pos = __position._M_const_cast();
    typedef ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> _Res;
    if (__pos._M_node == (*this)._M_end())
      {
        if ((*this).size() > 0 && !::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key((*this)._M_rightmost())))
          {
            return _Res(0, (*this)._M_rightmost());
          }
        else
          {
            return (*this)._M_get_insert_equal_pos(__k);
          }
      }
    else
      {
        if (!::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
          {
            typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __before = __pos;
            if (__pos._M_node == (*this)._M_leftmost())
              {
                return _Res((*this)._M_leftmost(), (*this)._M_leftmost());
              }
            else
              {
                if (!::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(( --__before)._M_node)))
                  {
                    if (_S_right(__before._M_node) == 0)
                      {
                        return _Res(0, __before._M_node);
                      }
                    else
                      {
                        return _Res(__pos._M_node, __pos._M_node);
                      }
                  }
                else
                  {
                    return (*this)._M_get_insert_equal_pos(__k);
                  }
              }
          }
        else
          {
            typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __after = __pos;
            if (__pos._M_node == (*this)._M_rightmost())
              {
                return _Res(0, (*this)._M_rightmost());
              }
            else
              {
                if (!::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(( ++__after)._M_node), __k))
                  {
                    if (_S_right(__pos._M_node) == 0)
                      {
                        return _Res(0, __pos._M_node);
                      }
                    else
                      {
                        return _Res(__after._M_node, __after._M_node);
                      }
                  }
                else
                  {
                    return ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *>(0, 0);
                  }
              }
          }
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  template < typename _Arg >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_equal_(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position, _Arg &&__v)
  {
    ::std::pair< ::std::_Rb_tree_node_base *, ::std::_Rb_tree_node_base *> __res = (*this)._M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));
    if (__res.second)
      {
        return (*this)._M_insert_(__res.first, __res.second, std::forward<_Arg>(__v));
      }
    return (*this)._M_insert_equal_lower(std::forward<_Arg>(__v));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __x, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z)
  {
    bool __insert_left = (__x != 0 || __p == (*this)._M_end()) || ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__z), _S_key(__p));
    _Rb_tree_insert_and_rebalance(__insert_left, __z, __p, this->_M_impl._M_header);
     ++::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count;
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__z)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_lower_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr __p, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z)
  {
    bool __insert_left = __p == (*this)._M_end() || !::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__p), _S_key(__z));
    _Rb_tree_insert_and_rebalance(__insert_left, __z, __p, this->_M_impl._M_header);
     ++::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count;
    return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(__z)));
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_equal_lower_node(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __x = (*this)._M_begin();
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = (*this)._M_end();
    while (__x != 0)
      {
        __y = __x;
        __x = !::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ? _S_left(__x) : _S_right(__x);
      }
    return (*this)._M_insert_lower_node(__y, __z);
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  template < typename ..._Args >
  ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, bool> _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_emplace_unique(_Args &&...__args)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z = (*this)._M_create_node(std::forward<_Args>(__args) ...);
    try
    {
      typedef ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, bool> _Res;
      auto __res = (*this)._M_get_insert_unique_pos(_S_key(__z));
      if (__res.second)
        {
          return _Res((*this)._M_insert_node(__res.first, __res.second, __z), true);
        }
      (*this)._M_destroy_node(__z);
      return _Res(((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(__res.first)))), false);
    }
    catch (...)
    {
      (*this)._M_destroy_node(__z);
      throw;
    }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  template < typename ..._Args >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_emplace_equal(_Args &&...__args)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z = (*this)._M_create_node(std::forward<_Args>(__args) ...);
    try
    {
      auto __res = (*this)._M_get_insert_equal_pos(_S_key(__z));
      return (*this)._M_insert_node(__res.first, __res.second, __z);
    }
    catch (...)
    {
      (*this)._M_destroy_node(__z);
      throw;
    }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  template < typename ..._Args >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_emplace_hint_unique(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __pos, _Args &&...__args)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z = (*this)._M_create_node(std::forward<_Args>(__args) ...);
    try
    {
      auto __res = (*this)._M_get_insert_hint_unique_pos(__pos, _S_key(__z));
      if (__res.second)
        {
          return (*this)._M_insert_node(__res.first, __res.second, __z);
        }
      (*this)._M_destroy_node(__z);
      return ((typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator(static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(__res.first))));
    }
    catch (...)
    {
      (*this)._M_destroy_node(__z);
      throw;
    }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  template < typename ..._Args >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_emplace_hint_equal(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __pos, _Args &&...__args)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __z = (*this)._M_create_node(std::forward<_Args>(__args) ...);
    try
    {
      auto __res = (*this)._M_get_insert_hint_equal_pos(__pos, _S_key(__z));
      if (__res.second)
        {
          return (*this)._M_insert_node(__res.first, __res.second, __z);
        }
      return (*this)._M_insert_equal_lower_node(__z);
    }
    catch (...)
    {
      (*this)._M_destroy_node(__z);
      throw;
    }
  }
  template < typename _Key, typename _Val, typename _KoV, typename _Cmp, typename _Alloc >
  template < typename _II >
  void _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::_M_insert_unique(_II __first, _II __last)
  {
    for (; __first != __last;  ++__first)
      {
        (*this)._M_insert_unique_((*this).end(), *__first);
      }
  }
  template < typename _Key, typename _Val, typename _KoV, typename _Cmp, typename _Alloc >
  template < typename _II >
  void _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::_M_insert_equal(_II __first, _II __last)
  {
    for (; __first != __last;  ++__first)
      {
        (*this)._M_insert_equal_((*this).end(), *__first);
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_erase_aux(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __position)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type __y = static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type>(_Rb_tree_rebalance_for_erase(const_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr>(__position._M_node), this->_M_impl._M_header));
    (*this)._M_destroy_node(__y);
     --::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_erase_aux(typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __first, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __last)
  {
    if (__first == (*this).begin() && __last == (*this).end())
      {
        (*this).clear();
      }
    else
      {
        while (__first != __last)
          {
            (*this).erase(__first++);
          }
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::erase(const _Key &__x)
  {
    ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator> __p = (*this).equal_range(__x);
    const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type __old_size = (*this).size();
    (*this).erase(__p.first, __p.second);
    return __old_size - (*this).size();
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::erase(const _Key *__first, const _Key *__last)
  {
    while (__first != __last)
      {
        (*this).erase(*__first++);
      }
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::find(const _Key &__k)
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator __j = (*this)._M_lower_bound((*this)._M_begin(), (*this)._M_end(), __k);
    return __j == (*this).end() || ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__j._M_node)) ? (*this).end() : __j;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::find(const _Key &__k) const 
  {
    typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __j = (*this)._M_lower_bound((*this)._M_begin(), (*this)._M_end(), __k);
    return __j == (*this).end() || ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(__k, _S_key(__j._M_node)) ? (*this).end() : __j;
  }
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::count(const _Key &__k) const 
  {
    ::std::pair<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator> __p = (*this).equal_range(__k);
    const typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type __n = std::distance(__p.first, __p.second);
    return __n;
  }
  unsigned int _Rb_tree_black_count(const ::std::_Rb_tree_node_base *__node, const ::std::_Rb_tree_node_base *__root) throw() __attribute__((__pure__));
  template < typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
  bool _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::__rb_verify() const 
  {
    if (::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count == 0 || (*this).begin() == (*this).end())
      {
        return ((::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_node_count == 0 && (*this).begin() == (*this).end()) && this->_M_impl._M_header._M_left == (*this)._M_end()) && this->_M_impl._M_header._M_right == (*this)._M_end();
      }
    unsigned int __len = _Rb_tree_black_count((*this)._M_leftmost(), (*this)._M_root());
    for (typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator __it = (*this).begin(); __it != (*this).end();  ++__it)
      {
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __x = static_cast<typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type>(__it._M_node);
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __L = _S_left(__x);
        typename ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type __R = _S_right(__x);
        if (__x->_M_color == ::std::_S_red)
          {
            if ((__L && __L->_M_color == ::std::_S_red) || (__R && __R->_M_color == ::std::_S_red))
              {
                return false;
              }
          }
        if (__L && ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
          {
            return false;
          }
        if (__R && ::std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
          {
            return false;
          }
        if ((!__L && !__R) && _Rb_tree_black_count(__x, (*this)._M_root()) != __len)
          {
            return false;
          }
      }
    if ((*this)._M_leftmost() != _Rb_tree_node_base::_S_minimum((*this)._M_root()))
      {
        return false;
      }
    if ((*this)._M_rightmost() != _Rb_tree_node_base::_S_maximum((*this)._M_root()))
      {
        return false;
      }
    return true;
  }
  template < typename _Key, typename _Compare = ::std::less<_Key>, typename _Alloc = ::std::allocator<_Key> >
  class  set
  {
      typedef typename _Alloc::value_type _Alloc_value_type;
    public:
      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;
    private:
      typedef typename _Alloc::template rebind< _Key>::other _Key_alloc_type;
      typedef ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type> _Rep_type;
      typename ::std::set<_Key, _Compare, _Alloc>::_Rep_type _M_t;
    public:
      typedef typename _Alloc::template rebind< _Key>::other::pointer pointer;
      typedef typename _Alloc::template rebind< _Key>::other::const_pointer const_pointer;
      typedef typename _Alloc::template rebind< _Key>::other::reference reference;
      typedef typename _Alloc::template rebind< _Key>::other::const_reference const_reference;
      typedef typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_iterator iterator;
      typedef typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_iterator const_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_reverse_iterator reverse_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_reverse_iterator const_reverse_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::size_type size_type;
      typedef typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::difference_type difference_type;
      inline set()
        : _M_t()
      {
      }
      inline explicit set(const _Compare &__comp, const typename ::std::set<_Key, _Compare, _Alloc>::allocator_type &__a  = (((typename ::std::set<_Key, _Compare, _Alloc>::allocator_type()))))
        : _M_t(__comp, ((typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type(__a))))
      {
      }
      template < typename _InputIterator >
      inline set(_InputIterator __first, _InputIterator __last)
        : _M_t()
      {
        ::std::set<_Key, _Compare, _Alloc>::_M_t._M_insert_unique(__first, __last);
      }
      template < typename _InputIterator >
      inline set(_InputIterator __first, _InputIterator __last, const _Compare &__comp, const typename ::std::set<_Key, _Compare, _Alloc>::allocator_type &__a  = (((typename ::std::set<_Key, _Compare, _Alloc>::allocator_type()))))
        : _M_t(__comp, ((typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type(__a))))
      {
        ::std::set<_Key, _Compare, _Alloc>::_M_t._M_insert_unique(__first, __last);
      }
      inline set(const ::std::set<_Key, _Compare, _Alloc> &__x)
        : _M_t(__x._M_t)
      {
      }
      inline set(::std::set<_Key, _Compare, _Alloc> &&__x) noexcept(is_nothrow_copy_constructible<_Compare>::value)
        : _M_t(std::move(__x._M_t))
      {
      }
      inline set(::std::initializer_list<typename ::std::set<_Key, _Compare, _Alloc>::value_type> __l, const _Compare &__comp  = (_Compare()), const typename ::std::set<_Key, _Compare, _Alloc>::allocator_type &__a  = (((typename ::std::set<_Key, _Compare, _Alloc>::allocator_type()))))
        : _M_t(__comp, ((typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type(__a))))
      {
        ::std::set<_Key, _Compare, _Alloc>::_M_t._M_insert_unique(__l.begin(), __l.end());
      }
      inline ::std::set<_Key, _Compare, _Alloc> &operator =(const ::std::set<_Key, _Compare, _Alloc> &__x)
      {
        ::std::set<_Key, _Compare, _Alloc>::_M_t = __x._M_t;
        return *this;
      }
      inline ::std::set<_Key, _Compare, _Alloc> &operator =(::std::set<_Key, _Compare, _Alloc> &&__x)
      {
        this->clear();
        this->swap(__x);
        return *this;
      }
      inline ::std::set<_Key, _Compare, _Alloc> &operator =(::std::initializer_list<typename ::std::set<_Key, _Compare, _Alloc>::value_type> __l)
      {
        this->clear();
        this->insert(__l.begin(), __l.end());
        return *this;
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::key_compare key_comp() const 
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.key_comp();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::value_compare value_comp() const 
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.key_comp();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::allocator_type get_allocator() const  noexcept(true)
      {
        return ((typename ::std::set<_Key, _Compare, _Alloc>::allocator_type(::std::set<_Key, _Compare, _Alloc>::_M_t.get_allocator())));
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator begin() const  noexcept(true)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.begin();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator end() const  noexcept(true)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.end();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::reverse_iterator rbegin() const  noexcept(true)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.rbegin();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::reverse_iterator rend() const  noexcept(true)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.rend();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator cbegin() const  noexcept(true)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.begin();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator cend() const  noexcept(true)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.end();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::reverse_iterator crbegin() const  noexcept(true)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.rbegin();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::reverse_iterator crend() const  noexcept(true)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.rend();
      }
      inline bool empty() const  noexcept(true)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.empty();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::size_type size() const  noexcept(true)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.size();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::size_type max_size() const  noexcept(true)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.max_size();
      }
      inline void swap(::std::set<_Key, _Compare, _Alloc> &__x)
      {
        ::std::set<_Key, _Compare, _Alloc>::_M_t.swap(__x._M_t);
      }
      template < typename ..._Args >
      inline ::std::pair<typename ::std::set<_Key, _Compare, _Alloc>::iterator, bool> emplace(_Args &&...__args)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t._M_emplace_unique(std::forward<_Args>(__args) ...);
      }
      template < typename ..._Args >
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator emplace_hint(typename ::std::set<_Key, _Compare, _Alloc>::const_iterator __pos, _Args &&...__args)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t._M_emplace_hint_unique(__pos, std::forward<_Args>(__args) ...);
      }
      inline ::std::pair<typename ::std::set<_Key, _Compare, _Alloc>::iterator, bool> insert(const typename ::std::set<_Key, _Compare, _Alloc>::value_type &__x)
      {
        ::std::pair<typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::iterator, bool> __p = ::std::set<_Key, _Compare, _Alloc>::_M_t._M_insert_unique(__x);
        return ::std::pair<typename ::std::set<_Key, _Compare, _Alloc>::iterator, bool>(__p.first, __p.second);
      }
      inline ::std::pair<typename ::std::set<_Key, _Compare, _Alloc>::iterator, bool> insert(typename ::std::set<_Key, _Compare, _Alloc>::value_type &&__x)
      {
        ::std::pair<typename ::std::_Rb_tree<typename ::std::set<_Key, _Compare, _Alloc>::key_type, typename ::std::set<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::set<_Key, _Compare, _Alloc>::value_type>, typename ::std::set<_Key, _Compare, _Alloc>::key_compare, typename ::std::set<_Key, _Compare, _Alloc>::_Key_alloc_type>::iterator, bool> __p = ::std::set<_Key, _Compare, _Alloc>::_M_t._M_insert_unique(std::move(__x));
        return ::std::pair<typename ::std::set<_Key, _Compare, _Alloc>::iterator, bool>(__p.first, __p.second);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator insert(typename ::std::set<_Key, _Compare, _Alloc>::const_iterator __position, const typename ::std::set<_Key, _Compare, _Alloc>::value_type &__x)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t._M_insert_unique_(__position, __x);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator insert(typename ::std::set<_Key, _Compare, _Alloc>::const_iterator __position, typename ::std::set<_Key, _Compare, _Alloc>::value_type &&__x)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t._M_insert_unique_(__position, std::move(__x));
      }
      template < typename _InputIterator >
      inline void insert(_InputIterator __first, _InputIterator __last)
      {
        ::std::set<_Key, _Compare, _Alloc>::_M_t._M_insert_unique(__first, __last);
      }
      inline void insert(::std::initializer_list<typename ::std::set<_Key, _Compare, _Alloc>::value_type> __l)
      {
        this->insert(__l.begin(), __l.end());
      }
      inline __attribute__((__abi_tag__("cxx11"))) typename ::std::set<_Key, _Compare, _Alloc>::iterator erase(typename ::std::set<_Key, _Compare, _Alloc>::const_iterator __position)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.erase(__position);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::size_type erase(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.erase(__x);
      }
      inline __attribute__((__abi_tag__("cxx11"))) typename ::std::set<_Key, _Compare, _Alloc>::iterator erase(typename ::std::set<_Key, _Compare, _Alloc>::const_iterator __first, typename ::std::set<_Key, _Compare, _Alloc>::const_iterator __last)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.erase(__first, __last);
      }
      inline void clear() noexcept(true)
      {
        ::std::set<_Key, _Compare, _Alloc>::_M_t.clear();
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::size_type count(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.find(__x) == ::std::set<_Key, _Compare, _Alloc>::_M_t.end() ? 0 : 1;
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator find(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.find(__x);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::const_iterator find(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.find(__x);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator lower_bound(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.lower_bound(__x);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::const_iterator lower_bound(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.lower_bound(__x);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::iterator upper_bound(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.upper_bound(__x);
      }
      inline typename ::std::set<_Key, _Compare, _Alloc>::const_iterator upper_bound(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.upper_bound(__x);
      }
      inline ::std::pair<typename ::std::set<_Key, _Compare, _Alloc>::iterator, typename ::std::set<_Key, _Compare, _Alloc>::iterator> equal_range(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.equal_range(__x);
      }
      inline ::std::pair<typename ::std::set<_Key, _Compare, _Alloc>::const_iterator, typename ::std::set<_Key, _Compare, _Alloc>::const_iterator> equal_range(const typename ::std::set<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::set<_Key, _Compare, _Alloc>::_M_t.equal_range(__x);
      }
    template < typename _K1, typename _C1, typename _A1 >
    friend bool operator ==(const ::std::set<_K1, _C1, _A1> &, const ::std::set<_K1, _C1, _A1> &);
    template < typename _K1, typename _C1, typename _A1 >
    friend bool operator <(const ::std::set<_K1, _C1, _A1> &, const ::std::set<_K1, _C1, _A1> &);
  };
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y)
  {
    return __x._M_t == __y._M_t;
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y)
  {
    return __x._M_t < __y._M_t;
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::set<_Key, _Compare, _Alloc> &__x, const ::std::set<_Key, _Compare, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline void swap(::std::set<_Key, _Compare, _Alloc> &__x, ::std::set<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline void swap(::std::set<_Key, _Compare, _Alloc> &__x, ::std::set<_Key, _Compare, _Alloc> &__y)
  {
    __x.swap(__y);
  }
  template < typename _Key, typename _Compare = ::std::less<_Key>, typename _Alloc = ::std::allocator<_Key> >
  class  multiset
  {
      typedef typename _Alloc::value_type _Alloc_value_type;
    public:
      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;
    private:
      typedef typename _Alloc::template rebind< _Key>::other _Key_alloc_type;
      typedef ::std::_Rb_tree<typename ::std::multiset<_Key, _Compare, _Alloc>::key_type, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type>, typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type> _Rep_type;
      typename ::std::multiset<_Key, _Compare, _Alloc>::_Rep_type _M_t;
    public:
      typedef typename _Alloc::template rebind< _Key>::other::pointer pointer;
      typedef typename _Alloc::template rebind< _Key>::other::const_pointer const_pointer;
      typedef typename _Alloc::template rebind< _Key>::other::reference reference;
      typedef typename _Alloc::template rebind< _Key>::other::const_reference const_reference;
      typedef typename ::std::_Rb_tree<typename ::std::multiset<_Key, _Compare, _Alloc>::key_type, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type>, typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_iterator iterator;
      typedef typename ::std::_Rb_tree<typename ::std::multiset<_Key, _Compare, _Alloc>::key_type, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type>, typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_iterator const_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::multiset<_Key, _Compare, _Alloc>::key_type, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type>, typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_reverse_iterator reverse_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::multiset<_Key, _Compare, _Alloc>::key_type, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type>, typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type>::const_reverse_iterator const_reverse_iterator;
      typedef typename ::std::_Rb_tree<typename ::std::multiset<_Key, _Compare, _Alloc>::key_type, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type>, typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type>::size_type size_type;
      typedef typename ::std::_Rb_tree<typename ::std::multiset<_Key, _Compare, _Alloc>::key_type, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type, ::std::_Identity<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type>, typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare, typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type>::difference_type difference_type;
      inline multiset()
        : _M_t()
      {
      }
      inline explicit multiset(const _Compare &__comp, const typename ::std::multiset<_Key, _Compare, _Alloc>::allocator_type &__a  = (((typename ::std::multiset<_Key, _Compare, _Alloc>::allocator_type()))))
        : _M_t(__comp, ((typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type(__a))))
      {
      }
      template < typename _InputIterator >
      inline multiset(_InputIterator __first, _InputIterator __last)
        : _M_t()
      {
        ::std::multiset<_Key, _Compare, _Alloc>::_M_t._M_insert_equal(__first, __last);
      }
      template < typename _InputIterator >
      inline multiset(_InputIterator __first, _InputIterator __last, const _Compare &__comp, const typename ::std::multiset<_Key, _Compare, _Alloc>::allocator_type &__a  = (((typename ::std::multiset<_Key, _Compare, _Alloc>::allocator_type()))))
        : _M_t(__comp, ((typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type(__a))))
      {
        ::std::multiset<_Key, _Compare, _Alloc>::_M_t._M_insert_equal(__first, __last);
      }
      inline multiset(const ::std::multiset<_Key, _Compare, _Alloc> &__x)
        : _M_t(__x._M_t)
      {
      }
      inline multiset(::std::multiset<_Key, _Compare, _Alloc> &&__x) noexcept(is_nothrow_copy_constructible<_Compare>::value)
        : _M_t(std::move(__x._M_t))
      {
      }
      inline multiset(::std::initializer_list<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type> __l, const _Compare &__comp  = (_Compare()), const typename ::std::multiset<_Key, _Compare, _Alloc>::allocator_type &__a  = (((typename ::std::multiset<_Key, _Compare, _Alloc>::allocator_type()))))
        : _M_t(__comp, ((typename ::std::multiset<_Key, _Compare, _Alloc>::_Key_alloc_type(__a))))
      {
        ::std::multiset<_Key, _Compare, _Alloc>::_M_t._M_insert_equal(__l.begin(), __l.end());
      }
      inline ::std::multiset<_Key, _Compare, _Alloc> &operator =(const ::std::multiset<_Key, _Compare, _Alloc> &__x)
      {
        ::std::multiset<_Key, _Compare, _Alloc>::_M_t = __x._M_t;
        return *this;
      }
      inline ::std::multiset<_Key, _Compare, _Alloc> &operator =(::std::multiset<_Key, _Compare, _Alloc> &&__x)
      {
        this->clear();
        this->swap(__x);
        return *this;
      }
      inline ::std::multiset<_Key, _Compare, _Alloc> &operator =(::std::initializer_list<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type> __l)
      {
        this->clear();
        this->insert(__l.begin(), __l.end());
        return *this;
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::key_compare key_comp() const 
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.key_comp();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::value_compare value_comp() const 
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.key_comp();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::allocator_type get_allocator() const  noexcept(true)
      {
        return ((typename ::std::multiset<_Key, _Compare, _Alloc>::allocator_type(::std::multiset<_Key, _Compare, _Alloc>::_M_t.get_allocator())));
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator begin() const  noexcept(true)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.begin();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator end() const  noexcept(true)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.end();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::reverse_iterator rbegin() const  noexcept(true)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.rbegin();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::reverse_iterator rend() const  noexcept(true)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.rend();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator cbegin() const  noexcept(true)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.begin();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator cend() const  noexcept(true)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.end();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::reverse_iterator crbegin() const  noexcept(true)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.rbegin();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::reverse_iterator crend() const  noexcept(true)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.rend();
      }
      inline bool empty() const  noexcept(true)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.empty();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::size_type size() const  noexcept(true)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.size();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::size_type max_size() const  noexcept(true)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.max_size();
      }
      inline void swap(::std::multiset<_Key, _Compare, _Alloc> &__x)
      {
        ::std::multiset<_Key, _Compare, _Alloc>::_M_t.swap(__x._M_t);
      }
      template < typename ..._Args >
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator emplace(_Args &&...__args)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t._M_emplace_equal(std::forward<_Args>(__args) ...);
      }
      template < typename ..._Args >
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator emplace_hint(typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator __pos, _Args &&...__args)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t._M_emplace_hint_equal(__pos, std::forward<_Args>(__args) ...);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator insert(const typename ::std::multiset<_Key, _Compare, _Alloc>::value_type &__x)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t._M_insert_equal(__x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator insert(typename ::std::multiset<_Key, _Compare, _Alloc>::value_type &&__x)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t._M_insert_equal(std::move(__x));
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator insert(typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator __position, const typename ::std::multiset<_Key, _Compare, _Alloc>::value_type &__x)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t._M_insert_equal_(__position, __x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator insert(typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator __position, typename ::std::multiset<_Key, _Compare, _Alloc>::value_type &&__x)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t._M_insert_equal_(__position, std::move(__x));
      }
      template < typename _InputIterator >
      inline void insert(_InputIterator __first, _InputIterator __last)
      {
        ::std::multiset<_Key, _Compare, _Alloc>::_M_t._M_insert_equal(__first, __last);
      }
      inline void insert(::std::initializer_list<typename ::std::multiset<_Key, _Compare, _Alloc>::value_type> __l)
      {
        this->insert(__l.begin(), __l.end());
      }
      inline __attribute__((__abi_tag__("cxx11"))) typename ::std::multiset<_Key, _Compare, _Alloc>::iterator erase(typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator __position)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.erase(__position);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::size_type erase(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.erase(__x);
      }
      inline __attribute__((__abi_tag__("cxx11"))) typename ::std::multiset<_Key, _Compare, _Alloc>::iterator erase(typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator __first, typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator __last)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.erase(__first, __last);
      }
      inline void clear() noexcept(true)
      {
        ::std::multiset<_Key, _Compare, _Alloc>::_M_t.clear();
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::size_type count(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.count(__x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator find(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.find(__x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator find(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.find(__x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator lower_bound(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.lower_bound(__x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator lower_bound(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.lower_bound(__x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::iterator upper_bound(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.upper_bound(__x);
      }
      inline typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator upper_bound(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.upper_bound(__x);
      }
      inline ::std::pair<typename ::std::multiset<_Key, _Compare, _Alloc>::iterator, typename ::std::multiset<_Key, _Compare, _Alloc>::iterator> equal_range(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x)
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.equal_range(__x);
      }
      inline ::std::pair<typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator, typename ::std::multiset<_Key, _Compare, _Alloc>::const_iterator> equal_range(const typename ::std::multiset<_Key, _Compare, _Alloc>::key_type &__x) const 
      {
        return ::std::multiset<_Key, _Compare, _Alloc>::_M_t.equal_range(__x);
      }
    template < typename _K1, typename _C1, typename _A1 >
    friend bool operator ==(const ::std::multiset<_K1, _C1, _A1> &, const ::std::multiset<_K1, _C1, _A1> &);
    template < typename _K1, typename _C1, typename _A1 >
    friend bool operator <(const ::std::multiset<_K1, _C1, _A1> &, const ::std::multiset<_K1, _C1, _A1> &);
  };
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator ==(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y)
  {
    return __x._M_t == __y._M_t;
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y)
  {
    return __x._M_t < __y._M_t;
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator !=(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator <=(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline bool operator >=(const ::std::multiset<_Key, _Compare, _Alloc> &__x, const ::std::multiset<_Key, _Compare, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Key, typename _Compare, typename _Alloc >
  inline void swap(::std::multiset<_Key, _Compare, _Alloc> &__x, ::std::multiset<_Key, _Compare, _Alloc> &__y);
  template < typename _Key, typename _Compare, typename _Alloc >
  inline void swap(::std::multiset<_Key, _Compare, _Alloc> &__x, ::std::multiset<_Key, _Compare, _Alloc> &__y)
  {
    __x.swap(__y);
  }
  namespace __detail {
    struct  _List_node_base
    {
        ::std::__detail::_List_node_base *_M_next;
        ::std::__detail::_List_node_base *_M_prev;
        static void swap(::std::__detail::_List_node_base &__x, ::std::__detail::_List_node_base &__y) noexcept(true);
        void _M_transfer(::std::__detail::_List_node_base *const __first, ::std::__detail::_List_node_base *const __last) noexcept(true);
        void _M_reverse() noexcept(true);
        void _M_hook(::std::__detail::_List_node_base *const __position) noexcept(true);
        void _M_unhook() noexcept(true);
    };
  }
  template < typename _Tp >
  struct  _List_node : ::std::__detail::_List_node_base
  {
      _Tp _M_data;
      template < typename ..._Args >
      inline _List_node(_Args &&...__args)
        : __detail::_List_node_base(), _M_data(std::forward<_Args>(__args) ...)
      {
      }
  };
  template < typename _Tp >
  struct  _List_iterator
  {
      typedef ::std::_List_iterator<_Tp> _Self;
      typedef ::std::_List_node<_Tp> _Node;
      typedef ::std::ptrdiff_t difference_type;
      typedef ::std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp *pointer;
      typedef _Tp &reference;
      inline _List_iterator()
        : _M_node()
      {
      }
      inline explicit _List_iterator(::std::__detail::_List_node_base *__x)
        : _M_node(__x)
      {
      }
      inline typename ::std::_List_iterator<_Tp>::reference operator *() const 
      {
        return static_cast<typename ::std::_List_iterator<_Tp>::_Node *>(::std::_List_iterator<_Tp>::_M_node)->_M_data;
      }
      inline typename ::std::_List_iterator<_Tp>::pointer operator ->() const 
      {
        return std::__addressof(static_cast<typename ::std::_List_iterator<_Tp>::_Node *>(::std::_List_iterator<_Tp>::_M_node)->_M_data);
      }
      inline typename ::std::_List_iterator<_Tp>::_Self &operator ++()
      {
        ::std::_List_iterator<_Tp>::_M_node = ::std::_List_iterator<_Tp>::_M_node->_M_next;
        return *this;
      }
      inline typename ::std::_List_iterator<_Tp>::_Self operator ++(int)
      {
        typename ::std::_List_iterator<_Tp>::_Self __tmp = *this;
        ::std::_List_iterator<_Tp>::_M_node = ::std::_List_iterator<_Tp>::_M_node->_M_next;
        return __tmp;
      }
      inline typename ::std::_List_iterator<_Tp>::_Self &operator --()
      {
        ::std::_List_iterator<_Tp>::_M_node = ::std::_List_iterator<_Tp>::_M_node->_M_prev;
        return *this;
      }
      inline typename ::std::_List_iterator<_Tp>::_Self operator --(int)
      {
        typename ::std::_List_iterator<_Tp>::_Self __tmp = *this;
        ::std::_List_iterator<_Tp>::_M_node = ::std::_List_iterator<_Tp>::_M_node->_M_prev;
        return __tmp;
      }
      inline bool operator ==(const typename ::std::_List_iterator<_Tp>::_Self &__x) const 
      {
        return ::std::_List_iterator<_Tp>::_M_node == __x._M_node;
      }
      inline bool operator !=(const typename ::std::_List_iterator<_Tp>::_Self &__x) const 
      {
        return ::std::_List_iterator<_Tp>::_M_node != __x._M_node;
      }
      ::std::__detail::_List_node_base *_M_node;
  };
  template < typename _Tp >
  struct  _List_const_iterator
  {
      typedef ::std::_List_const_iterator<_Tp> _Self;
      typedef const ::std::_List_node<_Tp> _Node;
      typedef ::std::_List_iterator<_Tp> iterator;
      typedef ::std::ptrdiff_t difference_type;
      typedef ::std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp *pointer;
      typedef const _Tp &reference;
      inline _List_const_iterator()
        : _M_node()
      {
      }
      inline explicit _List_const_iterator(const ::std::__detail::_List_node_base *__x)
        : _M_node(__x)
      {
      }
      inline _List_const_iterator(const typename ::std::_List_const_iterator<_Tp>::iterator &__x)
        : _M_node(__x._M_node)
      {
      }
      inline typename ::std::_List_const_iterator<_Tp>::reference operator *() const 
      {
        return static_cast<typename ::std::_List_const_iterator<_Tp>::_Node *>(::std::_List_const_iterator<_Tp>::_M_node)->_M_data;
      }
      inline typename ::std::_List_const_iterator<_Tp>::pointer operator ->() const 
      {
        return std::__addressof(static_cast<typename ::std::_List_const_iterator<_Tp>::_Node *>(::std::_List_const_iterator<_Tp>::_M_node)->_M_data);
      }
      inline typename ::std::_List_const_iterator<_Tp>::_Self &operator ++()
      {
        ::std::_List_const_iterator<_Tp>::_M_node = ::std::_List_const_iterator<_Tp>::_M_node->_M_next;
        return *this;
      }
      inline typename ::std::_List_const_iterator<_Tp>::_Self operator ++(int)
      {
        typename ::std::_List_const_iterator<_Tp>::_Self __tmp = *this;
        ::std::_List_const_iterator<_Tp>::_M_node = ::std::_List_const_iterator<_Tp>::_M_node->_M_next;
        return __tmp;
      }
      inline typename ::std::_List_const_iterator<_Tp>::_Self &operator --()
      {
        ::std::_List_const_iterator<_Tp>::_M_node = ::std::_List_const_iterator<_Tp>::_M_node->_M_prev;
        return *this;
      }
      inline typename ::std::_List_const_iterator<_Tp>::_Self operator --(int)
      {
        typename ::std::_List_const_iterator<_Tp>::_Self __tmp = *this;
        ::std::_List_const_iterator<_Tp>::_M_node = ::std::_List_const_iterator<_Tp>::_M_node->_M_prev;
        return __tmp;
      }
      inline bool operator ==(const typename ::std::_List_const_iterator<_Tp>::_Self &__x) const 
      {
        return ::std::_List_const_iterator<_Tp>::_M_node == __x._M_node;
      }
      inline bool operator !=(const typename ::std::_List_const_iterator<_Tp>::_Self &__x) const 
      {
        return ::std::_List_const_iterator<_Tp>::_M_node != __x._M_node;
      }
      const ::std::__detail::_List_node_base *_M_node;
  };
  template < typename _Val >
  inline bool operator ==(const ::std::_List_iterator<_Val> &__x, const ::std::_List_const_iterator<_Val> &__y);
  template < typename _Val >
  inline bool operator ==(const ::std::_List_iterator<_Val> &__x, const ::std::_List_const_iterator<_Val> &__y)
  {
    return __x._M_node == __y._M_node;
  }
  template < typename _Val >
  inline bool operator !=(const ::std::_List_iterator<_Val> &__x, const ::std::_List_const_iterator<_Val> &__y);
  template < typename _Val >
  inline bool operator !=(const ::std::_List_iterator<_Val> &__x, const ::std::_List_const_iterator<_Val> &__y)
  {
    return __x._M_node != __y._M_node;
  }
  template < typename _Tp, typename _Alloc >
  class  _List_base
  {
    protected:
      typedef typename _Alloc::template rebind< ::std::_List_node<_Tp> >::other _Node_alloc_type;
      typedef typename _Alloc::template rebind< _Tp>::other _Tp_alloc_type;
      struct  _List_impl : ::std::_List_base<_Tp, _Alloc>::_Node_alloc_type
      {
          ::std::__detail::_List_node_base _M_node;
          inline _List_impl()
            : _Node_alloc_type(), _M_node()
          {
          }
          inline _List_impl(const typename ::std::_List_base<_Tp, _Alloc>::_Node_alloc_type &__a)
            : _Node_alloc_type(__a), _M_node()
          {
          }
          inline _List_impl(typename ::std::_List_base<_Tp, _Alloc>::_Node_alloc_type &&__a)
            : _Node_alloc_type(std::move(__a)), _M_node()
          {
          }
      };
      typename ::std::_List_base<_Tp, _Alloc>::_List_impl _M_impl;
      inline ::std::_List_node<_Tp> *_M_get_node()
      {
        return ::std::_List_base<_Tp, _Alloc>::_M_impl._Node_alloc_type::allocate(1);
      }
      inline void _M_put_node(::std::_List_node<_Tp> *__p)
      {
        ::std::_List_base<_Tp, _Alloc>::_M_impl._Node_alloc_type::deallocate(__p, 1);
      }
    public:
      typedef _Alloc allocator_type;
      inline typename ::std::_List_base<_Tp, _Alloc>::_Node_alloc_type &_M_get_Node_allocator() noexcept(true)
      {
        return *static_cast<typename ::std::_List_base<_Tp, _Alloc>::_Node_alloc_type *>(&(*this).::std::_List_base<_Tp, _Alloc>::_M_impl);
      }
      inline const typename ::std::_List_base<_Tp, _Alloc>::_Node_alloc_type &_M_get_Node_allocator() const  noexcept(true)
      {
        return *static_cast<const typename ::std::_List_base<_Tp, _Alloc>::_Node_alloc_type *>(&(*this).::std::_List_base<_Tp, _Alloc>::_M_impl);
      }
      inline typename ::std::_List_base<_Tp, _Alloc>::_Tp_alloc_type _M_get_Tp_allocator() const  noexcept(true)
      {
        return ((typename ::std::_List_base<_Tp, _Alloc>::_Tp_alloc_type((*this)._M_get_Node_allocator())));
      }
      inline typename ::std::_List_base<_Tp, _Alloc>::allocator_type get_allocator() const  noexcept(true)
      {
        return ((typename ::std::_List_base<_Tp, _Alloc>::allocator_type((*this)._M_get_Node_allocator())));
      }
      inline _List_base()
        : _M_impl()
      {
        (*this)._M_init();
      }
      inline _List_base(const typename ::std::_List_base<_Tp, _Alloc>::_Node_alloc_type &__a)
        : _M_impl(__a)
      {
        (*this)._M_init();
      }
      inline _List_base(::std::_List_base<_Tp, _Alloc> &&__x)
        : _M_impl(std::move(__x._M_get_Node_allocator()))
      {
        (*this)._M_init();
        __detail::_List_node_base::swap(::std::_List_base<_Tp, _Alloc>::_M_impl._M_node, __x._M_impl._M_node);
      }
      inline ~_List_base() noexcept(true)
      {
        (*this)._M_clear();
      }
      void _M_clear();
      inline void _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
  };
  template < typename _Tp, typename _Alloc = ::std::allocator<_Tp> >
  class  list : protected ::std::_List_base<_Tp, _Alloc>
  {
      typedef typename _Alloc::value_type _Alloc_value_type;
      typedef ::std::_List_base<_Tp, _Alloc> _Base;
      typedef typename ::std::_List_base<_Tp, _Alloc>::_Tp_alloc_type _Tp_alloc_type;
      typedef typename ::std::_List_base<_Tp, _Alloc>::_Node_alloc_type _Node_alloc_type;
    public:
      typedef _Tp value_type;
      typedef typename ::std::_List_base<_Tp, _Alloc>::_Tp_alloc_type::pointer pointer;
      typedef typename ::std::_List_base<_Tp, _Alloc>::_Tp_alloc_type::const_pointer const_pointer;
      typedef typename ::std::_List_base<_Tp, _Alloc>::_Tp_alloc_type::reference reference;
      typedef typename ::std::_List_base<_Tp, _Alloc>::_Tp_alloc_type::const_reference const_reference;
      typedef ::std::_List_iterator<_Tp> iterator;
      typedef ::std::_List_const_iterator<_Tp> const_iterator;
      typedef ::std::reverse_iterator<typename ::std::list<_Tp, _Alloc>::const_iterator> const_reverse_iterator;
      typedef ::std::reverse_iterator<typename ::std::list<_Tp, _Alloc>::iterator> reverse_iterator;
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
    protected:
      typedef ::std::_List_node<_Tp> _Node;
      using ::std::_List_base<_Tp, _Alloc>::_M_impl;
      using ::std::_List_base<_Tp, _Alloc>::_M_put_node;
      using ::std::_List_base<_Tp, _Alloc>::_M_get_node;
      using ::std::_List_base<_Tp, _Alloc>::_M_get_Tp_allocator;
      using ::std::_List_base<_Tp, _Alloc>::_M_get_Node_allocator;
      template < typename ..._Args >
      inline typename ::std::list<_Tp, _Alloc>::_Node *_M_create_node(_Args &&...__args)
      {
        typename ::std::list<_Tp, _Alloc>::_Node *__p = this->_M_get_node();
        try
        {
          (_M_get_Node_allocator)().construct(__p, std::forward<_Args>(__args) ...);
        }
        catch (...)
        {
          _M_put_node(__p);
          throw;
        }
        return __p;
      }
    public:
      inline list()
        : _Base()
      {
      }
      inline explicit list(const typename ::std::list<_Tp, _Alloc>::allocator_type &__a)
        : _Base(((typename ::std::list<_Tp, _Alloc>::_Node_alloc_type(__a))))
      {
      }
      inline explicit list(typename ::std::list<_Tp, _Alloc>::size_type __n)
        : _Base()
      {
        (*this)._M_default_initialize(__n);
      }
      inline list(typename ::std::list<_Tp, _Alloc>::size_type __n, const typename ::std::list<_Tp, _Alloc>::value_type &__value, const typename ::std::list<_Tp, _Alloc>::allocator_type &__a  = (((typename ::std::list<_Tp, _Alloc>::allocator_type()))))
        : _Base(((typename ::std::list<_Tp, _Alloc>::_Node_alloc_type(__a))))
      {
        (*this)._M_fill_initialize(__n, __value);
      }
      inline list(const ::std::list<_Tp, _Alloc> &__x)
        : _Base(__x._M_get_Node_allocator())
      {
        (*this)._M_initialize_dispatch(__x.begin(), __x.end(), ::std::__false_type());
      }
      inline list(::std::list<_Tp, _Alloc> &&__x) noexcept(true)
        : _Base(std::move(__x))
      {
      }
      inline list(::std::initializer_list<typename ::std::list<_Tp, _Alloc>::value_type> __l, const typename ::std::list<_Tp, _Alloc>::allocator_type &__a  = (((typename ::std::list<_Tp, _Alloc>::allocator_type()))))
        : _Base(((typename ::std::list<_Tp, _Alloc>::_Node_alloc_type(__a))))
      {
        (*this)._M_initialize_dispatch(__l.begin(), __l.end(), ::std::__false_type());
      }
      template < typename _InputIterator, typename __type_tpl__param_2_1__ = ::std::_RequireInputIter<_InputIterator> >
      inline list(_InputIterator __first, _InputIterator __last, const typename ::std::list<_Tp, _Alloc>::allocator_type &__a  = (((typename ::std::list<_Tp, _Alloc>::allocator_type()))))
        : _Base(((typename ::std::list<_Tp, _Alloc>::_Node_alloc_type(__a))))
      {
        (*this)._M_initialize_dispatch(__first, __last, ::std::__false_type());
      }
      ::std::list<_Tp, _Alloc> &operator =(const ::std::list<_Tp, _Alloc> &__x);
      inline ::std::list<_Tp, _Alloc> &operator =(::std::list<_Tp, _Alloc> &&__x)
      {
        this->clear();
        this->swap(__x);
        return *this;
      }
      inline ::std::list<_Tp, _Alloc> &operator =(::std::initializer_list<typename ::std::list<_Tp, _Alloc>::value_type> __l)
      {
        this->assign(__l.begin(), __l.end());
        return *this;
      }
      inline void assign(typename ::std::list<_Tp, _Alloc>::size_type __n, const typename ::std::list<_Tp, _Alloc>::value_type &__val)
      {
        (*this)._M_fill_assign(__n, __val);
      }
      template < typename _InputIterator, typename __type_tpl__param_2_1__ = ::std::_RequireInputIter<_InputIterator> >
      inline void assign(_InputIterator __first, _InputIterator __last)
      {
        (*this)._M_assign_dispatch(__first, __last, ::std::__false_type());
      }
      inline void assign(::std::initializer_list<typename ::std::list<_Tp, _Alloc>::value_type> __l)
      {
        this->assign(__l.begin(), __l.end());
      }
      inline typename ::std::list<_Tp, _Alloc>::allocator_type get_allocator() const  noexcept(true)
      {
        return _Base::get_allocator();
      }
      inline typename ::std::list<_Tp, _Alloc>::iterator begin() noexcept(true)
      {
        return ((typename ::std::list<_Tp, _Alloc>::iterator(this->_M_impl._M_node._M_next)));
      }
      inline typename ::std::list<_Tp, _Alloc>::const_iterator begin() const  noexcept(true)
      {
        return ((typename ::std::list<_Tp, _Alloc>::const_iterator(this->_M_impl._M_node._M_next)));
      }
      inline typename ::std::list<_Tp, _Alloc>::iterator end() noexcept(true)
      {
        return ((typename ::std::list<_Tp, _Alloc>::iterator(&this->_M_impl._M_node)));
      }
      inline typename ::std::list<_Tp, _Alloc>::const_iterator end() const  noexcept(true)
      {
        return ((typename ::std::list<_Tp, _Alloc>::const_iterator(&this->_M_impl._M_node)));
      }
      inline typename ::std::list<_Tp, _Alloc>::reverse_iterator rbegin() noexcept(true)
      {
        return ((typename ::std::list<_Tp, _Alloc>::reverse_iterator((*this).end())));
      }
      inline typename ::std::list<_Tp, _Alloc>::const_reverse_iterator rbegin() const  noexcept(true)
      {
        return ((typename ::std::list<_Tp, _Alloc>::const_reverse_iterator((*this).end())));
      }
      inline typename ::std::list<_Tp, _Alloc>::reverse_iterator rend() noexcept(true)
      {
        return ((typename ::std::list<_Tp, _Alloc>::reverse_iterator((*this).begin())));
      }
      inline typename ::std::list<_Tp, _Alloc>::const_reverse_iterator rend() const  noexcept(true)
      {
        return ((typename ::std::list<_Tp, _Alloc>::const_reverse_iterator((*this).begin())));
      }
      inline typename ::std::list<_Tp, _Alloc>::const_iterator cbegin() const  noexcept(true)
      {
        return ((typename ::std::list<_Tp, _Alloc>::const_iterator(this->_M_impl._M_node._M_next)));
      }
      inline typename ::std::list<_Tp, _Alloc>::const_iterator cend() const  noexcept(true)
      {
        return ((typename ::std::list<_Tp, _Alloc>::const_iterator(&this->_M_impl._M_node)));
      }
      inline typename ::std::list<_Tp, _Alloc>::const_reverse_iterator crbegin() const  noexcept(true)
      {
        return ((typename ::std::list<_Tp, _Alloc>::const_reverse_iterator((*this).end())));
      }
      inline typename ::std::list<_Tp, _Alloc>::const_reverse_iterator crend() const  noexcept(true)
      {
        return ((typename ::std::list<_Tp, _Alloc>::const_reverse_iterator((*this).begin())));
      }
      inline bool empty() const  noexcept(true)
      {
        return this->_M_impl._M_node._M_next == &this->_M_impl._M_node;
      }
      inline typename ::std::list<_Tp, _Alloc>::size_type size() const  noexcept(true)
      {
        return std::distance((*this).begin(), (*this).end());
      }
      inline typename ::std::list<_Tp, _Alloc>::size_type max_size() const  noexcept(true)
      {
        return (_M_get_Node_allocator)().max_size();
      }
      void resize(typename ::std::list<_Tp, _Alloc>::size_type __new_size);
      void resize(typename ::std::list<_Tp, _Alloc>::size_type __new_size, const typename ::std::list<_Tp, _Alloc>::value_type &__x);
      inline typename ::std::list<_Tp, _Alloc>::reference front()
      {
        return *(*this).begin();
      }
      inline typename ::std::list<_Tp, _Alloc>::const_reference front() const 
      {
        return *(*this).begin();
      }
      inline typename ::std::list<_Tp, _Alloc>::reference back()
      {
        typename ::std::list<_Tp, _Alloc>::iterator __tmp = (*this).end();
         --__tmp;
        return *__tmp;
      }
      inline typename ::std::list<_Tp, _Alloc>::const_reference back() const 
      {
        typename ::std::list<_Tp, _Alloc>::const_iterator __tmp = (*this).end();
         --__tmp;
        return *__tmp;
      }
      inline void push_front(const typename ::std::list<_Tp, _Alloc>::value_type &__x)
      {
        this->_M_insert((*this).begin(), __x);
      }
      inline void push_front(typename ::std::list<_Tp, _Alloc>::value_type &&__x)
      {
        this->_M_insert((*this).begin(), std::move(__x));
      }
      template < typename ..._Args >
      inline void emplace_front(_Args &&...__args)
      {
        this->_M_insert((*this).begin(), std::forward<_Args>(__args) ...);
      }
      inline void pop_front()
      {
        this->_M_erase((*this).begin());
      }
      inline void push_back(const typename ::std::list<_Tp, _Alloc>::value_type &__x)
      {
        this->_M_insert((*this).end(), __x);
      }
      inline void push_back(typename ::std::list<_Tp, _Alloc>::value_type &&__x)
      {
        this->_M_insert((*this).end(), std::move(__x));
      }
      template < typename ..._Args >
      inline void emplace_back(_Args &&...__args)
      {
        this->_M_insert((*this).end(), std::forward<_Args>(__args) ...);
      }
      inline void pop_back()
      {
        this->_M_erase(((typename ::std::list<_Tp, _Alloc>::iterator(this->_M_impl._M_node._M_prev))));
      }
      template < typename ..._Args >
      typename ::std::list<_Tp, _Alloc>::iterator emplace(typename ::std::list<_Tp, _Alloc>::iterator __position, _Args &&...__args);
      typename ::std::list<_Tp, _Alloc>::iterator insert(typename ::std::list<_Tp, _Alloc>::iterator __position, const typename ::std::list<_Tp, _Alloc>::value_type &__x);
      inline typename ::std::list<_Tp, _Alloc>::iterator insert(typename ::std::list<_Tp, _Alloc>::iterator __position, typename ::std::list<_Tp, _Alloc>::value_type &&__x)
      {
        return (*this).emplace(__position, std::move(__x));
      }
      inline void insert(typename ::std::list<_Tp, _Alloc>::iterator __p, ::std::initializer_list<typename ::std::list<_Tp, _Alloc>::value_type> __l)
      {
        this->insert(__p, __l.begin(), __l.end());
      }
      inline void insert(typename ::std::list<_Tp, _Alloc>::iterator __position, typename ::std::list<_Tp, _Alloc>::size_type __n, const typename ::std::list<_Tp, _Alloc>::value_type &__x)
      {
        ::std::list<_Tp, _Alloc> __tmp(__n, __x, (*this).get_allocator());
        (*this).splice(__position, __tmp);
      }
      template < typename _InputIterator, typename __type_tpl__param_2_1__ = ::std::_RequireInputIter<_InputIterator> >
      inline void insert(typename ::std::list<_Tp, _Alloc>::iterator __position, _InputIterator __first, _InputIterator __last)
      {
        ::std::list<_Tp, _Alloc> __tmp(__first, __last, (*this).get_allocator());
        (*this).splice(__position, __tmp);
      }
      typename ::std::list<_Tp, _Alloc>::iterator erase(typename ::std::list<_Tp, _Alloc>::iterator __position);
      inline typename ::std::list<_Tp, _Alloc>::iterator erase(typename ::std::list<_Tp, _Alloc>::iterator __first, typename ::std::list<_Tp, _Alloc>::iterator __last)
      {
        while (__first != __last)
          {
            __first = (*this).erase(__first);
          }
        return __last;
      }
      inline void swap(::std::list<_Tp, _Alloc> &__x)
      {
        __detail::_List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);
        std::__alloc_swap<typename ::std::_List_base<_Tp, _Alloc>::_Node_alloc_type>::_S_do_it((_M_get_Node_allocator)(), __x._M_get_Node_allocator());
      }
      inline void clear() noexcept(true)
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
      inline void splice(typename ::std::list<_Tp, _Alloc>::iterator __position, ::std::list<_Tp, _Alloc> &&__x)
      {
        if (!__x.empty())
          {
            (*this)._M_check_equal_allocators(__x);
            this->_M_transfer(__position, __x.begin(), __x.end());
          }
      }
      inline void splice(typename ::std::list<_Tp, _Alloc>::iterator __position, ::std::list<_Tp, _Alloc> &__x)
      {
        (*this).splice(__position, std::move(__x));
      }
      inline void splice(typename ::std::list<_Tp, _Alloc>::iterator __position, ::std::list<_Tp, _Alloc> &&__x, typename ::std::list<_Tp, _Alloc>::iterator __i)
      {
        typename ::std::list<_Tp, _Alloc>::iterator __j = __i;
         ++__j;
        if (__position == __i || __position == __j)
          {
            return ;
          }
        if (this != &__x)
          {
            (*this)._M_check_equal_allocators(__x);
          }
        this->_M_transfer(__position, __i, __j);
      }
      inline void splice(typename ::std::list<_Tp, _Alloc>::iterator __position, ::std::list<_Tp, _Alloc> &__x, typename ::std::list<_Tp, _Alloc>::iterator __i)
      {
        (*this).splice(__position, std::move(__x), __i);
      }
      inline void splice(typename ::std::list<_Tp, _Alloc>::iterator __position, ::std::list<_Tp, _Alloc> &&__x, typename ::std::list<_Tp, _Alloc>::iterator __first, typename ::std::list<_Tp, _Alloc>::iterator __last)
      {
        if (__first != __last)
          {
            if (this != &__x)
              {
                (*this)._M_check_equal_allocators(__x);
              }
            this->_M_transfer(__position, __first, __last);
          }
      }
      inline void splice(typename ::std::list<_Tp, _Alloc>::iterator __position, ::std::list<_Tp, _Alloc> &__x, typename ::std::list<_Tp, _Alloc>::iterator __first, typename ::std::list<_Tp, _Alloc>::iterator __last)
      {
        (*this).splice(__position, std::move(__x), __first, __last);
      }
      void remove(const _Tp &__value);
      template < typename _Predicate >
      void remove_if(_Predicate __pred);
      void unique();
      template < typename _BinaryPredicate >
      void unique(_BinaryPredicate __binary_pred);
      void merge(::std::list<_Tp, _Alloc> &&__x);
      inline void merge(::std::list<_Tp, _Alloc> &__x)
      {
        (*this).merge(std::move(__x));
      }
      template < typename _StrictWeakOrdering >
      void merge(::std::list<_Tp, _Alloc> &&__x, _StrictWeakOrdering __comp);
      template < typename _StrictWeakOrdering >
      inline void merge(::std::list<_Tp, _Alloc> &__x, _StrictWeakOrdering __comp)
      {
        (*this).merge(std::move(__x), __comp);
      }
      inline void reverse() noexcept(true)
      {
        this->_M_impl._M_node._M_reverse();
      }
      void sort();
      template < typename _StrictWeakOrdering >
      void sort(_StrictWeakOrdering __comp);
    protected:
      template < typename _Integer >
      inline void _M_initialize_dispatch(_Integer __n, _Integer __x, ::std::__true_type)
      {
        (*this)._M_fill_initialize(static_cast<typename ::std::list<_Tp, _Alloc>::size_type>(__n), __x);
      }
      template < typename _InputIterator >
      inline void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type)
      {
        for (; __first != __last;  ++__first)
          {
            (*this).emplace_back(*__first);
          }
      }
      inline void _M_fill_initialize(typename ::std::list<_Tp, _Alloc>::size_type __n, const typename ::std::list<_Tp, _Alloc>::value_type &__x)
      {
        for (; __n;  --__n)
          {
            (*this).push_back(__x);
          }
      }
      inline void _M_default_initialize(typename ::std::list<_Tp, _Alloc>::size_type __n)
      {
        for (; __n;  --__n)
          {
            (*this).emplace_back();
          }
      }
      void _M_default_append(typename ::std::list<_Tp, _Alloc>::size_type __n);
      template < typename _Integer >
      inline void _M_assign_dispatch(_Integer __n, _Integer __val, ::std::__true_type)
      {
        (*this)._M_fill_assign(__n, __val);
      }
      template < typename _InputIterator >
      void _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2, ::std::__false_type);
      void _M_fill_assign(typename ::std::list<_Tp, _Alloc>::size_type __n, const typename ::std::list<_Tp, _Alloc>::value_type &__val);
      inline void _M_transfer(typename ::std::list<_Tp, _Alloc>::iterator __position, typename ::std::list<_Tp, _Alloc>::iterator __first, typename ::std::list<_Tp, _Alloc>::iterator __last)
      {
        __position._M_node->_M_transfer(__first._M_node, __last._M_node);
      }
      template < typename ..._Args >
      inline void _M_insert(typename ::std::list<_Tp, _Alloc>::iterator __position, _Args &&...__args)
      {
        typename ::std::list<_Tp, _Alloc>::_Node *__tmp = (*this)._M_create_node(std::forward<_Args>(__args) ...);
        __tmp->_M_hook(__position._M_node);
      }
      inline void _M_erase(typename ::std::list<_Tp, _Alloc>::iterator __position)
      {
        __position._M_node->_M_unhook();
        typename ::std::list<_Tp, _Alloc>::_Node *__n = static_cast<typename ::std::list<_Tp, _Alloc>::_Node *>(__position._M_node);
        (_M_get_Node_allocator)().destroy(__n);
        _M_put_node(__n);
      }
      inline void _M_check_equal_allocators(::std::list<_Tp, _Alloc> &__x)
      {
        if (std::__alloc_neq<typename ::std::_List_base<_Tp, _Alloc>::_Node_alloc_type>::_S_do_it((_M_get_Node_allocator)(), __x._M_get_Node_allocator()))
          {
            ::std::__throw_runtime_error("list::_M_check_equal_allocators");
          }
      }
  };
  template < typename _Tp, typename _Alloc >
  inline bool operator ==(const ::std::list<_Tp, _Alloc> &__x, const ::std::list<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator ==(const ::std::list<_Tp, _Alloc> &__x, const ::std::list<_Tp, _Alloc> &__y)
  {
    typedef typename ::std::list<_Tp, _Alloc>::const_iterator const_iterator;
    const_iterator __end1 = __x.end();
    const_iterator __end2 = __y.end();
    const_iterator __i1 = __x.begin();
    const_iterator __i2 = __y.begin();
    while ((__i1 != __end1 && __i2 != __end2) && *__i1 == *__i2)
      {
         ++__i1;
         ++__i2;
      }
    return __i1 == __end1 && __i2 == __end2;
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator <(const ::std::list<_Tp, _Alloc> &__x, const ::std::list<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator <(const ::std::list<_Tp, _Alloc> &__x, const ::std::list<_Tp, _Alloc> &__y)
  {
    return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator !=(const ::std::list<_Tp, _Alloc> &__x, const ::std::list<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator !=(const ::std::list<_Tp, _Alloc> &__x, const ::std::list<_Tp, _Alloc> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator >(const ::std::list<_Tp, _Alloc> &__x, const ::std::list<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator >(const ::std::list<_Tp, _Alloc> &__x, const ::std::list<_Tp, _Alloc> &__y)
  {
    return __y < __x;
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator <=(const ::std::list<_Tp, _Alloc> &__x, const ::std::list<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator <=(const ::std::list<_Tp, _Alloc> &__x, const ::std::list<_Tp, _Alloc> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Tp, typename _Alloc >
  inline bool operator >=(const ::std::list<_Tp, _Alloc> &__x, const ::std::list<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline bool operator >=(const ::std::list<_Tp, _Alloc> &__x, const ::std::list<_Tp, _Alloc> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Tp, typename _Alloc >
  inline void swap(::std::list<_Tp, _Alloc> &__x, ::std::list<_Tp, _Alloc> &__y);
  template < typename _Tp, typename _Alloc >
  inline void swap(::std::list<_Tp, _Alloc> &__x, ::std::list<_Tp, _Alloc> &__y)
  {
    __x.swap(__y);
  }
  template < typename _Tp, typename _Alloc >
  void _List_base<_Tp, _Alloc>::_M_clear()
  {
    typedef ::std::_List_node<_Tp> _Node;
    _Node *__cur = static_cast<_Node *>(::std::_List_base<_Tp, _Alloc>::_M_impl._M_node._M_next);
    while (__cur != &::std::_List_base<_Tp, _Alloc>::_M_impl._M_node)
      {
        _Node *__tmp = __cur;
        __cur = static_cast<_Node *>(__cur->_M_next);
        (*this)._M_get_Node_allocator().destroy(__tmp);
        (*this)._M_put_node(__tmp);
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename ..._Args >
  typename ::std::list<_Tp, _Alloc>::iterator list<_Tp, _Alloc>::emplace(typename ::std::list<_Tp, _Alloc>::iterator __position, _Args &&...__args)
  {
    typename ::std::list<_Tp, _Alloc>::_Node *__tmp = (*this)._M_create_node(std::forward<_Args>(__args) ...);
    __tmp->_M_hook(__position._M_node);
    return ((typename ::std::list<_Tp, _Alloc>::iterator(__tmp)));
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::list<_Tp, _Alloc>::iterator list<_Tp, _Alloc>::insert(typename ::std::list<_Tp, _Alloc>::iterator __position, const typename ::std::list<_Tp, _Alloc>::value_type &__x)
  {
    typename ::std::list<_Tp, _Alloc>::_Node *__tmp = (*this)._M_create_node(__x);
    __tmp->_M_hook(__position._M_node);
    return ((typename ::std::list<_Tp, _Alloc>::iterator(__tmp)));
  }
  template < typename _Tp, typename _Alloc >
  typename ::std::list<_Tp, _Alloc>::iterator list<_Tp, _Alloc>::erase(typename ::std::list<_Tp, _Alloc>::iterator __position)
  {
    typename ::std::list<_Tp, _Alloc>::iterator __ret = ((typename ::std::list<_Tp, _Alloc>::iterator(__position._M_node->_M_next)));
    (*this)._M_erase(__position);
    return __ret;
  }
  template < typename _Tp, typename _Alloc >
  void list<_Tp, _Alloc>::_M_default_append(typename ::std::list<_Tp, _Alloc>::size_type __n)
  {
    typename ::std::list<_Tp, _Alloc>::size_type __i(0);
    try
    {
      for (; __i < __n;  ++__i)
        {
          (*this).emplace_back();
        }
    }
    catch (...)
    {
      for (; __i;  --__i)
        {
          (*this).pop_back();
        }
      throw;
    }
  }
  template < typename _Tp, typename _Alloc >
  void list<_Tp, _Alloc>::resize(typename ::std::list<_Tp, _Alloc>::size_type __new_size)
  {
    typename ::std::list<_Tp, _Alloc>::iterator __i = (*this).begin();
    typename ::std::list<_Tp, _Alloc>::size_type __len(0);
    for (; __i != (*this).end() && __len < __new_size; ( ++__i,  ++__len))
      {
        ;
      }
    if (__len == __new_size)
      {
        (*this).erase(__i, (*this).end());
      }
    else
      {
        (*this)._M_default_append(__new_size - __len);
      }
  }
  template < typename _Tp, typename _Alloc >
  void list<_Tp, _Alloc>::resize(typename ::std::list<_Tp, _Alloc>::size_type __new_size, const typename ::std::list<_Tp, _Alloc>::value_type &__x)
  {
    typename ::std::list<_Tp, _Alloc>::iterator __i = (*this).begin();
    typename ::std::list<_Tp, _Alloc>::size_type __len(0);
    for (; __i != (*this).end() && __len < __new_size; ( ++__i,  ++__len))
      {
        ;
      }
    if (__len == __new_size)
      {
        (*this).erase(__i, (*this).end());
      }
    else
      {
        (*this).insert((*this).end(), __new_size - __len, __x);
      }
  }
  template < typename _Tp, typename _Alloc >
  ::std::list<_Tp, _Alloc> &list<_Tp, _Alloc>::operator =(const ::std::list<_Tp, _Alloc> &__x)
  {
    if (this != &__x)
      {
        typename ::std::list<_Tp, _Alloc>::iterator __first1 = (*this).begin();
        typename ::std::list<_Tp, _Alloc>::iterator __last1 = (*this).end();
        typename ::std::list<_Tp, _Alloc>::const_iterator __first2 = __x.begin();
        typename ::std::list<_Tp, _Alloc>::const_iterator __last2 = __x.end();
        for (; __first1 != __last1 && __first2 != __last2; ( ++__first1,  ++__first2))
          {
            *__first1 = *__first2;
          }
        if (__first2 == __last2)
          {
            (*this).erase(__first1, __last1);
          }
        else
          {
            (*this).insert(__last1, __first2, __last2);
          }
      }
    return *this;
  }
  template < typename _Tp, typename _Alloc >
  void list<_Tp, _Alloc>::_M_fill_assign(typename ::std::list<_Tp, _Alloc>::size_type __n, const typename ::std::list<_Tp, _Alloc>::value_type &__val)
  {
    typename ::std::list<_Tp, _Alloc>::iterator __i = (*this).begin();
    for (; __i != (*this).end() && __n > 0; ( ++__i,  --__n))
      {
        *__i = __val;
      }
    if (__n > 0)
      {
        (*this).insert((*this).end(), __n, __val);
      }
    else
      {
        (*this).erase(__i, (*this).end());
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _InputIterator >
  void list<_Tp, _Alloc>::_M_assign_dispatch(_InputIterator __first2, _InputIterator __last2, ::std::__false_type)
  {
    typename ::std::list<_Tp, _Alloc>::iterator __first1 = (*this).begin();
    typename ::std::list<_Tp, _Alloc>::iterator __last1 = (*this).end();
    for (; __first1 != __last1 && __first2 != __last2; ( ++__first1,  ++__first2))
      {
        *__first1 = *__first2;
      }
    if (__first2 == __last2)
      {
        (*this).erase(__first1, __last1);
      }
    else
      {
        (*this).insert(__last1, __first2, __last2);
      }
  }
  template < typename _Tp, typename _Alloc >
  void list<_Tp, _Alloc>::remove(const typename ::std::list<_Tp, _Alloc>::value_type &__value)
  {
    typename ::std::list<_Tp, _Alloc>::iterator __first = (*this).begin();
    typename ::std::list<_Tp, _Alloc>::iterator __last = (*this).end();
    typename ::std::list<_Tp, _Alloc>::iterator __extra = __last;
    while (__first != __last)
      {
        typename ::std::list<_Tp, _Alloc>::iterator __next = __first;
         ++__next;
        if (*__first == __value)
          {
            if (std::__addressof(*__first) != std::__addressof(__value))
              {
                (*this)._M_erase(__first);
              }
            else
              {
                __extra = __first;
              }
          }
        __first = __next;
      }
    if (__extra != __last)
      {
        (*this)._M_erase(__extra);
      }
  }
  template < typename _Tp, typename _Alloc >
  void list<_Tp, _Alloc>::unique()
  {
    typename ::std::list<_Tp, _Alloc>::iterator __first = (*this).begin();
    typename ::std::list<_Tp, _Alloc>::iterator __last = (*this).end();
    if (__first == __last)
      {
        return ;
      }
    typename ::std::list<_Tp, _Alloc>::iterator __next = __first;
    while ( ++__next != __last)
      {
        if (*__first == *__next)
          {
            (*this)._M_erase(__next);
          }
        else
          {
            __first = __next;
          }
        __next = __first;
      }
  }
  template < typename _Tp, typename _Alloc >
  void list<_Tp, _Alloc>::merge(::std::list<_Tp, _Alloc> &&__x)
  {
    if (this != &__x)
      {
        (*this)._M_check_equal_allocators(__x);
        typename ::std::list<_Tp, _Alloc>::iterator __first1 = (*this).begin();
        typename ::std::list<_Tp, _Alloc>::iterator __last1 = (*this).end();
        typename ::std::list<_Tp, _Alloc>::iterator __first2 = __x.begin();
        typename ::std::list<_Tp, _Alloc>::iterator __last2 = __x.end();
        while (__first1 != __last1 && __first2 != __last2)
          {
            if (*__first2 < *__first1)
              {
                typename ::std::list<_Tp, _Alloc>::iterator __next = __first2;
                (*this)._M_transfer(__first1, __first2,  ++__next);
                __first2 = __next;
              }
            else
              {
                 ++__first1;
              }
          }
        if (__first2 != __last2)
          {
            (*this)._M_transfer(__last1, __first2, __last2);
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _StrictWeakOrdering >
  void list<_Tp, _Alloc>::merge(::std::list<_Tp, _Alloc> &&__x, _StrictWeakOrdering __comp)
  {
    if (this != &__x)
      {
        (*this)._M_check_equal_allocators(__x);
        typename ::std::list<_Tp, _Alloc>::iterator __first1 = (*this).begin();
        typename ::std::list<_Tp, _Alloc>::iterator __last1 = (*this).end();
        typename ::std::list<_Tp, _Alloc>::iterator __first2 = __x.begin();
        typename ::std::list<_Tp, _Alloc>::iterator __last2 = __x.end();
        while (__first1 != __last1 && __first2 != __last2)
          {
            if (__comp(*__first2, *__first1))
              {
                typename ::std::list<_Tp, _Alloc>::iterator __next = __first2;
                (*this)._M_transfer(__first1, __first2,  ++__next);
                __first2 = __next;
              }
            else
              {
                 ++__first1;
              }
          }
        if (__first2 != __last2)
          {
            (*this)._M_transfer(__last1, __first2, __last2);
          }
      }
  }
  template < typename _Tp, typename _Alloc >
  void list<_Tp, _Alloc>::sort()
  {
    if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        ::std::list<_Tp, _Alloc> __carry;
        ::std::list<_Tp, _Alloc> __tmp[64L];
        ::std::list<_Tp, _Alloc> *__fill = &__tmp[0];
        ::std::list<_Tp, _Alloc> *__counter;
        do
          {
            __carry.splice(__carry.begin(), *this, (*this).begin());
            for (__counter = &__tmp[0]; __counter != __fill && !__counter->empty();  ++__counter)
              {
                __counter->merge(__carry);
                __carry.swap(*__counter);
              }
            __carry.swap(*__counter);
            if (__counter == __fill)
              {
                 ++__fill;
              }
          }
        while (!(*this).empty());
        for (__counter = &__tmp[1]; __counter != __fill;  ++__counter)
          {
            __counter->merge(*(__counter - 1));
          }
        (*this).swap(*(__fill - 1));
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _Predicate >
  void list<_Tp, _Alloc>::remove_if(_Predicate __pred)
  {
    typename ::std::list<_Tp, _Alloc>::iterator __first = (*this).begin();
    typename ::std::list<_Tp, _Alloc>::iterator __last = (*this).end();
    while (__first != __last)
      {
        typename ::std::list<_Tp, _Alloc>::iterator __next = __first;
         ++__next;
        if (__pred(*__first))
          {
            (*this)._M_erase(__first);
          }
        __first = __next;
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _BinaryPredicate >
  void list<_Tp, _Alloc>::unique(_BinaryPredicate __binary_pred)
  {
    typename ::std::list<_Tp, _Alloc>::iterator __first = (*this).begin();
    typename ::std::list<_Tp, _Alloc>::iterator __last = (*this).end();
    if (__first == __last)
      {
        return ;
      }
    typename ::std::list<_Tp, _Alloc>::iterator __next = __first;
    while ( ++__next != __last)
      {
        if (__binary_pred(*__first, *__next))
          {
            (*this)._M_erase(__next);
          }
        else
          {
            __first = __next;
          }
        __next = __first;
      }
  }
  template < typename _Tp, typename _Alloc >
  template < typename _StrictWeakOrdering >
  void list<_Tp, _Alloc>::sort(_StrictWeakOrdering __comp)
  {
    if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        ::std::list<_Tp, _Alloc> __carry;
        ::std::list<_Tp, _Alloc> __tmp[64L];
        ::std::list<_Tp, _Alloc> *__fill = &__tmp[0];
        ::std::list<_Tp, _Alloc> *__counter;
        do
          {
            __carry.splice(__carry.begin(), *this, (*this).begin());
            for (__counter = &__tmp[0]; __counter != __fill && !__counter->empty();  ++__counter)
              {
                __counter->merge(__carry, __comp);
                __carry.swap(*__counter);
              }
            __carry.swap(*__counter);
            if (__counter == __fill)
              {
                 ++__fill;
              }
          }
        while (!(*this).empty());
        for (__counter = &__tmp[1]; __counter != __fill;  ++__counter)
          {
            __counter->merge(*(__counter - 1), __comp);
          }
        (*this).swap(*(__fill - 1));
      }
  }
}
namespace boost {
  class  bad_weak_ptr : public ::std::exception
  {
    public:
      virtual inline const char *what() const  throw()
      {
        return "tr1::bad_weak_ptr";
      }
  };
  namespace detail {
    typedef ::std::type_info sp_typeinfo;
    inline int atomic_exchange_and_add(int *pw, int dv)
    {
      int r;
      __asm__ __volatile__("lock\n\t""xadd %1, %0" : "=m"(*pw), "=r"(r) : "m"(*pw), "1"(dv) : "memory", "cc");
      return r;
    }
    inline void atomic_increment(int *pw)
    {
      __asm__ ("lock\n\t""incl %0" : "=m"(*pw) : "m"(*pw) : "cc");
    }
    inline int atomic_conditional_increment(int *pw)
    {
      int rv;
      int tmp;
      __asm__ ("movl %0, %%eax\n\t""0:\n\t""test %%eax, %%eax\n\t""je 1f\n\t""movl %%eax, %2\n\t""incl %2\n\t""lock\n\t""cmpxchgl %2, %0\n\t""jne 0b\n\t""1:" : "=m"(*pw), "=&a"(rv), "=&r"(tmp) : "m"(*pw) : "cc");
      return rv;
    }
    class  sp_counted_base
    {
        sp_counted_base(const ::boost::detail::sp_counted_base &);
        ::boost::detail::sp_counted_base &operator =(const ::boost::detail::sp_counted_base &);
        int use_count_;
        int weak_count_;
      public:
        inline sp_counted_base()
          : use_count_(1), weak_count_(1)
        {
        }
        virtual inline ~sp_counted_base()
        {
        }
        virtual void dispose() = 0 ;
        virtual inline void destroy()
        {
          delete this;
        }
        virtual void *get_deleter(const ::boost::detail::sp_typeinfo &ti) = 0 ;
        virtual void *get_untyped_deleter() = 0 ;
        inline void add_ref_copy()
        {
          ::boost::detail::atomic_increment(&(*this).use_count_);
        }
        inline bool add_ref_lock()
        {
          return ::boost::detail::atomic_conditional_increment(&(*this).use_count_) != 0;
        }
        inline void release()
        {
          if (::boost::detail::atomic_exchange_and_add(&(*this).use_count_,  -1) == 1)
            {
              (*this).dispose();
              (*this).::boost::detail::sp_counted_base::weak_release();
            }
        }
        inline void weak_add_ref()
        {
          ::boost::detail::atomic_increment(&(*this).weak_count_);
        }
        inline void weak_release()
        {
          if (::boost::detail::atomic_exchange_and_add(&(*this).weak_count_,  -1) == 1)
            {
              (*this).destroy();
            }
        }
        inline long int use_count() const 
        {
          return static_cast<const volatile int &>((*this).use_count_);
        }
    };
    template < typename X >
    class  sp_counted_impl_p : public ::boost::detail::sp_counted_base
    {
        X *px_;
        sp_counted_impl_p(const ::boost::detail::sp_counted_impl_p<X> &);
        ::boost::detail::sp_counted_impl_p<X> &operator =(const ::boost::detail::sp_counted_impl_p<X> &);
        typedef ::boost::detail::sp_counted_impl_p<X> this_type;
      public:
        inline explicit sp_counted_impl_p(X *px)
          : px_(px)
        {
        }
        inline virtual void dispose()
        {
          boost::checked_delete(::boost::detail::sp_counted_impl_p<X>::px_);
        }
        inline virtual void *get_deleter(const ::boost::detail::sp_typeinfo &)
        {
          return 0;
        }
        inline virtual void *get_untyped_deleter()
        {
          return 0;
        }
    };
    template < typename P, typename D >
    class  sp_counted_impl_pd : public ::boost::detail::sp_counted_base
    {
        P ptr;
        D del;
        sp_counted_impl_pd(const ::boost::detail::sp_counted_impl_pd<P, D> &);
        ::boost::detail::sp_counted_impl_pd<P, D> &operator =(const ::boost::detail::sp_counted_impl_pd<P, D> &);
        typedef ::boost::detail::sp_counted_impl_pd<P, D> this_type;
      public:
        inline sp_counted_impl_pd(P p, D &d)
          : ptr(p), del(d)
        {
        }
        inline sp_counted_impl_pd(P p)
          : ptr(p), del()
        {
        }
        inline virtual void dispose()
        {
          ::boost::detail::sp_counted_impl_pd<P, D>::del(::boost::detail::sp_counted_impl_pd<P, D>::ptr);
        }
        inline virtual void *get_deleter(const ::boost::detail::sp_typeinfo &ti)
        {
          return ti == typeid(D) ? &reinterpret_cast<char &>(::boost::detail::sp_counted_impl_pd<P, D>::del) : 0;
        }
        inline virtual void *get_untyped_deleter()
        {
          return &reinterpret_cast<char &>(::boost::detail::sp_counted_impl_pd<P, D>::del);
        }
    };
    template < typename P, typename D, typename A >
    class  sp_counted_impl_pda : public ::boost::detail::sp_counted_base
    {
        P p_;
        D d_;
        A a_;
        sp_counted_impl_pda(const ::boost::detail::sp_counted_impl_pda<P, D, A> &);
        ::boost::detail::sp_counted_impl_pda<P, D, A> &operator =(const ::boost::detail::sp_counted_impl_pda<P, D, A> &);
        typedef ::boost::detail::sp_counted_impl_pda<P, D, A> this_type;
      public:
        inline sp_counted_impl_pda(P p, D &d, A a)
          : p_(p), d_(d), a_(a)
        {
        }
        inline sp_counted_impl_pda(P p, A a)
          : p_(p), d_(), a_(a)
        {
        }
        inline virtual void dispose()
        {
          ::boost::detail::sp_counted_impl_pda<P, D, A>::d_(::boost::detail::sp_counted_impl_pda<P, D, A>::p_);
        }
        inline virtual void destroy()
        {
          typedef typename A::template rebind< typename ::boost::detail::sp_counted_impl_pda<P, D, A>::this_type>::other A2;
          A2 a2(::boost::detail::sp_counted_impl_pda<P, D, A>::a_);
          this->~this_type();
          a2.deallocate(this, 1);
        }
        inline virtual void *get_deleter(const ::boost::detail::sp_typeinfo &ti)
        {
          return ti == typeid(D) ? &reinterpret_cast<char &>(::boost::detail::sp_counted_impl_pda<P, D, A>::d_) : 0;
        }
        inline virtual void *get_untyped_deleter()
        {
          return &reinterpret_cast<char &>(::boost::detail::sp_counted_impl_pda<P, D, A>::d_);
        }
    };
    template < typename T >
    struct  addr_impl_ref
    {
        T &v_;
        inline addr_impl_ref(T &v)
          : v_(v)
        {
        }
        inline operator T &() const 
        {
          return ::boost::detail::addr_impl_ref<T>::v_;
        }
      private:
        ::boost::detail::addr_impl_ref<T> &operator =(const ::boost::detail::addr_impl_ref<T> &);
    };
    template < typename T >
    struct  addressof_impl
    {
        static inline T *f(T &v, long int)
        {
          return reinterpret_cast<T *>(&const_cast<char &>(reinterpret_cast<const volatile char &>(v)));
        }
        static inline T *f(T *v, int)
        {
          return v;
        }
    };
  }
  template < typename T >
  T *addressof(T &v);
  template < typename T >
  T *addressof(T &v)
  {
    return boost::detail::addressof_impl<T>::f(::boost::detail::addr_impl_ref<T>(v), 0);
  }
  namespace detail {
    struct  sp_nothrow_tag
    {
    };
    template < typename D >
    struct  sp_inplace_tag
    {
    };
    template < typename T >
    class  sp_reference_wrapper
    {
      public:
        inline explicit sp_reference_wrapper(T &t)
          : t_(boost::addressof(t))
        {
        }
        template < typename Y >
        inline void operator ()(Y *p) const 
        {
          (*::boost::detail::sp_reference_wrapper<T>::t_)(p);
        }
      private:
        T *t_;
    };
    template < typename D >
    struct  sp_convert_reference
    {
        typedef D type;
    };
    template < typename D >
    struct  sp_convert_reference<D &>
    {
        typedef ::boost::detail::sp_reference_wrapper<D> type;
    };
    class weak_count;
 /* Instantiation of class template '::std::binary_function< ::boost::detail::sp_counted_base *, ::boost::detail::sp_counted_base *, bool>' */ 
 /* Instantiation of class template '::std::less< ::boost::detail::sp_counted_base *>' */ 
 /* Instantiation of template function 'bool ::std::less< ::boost::detail::sp_counted_base *>::operator ()(::boost::detail::sp_counted_base *const &, ::boost::detail::sp_counted_base *const &) const ' */ 
    class  shared_count
    {
        ::boost::detail::sp_counted_base *pi_;
      public:
        inline shared_count()
          : pi_(0)
        {
        }
        template < typename Y >
        inline explicit shared_count(Y *p)
          : pi_(0)
        {
          try
          {
            (*this).pi_ = (new ::boost::detail::sp_counted_impl_p<Y>(p));
          }
          catch (...)
          {
            boost::checked_delete(p);
            throw;
          }
        }
        template < typename P, typename D >
        inline shared_count(P p, D d)
          : pi_(0)
        {
          try
          {
            (*this).pi_ = (new ::boost::detail::sp_counted_impl_pd<P, D>(p, d));
          }
          catch (...)
          {
            d(p);
            throw;
          }
        }
        template < typename P, typename D >
        inline shared_count(P p, ::boost::detail::sp_inplace_tag<D>)
          : pi_(0)
        {
          try
          {
            (*this).pi_ = (new ::boost::detail::sp_counted_impl_pd<P, D>(p));
          }
          catch (...)
          {
            D::operator_fn(p);
            throw;
          }
        }
        template < typename P, typename D, typename A >
        inline shared_count(P p, D d, A a)
          : pi_(0)
        {
          typedef ::boost::detail::sp_counted_impl_pda<P, D, A> impl_type;
          typedef typename A::template rebind< impl_type>::other A2;
          A2 a2(a);
          try
          {
            (*this).pi_ = a2.allocate(1, static_cast<impl_type *>(0));
            new (static_cast<void *>((*this).pi_))impl_type(p, d, a);
          }
          catch (...)
          {
            d(p);
            if ((*this).pi_ != 0)
              {
                a2.deallocate(static_cast<impl_type *>((*this).pi_), 1);
              }
            throw;
          }
        }
        template < typename P, typename D, typename A >
        inline shared_count(P p, ::boost::detail::sp_inplace_tag<D>, A a)
          : pi_(0)
        {
          typedef ::boost::detail::sp_counted_impl_pda<P, D, A> impl_type;
          typedef typename A::template rebind< impl_type>::other A2;
          A2 a2(a);
          try
          {
            (*this).pi_ = a2.allocate(1, static_cast<impl_type *>(0));
            new (static_cast<void *>((*this).pi_))impl_type(p, a);
          }
          catch (...)
          {
            D::operator_fn(p);
            if ((*this).pi_ != 0)
              {
                a2.deallocate(static_cast<impl_type *>((*this).pi_), 1);
              }
            throw;
          }
        }
        template < typename Y >
        inline explicit shared_count(::std::auto_ptr<Y> &r)
          : pi_(new ::boost::detail::sp_counted_impl_p<Y>(r.get()))
        {
          r.release();
        }
        template < typename Y, typename D >
        inline explicit shared_count(::std::unique_ptr<Y, D> &r)
          : pi_(0)
        {
          typedef typename ::boost::detail::sp_convert_reference<D>::type D2;
          D2 d2(r.get_deleter());
          (*this).pi_ = (new ::boost::detail::sp_counted_impl_pd<typename ::std::unique_ptr<Y, D>::pointer, D2>(r.get(), d2));
          r.release();
        }
        inline ~shared_count()
        {
          if ((*this).pi_ != 0)
            {
              (*(*this).pi_).::boost::detail::sp_counted_base::release();
            }
        }
        inline shared_count(const ::boost::detail::shared_count &r)
          : pi_(r.pi_)
        {
          if ((*this).pi_ != 0)
            {
              (*(*this).pi_).::boost::detail::sp_counted_base::add_ref_copy();
            }
        }
        inline shared_count(::boost::detail::shared_count &&r)
          : pi_(r.pi_)
        {
          r.pi_ = 0;
        }
        inline explicit shared_count(const ::boost::detail::weak_count &r);
        inline shared_count(const ::boost::detail::weak_count &r, ::boost::detail::sp_nothrow_tag);
        inline ::boost::detail::shared_count &operator =(const ::boost::detail::shared_count &r)
        {
          ::boost::detail::sp_counted_base *tmp(r.pi_);
          if (tmp != (*this).pi_)
            {
              if (tmp != 0)
                {
                  (*tmp).::boost::detail::sp_counted_base::add_ref_copy();
                }
              if ((*this).pi_ != 0)
                {
                  (*(*this).pi_).::boost::detail::sp_counted_base::release();
                }
              (*this).pi_ = tmp;
            }
          return *this;
        }
        inline void swap(::boost::detail::shared_count &r)
        {
          ::boost::detail::sp_counted_base *tmp(r.pi_);
          r.pi_ = (*this).pi_;
          (*this).pi_ = tmp;
        }
        inline long int use_count() const 
        {
          return (*this).pi_ != 0 ? (*(*this).pi_).::boost::detail::sp_counted_base::use_count() : 0;
        }
        inline bool unique() const 
        {
          return (*this).::boost::detail::shared_count::use_count() == 1;
        }
        inline bool empty() const 
        {
          return (*this).pi_ == 0;
        }
        inline void *get_deleter(const ::boost::detail::sp_typeinfo &ti) const 
        {
          return (*this).pi_ ? (*(*this).pi_).get_deleter(ti) : 0;
        }
        inline void *get_untyped_deleter() const 
        {
          return (*this).pi_ ? (*(*this).pi_).get_untyped_deleter() : 0;
        }
      friend class ::boost::detail::weak_count;
      friend inline bool operator ==(const ::boost::detail::shared_count &a, const ::boost::detail::shared_count &b)
      {
        return a.pi_ == b.pi_;
      }
      friend inline bool operator <(const ::boost::detail::shared_count &a, const ::boost::detail::shared_count &b)
      {
        return ::std::less< ::boost::detail::sp_counted_base *>().::std::less< ::boost::detail::sp_counted_base *>::operator ()(a.pi_, b.pi_);
      }
    };
 /* Instantiation of template function 'bool ::std::less< ::boost::detail::sp_counted_base *>::operator ()(::boost::detail::sp_counted_base *const &, ::boost::detail::sp_counted_base *const &) const ' */ 
    class  weak_count
    {
        ::boost::detail::sp_counted_base *pi_;
      public:
        inline weak_count()
          : pi_(0)
        {
        }
        inline weak_count(const ::boost::detail::shared_count &r)
          : pi_(r.pi_)
        {
          if ((*this).pi_ != 0)
            {
              (*(*this).pi_).::boost::detail::sp_counted_base::weak_add_ref();
            }
        }
        inline weak_count(const ::boost::detail::weak_count &r)
          : pi_(r.pi_)
        {
          if ((*this).pi_ != 0)
            {
              (*(*this).pi_).::boost::detail::sp_counted_base::weak_add_ref();
            }
        }
        inline weak_count(::boost::detail::weak_count &&r)
          : pi_(r.pi_)
        {
          r.pi_ = 0;
        }
        inline ~weak_count()
        {
          if ((*this).pi_ != 0)
            {
              (*(*this).pi_).::boost::detail::sp_counted_base::weak_release();
            }
        }
        inline ::boost::detail::weak_count &operator =(const ::boost::detail::shared_count &r)
        {
          ::boost::detail::sp_counted_base *tmp(r.pi_);
          if (tmp != (*this).pi_)
            {
              if (tmp != 0)
                {
                  (*tmp).::boost::detail::sp_counted_base::weak_add_ref();
                }
              if ((*this).pi_ != 0)
                {
                  (*(*this).pi_).::boost::detail::sp_counted_base::weak_release();
                }
              (*this).pi_ = tmp;
            }
          return *this;
        }
        inline ::boost::detail::weak_count &operator =(const ::boost::detail::weak_count &r)
        {
          ::boost::detail::sp_counted_base *tmp(r.pi_);
          if (tmp != (*this).pi_)
            {
              if (tmp != 0)
                {
                  (*tmp).::boost::detail::sp_counted_base::weak_add_ref();
                }
              if ((*this).pi_ != 0)
                {
                  (*(*this).pi_).::boost::detail::sp_counted_base::weak_release();
                }
              (*this).pi_ = tmp;
            }
          return *this;
        }
        inline void swap(::boost::detail::weak_count &r)
        {
          ::boost::detail::sp_counted_base *tmp(r.pi_);
          r.pi_ = (*this).pi_;
          (*this).pi_ = tmp;
        }
        inline long int use_count() const 
        {
          return (*this).pi_ != 0 ? (*(*this).pi_).::boost::detail::sp_counted_base::use_count() : 0;
        }
        inline bool empty() const 
        {
          return (*this).pi_ == 0;
        }
      friend class ::boost::detail::shared_count;
      friend inline bool operator ==(const ::boost::detail::weak_count &a, const ::boost::detail::weak_count &b)
      {
        return a.pi_ == b.pi_;
      }
      friend inline bool operator <(const ::boost::detail::weak_count &a, const ::boost::detail::weak_count &b)
      {
        return ::std::less< ::boost::detail::sp_counted_base *>().::std::less< ::boost::detail::sp_counted_base *>::operator ()(a.pi_, b.pi_);
      }
    };
 /* Instantiation of template function 'void ::boost::throw_exception< ::boost::bad_weak_ptr>(const ::boost::bad_weak_ptr &)' */ 
    inline shared_count::shared_count(const ::boost::detail::weak_count &r)
      : pi_(r.pi_)
    {
      if ((*this).pi_ == 0 || !(*(*this).pi_).::boost::detail::sp_counted_base::add_ref_lock())
        {
          boost::throw_exception(::boost::bad_weak_ptr());
        }
    }
    inline shared_count::shared_count(const ::boost::detail::weak_count &r, ::boost::detail::sp_nothrow_tag)
      : pi_(r.pi_)
    {
      if ((*this).pi_ != 0 && !(*(*this).pi_).::boost::detail::sp_counted_base::add_ref_lock())
        {
          (*this).pi_ = 0;
        }
    }
    template < typename Y, typename T >
    struct  sp_convertible
    {
        typedef char (&yes)[1L];
        typedef char (&no)[2L];
        static typename ::boost::detail::sp_convertible<Y, T>::yes f(T *);
        static typename ::boost::detail::sp_convertible<Y, T>::no f(...);
        enum _vt
        {
          value = sizeof((f)(static_cast<Y *>(0))) == sizeof(typename ::boost::detail::sp_convertible<Y, T>::yes)
        };
    };
    template < typename Y, typename T >
    struct  sp_convertible<Y, T []>
    {
        enum _vt
        {
          value = false
        };
    };
    template < typename Y, typename T >
    struct  sp_convertible<Y [], T []>
    {
        enum _vt
        {
          value = sp_convertible<Y [1L], T [1L]>::value
        };
    };
    template < typename Y, ::std::size_t N, typename T >
    struct  sp_convertible<Y [N], T []>
    {
        enum _vt
        {
          value = sp_convertible<Y [1L], T [1L]>::value
        };
    };
    struct  sp_empty
    {
    };
    template < bool __nontype_tpl_param_1_0__ >
    struct sp_enable_if_convertible_impl;
    template <>
    struct  sp_enable_if_convertible_impl<true>
    {
        typedef ::boost::detail::sp_empty type;
    };
    template <>
    struct  sp_enable_if_convertible_impl<false>
    {
    };
    template < typename Y, typename T >
    struct  sp_enable_if_convertible : ::boost::detail::sp_enable_if_convertible_impl<sp_convertible<Y, T>::value>
    {
    };
    inline void yield(unsigned int k)
    {
      if (k < 4)
        {
        }
      else
        {
          if (k < 16)
            {
              __asm__ __volatile__("rep; nop" :  :  : "memory");
            }
          else
            {
              if (k < 32 || k & 1)
                {
                  ::sched_yield();
                }
              else
                {
                  ::timespec rqtp = { /* .::timespec::tv_sec =  */ 0,  /* .::timespec::tv_nsec =  */ 0};
                  rqtp.tv_sec = 0;
                  rqtp.tv_nsec = 1000;
                  ::nanosleep(&rqtp, 0);
                }
            }
        }
    }
    class  spinlock
    {
      public:
        int v_;
        inline bool try_lock()
        {
          int r(__sync_lock_test_and_set(&(*this).v_, 1));
          return r == 0;
        }
        inline void lock()
        {
          for (unsigned int k(0); !(*this).::boost::detail::spinlock::try_lock();  ++k)
            {
              boost::detail::yield(k);
            }
        }
        inline void unlock()
        {
          __sync_lock_release(&(*this).v_);
        }
        class  scoped_lock
        {
            ::boost::detail::spinlock &sp_;
            scoped_lock(const ::boost::detail::spinlock::scoped_lock &);
            ::boost::detail::spinlock::scoped_lock &operator =(const ::boost::detail::spinlock::scoped_lock &);
          public:
            inline explicit scoped_lock(::boost::detail::spinlock &sp)
              : sp_(sp)
            {
              sp.::boost::detail::spinlock::lock();
            }
            inline ~scoped_lock()
            {
              (*this).sp_.::boost::detail::spinlock::unlock();
            }
        };
    };
    template < int I >
    class  spinlock_pool
    {
        static ::boost::detail::spinlock pool_[41L];
      public:
        static inline ::boost::detail::spinlock &spinlock_for(const void *pv)
        {
          ::std::size_t i(reinterpret_cast< ::std::size_t>(pv) % 41);
          return ::boost::detail::spinlock_pool<I>::pool_[i];
        }
        class  scoped_lock
        {
            ::boost::detail::spinlock &sp_;
            scoped_lock(const typename ::boost::detail::spinlock_pool<I>::scoped_lock &);
            typename ::boost::detail::spinlock_pool<I>::scoped_lock &operator =(const typename ::boost::detail::spinlock_pool<I>::scoped_lock &);
          public:
            inline explicit scoped_lock(const void *pv)
              : sp_((spinlock_for)(pv))
            {
              ::boost::detail::spinlock_pool<I>::scoped_lock::sp_.lock();
            }
            inline ~scoped_lock()
            {
              ::boost::detail::spinlock_pool<I>::scoped_lock::sp_.unlock();
            }
        };
    };
    template < int I >
    ::boost::detail::spinlock spinlock_pool<I>::pool_[41L] = { /* [0] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [1] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [2] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [3] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [4] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [5] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [6] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [7] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [8] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [9] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [10] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [11] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [12] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [13] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [14] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [15] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [16] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [17] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [18] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [19] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [20] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [21] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [22] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [23] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [24] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [25] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [26] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [27] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [28] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [29] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [30] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [31] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [32] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [33] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [34] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [35] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [36] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [37] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [38] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [39] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0},  /* [40] =  */ { /* .::boost::detail::spinlock::v_ =  */ 0}};
  }
  enum memory_order
  {
    memory_order_relaxed = 0,
    memory_order_acquire = 1,
    memory_order_release = 2,
    memory_order_acq_rel = 3,
    memory_order_seq_cst = 7,
    memory_order_consume = 8
  };
  template < typename T >
  class shared_ptr;
  template < typename T >
  class weak_ptr;
  template < typename T >
  class enable_shared_from_this;
  class enable_shared_from_raw;
  namespace detail {
    template < typename T >
    struct  sp_element
    {
        typedef T type;
    };
    template < typename T >
    struct  sp_element<T []>
    {
        typedef T type;
    };
    template < typename T, ::std::size_t N >
    struct  sp_element<T [N]>
    {
        typedef T type;
    };
    template < typename T >
    struct  sp_dereference
    {
        typedef T &type;
    };
    template <>
    struct  sp_dereference<void>
    {
        typedef void type;
    };
    template <>
    struct  sp_dereference<const void>
    {
        typedef void type;
    };
    template <>
    struct  sp_dereference<volatile void>
    {
        typedef void type;
    };
    template <>
    struct  sp_dereference<const volatile void>
    {
        typedef void type;
    };
    template < typename T >
    struct  sp_dereference<T []>
    {
        typedef void type;
    };
    template < typename T, ::std::size_t N >
    struct  sp_dereference<T [N]>
    {
        typedef void type;
    };
    template < typename T >
    struct  sp_member_access
    {
        typedef T *type;
    };
    template < typename T >
    struct  sp_member_access<T []>
    {
        typedef void type;
    };
    template < typename T, ::std::size_t N >
    struct  sp_member_access<T [N]>
    {
        typedef void type;
    };
    template < typename T >
    struct  sp_array_access
    {
        typedef void type;
    };
    template < typename T >
    struct  sp_array_access<T []>
    {
        typedef T &type;
    };
    template < typename T, ::std::size_t N >
    struct  sp_array_access<T [N]>
    {
        typedef T &type;
    };
    template < typename T >
    struct  sp_extent
    {
        enum _vt
        {
          value = 0
        };
    };
    template < typename T, ::std::size_t N >
    struct  sp_extent<T [N]>
    {
        enum _vt
        {
          value = N
        };
    };
    template < typename X, typename Y, typename T >
    inline void sp_enable_shared_from_this(const ::boost::shared_ptr<X> *ppx, const Y *py, const ::boost::enable_shared_from_this<T> *pe);
    template < typename X, typename Y, typename T >
    inline void sp_enable_shared_from_this(const ::boost::shared_ptr<X> *ppx, const Y *py, const ::boost::enable_shared_from_this<T> *pe)
    {
      if (pe != 0)
        {
          pe->_internal_accept_owner(ppx, const_cast<Y *>(py));
        }
    }
    template < typename X, typename Y >
    inline void sp_enable_shared_from_this(::boost::shared_ptr<X> *ppx, const Y *py, const ::boost::enable_shared_from_raw *pe);
    inline void sp_enable_shared_from_this(...)
    {
    }
    template < typename T, typename R >
    struct  sp_enable_if_auto_ptr
    {
    };
    template < typename T, typename R >
    struct  sp_enable_if_auto_ptr< ::std::auto_ptr<T>, R>
    {
        typedef R type;
    };
    template < typename Y, typename T >
    inline void sp_assert_convertible();
    template < typename Y, typename T >
    inline void sp_assert_convertible()
    {
      typedef char tmp[sp_convertible<Y, T>::value ? 1 :  -1];
      (void)sizeof(tmp);
    }
    template < typename T, typename Y >
    inline void sp_pointer_construct(::boost::shared_ptr<T> *ppx, Y *p, ::boost::detail::shared_count &pn);
    template < typename T, typename Y >
    inline void sp_pointer_construct(::boost::shared_ptr<T> *ppx, Y *p, ::boost::detail::shared_count &pn)
    {
      ::boost::detail::shared_count(p).::boost::detail::shared_count::swap(pn);
      boost::detail::sp_enable_shared_from_this(ppx, p, p);
    }
    template < typename T, typename Y >
    inline void sp_pointer_construct(::boost::shared_ptr<T []> *, Y *p, ::boost::detail::shared_count &pn);
    template < typename T, typename Y >
    inline void sp_pointer_construct(::boost::shared_ptr<T []> *, Y *p, ::boost::detail::shared_count &pn)
    {
      sp_assert_convertible<Y [], T []>();
      ::boost::detail::shared_count(p, ::boost::checked_array_deleter<T>()).::boost::detail::shared_count::swap(pn);
    }
    template < typename T, ::std::size_t N, typename Y >
    inline void sp_pointer_construct(::boost::shared_ptr<T [N]> *, Y *p, ::boost::detail::shared_count &pn);
    template < typename T, ::std::size_t N, typename Y >
    inline void sp_pointer_construct(::boost::shared_ptr<T [N]> *, Y *p, ::boost::detail::shared_count &pn)
    {
      sp_assert_convertible<Y [N], T [N]>();
      ::boost::detail::shared_count(p, ::boost::checked_array_deleter<T>()).::boost::detail::shared_count::swap(pn);
    }
    template < typename T, typename Y >
    inline void sp_deleter_construct(::boost::shared_ptr<T> *ppx, Y *p);
    template < typename T, typename Y >
    inline void sp_deleter_construct(::boost::shared_ptr<T> *ppx, Y *p)
    {
      boost::detail::sp_enable_shared_from_this(ppx, p, p);
    }
    template < typename T, typename Y >
    inline void sp_deleter_construct(::boost::shared_ptr<T []> *, Y *);
    template < typename T, typename Y >
    inline void sp_deleter_construct(::boost::shared_ptr<T []> *, Y *)
    {
      sp_assert_convertible<Y [], T []>();
    }
    template < typename T, ::std::size_t N, typename Y >
    inline void sp_deleter_construct(::boost::shared_ptr<T [N]> *, Y *);
    template < typename T, ::std::size_t N, typename Y >
    inline void sp_deleter_construct(::boost::shared_ptr<T [N]> *, Y *)
    {
      sp_assert_convertible<Y [N], T [N]>();
    }
  }
  template < typename T >
  class  shared_ptr
  {
      typedef ::boost::shared_ptr<T> this_type;
    public:
      typedef typename ::boost::detail::sp_element<T>::type element_type;
      inline shared_ptr() noexcept(true)
        : px(0), pn()
      {
      }
      inline shared_ptr(::boost::detail::sp_nullptr_t) noexcept(true)
        : px(0), pn()
      {
      }
      template < typename Y >
      inline explicit shared_ptr(Y *p)
        : px(p), pn()
      {
        boost::detail::sp_pointer_construct(this, p, ::boost::shared_ptr<T>::pn);
      }
      template < typename Y, typename D >
      inline shared_ptr(Y *p, D d)
        : px(p), pn(p, d)
      {
        boost::detail::sp_deleter_construct(this, p);
      }
      template < typename D >
      inline shared_ptr(::boost::detail::sp_nullptr_t p, D d)
        : px(p), pn(p, d)
      {
      }
      template < typename Y, typename D, typename A >
      inline shared_ptr(Y *p, D d, A a)
        : px(p), pn(p, d, a)
      {
        boost::detail::sp_deleter_construct(this, p);
      }
      template < typename D, typename A >
      inline shared_ptr(::boost::detail::sp_nullptr_t p, D d, A a)
        : px(p), pn(p, d, a)
      {
      }
      inline shared_ptr(const ::boost::shared_ptr<T> &r) noexcept(true)
        : px(r.px), pn(r.pn)
      {
      }
      template < typename Y >
      inline explicit shared_ptr(const ::boost::weak_ptr<Y> &r)
        : pn(r.pn)
      {
        boost::detail::sp_assert_convertible<Y, T>();
        ::boost::shared_ptr<T>::px = r.px;
      }
      template < typename Y >
      inline shared_ptr(const ::boost::weak_ptr<Y> &r, ::boost::detail::sp_nothrow_tag) noexcept(true)
        : px(0), pn(r.pn, ::boost::detail::sp_nothrow_tag())
      {
        if (!::boost::shared_ptr<T>::pn.empty())
          {
            ::boost::shared_ptr<T>::px = r.px;
          }
      }
      template < typename Y >
      inline shared_ptr(const ::boost::shared_ptr<Y> &r, typename ::boost::detail::sp_enable_if_convertible<Y, T>::type  = (::boost::detail::sp_empty())) noexcept(true)
        : px(r.px), pn(r.pn)
      {
        boost::detail::sp_assert_convertible<Y, T>();
      }
      template < typename Y >
      inline shared_ptr(const ::boost::shared_ptr<Y> &r, typename ::boost::shared_ptr<T>::element_type *p) noexcept(true)
        : px(p), pn(r.pn)
      {
      }
      template < typename Y >
      inline explicit shared_ptr(::std::auto_ptr<Y> &r)
        : px(r.get()), pn()
      {
        boost::detail::sp_assert_convertible<Y, T>();
        Y *tmp = r.get();
        ::boost::shared_ptr<T>::pn = ::boost::detail::shared_count(r);
        boost::detail::sp_deleter_construct(this, tmp);
      }
      template < typename Y >
      inline shared_ptr(::std::auto_ptr<Y> &&r)
        : px(r.get()), pn()
      {
        boost::detail::sp_assert_convertible<Y, T>();
        Y *tmp = r.get();
        ::boost::shared_ptr<T>::pn = ::boost::detail::shared_count(r);
        boost::detail::sp_deleter_construct(this, tmp);
      }
      template < typename Y, typename D >
      inline shared_ptr(::std::unique_ptr<Y, D> &&r)
        : px(r.get()), pn()
      {
        boost::detail::sp_assert_convertible<Y, T>();
        typename ::std::unique_ptr<Y, D>::pointer tmp = r.get();
        ::boost::shared_ptr<T>::pn = ::boost::detail::shared_count(r);
        boost::detail::sp_deleter_construct(this, tmp);
      }
      inline ::boost::shared_ptr<T> &operator =(const ::boost::shared_ptr<T> &r) noexcept(true)
      {
        ((typename ::boost::shared_ptr<T>::this_type(r))).swap(*this);
        return *this;
      }
      template < typename Y >
      inline ::boost::shared_ptr<T> &operator =(const ::boost::shared_ptr<Y> &r) noexcept(true)
      {
        ((typename ::boost::shared_ptr<T>::this_type(r))).swap(*this);
        return *this;
      }
      template < typename Y >
      inline ::boost::shared_ptr<T> &operator =(::std::auto_ptr<Y> &r)
      {
        ((typename ::boost::shared_ptr<T>::this_type(r))).swap(*this);
        return *this;
      }
      template < typename Y >
      inline ::boost::shared_ptr<T> &operator =(::std::auto_ptr<Y> &&r)
      {
        ((typename ::boost::shared_ptr<T>::this_type(static_cast< ::std::auto_ptr<Y> &&>(r)))).swap(*this);
        return *this;
      }
      template < typename Y, typename D >
      inline ::boost::shared_ptr<T> &operator =(::std::unique_ptr<Y, D> &&r)
      {
        ((typename ::boost::shared_ptr<T>::this_type(static_cast< ::std::unique_ptr<Y, D> &&>(r)))).swap(*this);
        return *this;
      }
      inline shared_ptr(::boost::shared_ptr<T> &&r) noexcept(true)
        : px(r.px), pn()
      {
        ::boost::shared_ptr<T>::pn.swap(r.pn);
        r.px = 0;
      }
      template < typename Y >
      inline shared_ptr(::boost::shared_ptr<Y> &&r, typename ::boost::detail::sp_enable_if_convertible<Y, T>::type  = (::boost::detail::sp_empty())) noexcept(true)
        : px(r.px), pn()
      {
        boost::detail::sp_assert_convertible<Y, T>();
        ::boost::shared_ptr<T>::pn.swap(r.pn);
        r.px = 0;
      }
      inline ::boost::shared_ptr<T> &operator =(::boost::shared_ptr<T> &&r) noexcept(true)
      {
        ((typename ::boost::shared_ptr<T>::this_type(static_cast< ::boost::shared_ptr<T> &&>(r)))).swap(*this);
        return *this;
      }
      template < typename Y >
      inline ::boost::shared_ptr<T> &operator =(::boost::shared_ptr<Y> &&r) noexcept(true)
      {
        ((typename ::boost::shared_ptr<T>::this_type(static_cast< ::boost::shared_ptr<Y> &&>(r)))).swap(*this);
        return *this;
      }
      inline ::boost::shared_ptr<T> &operator =(::boost::detail::sp_nullptr_t) noexcept(true)
      {
        ((typename ::boost::shared_ptr<T>::this_type())).swap(*this);
        return *this;
      }
      inline void reset() noexcept(true)
      {
        ((typename ::boost::shared_ptr<T>::this_type())).swap(*this);
      }
      template < typename Y >
      inline void reset(Y *p)
      {
        p == 0 || p != ::boost::shared_ptr<T>::px ? static_cast<void>(0) : __assert_fail("p == 0 || p != px", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 624, __PRETTY_FUNCTION__);
        ((typename ::boost::shared_ptr<T>::this_type(p))).swap(*this);
      }
      template < typename Y, typename D >
      inline void reset(Y *p, D d)
      {
        ((typename ::boost::shared_ptr<T>::this_type(p, d))).swap(*this);
      }
      template < typename Y, typename D, typename A >
      inline void reset(Y *p, D d, A a)
      {
        ((typename ::boost::shared_ptr<T>::this_type(p, d, a))).swap(*this);
      }
      template < typename Y >
      inline void reset(const ::boost::shared_ptr<Y> &r, typename ::boost::shared_ptr<T>::element_type *p)
      {
        ((typename ::boost::shared_ptr<T>::this_type(r, p))).swap(*this);
      }
      inline typename ::boost::detail::sp_dereference<T>::type operator *() const 
      {
        ::boost::shared_ptr<T>::px != 0 ? static_cast<void>(0) : __assert_fail("px != 0", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 646, __PRETTY_FUNCTION__);
        return *::boost::shared_ptr<T>::px;
      }
      inline typename ::boost::detail::sp_member_access<T>::type operator ->() const 
      {
        ::boost::shared_ptr<T>::px != 0 ? static_cast<void>(0) : __assert_fail("px != 0", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 653, __PRETTY_FUNCTION__);
        return ::boost::shared_ptr<T>::px;
      }
      inline typename ::boost::detail::sp_array_access<T>::type operator [](::std::ptrdiff_t i) const 
      {
        ::boost::shared_ptr<T>::px != 0 ? static_cast<void>(0) : __assert_fail("px != 0", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 660, __PRETTY_FUNCTION__);
        i >= 0 && (i < boost::detail::sp_extent<T>::value || boost::detail::sp_extent<T>::value == 0) ? static_cast<void>(0) : __assert_fail("i >= 0 && ( i < boost::detail::sp_extent< T >::value || boost::detail::sp_extent< T >::value == 0 )", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 661, __PRETTY_FUNCTION__);
        return ::boost::shared_ptr<T>::px[i];
      }
      inline typename ::boost::shared_ptr<T>::element_type *get() const  noexcept(true)
      {
        return ::boost::shared_ptr<T>::px;
      }
      inline explicit operator bool() const  noexcept(true)
      {
        return ::boost::shared_ptr<T>::px != 0;
      }
      inline bool operator !() const  noexcept(true)
      {
        return ::boost::shared_ptr<T>::px == 0;
      }
      inline bool unique() const  noexcept(true)
      {
        return ::boost::shared_ptr<T>::pn.unique();
      }
      inline long int use_count() const  noexcept(true)
      {
        return ::boost::shared_ptr<T>::pn.use_count();
      }
      inline void swap(::boost::shared_ptr<T> &other) noexcept(true)
      {
        std::swap(::boost::shared_ptr<T>::px, other.px);
        ::boost::shared_ptr<T>::pn.swap(other.pn);
      }
      template < typename Y >
      inline bool owner_before(const ::boost::shared_ptr<Y> &rhs) const  noexcept(true)
      {
        return ::boost::shared_ptr<T>::pn < rhs.pn;
      }
      template < typename Y >
      inline bool owner_before(const ::boost::weak_ptr<Y> &rhs) const  noexcept(true)
      {
        return ::boost::shared_ptr<T>::pn < rhs.pn;
      }
      inline void *_internal_get_deleter(const ::boost::detail::sp_typeinfo &ti) const  noexcept(true)
      {
        return ::boost::shared_ptr<T>::pn.get_deleter(ti);
      }
      inline void *_internal_get_untyped_deleter() const  noexcept(true)
      {
        return ::boost::shared_ptr<T>::pn.get_untyped_deleter();
      }
      inline bool _internal_equiv(const ::boost::shared_ptr<T> &r) const  noexcept(true)
      {
        return ::boost::shared_ptr<T>::px == r.px && ::boost::shared_ptr<T>::pn == r.pn;
      }
    private:
      typename ::boost::shared_ptr<T>::element_type *px;
      ::boost::detail::shared_count pn;
    template < typename Y >
    friend class shared_ptr;
    template < typename Y >
    friend class weak_ptr;
  };
  template < typename T, typename U >
  inline bool operator ==(const ::boost::shared_ptr<T> &a, const ::boost::shared_ptr<U> &b) noexcept(true);
  template < typename T, typename U >
  inline bool operator ==(const ::boost::shared_ptr<T> &a, const ::boost::shared_ptr<U> &b) noexcept(true)
  {
    return a.get() == b.get();
  }
  template < typename T, typename U >
  inline bool operator !=(const ::boost::shared_ptr<T> &a, const ::boost::shared_ptr<U> &b) noexcept(true);
  template < typename T, typename U >
  inline bool operator !=(const ::boost::shared_ptr<T> &a, const ::boost::shared_ptr<U> &b) noexcept(true)
  {
    return a.get() != b.get();
  }
  template < typename T >
  inline bool operator ==(const ::boost::shared_ptr<T> &p, ::boost::detail::sp_nullptr_t) noexcept(true);
  template < typename T >
  inline bool operator ==(const ::boost::shared_ptr<T> &p, ::boost::detail::sp_nullptr_t) noexcept(true)
  {
    return p.get() == 0;
  }
  template < typename T >
  inline bool operator ==(::boost::detail::sp_nullptr_t, const ::boost::shared_ptr<T> &p) noexcept(true);
  template < typename T >
  inline bool operator ==(::boost::detail::sp_nullptr_t, const ::boost::shared_ptr<T> &p) noexcept(true)
  {
    return p.get() == 0;
  }
  template < typename T >
  inline bool operator !=(const ::boost::shared_ptr<T> &p, ::boost::detail::sp_nullptr_t) noexcept(true);
  template < typename T >
  inline bool operator !=(const ::boost::shared_ptr<T> &p, ::boost::detail::sp_nullptr_t) noexcept(true)
  {
    return p.get() != 0;
  }
  template < typename T >
  inline bool operator !=(::boost::detail::sp_nullptr_t, const ::boost::shared_ptr<T> &p) noexcept(true);
  template < typename T >
  inline bool operator !=(::boost::detail::sp_nullptr_t, const ::boost::shared_ptr<T> &p) noexcept(true)
  {
    return p.get() != 0;
  }
  template < typename T, typename U >
  inline bool operator <(const ::boost::shared_ptr<T> &a, const ::boost::shared_ptr<U> &b) noexcept(true);
  template < typename T, typename U >
  inline bool operator <(const ::boost::shared_ptr<T> &a, const ::boost::shared_ptr<U> &b) noexcept(true)
  {
    return a.owner_before(b);
  }
  template < typename T >
  inline void swap(::boost::shared_ptr<T> &a, ::boost::shared_ptr<T> &b) noexcept(true);
  template < typename T >
  inline void swap(::boost::shared_ptr<T> &a, ::boost::shared_ptr<T> &b) noexcept(true)
  {
    a.swap(b);
  }
  template < typename T, typename U >
  ::boost::shared_ptr<T> static_pointer_cast(const ::boost::shared_ptr<U> &r) noexcept(true);
  template < typename T, typename U >
  ::boost::shared_ptr<T> static_pointer_cast(const ::boost::shared_ptr<U> &r) noexcept(true)
  {
    (void)static_cast<T *>(static_cast<U *>(0));
    typedef typename ::boost::shared_ptr<T>::element_type E;
    E *p = static_cast<E *>(r.get());
    return ::boost::shared_ptr<T>(r, p);
  }
  template < typename T, typename U >
  ::boost::shared_ptr<T> const_pointer_cast(const ::boost::shared_ptr<U> &r) noexcept(true);
  template < typename T, typename U >
  ::boost::shared_ptr<T> const_pointer_cast(const ::boost::shared_ptr<U> &r) noexcept(true)
  {
    (void)const_cast<T *>(static_cast<U *>(0));
    typedef typename ::boost::shared_ptr<T>::element_type E;
    E *p = const_cast<E *>(r.get());
    return ::boost::shared_ptr<T>(r, p);
  }
  template < typename T, typename U >
  ::boost::shared_ptr<T> dynamic_pointer_cast(const ::boost::shared_ptr<U> &r) noexcept(true);
  template < typename T, typename U >
  ::boost::shared_ptr<T> dynamic_pointer_cast(const ::boost::shared_ptr<U> &r) noexcept(true)
  {
    (void)dynamic_cast<T *>(static_cast<U *>(0));
    typedef typename ::boost::shared_ptr<T>::element_type E;
    E *p = dynamic_cast<E *>(r.get());
    return p ? ::boost::shared_ptr<T>(r, p) : ::boost::shared_ptr<T>();
  }
  template < typename T, typename U >
  ::boost::shared_ptr<T> reinterpret_pointer_cast(const ::boost::shared_ptr<U> &r) noexcept(true);
  template < typename T, typename U >
  ::boost::shared_ptr<T> reinterpret_pointer_cast(const ::boost::shared_ptr<U> &r) noexcept(true)
  {
    (void)reinterpret_cast<T *>(static_cast<U *>(0));
    typedef typename ::boost::shared_ptr<T>::element_type E;
    E *p = reinterpret_cast<E *>(r.get());
    return ::boost::shared_ptr<T>(r, p);
  }
  template < typename T >
  inline typename ::boost::shared_ptr<T>::element_type *get_pointer(const ::boost::shared_ptr<T> &p) noexcept(true);
  template < typename T >
  inline typename ::boost::shared_ptr<T>::element_type *get_pointer(const ::boost::shared_ptr<T> &p) noexcept(true)
  {
    return p.get();
  }
  template < typename E, typename T, typename Y >
  ::std::basic_ostream<E, T> &operator <<(::std::basic_ostream<E, T> &os, const ::boost::shared_ptr<Y> &p);
  template < typename E, typename T, typename Y >
  ::std::basic_ostream<E, T> &operator <<(::std::basic_ostream<E, T> &os, const ::boost::shared_ptr<Y> &p)
  {
    os << p.get();
    return os;
  }
  namespace detail {
    template < typename D, typename T >
    D *basic_get_deleter(const ::boost::shared_ptr<T> &p) noexcept(true);
    template < typename D, typename T >
    D *basic_get_deleter(const ::boost::shared_ptr<T> &p) noexcept(true)
    {
      return static_cast<D *>(p._internal_get_deleter(typeid(D)));
    }
 /* Instantiation of class template '::boost::detail::sp_element<void>' */ 
 /* Instantiation of class template '::boost::detail::sp_member_access<void>' */ 
 /* Instantiation of class template '::boost::detail::sp_array_access<void>' */ 
 /* Instantiation of class template '::boost::shared_ptr<void>' */ 
 /* Instantiation of template function '::boost::shared_ptr<void>::shared_ptr()' */ 
    class  esft2_deleter_wrapper
    {
        ::boost::shared_ptr<void> deleter_;
      public:
        inline esft2_deleter_wrapper()
        {
        }
        template < typename T >
        inline void set_deleter(const ::boost::shared_ptr<T> &deleter)
        {
          (*this).deleter_ = deleter;
        }
        template < typename D >
        inline D *get_deleter() const  noexcept(true)
        {
          return boost::detail::basic_get_deleter<D>((*this).deleter_);
        }
        template < typename T >
        inline void operator ()(T *)
        {
          (*this).deleter_.::boost::shared_ptr<void>::use_count() <= 1 ? static_cast<void>(0) : __assert_fail("deleter_.use_count() <= 1", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 921, __PRETTY_FUNCTION__);
          (*this).deleter_.::boost::shared_ptr<void>::reset();
        }
    };
  }
  template < typename D, typename T >
  D *get_deleter(const ::boost::shared_ptr<T> &p) noexcept(true);
  template < typename D, typename T >
  D *get_deleter(const ::boost::shared_ptr<T> &p) noexcept(true)
  {
    D *del = boost::detail::basic_get_deleter<D>(p);
    if (del == 0)
      {
        ::boost::detail::esft2_deleter_wrapper *del_wrapper = boost::detail::basic_get_deleter< ::boost::detail::esft2_deleter_wrapper>(p);
        if (del_wrapper)
          {
            del = (*del_wrapper).::boost::detail::esft2_deleter_wrapper::get_deleter<D>();
          }
      }
    return del;
  }
  template < typename T >
  inline bool atomic_is_lock_free(const ::boost::shared_ptr<T> *) noexcept(true);
  template < typename T >
  inline bool atomic_is_lock_free(const ::boost::shared_ptr<T> *) noexcept(true)
  {
    return false;
  }
 /* Instantiation of class template '::boost::detail::spinlock_pool<2>' */ 
 /* Instantiation of class template '::boost::detail::spinlock_pool<2>::scoped_lock' */ 
  template < typename T >
  ::boost::shared_ptr<T> atomic_load(const ::boost::shared_ptr<T> *p);
  template < typename T >
  ::boost::shared_ptr<T> atomic_load(const ::boost::shared_ptr<T> *p)
  {
    ::boost::detail::spinlock_pool<2>::scoped_lock lock(p);
    return *p;
  }
  template < typename T >
  inline ::boost::shared_ptr<T> atomic_load_explicit(const ::boost::shared_ptr<T> *p, ::boost::memory_order);
  template < typename T >
  inline ::boost::shared_ptr<T> atomic_load_explicit(const ::boost::shared_ptr<T> *p, ::boost::memory_order)
  {
    return atomic_load(p);
  }
  template < typename T >
  void atomic_store(::boost::shared_ptr<T> *p, ::boost::shared_ptr<T> r);
  template < typename T >
  void atomic_store(::boost::shared_ptr<T> *p, ::boost::shared_ptr<T> r)
  {
    ::boost::detail::spinlock_pool<2>::scoped_lock lock(p);
    p->swap(r);
  }
  template < typename T >
  inline void atomic_store_explicit(::boost::shared_ptr<T> *p, ::boost::shared_ptr<T> r, ::boost::memory_order);
  template < typename T >
  inline void atomic_store_explicit(::boost::shared_ptr<T> *p, ::boost::shared_ptr<T> r, ::boost::memory_order)
  {
    atomic_store(p, r);
  }
  template < typename T >
  ::boost::shared_ptr<T> atomic_exchange(::boost::shared_ptr<T> *p, ::boost::shared_ptr<T> r);
  template < typename T >
  ::boost::shared_ptr<T> atomic_exchange(::boost::shared_ptr<T> *p, ::boost::shared_ptr<T> r)
  {
    ::boost::detail::spinlock &sp = boost::detail::spinlock_pool<2>::spinlock_for(p);
    sp.::boost::detail::spinlock::lock();
    p->swap(r);
    sp.::boost::detail::spinlock::unlock();
    return r;
  }
  template < typename T >
  ::boost::shared_ptr<T> atomic_exchange_explicit(::boost::shared_ptr<T> *p, ::boost::shared_ptr<T> r, ::boost::memory_order);
  template < typename T >
  ::boost::shared_ptr<T> atomic_exchange_explicit(::boost::shared_ptr<T> *p, ::boost::shared_ptr<T> r, ::boost::memory_order)
  {
    return atomic_exchange(p, r);
  }
  template < typename T >
  bool atomic_compare_exchange(::boost::shared_ptr<T> *p, ::boost::shared_ptr<T> *v, ::boost::shared_ptr<T> w);
  template < typename T >
  bool atomic_compare_exchange(::boost::shared_ptr<T> *p, ::boost::shared_ptr<T> *v, ::boost::shared_ptr<T> w)
  {
    ::boost::detail::spinlock &sp = boost::detail::spinlock_pool<2>::spinlock_for(p);
    sp.::boost::detail::spinlock::lock();
    if (p->_internal_equiv(*v))
      {
        p->swap(w);
        sp.::boost::detail::spinlock::unlock();
        return true;
      }
    else
      {
        ::boost::shared_ptr<T> tmp(*p);
        sp.::boost::detail::spinlock::unlock();
        tmp.swap(*v);
        return false;
      }
  }
  template < typename T >
  inline bool atomic_compare_exchange_explicit(::boost::shared_ptr<T> *p, ::boost::shared_ptr<T> *v, ::boost::shared_ptr<T> w, ::boost::memory_order, ::boost::memory_order);
  template < typename T >
  inline bool atomic_compare_exchange_explicit(::boost::shared_ptr<T> *p, ::boost::shared_ptr<T> *v, ::boost::shared_ptr<T> w, ::boost::memory_order, ::boost::memory_order)
  {
    return atomic_compare_exchange(p, v, w);
  }
  template < typename T >
  struct hash;
  template < typename T >
  ::std::size_t hash_value(const ::boost::shared_ptr<T> &p) noexcept(true);
  template < typename T >
  ::std::size_t hash_value(const ::boost::shared_ptr<T> &p) noexcept(true)
  {
    return ::boost::hash<T *>()(p.get());
  }
  namespace detail {
    class  lightweight_mutex
    {
        ::pthread_mutex_t m_;
        lightweight_mutex(const ::boost::detail::lightweight_mutex &);
        ::boost::detail::lightweight_mutex &operator =(const ::boost::detail::lightweight_mutex &);
      public:
        inline lightweight_mutex()
        {
          static const char __MERCURIUM_PRETTY_FUNCTION__[56L] = "::boost::detail::lightweight_mutex::lightweight_mutex()";
          ::pthread_mutex_init(&(*this).m_, 0) == 0 ? static_cast<void>(0) : ::__assert_fail("pthread_mutex_init( &m_, 0 ) == 0", "/usr/include/boost/smart_ptr/detail/lwm_pthreads.hpp", 48, __MERCURIUM_PRETTY_FUNCTION__);
        }
        inline ~lightweight_mutex()
        {
          static const char __MERCURIUM_PRETTY_FUNCTION__[69L] = "void ::boost::detail::lightweight_mutex::~lightweight_mutex() const ";
          ::pthread_mutex_destroy(&(*this).m_) == 0 ? static_cast<void>(0) : ::__assert_fail("pthread_mutex_destroy( &m_ ) == 0", "/usr/include/boost/smart_ptr/detail/lwm_pthreads.hpp", 54, __MERCURIUM_PRETTY_FUNCTION__);
        }
        class scoped_lock;
        class  scoped_lock
        {
            ::pthread_mutex_t &m_;
            scoped_lock(const ::boost::detail::lightweight_mutex::scoped_lock &);
            ::boost::detail::lightweight_mutex::scoped_lock &operator =(const ::boost::detail::lightweight_mutex::scoped_lock &);
          public:
            inline scoped_lock(::boost::detail::lightweight_mutex &m)
              : m_(m.m_)
            {
              static const char __MERCURIUM_PRETTY_FUNCTION__[99L] = "::boost::detail::lightweight_mutex::scoped_lock::scoped_lock(::boost::detail::lightweight_mutex &)";
              ::pthread_mutex_lock(&(*this).m_) == 0 ? static_cast<void>(0) : ::__assert_fail("pthread_mutex_lock( &m_ ) == 0", "/usr/include/boost/smart_ptr/detail/lwm_pthreads.hpp", 73, __MERCURIUM_PRETTY_FUNCTION__);
            }
            inline ~scoped_lock()
            {
              static const char __MERCURIUM_PRETTY_FUNCTION__[76L] = "void ::boost::detail::lightweight_mutex::scoped_lock::~scoped_lock() const ";
              ::pthread_mutex_unlock(&(*this).m_) == 0 ? static_cast<void>(0) : ::__assert_fail("pthread_mutex_unlock( &m_ ) == 0", "/usr/include/boost/smart_ptr/detail/lwm_pthreads.hpp", 78, __MERCURIUM_PRETTY_FUNCTION__);
            }
        };
      friend class ::boost::detail::lightweight_mutex::scoped_lock;
    };
  }
}
namespace boost_132 {
   class  bad_weak_ptr : public ::std::exception
  {
    public:
      virtual inline const char *what() const  throw()
      {
        return "boost::bad_weak_ptr";
      }
  };
 /* Instantiation of template function 'void ::boost::serialization::throw_exception< ::boost_132::bad_weak_ptr>(const ::boost_132::bad_weak_ptr &)' */ 
  namespace detail {
    class  sp_counted_base
    {
        typedef ::boost::detail::lightweight_mutex mutex_type;
      public:
        inline sp_counted_base()
          : use_count_(1), weak_count_(1)
        {
        }
        virtual inline ~sp_counted_base()
        {
        }
        virtual void dispose() = 0 ;
        virtual inline void destruct()
        {
          delete this;
        }
        virtual void *get_deleter(const ::std::type_info &ti) = 0 ;
        inline void add_ref_copy()
        {
          ::boost::detail::lightweight_mutex::scoped_lock lock(((*this).mtx_));
           ++(*this).use_count_;
        }
        inline void add_ref_lock()
        {
          ::boost::detail::lightweight_mutex::scoped_lock lock(((*this).mtx_));
          if ((*this).use_count_ == 0)
            {
              boost::serialization::throw_exception(::boost_132::bad_weak_ptr());
            }
           ++(*this).use_count_;
        }
        inline void release()
        {
          {
            ::boost::detail::lightweight_mutex::scoped_lock lock(((*this).mtx_));
            long int new_use_count( --(*this).use_count_);
            if (new_use_count != 0)
              {
                return ;
              }
          }
          (*this).dispose();
          (*this).::boost_132::detail::sp_counted_base::weak_release();
        }
        inline void weak_add_ref()
        {
          ::boost::detail::lightweight_mutex::scoped_lock lock(((*this).mtx_));
           ++(*this).weak_count_;
        }
        inline void weak_release()
        {
          long int new_weak_count;
          {
            ::boost::detail::lightweight_mutex::scoped_lock lock(((*this).mtx_));
            new_weak_count =  --(*this).weak_count_;
          }
          if (new_weak_count == 0)
            {
              (*this).destruct();
            }
        }
        inline long int use_count() const 
        {
          ::boost::detail::lightweight_mutex::scoped_lock lock(((*this).mtx_));
          return (*this).use_count_;
        }
        sp_counted_base(const ::boost_132::detail::sp_counted_base &);
        ::boost_132::detail::sp_counted_base &operator =(const ::boost_132::detail::sp_counted_base &);
        long int use_count_;
        long int weak_count_;
        mutable ::boost_132::detail::sp_counted_base::mutex_type mtx_;
    };
    template < typename P, typename D >
    class  sp_counted_base_impl : public ::boost_132::detail::sp_counted_base
    {
      public:
        P ptr;
        D del;
        sp_counted_base_impl(const ::boost_132::detail::sp_counted_base_impl<P, D> &);
        ::boost_132::detail::sp_counted_base_impl<P, D> &operator =(const ::boost_132::detail::sp_counted_base_impl<P, D> &);
        typedef ::boost_132::detail::sp_counted_base_impl<P, D> this_type;
        inline sp_counted_base_impl(P p, D d)
          : ptr(p), del(d)
        {
        }
        inline virtual void dispose()
        {
          ::boost_132::detail::sp_counted_base_impl<P, D>::del(::boost_132::detail::sp_counted_base_impl<P, D>::ptr);
        }
        inline virtual void *get_deleter(const ::std::type_info &ti)
        {
          return ti == typeid(D) ? &(*this).::boost_132::detail::sp_counted_base_impl<P, D>::del : 0;
        }
    };
    class weak_count;
 /* Instantiation of class template '::std::binary_function< ::boost_132::detail::sp_counted_base *, ::boost_132::detail::sp_counted_base *, bool>' */ 
 /* Instantiation of class template '::std::less< ::boost_132::detail::sp_counted_base *>' */ 
 /* Instantiation of template function 'bool ::std::less< ::boost_132::detail::sp_counted_base *>::operator ()(::boost_132::detail::sp_counted_base *const &, ::boost_132::detail::sp_counted_base *const &) const ' */ 
    class  shared_count
    {
      public:
        ::boost_132::detail::sp_counted_base *pi_;
        inline shared_count()
          : pi_(0)
        {
        }
        template < typename P, typename D >
        inline shared_count(P p, D d)
          : pi_(0)
        {
          try
          {
            (*this).pi_ = (new ::boost_132::detail::sp_counted_base_impl<P, D>(p, d));
          }
          catch (...)
          {
            d(p);
            throw;
          }
        }
        template < typename Y >
        inline explicit shared_count(::std::auto_ptr<Y> &r)
          : pi_(new ::boost_132::detail::sp_counted_base_impl<Y *, ::boost::checked_deleter<Y> >(r.get(), ::boost::checked_deleter<Y>()))
        {
          r.release();
        }
        inline ~shared_count()
        {
          if ((*this).pi_ != 0)
            {
              (*(*this).pi_).::boost_132::detail::sp_counted_base::release();
            }
        }
        inline shared_count(const ::boost_132::detail::shared_count &r)
          : pi_(r.pi_)
        {
          if ((*this).pi_ != 0)
            {
              (*(*this).pi_).::boost_132::detail::sp_counted_base::add_ref_copy();
            }
        }
        inline explicit shared_count(const ::boost_132::detail::weak_count &r);
        inline ::boost_132::detail::shared_count &operator =(const ::boost_132::detail::shared_count &r)
        {
          ::boost_132::detail::sp_counted_base *tmp(r.pi_);
          if (tmp != (*this).pi_)
            {
              if (tmp != 0)
                {
                  (*tmp).::boost_132::detail::sp_counted_base::add_ref_copy();
                }
              if ((*this).pi_ != 0)
                {
                  (*(*this).pi_).::boost_132::detail::sp_counted_base::release();
                }
              (*this).pi_ = tmp;
            }
          return *this;
        }
        inline void swap(::boost_132::detail::shared_count &r)
        {
          ::boost_132::detail::sp_counted_base *tmp(r.pi_);
          r.pi_ = (*this).pi_;
          (*this).pi_ = tmp;
        }
        inline long int use_count() const 
        {
          return (*this).pi_ != 0 ? (*(*this).pi_).::boost_132::detail::sp_counted_base::use_count() : 0;
        }
        inline bool unique() const 
        {
          return (*this).::boost_132::detail::shared_count::use_count() == 1;
        }
        inline void *get_deleter(const ::std::type_info &ti) const 
        {
          return (*this).pi_ ? (*(*this).pi_).get_deleter(ti) : 0;
        }
      friend class ::boost_132::detail::weak_count;
      friend inline bool operator ==(const ::boost_132::detail::shared_count &a, const ::boost_132::detail::shared_count &b)
      {
        return a.pi_ == b.pi_;
      }
      friend inline bool operator <(const ::boost_132::detail::shared_count &a, const ::boost_132::detail::shared_count &b)
      {
        return ::std::less< ::boost_132::detail::sp_counted_base *>().::std::less< ::boost_132::detail::sp_counted_base *>::operator ()(a.pi_, b.pi_);
      }
    };
 /* Instantiation of template function 'bool ::std::less< ::boost_132::detail::sp_counted_base *>::operator ()(::boost_132::detail::sp_counted_base *const &, ::boost_132::detail::sp_counted_base *const &) const ' */ 
    class  weak_count
    {
        ::boost_132::detail::sp_counted_base *pi_;
      public:
        inline weak_count()
          : pi_(0)
        {
        }
        inline weak_count(const ::boost_132::detail::shared_count &r)
          : pi_(r.pi_)
        {
          if ((*this).pi_ != 0)
            {
              (*(*this).pi_).::boost_132::detail::sp_counted_base::weak_add_ref();
            }
        }
        inline weak_count(const ::boost_132::detail::weak_count &r)
          : pi_(r.pi_)
        {
          if ((*this).pi_ != 0)
            {
              (*(*this).pi_).::boost_132::detail::sp_counted_base::weak_add_ref();
            }
        }
        inline ~weak_count()
        {
          if ((*this).pi_ != 0)
            {
              (*(*this).pi_).::boost_132::detail::sp_counted_base::weak_release();
            }
        }
        inline ::boost_132::detail::weak_count &operator =(const ::boost_132::detail::shared_count &r)
        {
          ::boost_132::detail::sp_counted_base *tmp(r.pi_);
          if (tmp != 0)
            {
              (*tmp).::boost_132::detail::sp_counted_base::weak_add_ref();
            }
          if ((*this).pi_ != 0)
            {
              (*(*this).pi_).::boost_132::detail::sp_counted_base::weak_release();
            }
          (*this).pi_ = tmp;
          return *this;
        }
        inline ::boost_132::detail::weak_count &operator =(const ::boost_132::detail::weak_count &r)
        {
          ::boost_132::detail::sp_counted_base *tmp(r.pi_);
          if (tmp != 0)
            {
              (*tmp).::boost_132::detail::sp_counted_base::weak_add_ref();
            }
          if ((*this).pi_ != 0)
            {
              (*(*this).pi_).::boost_132::detail::sp_counted_base::weak_release();
            }
          (*this).pi_ = tmp;
          return *this;
        }
        inline void swap(::boost_132::detail::weak_count &r)
        {
          ::boost_132::detail::sp_counted_base *tmp(r.pi_);
          r.pi_ = (*this).pi_;
          (*this).pi_ = tmp;
        }
        inline long int use_count() const 
        {
          return (*this).pi_ != 0 ? (*(*this).pi_).::boost_132::detail::sp_counted_base::use_count() : 0;
        }
      friend class ::boost_132::detail::shared_count;
      friend inline bool operator ==(const ::boost_132::detail::weak_count &a, const ::boost_132::detail::weak_count &b)
      {
        return a.pi_ == b.pi_;
      }
      friend inline bool operator <(const ::boost_132::detail::weak_count &a, const ::boost_132::detail::weak_count &b)
      {
        return ::std::less< ::boost_132::detail::sp_counted_base *>().::std::less< ::boost_132::detail::sp_counted_base *>::operator ()(a.pi_, b.pi_);
      }
    };
 /* Instantiation of template function 'void ::boost::serialization::throw_exception< ::boost_132::bad_weak_ptr>(const ::boost_132::bad_weak_ptr &)' */ 
    inline shared_count::shared_count(const ::boost_132::detail::weak_count &r)
      : pi_(r.pi_)
    {
      if ((*this).pi_ != 0)
        {
          (*(*this).pi_).::boost_132::detail::sp_counted_base::add_ref_lock();
        }
      else
        {
          boost::serialization::throw_exception(::boost_132::bad_weak_ptr());
        }
    }
  }
  template < typename T >
  class weak_ptr;
  template < typename T >
  class enable_shared_from_this;
  namespace detail {
    struct  static_cast_tag
    {
    };
    struct  const_cast_tag
    {
    };
    struct  dynamic_cast_tag
    {
    };
    struct  polymorphic_cast_tag
    {
    };
    template < typename T >
    struct  shared_ptr_traits
    {
        typedef T &reference;
    };
    template <>
    struct  shared_ptr_traits<void>
    {
        typedef void reference;
    };
    template <>
    struct  shared_ptr_traits<const void>
    {
        typedef void reference;
    };
    template <>
    struct  shared_ptr_traits<volatile void>
    {
        typedef void reference;
    };
    template <>
    struct  shared_ptr_traits<const volatile void>
    {
        typedef void reference;
    };
    template < typename T, typename Y >
    void sp_enable_shared_from_this(const ::boost_132::detail::shared_count &pn, const ::boost_132::enable_shared_from_this<T> *pe, const Y *px);
    template < typename T, typename Y >
    void sp_enable_shared_from_this(const ::boost_132::detail::shared_count &pn, const ::boost_132::enable_shared_from_this<T> *pe, const Y *px)
    {
      if (pe != 0)
        {
          pe->_internal_weak_this._internal_assign(const_cast<Y *>(px), pn);
        }
    }
    inline void sp_enable_shared_from_this(const ::boost_132::detail::shared_count &, ...)
    {
    }
  }
  template < typename T >
  class  shared_ptr
  {
      typedef ::boost_132::shared_ptr<T> this_type;
    public:
      typedef T element_type;
      typedef T value_type;
      typedef T *pointer;
      typedef typename ::boost_132::detail::shared_ptr_traits<T>::reference reference;
      inline shared_ptr()
        : px(0), pn()
      {
      }
      template < typename Y >
      inline explicit shared_ptr(Y *p)
        : px(p), pn(p, ::boost::checked_deleter<Y>())
      {
        detail::sp_enable_shared_from_this(::boost_132::shared_ptr<T>::pn, p, p);
      }
      template < typename Y, typename D >
      inline shared_ptr(Y *p, D d)
        : px(p), pn(p, d)
      {
        detail::sp_enable_shared_from_this(::boost_132::shared_ptr<T>::pn, p, p);
      }
      inline ::boost_132::shared_ptr<T> &operator =(const ::boost_132::shared_ptr<T> &r)
      {
        ::boost_132::shared_ptr<T>::px = r.px;
        ::boost_132::shared_ptr<T>::pn = r.pn;
        return *this;
      }
      template < typename Y >
      inline explicit shared_ptr(const ::boost_132::weak_ptr<Y> &r)
        : pn(r.pn)
      {
        ::boost_132::shared_ptr<T>::px = r.px;
      }
      template < typename Y >
      inline shared_ptr(const ::boost_132::shared_ptr<Y> &r)
        : px(r.px), pn(r.pn)
      {
      }
      template < typename Y >
      inline shared_ptr(const ::boost_132::shared_ptr<Y> &r, ::boost_132::detail::static_cast_tag)
        : px(static_cast<typename ::boost_132::shared_ptr<T>::element_type *>(r.px)), pn(r.pn)
      {
      }
      template < typename Y >
      inline shared_ptr(const ::boost_132::shared_ptr<Y> &r, ::boost_132::detail::const_cast_tag)
        : px(const_cast<typename ::boost_132::shared_ptr<T>::element_type *>(r.px)), pn(r.pn)
      {
      }
      template < typename Y >
      inline shared_ptr(const ::boost_132::shared_ptr<Y> &r, ::boost_132::detail::dynamic_cast_tag)
        : px(dynamic_cast<typename ::boost_132::shared_ptr<T>::element_type *>(r.px)), pn(r.pn)
      {
        if (::boost_132::shared_ptr<T>::px == 0)
          {
            ::boost_132::shared_ptr<T>::pn = ::boost_132::detail::shared_count();
          }
      }
      template < typename Y >
      inline shared_ptr(const ::boost_132::shared_ptr<Y> &r, ::boost_132::detail::polymorphic_cast_tag)
        : px(dynamic_cast<typename ::boost_132::shared_ptr<T>::element_type *>(r.px)), pn(r.pn)
      {
        if (::boost_132::shared_ptr<T>::px == 0)
          {
            boost::serialization::throw_exception(::std::bad_cast());
          }
      }
      template < typename Y >
      inline explicit shared_ptr(::std::auto_ptr<Y> &r)
        : px(r.get()), pn()
      {
        Y *tmp = r.get();
        ::boost_132::shared_ptr<T>::pn = ::boost_132::detail::shared_count(r);
        detail::sp_enable_shared_from_this(::boost_132::shared_ptr<T>::pn, tmp, tmp);
      }
      template < typename Y >
      inline ::boost_132::shared_ptr<T> &operator =(const ::boost_132::shared_ptr<Y> &r)
      {
        ::boost_132::shared_ptr<T>::px = r.px;
        ::boost_132::shared_ptr<T>::pn = r.pn;
        return *this;
      }
      template < typename Y >
      inline ::boost_132::shared_ptr<T> &operator =(::std::auto_ptr<Y> &r)
      {
        ((typename ::boost_132::shared_ptr<T>::this_type(r))).swap(*this);
        return *this;
      }
      inline void reset()
      {
        ((typename ::boost_132::shared_ptr<T>::this_type())).swap(*this);
      }
      template < typename Y >
      inline void reset(Y *p)
      {
        p == 0 || p != ::boost_132::shared_ptr<T>::px ? static_cast<void>(0) : __assert_fail("p == 0 || p != px", "/usr/include/boost/serialization/detail/shared_ptr_132.hpp", 241, __PRETTY_FUNCTION__);
        ((typename ::boost_132::shared_ptr<T>::this_type(p))).swap(*this);
      }
      template < typename Y, typename D >
      inline void reset(Y *p, D d)
      {
        ((typename ::boost_132::shared_ptr<T>::this_type(p, d))).swap(*this);
      }
      inline typename ::boost_132::shared_ptr<T>::reference operator *() const 
      {
        ::boost_132::shared_ptr<T>::px != 0 ? static_cast<void>(0) : __assert_fail("px != 0", "/usr/include/boost/serialization/detail/shared_ptr_132.hpp", 252, __PRETTY_FUNCTION__);
        return *::boost_132::shared_ptr<T>::px;
      }
      inline T *operator ->() const 
      {
        ::boost_132::shared_ptr<T>::px != 0 ? static_cast<void>(0) : __assert_fail("px != 0", "/usr/include/boost/serialization/detail/shared_ptr_132.hpp", 258, __PRETTY_FUNCTION__);
        return ::boost_132::shared_ptr<T>::px;
      }
      inline T *get() const 
      {
        return ::boost_132::shared_ptr<T>::px;
      }
      typedef T *(::boost_132::shared_ptr<T>::this_type::*unspecified_bool_type);
      inline operator typename ::boost_132::shared_ptr<T>::unspecified_bool_type() const 
      {
        return ::boost_132::shared_ptr<T>::px == 0 ? 0 : (&::boost_132::shared_ptr<T>::px);
      }
      inline bool operator !() const 
      {
        return ::boost_132::shared_ptr<T>::px == 0;
      }
      inline bool unique() const 
      {
        return ::boost_132::shared_ptr<T>::pn.unique();
      }
      inline long int use_count() const 
      {
        return ::boost_132::shared_ptr<T>::pn.use_count();
      }
      inline void swap(::boost_132::shared_ptr<T> &other)
      {
        std::swap(::boost_132::shared_ptr<T>::px, other.px);
        ::boost_132::shared_ptr<T>::pn.swap(other.pn);
      }
      template < typename Y >
      inline bool _internal_less(const ::boost_132::shared_ptr<Y> &rhs) const 
      {
        return ::boost_132::shared_ptr<T>::pn < rhs.pn;
      }
      inline void *_internal_get_deleter(const ::std::type_info &ti) const 
      {
        return ::boost_132::shared_ptr<T>::pn.get_deleter(ti);
      }
      T *px;
      ::boost_132::detail::shared_count pn;
    template < typename Y >
    friend class shared_ptr;
    template < typename Y >
    friend class weak_ptr;
  };
  template < typename T, typename U >
  inline bool operator ==(const ::boost_132::shared_ptr<T> &a, const ::boost_132::shared_ptr<U> &b);
  template < typename T, typename U >
  inline bool operator ==(const ::boost_132::shared_ptr<T> &a, const ::boost_132::shared_ptr<U> &b)
  {
    return a.get() == b.get();
  }
  template < typename T, typename U >
  inline bool operator !=(const ::boost_132::shared_ptr<T> &a, const ::boost_132::shared_ptr<U> &b);
  template < typename T, typename U >
  inline bool operator !=(const ::boost_132::shared_ptr<T> &a, const ::boost_132::shared_ptr<U> &b)
  {
    return a.get() != b.get();
  }
  template < typename T, typename U >
  inline bool operator <(const ::boost_132::shared_ptr<T> &a, const ::boost_132::shared_ptr<U> &b);
  template < typename T, typename U >
  inline bool operator <(const ::boost_132::shared_ptr<T> &a, const ::boost_132::shared_ptr<U> &b)
  {
    return a._internal_less(b);
  }
  template < typename T >
  inline void swap(::boost_132::shared_ptr<T> &a, ::boost_132::shared_ptr<T> &b);
  template < typename T >
  inline void swap(::boost_132::shared_ptr<T> &a, ::boost_132::shared_ptr<T> &b)
  {
    a.swap(b);
  }
  template < typename T, typename U >
  ::boost_132::shared_ptr<T> static_pointer_cast(const ::boost_132::shared_ptr<U> &r);
  template < typename T, typename U >
  ::boost_132::shared_ptr<T> static_pointer_cast(const ::boost_132::shared_ptr<U> &r)
  {
    return ::boost_132::shared_ptr<T>(r, ::boost_132::detail::static_cast_tag());
  }
  template < typename T, typename U >
  ::boost_132::shared_ptr<T> const_pointer_cast(const ::boost_132::shared_ptr<U> &r);
  template < typename T, typename U >
  ::boost_132::shared_ptr<T> const_pointer_cast(const ::boost_132::shared_ptr<U> &r)
  {
    return ::boost_132::shared_ptr<T>(r, ::boost_132::detail::const_cast_tag());
  }
  template < typename T, typename U >
  ::boost_132::shared_ptr<T> dynamic_pointer_cast(const ::boost_132::shared_ptr<U> &r);
  template < typename T, typename U >
  ::boost_132::shared_ptr<T> dynamic_pointer_cast(const ::boost_132::shared_ptr<U> &r)
  {
    return ::boost_132::shared_ptr<T>(r, ::boost_132::detail::dynamic_cast_tag());
  }
  template < typename T, typename U >
  ::boost_132::shared_ptr<T> shared_static_cast(const ::boost_132::shared_ptr<U> &r);
  template < typename T, typename U >
  ::boost_132::shared_ptr<T> shared_static_cast(const ::boost_132::shared_ptr<U> &r)
  {
    return ::boost_132::shared_ptr<T>(r, ::boost_132::detail::static_cast_tag());
  }
  template < typename T, typename U >
  ::boost_132::shared_ptr<T> shared_dynamic_cast(const ::boost_132::shared_ptr<U> &r);
  template < typename T, typename U >
  ::boost_132::shared_ptr<T> shared_dynamic_cast(const ::boost_132::shared_ptr<U> &r)
  {
    return ::boost_132::shared_ptr<T>(r, ::boost_132::detail::dynamic_cast_tag());
  }
  template < typename T, typename U >
  ::boost_132::shared_ptr<T> shared_polymorphic_cast(const ::boost_132::shared_ptr<U> &r);
  template < typename T, typename U >
  ::boost_132::shared_ptr<T> shared_polymorphic_cast(const ::boost_132::shared_ptr<U> &r)
  {
    return ::boost_132::shared_ptr<T>(r, ::boost_132::detail::polymorphic_cast_tag());
  }
  template < typename T, typename U >
  ::boost_132::shared_ptr<T> shared_polymorphic_downcast(const ::boost_132::shared_ptr<U> &r);
  template < typename T, typename U >
  ::boost_132::shared_ptr<T> shared_polymorphic_downcast(const ::boost_132::shared_ptr<U> &r)
  {
    dynamic_cast<T *>(r.get()) == r.get() ? static_cast<void>(0) : __assert_fail("dynamic_cast<T *>(r.get()) == r.get()", "/usr/include/boost/serialization/detail/shared_ptr_132.hpp", 411, __PRETTY_FUNCTION__);
    return shared_static_cast<T>(r);
  }
  template < typename T >
  inline T *get_pointer(const ::boost_132::shared_ptr<T> &p);
  template < typename T >
  inline T *get_pointer(const ::boost_132::shared_ptr<T> &p)
  {
    return p.get();
  }
  template < typename E, typename T, typename Y >
  ::std::basic_ostream<E, T> &operator <<(::std::basic_ostream<E, T> &os, const ::boost_132::shared_ptr<Y> &p);
  template < typename E, typename T, typename Y >
  ::std::basic_ostream<E, T> &operator <<(::std::basic_ostream<E, T> &os, const ::boost_132::shared_ptr<Y> &p)
  {
    os << p.get();
    return os;
  }
  template < typename D, typename T >
  D *get_deleter(const ::boost_132::shared_ptr<T> &p);
  template < typename D, typename T >
  D *get_deleter(const ::boost_132::shared_ptr<T> &p)
  {
    return static_cast<D *>(p._internal_get_deleter(typeid(D)));
  }
  namespace serialization {
    namespace detail {
      struct  null_deleter
      {
          inline void operator ()(const void *) const 
          {
          }
      };
    }
  }
}
namespace boost {
   namespace serialization {
     template < typename Archive, typename P, typename D >
    inline void serialize(Archive &, ::boost_132::detail::sp_counted_base_impl<P, D> &, const unsigned int);
    template < typename Archive, typename P, typename D >
    inline void serialize(Archive &, ::boost_132::detail::sp_counted_base_impl<P, D> &, const unsigned int)
    {
      boost::serialization::void_cast_register< ::boost_132::detail::sp_counted_base_impl<P, D>, ::boost_132::detail::sp_counted_base>(static_cast< ::boost_132::detail::sp_counted_base_impl<P, D> *>(0L), static_cast< ::boost_132::detail::sp_counted_base *>(0L));
    }
    template < typename Archive, typename P, typename D >
    inline void save_construct_data(Archive &ar, const ::boost_132::detail::sp_counted_base_impl<P, D> *t, const unsigned int);
    template < typename Archive, typename P, typename D >
    inline void save_construct_data(Archive &ar, const ::boost_132::detail::sp_counted_base_impl<P, D> *t, const unsigned int)
    {
      ar << boost::serialization::make_nvp("ptr", t->ptr);
    }
    template < typename Archive, typename P, typename D >
    inline void load_construct_data(Archive &ar, ::boost_132::detail::sp_counted_base_impl<P, D> *t, const unsigned int);
    template < typename Archive, typename P, typename D >
    inline void load_construct_data(Archive &ar, ::boost_132::detail::sp_counted_base_impl<P, D> *t, const unsigned int)
    {
      P ptr_;
      ar >> boost::serialization::make_nvp("ptr", ptr_);
      ::new (t)::boost_132::detail::sp_counted_base_impl<P, ::boost_132::serialization::detail::null_deleter>(ptr_, ::boost_132::serialization::detail::null_deleter());
      t->use_count_ = 0;
    }
 /* Instantiation of class template '::std::pair<const char *, ::boost_132::detail::sp_counted_base *const *>' */ 
 /* Instantiation of class template '::boost::serialization::traits<const ::boost::serialization::nvp< ::boost_132::detail::sp_counted_base *const >, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp< ::boost_132::detail::sp_counted_base *const > >, ::mpl_::bool_<true> >' */ 
 /* Instantiation of class template '::boost::serialization::wrapper_traits<const ::boost::serialization::nvp< ::boost_132::detail::sp_counted_base *const >, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp< ::boost_132::detail::sp_counted_base *const > > >' */ 
 /* Instantiation of class template '::boost::serialization::nvp< ::boost_132::detail::sp_counted_base *const >' */ 
    template < typename Archive >
    inline void save(Archive &ar, const ::boost_132::detail::shared_count &t, const unsigned int);
    template < typename Archive >
    inline void save(Archive &ar, const ::boost_132::detail::shared_count &t, const unsigned int)
    {
      ar << boost::serialization::make_nvp("pi", t.pi_);
    }
 /* Instantiation of class template '::std::pair<const char *, ::boost_132::detail::sp_counted_base **>' */ 
 /* Instantiation of class template '::boost::serialization::traits<const ::boost::serialization::nvp< ::boost_132::detail::sp_counted_base *>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp< ::boost_132::detail::sp_counted_base *> >, ::mpl_::bool_<true> >' */ 
 /* Instantiation of class template '::boost::serialization::wrapper_traits<const ::boost::serialization::nvp< ::boost_132::detail::sp_counted_base *>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp< ::boost_132::detail::sp_counted_base *> > >' */ 
 /* Instantiation of class template '::boost::serialization::nvp< ::boost_132::detail::sp_counted_base *>' */ 
    template < typename Archive >
    inline void load(Archive &ar, ::boost_132::detail::shared_count &t, const unsigned int);
    template < typename Archive >
    inline void load(Archive &ar, ::boost_132::detail::shared_count &t, const unsigned int)
    {
      ar >> boost::serialization::make_nvp("pi", t.pi_);
      if (0L != t.pi_)
        {
          (*t.pi_).::boost_132::detail::sp_counted_base::add_ref_copy();
        }
    }
    template < typename Archive >
    inline void serialize(Archive &ar, ::boost_132::detail::shared_count &t, const unsigned int file_version);
    template < typename Archive >
    inline void serialize(Archive &ar, ::boost_132::detail::shared_count &t, const unsigned int file_version)
    {
      split_free(ar, t, file_version);
    }
    template < typename Archive, typename T >
    inline void save(Archive &ar, const ::boost_132::shared_ptr<T> &t, const unsigned int);
    template < typename Archive, typename T >
    inline void save(Archive &ar, const ::boost_132::shared_ptr<T> &t, const unsigned int)
    {
      ar.register_type(static_cast< ::boost_132::detail::sp_counted_base_impl<T *, ::boost::checked_deleter<T> > *>(0L));
      ar << boost::serialization::make_nvp("px", t.px);
      ar << boost::serialization::make_nvp("pn", t.pn);
    }
    template < typename Archive, typename T >
    inline void load(Archive &ar, ::boost_132::shared_ptr<T> &t, const unsigned int);
    template < typename Archive, typename T >
    inline void load(Archive &ar, ::boost_132::shared_ptr<T> &t, const unsigned int)
    {
      ar.register_type(static_cast< ::boost_132::detail::sp_counted_base_impl<T *, ::boost::checked_deleter<T> > *>(0L));
      ar >> boost::serialization::make_nvp("px", t.px);
      ar >> boost::serialization::make_nvp("pn", t.pn);
    }
    template < typename Archive, typename T >
    inline void serialize(Archive &ar, ::boost_132::shared_ptr<T> &t, const unsigned int file_version);
    template < typename Archive, typename T >
    inline void serialize(Archive &ar, ::boost_132::shared_ptr<T> &t, const unsigned int file_version)
    {
      static_assert(boost::serialization::tracking_level<T>::value != ::boost::serialization::track_never, "boost::serialization::tracking_level< T >::value != boost::serialization::track_never");
      boost::serialization::split_free(ar, t, file_version);
    }
  }
}
namespace boost_132 {
   template < typename T >
  class shared_ptr;
}
namespace boost {
  template < typename T >
  class shared_ptr;
  namespace serialization {
    template < typename Archive, typename T >
    inline void load(Archive &ar, ::boost::shared_ptr<T> &t, const unsigned int file_version);
 /* Instantiation of class template '::__gnu_cxx::new_allocator< ::boost::shared_ptr<const void> >' */ 
 /* Instantiation of class template '::std::allocator< ::boost::shared_ptr<const void> >' */ 
 /* Instantiation of class template '::std::allocator< ::boost::shared_ptr<const void> >::rebind< ::boost::shared_ptr<const void> >' */ 
 /* Instantiation of class template '::std::allocator< ::boost::shared_ptr<const void> >::rebind< ::std::_Rb_tree_node< ::boost::shared_ptr<const void> > >' */ 
 /* Instantiation of class template '::__gnu_cxx::new_allocator< ::std::_Rb_tree_node< ::boost::shared_ptr<const void> > >' */ 
 /* Instantiation of class template '::std::allocator< ::std::_Rb_tree_node< ::boost::shared_ptr<const void> > >' */ 
 /* Instantiation of class template '::std::_Rb_tree< ::boost::shared_ptr<const void>, ::boost::shared_ptr<const void>, ::std::_Identity< ::boost::shared_ptr<const void> >, ::boost::archive::detail::shared_ptr_helper::collection_type_compare, ::std::allocator< ::boost::shared_ptr<const void> > >::_Rb_tree_impl< ::boost::archive::detail::shared_ptr_helper::collection_type_compare, true>' */ 
 /* Instantiation of class template '::std::_Rb_tree< ::boost::shared_ptr<const void>, ::boost::shared_ptr<const void>, ::std::_Identity< ::boost::shared_ptr<const void> >, ::boost::archive::detail::shared_ptr_helper::collection_type_compare, ::std::allocator< ::boost::shared_ptr<const void> > >' */ 
 /* Instantiation of class template '::std::set< ::boost::shared_ptr<const void>, ::boost::archive::detail::shared_ptr_helper::collection_type_compare>' */ 
 /* Instantiation of class template '::boost::detail::sp_element<const void>' */ 
 /* Instantiation of class template '::boost::detail::sp_member_access<const void>' */ 
 /* Instantiation of class template '::boost::detail::sp_array_access<const void>' */ 
 /* Instantiation of class template '::boost::shared_ptr<const void>' */ 
 /* Instantiation of template function '::boost::detail::sp_element<const void>::type *::boost::shared_ptr<const void>::get() const ' */ 
 /* Instantiation of class template '::boost::detail::sp_convertible<void, void>' */ 
 /* Instantiation of class template '::boost::detail::sp_enable_if_convertible<void, void>' */ 
 /* Instantiation of class template '::boost_132::shared_ptr<const void>' */ 
  }
  namespace archive {
    namespace detail {
      class  shared_ptr_helper
      {
          struct  collection_type_compare
          {
              inline bool operator ()(const ::boost::shared_ptr<const void> &lhs, const ::boost::shared_ptr<const void> &rhs) const 
              {
                return lhs.::boost::shared_ptr<const void>::get() < rhs.::boost::shared_ptr<const void>::get();
              }
          };
          typedef ::std::set< ::boost::shared_ptr<const void>, ::boost::archive::detail::shared_ptr_helper::collection_type_compare> collection_type;
          typedef ::std::set< ::boost::shared_ptr<const void>, ::boost::archive::detail::shared_ptr_helper::collection_type_compare>::const_iterator iterator_type;
          ::boost::archive::detail::shared_ptr_helper::collection_type *m_pointers;
          struct  null_deleter
          {
              inline void operator ()(const void *) const 
              {
              }
          };
          struct  void_deleter
          {
              const ::boost::serialization::extended_type_info *m_eti;
              inline void_deleter(const ::boost::serialization::extended_type_info *eti)
                : m_eti(eti)
              {
              }
              inline void operator ()(void *vp) const 
              {
                (*(*this).m_eti).destroy(vp);
              }
          };
          ::std::list< ::boost_132::shared_ptr<const void> > *m_pointers_132;
          ::boost::shared_ptr<void> get_od(const void *od, const ::boost::serialization::extended_type_info *true_type, const ::boost::serialization::extended_type_info *this_type);
          void append(const ::boost::shared_ptr<const void> &);
          template < typename T >
          struct  non_polymorphic
          {
              static inline const ::boost::serialization::extended_type_info *get_object_identifier(T &)
              {
                return &boost::serialization::singleton<typename ::boost::serialization::type_info_implementation<T>::type>::get_const_instance();
              }
          };
          template < typename T >
          struct  polymorphic
          {
              static inline const ::boost::serialization::extended_type_info *get_object_identifier(T &t)
              {
                return boost::serialization::singleton<typename ::boost::serialization::type_info_implementation<T>::type>::get_const_instance().get_derived_extended_type_info(t);
              }
          };
        public:
          template < typename T >
          inline void reset(::boost::shared_ptr<T> &s, T *t)
          {
            if (0L == t)
              {
                s.reset();
                return ;
              }
            const ::boost::serialization::extended_type_info *this_type = &boost::serialization::type_info_implementation<T>::type::get_const_instance();
            typedef typename ::boost::mpl::eval_if< ::boost::is_polymorphic<T>, ::boost::mpl::identity<typename ::boost::archive::detail::shared_ptr_helper::polymorphic<T> >, ::boost::mpl::identity<typename ::boost::archive::detail::shared_ptr_helper::non_polymorphic<T> > >::type type;
            const ::boost::serialization::extended_type_info *true_type = type::get_object_identifier(*t);
            if (0L == true_type)
              {
                boost::serialization::throw_exception(::boost::archive::archive_exception(::boost::archive::archive_exception::unregistered_class, (*this_type).get_debug_info() /* , 0L */ ));
              }
            ::boost::shared_ptr<void> r(((*this).::boost::archive::detail::shared_ptr_helper::get_od(static_cast<const void *>(t), true_type, this_type)));
            if ( !r)
              {
                s.reset(t);
                const void *od(::boost::serialization::void_downcast(*true_type, *this_type, static_cast<const void *>(t)));
                ::boost::shared_ptr<const void> sp(s, od);
                (*this).::boost::archive::detail::shared_ptr_helper::append(sp);
              }
            else
              {
                s = ::boost::shared_ptr<T>(r, static_cast<T *>(r.::boost::shared_ptr<void>::get()));
              }
          }
          void append(const ::boost_132::shared_ptr<const void> &t);
          shared_ptr_helper();
          ~shared_ptr_helper();
        template < typename Archive, typename T >
        friend void (::boost::serialization::load)(Archive &, ::boost::shared_ptr<T> &, const unsigned int);
      };
 /* Instantiation of class template '::boost::archive::detail::interface_iarchive<class text_iarchive>' */ 
 /* Instantiation of class template '::boost::archive::detail::common_iarchive<class text_iarchive>' */ 
 /* Instantiation of class template '::boost::archive::basic_text_iarchive<class text_iarchive>' */ 
 /* Instantiation of class template '::boost::archive::text_iarchive_impl<class text_iarchive>' */ 
    }
    class  text_iarchive : public ::boost::archive::text_iarchive_impl< ::boost::archive::text_iarchive>, public ::boost::archive::detail::shared_ptr_helper
    {
      public:
        inline text_iarchive(::std::istream &is_, unsigned int flags  = (0))
          : ::boost::archive::text_iarchive_impl< ::boost::archive::text_iarchive>(is_, flags)
        {
        }
        inline ~text_iarchive()
        {
        }
    };
    namespace detail {
      template < typename Serializable >
      typename ::boost::archive::detail::_ptr_serialization_support< ::boost::archive::text_iarchive, Serializable>::type instantiate_ptr_serialization(Serializable *, ::boost::archive::text_iarchive *, ::boost::archive::detail::adl_tag);
    }
  }
}
namespace std __attribute__((__visibility__("default"))) {
   struct  _Resetiosflags
  {
      ::std::ios_base::fmtflags _M_mask;
  };
  inline ::std::_Resetiosflags resetiosflags(::std::ios_base::fmtflags __mask)
  {
    return { /* .::std::_Resetiosflags::_M_mask =  */ __mask};
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::_Resetiosflags __f);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::_Resetiosflags __f)
  {
    __is.setf((::std::ios_base::fmtflags)0, __f._M_mask);
    return __is;
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, ::std::_Resetiosflags __f);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, ::std::_Resetiosflags __f)
  {
    __os.setf((::std::ios_base::fmtflags)0, __f._M_mask);
    return __os;
  }
  struct  _Setiosflags
  {
      ::std::ios_base::fmtflags _M_mask;
  };
  inline ::std::_Setiosflags setiosflags(::std::ios_base::fmtflags __mask)
  {
    return { /* .::std::_Setiosflags::_M_mask =  */ __mask};
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::_Setiosflags __f);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::_Setiosflags __f)
  {
    __is.setf(__f._M_mask);
    return __is;
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, ::std::_Setiosflags __f);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, ::std::_Setiosflags __f)
  {
    __os.setf(__f._M_mask);
    return __os;
  }
  struct  _Setbase
  {
      int _M_base;
  };
  inline ::std::_Setbase setbase(int __base)
  {
    return { /* .::std::_Setbase::_M_base =  */ __base};
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::_Setbase __f);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::_Setbase __f)
  {
    __is.setf(__f._M_base == 8 ? ::std::ios_base::oct : __f._M_base == 10 ? ::std::ios_base::dec : __f._M_base == 16 ? ::std::ios_base::hex : (::std::ios_base::fmtflags)0, ::std::ios_base::basefield);
    return __is;
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, ::std::_Setbase __f);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, ::std::_Setbase __f)
  {
    __os.setf(__f._M_base == 8 ? ::std::ios_base::oct : __f._M_base == 10 ? ::std::ios_base::dec : __f._M_base == 16 ? ::std::ios_base::hex : (::std::ios_base::fmtflags)0, ::std::ios_base::basefield);
    return __os;
  }
  template < typename _CharT >
  struct  _Setfill
  {
      _CharT _M_c;
  };
  template < typename _CharT >
  inline ::std::_Setfill<_CharT> setfill(_CharT __c);
  template < typename _CharT >
  inline ::std::_Setfill<_CharT> setfill(_CharT __c)
  {
    return { __c };
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::_Setfill<_CharT> __f);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::_Setfill<_CharT> __f)
  {
    __is.fill(__f._M_c);
    return __is;
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, ::std::_Setfill<_CharT> __f);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, ::std::_Setfill<_CharT> __f)
  {
    __os.fill(__f._M_c);
    return __os;
  }
  struct  _Setprecision
  {
      int _M_n;
  };
  inline ::std::_Setprecision setprecision(int __n)
  {
    return { /* .::std::_Setprecision::_M_n =  */ __n};
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::_Setprecision __f);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::_Setprecision __f)
  {
    __is.precision(__f._M_n);
    return __is;
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, ::std::_Setprecision __f);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, ::std::_Setprecision __f)
  {
    __os.precision(__f._M_n);
    return __os;
  }
  struct  _Setw
  {
      int _M_n;
  };
  inline ::std::_Setw setw(int __n)
  {
    return { /* .::std::_Setw::_M_n =  */ __n};
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::_Setw __f);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::_Setw __f)
  {
    __is.width(__f._M_n);
    return __is;
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, ::std::_Setw __f);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, ::std::_Setw __f)
  {
    __os.width(__f._M_n);
    return __os;
  }
  template < typename _MoneyT >
  struct  _Get_money
  {
      _MoneyT &_M_mon;
      bool _M_intl;
  };
  template < typename _MoneyT >
  inline ::std::_Get_money<_MoneyT> get_money(_MoneyT &__mon, bool __intl  = (false));
  template < typename _MoneyT >
  inline ::std::_Get_money<_MoneyT> get_money(_MoneyT &__mon, bool __intl)
  {
    return { __mon, __intl };
  }
  template < typename _CharT, typename _Traits, typename _MoneyT >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::_Get_money<_MoneyT> __f);
  template < typename _CharT, typename _Traits, typename _MoneyT >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__is, ::std::_Get_money<_MoneyT> __f)
  {
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          typedef ::std::istreambuf_iterator<_CharT, _Traits> _Iter;
          typedef ::std::money_get<_CharT, _Iter> _MoneyGet;
          const _MoneyGet &__mg = use_facet<_MoneyGet>(__is.getloc());
          __mg.get(_Iter(__is.rdbuf()), _Iter(), __f._M_intl, __is, __err, __f._M_mon);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __is._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __is._M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            __is.setstate(__err);
          }
      }
    return __is;
  }
  template < typename _MoneyT >
  struct  _Put_money
  {
      const _MoneyT &_M_mon;
      bool _M_intl;
  };
  template < typename _MoneyT >
  inline ::std::_Put_money<_MoneyT> put_money(const _MoneyT &__mon, bool __intl  = (false));
  template < typename _MoneyT >
  inline ::std::_Put_money<_MoneyT> put_money(const _MoneyT &__mon, bool __intl)
  {
    return { __mon, __intl };
  }
  template < typename _CharT, typename _Traits, typename _MoneyT >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, ::std::_Put_money<_MoneyT> __f);
  template < typename _CharT, typename _Traits, typename _MoneyT >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, ::std::_Put_money<_MoneyT> __f)
  {
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          typedef ::std::ostreambuf_iterator<_CharT, _Traits> _Iter;
          typedef ::std::money_put<_CharT, _Iter> _MoneyPut;
          const _MoneyPut &__mp = use_facet<_MoneyPut>(__os.getloc());
          if (__mp.put(_Iter(__os.rdbuf()), __f._M_intl, __os, __os.fill(), __f._M_mon).failed())
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __os._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __os._M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            __os.setstate(__err);
          }
      }
    return __os;
  }
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, ::std::_Setfill<char>);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, ::std::_Setiosflags);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, ::std::_Resetiosflags);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, ::std::_Setbase);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, ::std::_Setprecision);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, ::std::_Setw);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, ::std::_Setfill<char>);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, ::std::_Setiosflags);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, ::std::_Resetiosflags);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, ::std::_Setbase);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, ::std::_Setprecision);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, ::std::_Setw);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, ::std::_Setfill<wchar_t>);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, ::std::_Setiosflags);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, ::std::_Resetiosflags);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, ::std::_Setbase);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, ::std::_Setprecision);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, ::std::_Setw);
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, ::std::_Setfill<wchar_t>);
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, ::std::_Setiosflags);
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, ::std::_Resetiosflags);
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, ::std::_Setbase);
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, ::std::_Setprecision);
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, ::std::_Setw);
}
namespace boost {
  typedef ::uintmax_t static_min_max_unsigned_type;
  typedef ::intmax_t static_min_max_signed_type;
  typedef ::uintmax_t static_log2_argument_type;
  typedef int static_log2_result_type;
  template < typename T >
  class integer_traits;
  template <>
  class integer_traits<bool>;
  template <>
  class integer_traits<char>;
  template <>
  class integer_traits<signed char>;
  template <>
  class integer_traits<unsigned char>;
  template <>
  class integer_traits<wchar_t>;
  template <>
  class integer_traits<short int>;
  template <>
  class integer_traits<unsigned short int>;
  template <>
  class integer_traits<int>;
  template <>
  class integer_traits<unsigned int>;
  template <>
  class integer_traits<long int>;
  template <>
  class integer_traits<unsigned long int>;
  template <>
  class integer_traits<long long int>;
  template <>
  class integer_traits<unsigned long long int>;
  template < typename LeastInt >
  struct int_fast_t;
  template < int Bits >
  struct int_t;
  template < int Bits >
  struct uint_t;
  template < ::boost::long_long_type MaxValue >
  struct int_max_value_t;
  template < ::boost::long_long_type MinValue >
  struct int_min_value_t;
  template < ::boost::ulong_long_type MaxValue >
  struct uint_value_t;
  template < ::std::size_t Bit >
  struct high_bit_mask_t;
  template < ::std::size_t Bits >
  struct low_bits_mask_t;
  template <>
  struct low_bits_mask_t<8LU>;
  template < ::boost::static_log2_argument_type Value >
  struct static_log2;
  template <>
  struct static_log2<0LU>;
  template < ::boost::static_min_max_signed_type Value1, ::boost::static_min_max_signed_type Value2 >
  struct static_signed_min;
  template < ::boost::static_min_max_signed_type Value1, ::boost::static_min_max_signed_type Value2 >
  struct static_signed_max;
  template < ::boost::static_min_max_unsigned_type Value1, ::boost::static_min_max_unsigned_type Value2 >
  struct static_unsigned_min;
  template < ::boost::static_min_max_unsigned_type Value1, ::boost::static_min_max_unsigned_type Value2 >
  struct static_unsigned_max;
  template < typename LeastInt >
  struct  int_fast_t
  {
      typedef LeastInt fast;
      typedef typename ::boost::int_fast_t<LeastInt>::fast type;
  };
  namespace detail {
    template < int Category >
    struct  int_least_helper
    {
    };
    template < int Category >
    struct  uint_least_helper
    {
    };
    template <>
    struct  int_least_helper<1>
    {
        typedef ::boost::long_long_type least;
    };
    template <>
    struct  int_least_helper<2>
    {
        typedef long int least;
    };
    template <>
    struct  int_least_helper<3>
    {
        typedef int least;
    };
    template <>
    struct  int_least_helper<4>
    {
        typedef short int least;
    };
    template <>
    struct  int_least_helper<5>
    {
        typedef signed char least;
    };
    template <>
    struct  uint_least_helper<1>
    {
        typedef ::boost::ulong_long_type least;
    };
    template <>
    struct  uint_least_helper<2>
    {
        typedef unsigned long int least;
    };
    template <>
    struct  uint_least_helper<3>
    {
        typedef unsigned int least;
    };
    template <>
    struct  uint_least_helper<4>
    {
        typedef unsigned short int least;
    };
    template <>
    struct  uint_least_helper<5>
    {
        typedef unsigned char least;
    };
    template < int Bits >
    struct  exact_signed_base_helper
    {
    };
    template < int Bits >
    struct  exact_unsigned_base_helper
    {
    };
    template <>
    struct  exact_signed_base_helper<8>
    {
        typedef signed char exact;
    };
    template <>
    struct  exact_unsigned_base_helper<8>
    {
        typedef unsigned char exact;
    };
    template <>
    struct  exact_signed_base_helper<16>
    {
        typedef short int exact;
    };
    template <>
    struct  exact_unsigned_base_helper<16>
    {
        typedef unsigned short int exact;
    };
    template <>
    struct  exact_signed_base_helper<32>
    {
        typedef int exact;
    };
    template <>
    struct  exact_unsigned_base_helper<32>
    {
        typedef unsigned int exact;
    };
    template <>
    struct  exact_signed_base_helper<64>
    {
        typedef long int exact;
    };
    template <>
    struct  exact_unsigned_base_helper<64>
    {
        typedef unsigned long int exact;
    };
  }
  template < int Bits >
  struct  int_t : ::boost::detail::exact_signed_base_helper<Bits>
  {
      static_assert(Bits <= (int)(sizeof(::intmax_t) * 8), "No suitable signed integer type with the requested number of bits is available.");
      typedef typename ::boost::detail::int_least_helper<(Bits <= (int)(sizeof(::boost::long_long_type) * 8)) + (Bits - 1 <= ::std::numeric_limits<long int>::digits) + (Bits - 1 <= ::std::numeric_limits<int>::digits) + (Bits - 1 <= ::std::numeric_limits<short int>::digits) + (Bits - 1 <= ::std::numeric_limits<signed char>::digits)>::least least;
      typedef typename ::boost::int_fast_t<typename ::boost::int_t<Bits>::least>::type fast;
  };
  template < int Bits >
  struct  uint_t : ::boost::detail::exact_unsigned_base_helper<Bits>
  {
      static_assert(Bits <= (int)(sizeof(::uintmax_t) * 8), "No suitable unsigned integer type with the requested number of bits is available.");
      typedef typename ::boost::detail::uint_least_helper<(Bits <= (int)(sizeof(::boost::long_long_type) * 8)) + (Bits <= ::std::numeric_limits<unsigned long int>::digits) + (Bits <= ::std::numeric_limits<unsigned int>::digits) + (Bits <= ::std::numeric_limits<unsigned short int>::digits) + (Bits <= ::std::numeric_limits<unsigned char>::digits)>::least least;
      typedef typename ::boost::int_fast_t<typename ::boost::uint_t<Bits>::least>::type fast;
  };
  template < ::boost::long_long_type MaxValue >
  struct  int_max_value_t
  {
      typedef typename ::boost::detail::int_least_helper<(MaxValue <= ::boost::detail::integer_traits_base<long long int,  -9223372036854775807LL - 1, 9223372036854775807LL>::const_max) + (MaxValue <= ::boost::detail::integer_traits_base<long int,  -9223372036854775807L - 1L, 9223372036854775807L>::const_max) + (MaxValue <= ::boost::detail::integer_traits_base<int,  -2147483647 - 1, 2147483647>::const_max) + (MaxValue <= ::boost::detail::integer_traits_base<short int,  -32767 - 1, 32767>::const_max) + (MaxValue <= ::boost::detail::integer_traits_base<signed char,  -127 - 1, 127>::const_max)>::least least;
      typedef typename ::boost::int_fast_t<typename ::boost::int_max_value_t<MaxValue>::least>::type fast;
  };
  template < ::boost::long_long_type MinValue >
  struct  int_min_value_t
  {
      typedef typename ::boost::detail::int_least_helper<((MinValue >= ::boost::detail::integer_traits_base<long long int,  -9223372036854775807LL - 1, 9223372036854775807LL>::const_min)) + (MinValue >= ::boost::detail::integer_traits_base<long int,  -9223372036854775807L - 1L, 9223372036854775807L>::const_min) + (MinValue >= ::boost::detail::integer_traits_base<int,  -2147483647 - 1, 2147483647>::const_min) + (MinValue >= ::boost::detail::integer_traits_base<short int,  -32767 - 1, 32767>::const_min) + (MinValue >= ::boost::detail::integer_traits_base<signed char,  -127 - 1, 127>::const_min)>::least least;
      typedef typename ::boost::int_fast_t<typename ::boost::int_min_value_t<MinValue>::least>::type fast;
  };
  template < ::boost::ulong_long_type MaxValue >
  struct  uint_value_t
  {
      typedef typename ::boost::detail::uint_least_helper<(MaxValue <= ::boost::detail::integer_traits_base<unsigned long long int, 0, 9223372036854775807LL * 2LLU + 1>::const_max) + (MaxValue <= ::boost::detail::integer_traits_base<unsigned long int, 0, 9223372036854775807L * 2LU + 1LU>::const_max) + (MaxValue <= ::boost::detail::integer_traits_base<unsigned int, 0, 2147483647 * 2U + 1U>::const_max) + (MaxValue <= ::boost::detail::integer_traits_base<unsigned short int, 0, 32767 * 2 + 1>::const_max) + (MaxValue <= ::boost::detail::integer_traits_base<unsigned char, 0, 127 * 2 + 1>::const_max)>::least least;
      typedef typename ::boost::int_fast_t<typename ::boost::uint_value_t<MaxValue>::least>::type fast;
  };
  namespace archive {
    class save_access;
    template < typename OStream >
    class  basic_text_oprimitive
    {
      protected:
        OStream &os;
        ::boost::io::ios_flags_saver flags_saver;
        ::boost::io::ios_precision_saver precision_saver;
        ::boost::scoped_ptr< ::std::locale> archive_locale;
        ::boost::archive::basic_streambuf_locale_saver<typename OStream::char_type, typename OStream::traits_type> locale_saver;
        template < typename T >
        inline void save(const T &t)
        {
          if (::boost::archive::basic_text_oprimitive<OStream>::os.fail())
            {
              boost::serialization::throw_exception(::boost::archive::archive_exception(::boost::archive::archive_exception::output_stream_error /* , 0L, 0L */ ));
            }
          ::boost::archive::basic_text_oprimitive<OStream>::os << t;
        }
        inline void save(const bool t)
        {
          0 == static_cast<int>(t) || 1 == static_cast<int>(t) ? static_cast<void>(0) : __assert_fail("0 == static_cast<int>(t) || 1 == static_cast<int>(t)", "/usr/include/boost/archive/basic_text_oprimitive.hpp", 100, __PRETTY_FUNCTION__);
          if (::boost::archive::basic_text_oprimitive<OStream>::os.fail())
            {
              boost::serialization::throw_exception(::boost::archive::archive_exception(::boost::archive::archive_exception::output_stream_error /* , 0L, 0L */ ));
            }
          ::boost::archive::basic_text_oprimitive<OStream>::os << t;
        }
        inline void save(const signed char t)
        {
          (*this).save(static_cast<short int>(t));
        }
        inline void save(const unsigned char t)
        {
          (*this).save(static_cast<unsigned short int>(t));
        }
        inline void save(const char t)
        {
          (*this).save(static_cast<short int>(t));
        }
        inline void save(const wchar_t t)
        {
          (*this).save(static_cast<int>(t));
        }
        inline void save(const float t)
        {
          if (::boost::archive::basic_text_oprimitive<OStream>::os.fail())
            {
              boost::serialization::throw_exception(::boost::archive::archive_exception(::boost::archive::archive_exception::output_stream_error /* , 0L, 0L */ ));
            }
          ::boost::archive::basic_text_oprimitive<OStream>::os << std::setprecision(::std::numeric_limits<float>::digits10 + 2);
          ::boost::archive::basic_text_oprimitive<OStream>::os << t;
        }
        inline void save(const double t)
        {
          if (::boost::archive::basic_text_oprimitive<OStream>::os.fail())
            {
              boost::serialization::throw_exception(::boost::archive::archive_exception(::boost::archive::archive_exception::output_stream_error /* , 0L, 0L */ ));
            }
          ::boost::archive::basic_text_oprimitive<OStream>::os << std::setprecision(::std::numeric_limits<double>::digits10 + 2);
          ::boost::archive::basic_text_oprimitive<OStream>::os << t;
        }
        basic_text_oprimitive(OStream &os, bool no_codecvt);
        ~basic_text_oprimitive();
      public:
        inline void put(typename OStream::char_type c)
        {
          if (::boost::archive::basic_text_oprimitive<OStream>::os.fail())
            {
              boost::serialization::throw_exception(::boost::archive::archive_exception(::boost::archive::archive_exception::output_stream_error /* , 0L, 0L */ ));
            }
          ::boost::archive::basic_text_oprimitive<OStream>::os.put(c);
        }
        inline void put(const char *s)
        {
          while ('\000' != *s)
            {
              ::boost::archive::basic_text_oprimitive<OStream>::os.put(*s++);
            }
        }
        void save_binary(const void *address, ::std::size_t count);
    };
    namespace detail {
      class basic_oarchive_impl;
      class basic_oserializer;
      class basic_pointer_oserializer;
      class  basic_oarchive : ::boost::noncopyable_::noncopyable
      {
          ::boost::archive::detail::basic_oarchive_impl *pimpl;
          virtual void vsave(const ::boost::archive::version_type t) = 0 ;
          virtual void vsave(const ::boost::archive::object_id_type t) = 0 ;
          virtual void vsave(const ::boost::archive::object_reference_type t) = 0 ;
          virtual void vsave(const ::boost::archive::class_id_type t) = 0 ;
          virtual void vsave(const ::boost::archive::class_id_optional_type t) = 0 ;
          virtual void vsave(const ::boost::archive::class_id_reference_type t) = 0 ;
          virtual void vsave(const ::boost::archive::class_name_type &t) = 0 ;
          virtual void vsave(const ::boost::archive::tracking_type t) = 0 ;
        protected:
          basic_oarchive(unsigned int flags  = (0));
          virtual ~basic_oarchive();
        public:
          void register_basic_serializer(const ::boost::archive::detail::basic_oserializer &bos);
          void save_object(const void *x, const ::boost::archive::detail::basic_oserializer &bos);
          void save_pointer(const void *t, const ::boost::archive::detail::basic_pointer_oserializer *bpos_ptr);
          inline void save_null_pointer()
          {
            (*this).vsave(::boost::archive::class_id_type( -1));
          }
          void end_preamble();
          ::boost::archive::library_version_type get_library_version() const ;
          unsigned int get_flags() const ;
        friend class ::boost::archive::detail::basic_oarchive_impl;
      };
      class  basic_oserializer : public ::boost::archive::detail::basic_serializer
      {
          ::boost::archive::detail::basic_pointer_oserializer *m_bpos;
        protected:
          explicit basic_oserializer(const ::boost::serialization::extended_type_info &type_);
          virtual ~basic_oserializer();
        public:
          inline bool serialized_as_pointer() const 
          {
            return (*this).m_bpos != 0L;
          }
          inline void set_bpos(::boost::archive::detail::basic_pointer_oserializer *bpos)
          {
            (*this).m_bpos = bpos;
          }
          inline const ::boost::archive::detail::basic_pointer_oserializer *get_bpos() const 
          {
            return (*this).m_bpos;
          }
          virtual void save_object_data(::boost::archive::detail::basic_oarchive &ar, const void *x) const  = 0 ;
          virtual bool class_info() const  = 0 ;
          virtual bool tracking(const unsigned int flags) const  = 0 ;
          virtual ::boost::archive::version_type version() const  = 0 ;
          virtual bool is_polymorphic() const  = 0 ;
      };
      class  basic_pointer_oserializer : public ::boost::archive::detail::basic_serializer
      {
        protected:
          explicit basic_pointer_oserializer(const ::boost::serialization::extended_type_info &type_);
        public:
          virtual ~basic_pointer_oserializer();
          virtual const ::boost::archive::detail::basic_oserializer &get_basic_serializer() const  = 0 ;
          virtual void save_object_ptr(::boost::archive::detail::basic_oarchive &ar, const void *x) const  = 0 ;
      };
    }
    class  save_access
    {
      public:
        template < typename Archive >
        static inline void end_preamble(Archive &ar)
        {
          ar.end_preamble();
        }
        template < typename Archive, typename T >
        static inline void save_primitive(Archive &ar, const T &t)
        {
          ar.end_preamble();
          ar.save(t);
        }
    };
    namespace detail {
      template < typename Archive, typename T >
      class  oserializer : public ::boost::archive::detail::basic_oserializer
      {
        public:
          inline explicit oserializer()
            : basic_oserializer(boost::serialization::singleton<typename ::boost::serialization::type_info_implementation<T>::type>::get_const_instance())
          {
          }
          virtual void save_object_data(::boost::archive::detail::basic_oarchive &ar, const void *x) const  __attribute__((__used__));
          inline virtual bool class_info() const 
          {
            return boost::serialization::implementation_level<T>::value >= ::boost::serialization::object_class_info;
          }
          inline virtual bool tracking(const unsigned int) const 
          {
            return boost::serialization::tracking_level<T>::value == ::boost::serialization::track_always || (boost::serialization::tracking_level<T>::value == ::boost::serialization::track_selectively && (*this).serialized_as_pointer());
          }
          inline virtual ::boost::archive::version_type version() const 
          {
            return ::boost::archive::version_type(::boost::serialization::version<T>::value);
          }
          inline virtual bool is_polymorphic() const 
          {
            return boost::is_polymorphic<T>::value;
          }
          inline virtual ~oserializer()
          {
          }
      };
      template < typename Archive, typename T >
      __attribute__((__used__)) void oserializer<Archive, T>::save_object_data(::boost::archive::detail::basic_oarchive &ar, const void *x) const 
      {
        static_assert(boost::is_const<T>::value == false, "boost::is_const< T >::value == false");
        boost::serialization::serialize_adl(boost::serialization::smart_cast_reference<Archive &>(ar), *static_cast<T *>(const_cast<void *>(x)), (*this).version());
      }
      template < typename Archive, typename T >
      class  pointer_oserializer : public ::boost::archive::detail::basic_pointer_oserializer
      {
          inline const ::boost::archive::detail::basic_oserializer &get_basic_serializer() const 
          {
            return boost::serialization::singleton< ::boost::archive::detail::oserializer<Archive, T> >::get_const_instance();
          }
          virtual void save_object_ptr(::boost::archive::detail::basic_oarchive &ar, const void *x) const  __attribute__((__used__));
        public:
          pointer_oserializer();
          virtual ~pointer_oserializer();
      };
      template < typename Archive, typename T >
      __attribute__((__used__)) void pointer_oserializer<Archive, T>::save_object_ptr(::boost::archive::detail::basic_oarchive &ar, const void *x) const 
      {
        0L != x ? static_cast<void>(0) : __assert_fail("__null != x", "/usr/include/boost/archive/detail/oserializer.hpp", 189, __PRETTY_FUNCTION__);
        T *t = static_cast<T *>(const_cast<void *>(x));
        const unsigned int file_version = boost::serialization::version<T>::value;
        Archive &ar_impl = boost::serialization::smart_cast_reference<Archive &>(ar);
        boost::serialization::save_construct_data_adl<Archive, T>(ar_impl, t, file_version);
        ar_impl << boost::serialization::make_nvp(0L, *t);
      }
      template < typename Archive, typename T >
      pointer_oserializer<Archive, T>::pointer_oserializer()
        : basic_pointer_oserializer(boost::serialization::singleton<typename ::boost::serialization::type_info_implementation<T>::type>::get_const_instance())
      {
        boost::serialization::singleton< ::boost::archive::detail::oserializer<Archive, T> >::get_mutable_instance().set_bpos(this);
        archive_serializer_map<Archive>::insert(this);
      }
      template < typename Archive, typename T >
      pointer_oserializer<Archive, T>::~pointer_oserializer()
      {
        archive_serializer_map<Archive>::erase(this);
      }
      template < typename Archive >
      struct  save_non_pointer_type
      {
          struct  save_primitive
          {
              template < typename T >
              static inline void invoke(Archive &ar, const T &t)
              {
                save_access::save_primitive(ar, t);
              }
          };
          struct  save_only
          {
              template < typename T >
              static inline void invoke(Archive &ar, const T &t)
              {
                boost::serialization::serialize_adl(ar, const_cast<T &>(t), ::boost::serialization::version<T>::value);
              }
          };
          struct  save_standard
          {
              template < typename T >
              static inline void invoke(Archive &ar, const T &t)
              {
                ar.save_object(&t, boost::serialization::singleton< ::boost::archive::detail::oserializer<Archive, T> >::get_const_instance());
              }
          };
          struct  save_conditional
          {
              template < typename T >
              static inline void invoke(Archive &ar, const T &t)
              {
                save_standard::invoke(ar, t);
              }
          };
          template < typename T >
          static inline void invoke(Archive &ar, const T &t)
          {
            typedef typename ::boost::mpl::eval_if< ::boost::mpl::equal_to< ::boost::serialization::implementation_level<T>, ::mpl_::int_<1> >, ::boost::mpl::identity<typename ::boost::archive::detail::save_non_pointer_type<Archive>::save_primitive>, ::boost::mpl::eval_if< ::boost::mpl::greater_equal< ::boost::serialization::implementation_level<T>, ::mpl_::int_<3> >, ::boost::mpl::identity<typename ::boost::archive::detail::save_non_pointer_type<Archive>::save_standard>, ::boost::mpl::eval_if< ::boost::mpl::equal_to< ::boost::serialization::tracking_level<T>, ::mpl_::int_<0> >, ::boost::mpl::identity<typename ::boost::archive::detail::save_non_pointer_type<Archive>::save_only>, ::boost::mpl::identity<typename ::boost::archive::detail::save_non_pointer_type<Archive>::save_conditional> > > >::type typex;
            check_object_versioning<T>();
            typex::invoke(ar, t);
          }
          template < typename T >
          static inline void invoke(Archive &ar, T &t)
          {
            check_object_level<T>();
            check_object_tracking<T>();
            invoke(ar, const_cast<const T &>(t));
          }
      };
      template < typename Archive >
      struct  save_pointer_type
      {
          struct  abstract
          {
              template < typename T >
              static inline const ::boost::archive::detail::basic_pointer_oserializer *register_type(Archive &)
              {
                static_assert(boost::is_polymorphic<T>::value, "boost::is_polymorphic< T >::value");
                return 0L;
              }
          };
          struct  non_abstract
          {
              template < typename T >
              static inline const ::boost::archive::detail::basic_pointer_oserializer *register_type(Archive &ar)
              {
                return ar.register_type(static_cast<T *>(0L));
              }
          };
          template < typename T >
          static inline const ::boost::archive::detail::basic_pointer_oserializer *register_type(Archive &ar, T &)
          {
            typedef typename ::boost::mpl::eval_if< ::boost::serialization::is_abstract<T>, ::boost::mpl::identity<typename ::boost::archive::detail::save_pointer_type<Archive>::abstract>, ::boost::mpl::identity<typename ::boost::archive::detail::save_pointer_type<Archive>::non_abstract> >::type typex;
            return typex::template register_type<T>(ar);
          }
          struct  non_polymorphic
          {
              template < typename T >
              static inline void save(Archive &ar, T &t)
              {
                const ::boost::archive::detail::basic_pointer_oserializer &bpos = boost::serialization::singleton< ::boost::archive::detail::pointer_oserializer<Archive, T> >::get_const_instance();
                ar.save_pointer(&t, &bpos);
              }
          };
          struct  polymorphic
          {
              template < typename T >
              static inline void save(Archive &ar, T &t)
              {
                const typename ::boost::serialization::type_info_implementation<T>::type &i = boost::serialization::singleton<typename ::boost::serialization::type_info_implementation<T>::type>::get_const_instance();
                const ::boost::serialization::extended_type_info *const this_type = &i;
                0L != this_type ? static_cast<void>(0) : __assert_fail("__null != this_type", "/usr/include/boost/archive/detail/oserializer.hpp", 387, __PRETTY_FUNCTION__);
                const ::boost::serialization::extended_type_info *true_type = i.get_derived_extended_type_info(t);
                if (0L == true_type)
                  {
                    boost::serialization::throw_exception(::boost::archive::archive_exception(::boost::archive::archive_exception::unregistered_class, "derived class not registered or exported" /* , 0L */ ));
                  }
                const void *vp(static_cast<const void *>(&t));
                if (*this_type == *true_type)
                  {
                    const ::boost::archive::detail::basic_pointer_oserializer *bpos = register_type(ar, t);
                    ar.save_pointer(vp, bpos);
                    return ;
                  }
                vp = serialization::void_downcast(*true_type, *this_type, static_cast<const void *>(&t));
                if (0L == vp)
                  {
                    boost::serialization::throw_exception(::boost::archive::archive_exception(::boost::archive::archive_exception::unregistered_cast, (*true_type).get_debug_info(), (*this_type).get_debug_info()));
                  }
                const ::boost::archive::detail::basic_pointer_oserializer *bpos(static_cast<const ::boost::archive::detail::basic_pointer_oserializer *>(boost::serialization::singleton< ::boost::archive::detail::archive_serializer_map<Archive> >::get_const_instance().find(*true_type)));
                0L != bpos ? static_cast<void>(0) : __assert_fail("__null != bpos", "/usr/include/boost/archive/detail/oserializer.hpp", 436, __PRETTY_FUNCTION__);
                if (0L == bpos)
                  {
                    boost::serialization::throw_exception(::boost::archive::archive_exception(::boost::archive::archive_exception::unregistered_class, "derived class not registered or exported" /* , 0L */ ));
                  }
                ar.save_pointer(vp, bpos);
              }
          };
          template < typename T >
          static inline void save(Archive &ar, const T &t)
          {
            check_pointer_level<T>();
            check_pointer_tracking<T>();
            typedef typename ::boost::mpl::eval_if< ::boost::is_polymorphic<T>, ::boost::mpl::identity<typename ::boost::archive::detail::save_pointer_type<Archive>::polymorphic>, ::boost::mpl::identity<typename ::boost::archive::detail::save_pointer_type<Archive>::non_polymorphic> >::type type;
            type::save(ar, const_cast<T &>(t));
          }
          template < typename TPtr >
          static inline void invoke(Archive &ar, const TPtr t)
          {
            register_type(ar, *t);
            if (0L == t)
              {
                ::boost::archive::detail::basic_oarchive &boa = boost::serialization::smart_cast_reference< ::boost::archive::detail::basic_oarchive &>(ar);
                boa.::boost::archive::detail::basic_oarchive::save_null_pointer();
                save_access::end_preamble(ar);
                return ;
              }
            save(ar, *t);
          }
      };
 /* Instantiation of class template '::std::pair<const char *, const int *>' */ 
 /* Instantiation of class template '::boost::serialization::traits<const ::boost::serialization::nvp<const int>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp<const int> >, ::mpl_::bool_<true> >' */ 
 /* Instantiation of class template '::boost::serialization::wrapper_traits<const ::boost::serialization::nvp<const int>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp<const int> > >' */ 
 /* Instantiation of class template '::boost::serialization::nvp<const int>' */ 
      template < typename Archive >
      struct  save_enum_type
      {
          template < typename T >
          static inline void invoke(Archive &ar, const T &t)
          {
            const int i = static_cast<int>(t);
            ar << boost::serialization::make_nvp(0L, i);
          }
      };
      template < typename Archive >
      struct  save_array_type
      {
          template < typename T >
          static inline void invoke(Archive &ar, const T &t)
          {
            typedef typename ::boost::remove_extent<T>::type value_type;
            save_access::end_preamble(ar);
            ::std::size_t c = sizeof(t) / (static_cast<const char *>(static_cast<const void *>(&t[1])) - static_cast<const char *>(static_cast<const void *>(&t[0])));
            ::boost::serialization::collection_size_type count((c));
            ar << boost::serialization::make_nvp("count", count);
            ar << serialization::make_array(static_cast<const value_type *>(&t[0]), count);
          }
      };
    }
    template < typename Archive, typename T >
    inline void save(Archive &ar, T &t);
    template < typename Archive, typename T >
    inline void save(Archive &ar, T &t)
    {
      typedef typename ::boost::mpl::eval_if< ::boost::is_pointer<T>, ::boost::mpl::identity< ::boost::archive::detail::save_pointer_type<Archive> >, ::boost::mpl::eval_if< ::boost::is_enum<T>, ::boost::mpl::identity< ::boost::archive::detail::save_enum_type<Archive> >, ::boost::mpl::eval_if< ::boost::is_array<T>, ::boost::mpl::identity< ::boost::archive::detail::save_array_type<Archive> >, ::boost::mpl::identity< ::boost::archive::detail::save_non_pointer_type<Archive> > > > >::type typex;
      typex::invoke(ar, t);
    }
    namespace detail {
      template < typename Archive >
      class  interface_oarchive
      {
        protected:
          inline interface_oarchive()
          {
          }
        public:
          typedef ::mpl_::bool_<false> is_loading;
          typedef ::mpl_::bool_<true> is_saving;
          inline Archive *This()
          {
            return static_cast<Archive *>(this);
          }
          template < typename T >
          inline const ::boost::archive::detail::basic_pointer_oserializer *register_type(const T *  = (0L))
          {
            const ::boost::archive::detail::basic_pointer_oserializer &bpos = boost::serialization::singleton< ::boost::archive::detail::pointer_oserializer<Archive, T> >::get_const_instance();
            this->This()->register_basic_serializer(bpos.get_basic_serializer());
            return &bpos;
          }
          template < typename T >
          inline Archive &operator <<(T &t)
          {
            this->This()->save_override(t, 0);
            return *this->This();
          }
          template < typename T >
          inline Archive &operator &(T &t)
          {
            return *this->This() << const_cast<const T &>(t);
          }
      };
      template < typename Archive >
      class  common_oarchive : public ::boost::archive::detail::basic_oarchive, public ::boost::archive::detail::interface_oarchive<Archive>
      {
          inline virtual void vsave(const ::boost::archive::version_type t)
          {
            *this->This() << t;
          }
          inline virtual void vsave(const ::boost::archive::object_id_type t)
          {
            *this->This() << t;
          }
          inline virtual void vsave(const ::boost::archive::object_reference_type t)
          {
            *this->This() << t;
          }
          inline virtual void vsave(const ::boost::archive::class_id_type t)
          {
            *this->This() << t;
          }
          inline virtual void vsave(const ::boost::archive::class_id_reference_type t)
          {
            *this->This() << t;
          }
          inline virtual void vsave(const ::boost::archive::class_id_optional_type t)
          {
            *this->This() << t;
          }
          inline virtual void vsave(const ::boost::archive::class_name_type &t)
          {
            *this->This() << t;
          }
          inline virtual void vsave(const ::boost::archive::tracking_type t)
          {
            *this->This() << t;
          }
        protected:
          template < typename T >
          inline void save_override(T &t, int)
          {
            archive::save(*this->This(), t);
          }
          inline void save_start(const char *)
          {
          }
          inline void save_end(const char *)
          {
          }
          inline common_oarchive(unsigned int flags  = (0))
            : basic_oarchive(flags), interface_oarchive<Archive>()
          {
          }
        friend class ::boost::archive::detail::interface_oarchive<Archive>;
      };
    }
  }
  namespace serialization {
     template <>
    struct  implementation_level_impl<const ::std::basic_string<char> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<1> type;
        static const int value = ::mpl_::int_<1>::value;
    };
    template <>
    struct  implementation_level_impl<const ::std::basic_string<wchar_t> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<1> type;
        static const int value = ::mpl_::int_<1>::value;
    };
 /* Instantiation of template function '::std::allocator<char>::allocator()' */ 
  }
  namespace archive {
    template < typename Archive >
    class  basic_text_oarchive : public ::boost::archive::detail::common_oarchive<Archive>
    {
      protected:
        enum mcc_enum_anon_84
        {
          none = 0,
          eol = 1,
          space = 2
        };
        typename ::boost::archive::basic_text_oarchive<Archive>::mcc_enum_anon_84 delimiter;
        void newtoken();
        inline void newline()
        {
          ::boost::archive::basic_text_oarchive<Archive>::delimiter = ::boost::archive::basic_text_oarchive<Archive>::eol;
        }
        typedef ::boost::archive::detail::common_oarchive<Archive> detail_common_oarchive;
        template < typename T >
        inline void save_override(T &t, int)
        {
          this->detail_common_oarchive::save_override(t, 0);
        }
        inline void save_override(const ::boost::archive::object_id_type &t, int)
        {
          this->This()->newline();
          this->detail_common_oarchive::save_override(t, 0);
        }
        inline void save_override(const ::boost::archive::class_id_optional_type &, int)
        {
        }
        inline void save_override(const ::boost::archive::class_name_type &t, int)
        {
          const ::std::string s((t) /* , (::std::allocator<char>()) */ );
          *this->This() << s;
        }
        void init();
        inline basic_text_oarchive(unsigned int flags)
          : detail::common_oarchive<Archive>(flags), delimiter(::boost::archive::basic_text_oarchive<Archive>::none)
        {
        }
        inline ~basic_text_oarchive()
        {
        }
      friend class ::boost::archive::detail::interface_oarchive<Archive>;
    };
 /* Instantiation of class template '::boost::archive::basic_text_oprimitive< ::std::basic_ostream<char> >' */ 
    template < typename Archive >
    class  text_oarchive_impl : public ::boost::archive::basic_text_oprimitive< ::std::basic_ostream<char> >, public ::boost::archive::basic_text_oarchive<Archive>
    {
      protected:
        template < typename T >
        inline void save(const T &t)
        {
          this->newtoken();
          basic_text_oprimitive< ::std::ostream>::save(t);
        }
        inline void save(const ::boost::archive::version_type &t)
        {
          (*this).save(static_cast<unsigned int>(t));
        }
        inline void save(const ::boost::serialization::item_version_type &t)
        {
          (*this).save(static_cast<unsigned int>(t));
        }
        void save(const char *t);
        void save(const wchar_t *t);
        void save(const ::std::string &s);
        void save(const ::std::wstring &ws);
        text_oarchive_impl(::std::ostream &os, unsigned int flags);
        inline ~text_oarchive_impl()
        {
        }
      public:
        void save_binary(const void *address, ::std::size_t count);
      friend class ::boost::archive::detail::interface_oarchive<Archive>;
      friend class ::boost::archive::basic_text_oarchive<Archive>;
      friend class save_access;
    };
 /* Instantiation of class template '::boost::archive::detail::interface_oarchive<class text_oarchive>' */ 
 /* Instantiation of class template '::boost::archive::detail::common_oarchive<class text_oarchive>' */ 
 /* Instantiation of class template '::boost::archive::basic_text_oarchive<class text_oarchive>' */ 
 /* Instantiation of class template '::boost::archive::text_oarchive_impl<class text_oarchive>' */ 
    class  text_oarchive : public ::boost::archive::text_oarchive_impl< ::boost::archive::text_oarchive>
    {
      public:
        inline text_oarchive(::std::ostream &os_, unsigned int flags  = (0))
          : ::boost::archive::text_oarchive_impl< ::boost::archive::text_oarchive>(os_, flags)
        {
        }
        inline ~text_oarchive()
        {
        }
    };
    typedef ::boost::archive::text_oarchive naked_text_oarchive;
    namespace detail {
      template < typename Serializable >
      typename ::boost::archive::detail::_ptr_serialization_support< ::boost::archive::text_oarchive, Serializable>::type instantiate_ptr_serialization(Serializable *, ::boost::archive::text_oarchive *, ::boost::archive::detail::adl_tag);
 /* Instantiation of class template '::std::pair<const char *, const ::boost::serialization::item_version_type *>' */ 
 /* Instantiation of class template '::boost::serialization::traits<const ::boost::serialization::nvp<const ::boost::serialization::item_version_type>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp<const ::boost::serialization::item_version_type> >, ::mpl_::bool_<true> >' */ 
 /* Instantiation of class template '::boost::serialization::wrapper_traits<const ::boost::serialization::nvp<const ::boost::serialization::item_version_type>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp<const ::boost::serialization::item_version_type> > >' */ 
 /* Instantiation of class template '::boost::serialization::nvp<const ::boost::serialization::item_version_type>' */ 
    }
  }
  namespace serialization {
     namespace stl {
      template < typename Archive, typename Container >
      inline void save_collection(Archive &ar, const Container &s);
      template < typename Archive, typename Container >
      inline void save_collection(Archive &ar, const Container &s)
      {
        ::boost::serialization::collection_size_type count(s.size());
        const ::boost::serialization::item_version_type item_version(version<typename Container::value_type>::value);
        ar << boost::serialization::make_nvp("count", count);
        ar << boost::serialization::make_nvp("item_version", item_version);
        typename Container::const_iterator it = s.begin();
        while (count-- > 0)
          {
            boost::serialization::save_construct_data_adl(ar, &*it, item_version);
            ar << boost::serialization::make_nvp("item", *it++);
          }
      }
    }
  }
}
namespace mpl_ {
   template < ::std::size_t N >
  struct size_t;
}
namespace boost {
  namespace mpl {
    using ::mpl_::size_t;
  }
}
namespace mpl_ {
   template < ::std::size_t N >
  struct  size_t
  {
      static const ::std::size_t value = N;
      typedef ::mpl_::size_t<N> type;
      typedef ::std::size_t value_type;
      typedef ::mpl_::integral_c_tag tag;
      typedef ::mpl_::size_t<static_cast< ::std::size_t>(::mpl_::size_t<N>::value + 1)> next;
      typedef ::mpl_::size_t<static_cast< ::std::size_t>(::mpl_::size_t<N>::value - 1)> prior;
      inline operator ::std::size_t() const 
      {
        return static_cast< ::std::size_t>(this->value);
      }
  };
}
namespace boost {
  template < typename T >
  struct alignment_of;
  namespace detail {
    template < typename T >
    struct  alignment_of_hack
    {
        char c;
        T t;
        alignment_of_hack();
    };
    template < unsigned int A, unsigned int S >
    struct  alignment_logic
    {
        static const ::std::size_t value = A < S ? A : S;
    };
    template < typename T >
    struct  alignment_of_impl
    {
        static const ::std::size_t value = alignof(T);
    };
  }
  template < typename T >
  struct  alignment_of : ::boost::integral_constant<unsigned long int, ::boost::detail::alignment_of_impl<T>::value>
  {
  };
  template < typename T >
  struct  alignment_of<T &> : ::boost::alignment_of<T *>
  {
  };
 /* Instantiation of class template '::mpl_::integral_c<unsigned long int, 0>' */ 
 /* Instantiation of class template '::boost::integral_constant<unsigned long int, 0>' */ 
  template <>
  struct  alignment_of<void> : ::boost::integral_constant<unsigned long int, 0>
  {
  };
  template <>
  struct  alignment_of<const void> : ::boost::integral_constant<unsigned long int, 0>
  {
  };
  template <>
  struct  alignment_of<volatile void> : ::boost::integral_constant<unsigned long int, 0>
  {
  };
  template <>
  struct  alignment_of<const volatile void> : ::boost::integral_constant<unsigned long int, 0>
  {
  };
  namespace detail {
    template < typename T >
    struct  is_scalar_impl
    {
        static const bool value = ::boost::type_traits::ice_or< ::boost::is_arithmetic<T>::value, ::boost::is_enum<T>::value, ::boost::is_pointer<T>::value, ::boost::is_member_pointer<T>::value>::value;
    };
    template <>
    struct  is_scalar_impl<void>
    {
        static const bool value = false;
    };
    template <>
    struct  is_scalar_impl<const void>
    {
        static const bool value = false;
    };
    template <>
    struct  is_scalar_impl<volatile void>
    {
        static const bool value = false;
    };
    template <>
    struct  is_scalar_impl<const volatile void>
    {
        static const bool value = false;
    };
  }
  template < typename T >
  struct  is_scalar : ::boost::integral_constant<bool, ::boost::detail::is_scalar_impl<T>::value>
  {
  };
  template < typename T >
  struct is_POD;
  namespace detail {
    template < typename T >
    struct  is_pod_impl
    {
        static const bool value = ::boost::type_traits::ice_or< ::boost::is_scalar<T>::value, ::boost::is_void<T>::value, __is_pod(T)>::value;
    };
    template < typename T, ::std::size_t sz >
    struct  is_pod_impl<T [sz]> : ::boost::detail::is_pod_impl<T>
    {
    };
    template <>
    struct  is_pod_impl<void>
    {
        static const bool value = true;
    };
    template <>
    struct  is_pod_impl<const void>
    {
        static const bool value = true;
    };
    template <>
    struct  is_pod_impl<volatile void>
    {
        static const bool value = true;
    };
    template <>
    struct  is_pod_impl<const volatile void>
    {
        static const bool value = true;
    };
  }
  template < typename T >
  struct  is_pod : ::boost::integral_constant<bool, ::boost::detail::is_pod_impl<T>::value>
  {
  };
  template < typename T >
  struct  is_POD : ::boost::integral_constant<bool, ::boost::is_pod<T>::value>
  {
  };
  namespace detail {
    class alignment_dummy;
    typedef void (*function_ptr)();
    typedef int (::boost::detail::alignment_dummy::*member_ptr);
    typedef int (::boost::detail::alignment_dummy::*member_function_ptr)();
    template < bool found, ::std::size_t target, typename TestType >
    struct  lower_alignment_helper
    {
        typedef char type;
        enum mcc_enum_anon_85
        {
          value = true
        };
    };
    template < ::std::size_t target, typename TestType >
    struct  lower_alignment_helper<false, target, TestType>
    {
        enum mcc_enum_anon_86
        {
          value = alignment_of<TestType>::value == target
        };
        typedef typename ::boost::mpl::if_c< ::boost::detail::lower_alignment_helper<false, target, TestType>::value, TestType, char>::type type;
    };
    template < typename T >
    struct  has_one_T
    {
        T data;
    };
    template < ::std::size_t target >
    union  lower_alignment
    {
        enum mcc_enum_anon_87
        {
          found0 = false
        };
        typename ::boost::detail::lower_alignment_helper<false, target, char>::type t0;
        enum mcc_enum_anon_88
        {
          found1 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found0, target, char>::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found1, target, short int>::type t1;
        enum mcc_enum_anon_89
        {
          found2 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found1, target, short int>::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found2, target, int>::type t2;
        enum mcc_enum_anon_90
        {
          found3 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found2, target, int>::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found3, target, long int>::type t3;
        enum mcc_enum_anon_91
        {
          found4 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found3, target, long int>::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found4, target, long long int>::type t4;
        enum mcc_enum_anon_92
        {
          found5 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found4, target, ::boost::long_long_type>::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found5, target, float>::type t5;
        enum mcc_enum_anon_93
        {
          found6 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found5, target, float>::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found6, target, double>::type t6;
        enum mcc_enum_anon_94
        {
          found7 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found6, target, double>::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found7, target, long double>::type t7;
        enum mcc_enum_anon_95
        {
          found8 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found7, target, long double>::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found8, target, void *>::type t8;
        enum mcc_enum_anon_96
        {
          found9 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found8, target, void *>::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found9, target, void (*)()>::type t9;
        enum mcc_enum_anon_97
        {
          found10 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found9, target, ::boost::detail::function_ptr>::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found10, target, int (::boost::detail::alignment_dummy::*)>::type t10;
        enum mcc_enum_anon_98
        {
          found11 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found10, target, ::boost::detail::member_ptr>::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found11, target, int (::boost::detail::alignment_dummy::*)()>::type t11;
        enum mcc_enum_anon_99
        {
          found12 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found11, target, ::boost::detail::member_function_ptr>::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found12, target, ::boost::detail::has_one_T<char> >::type t12;
        enum mcc_enum_anon_100
        {
          found13 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found12, target, ::boost::detail::has_one_T<char> >::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found13, target, ::boost::detail::has_one_T<short int> >::type t13;
        enum mcc_enum_anon_101
        {
          found14 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found13, target, ::boost::detail::has_one_T<short int> >::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found14, target, ::boost::detail::has_one_T<int> >::type t14;
        enum mcc_enum_anon_102
        {
          found15 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found14, target, ::boost::detail::has_one_T<int> >::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found15, target, ::boost::detail::has_one_T<long int> >::type t15;
        enum mcc_enum_anon_103
        {
          found16 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found15, target, ::boost::detail::has_one_T<long int> >::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found16, target, ::boost::detail::has_one_T<long long int> >::type t16;
        enum mcc_enum_anon_104
        {
          found17 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found16, target, ::boost::detail::has_one_T<long long int> >::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found17, target, ::boost::detail::has_one_T<float> >::type t17;
        enum mcc_enum_anon_105
        {
          found18 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found17, target, ::boost::detail::has_one_T<float> >::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found18, target, ::boost::detail::has_one_T<double> >::type t18;
        enum mcc_enum_anon_106
        {
          found19 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found18, target, ::boost::detail::has_one_T<double> >::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found19, target, ::boost::detail::has_one_T<long double> >::type t19;
        enum mcc_enum_anon_107
        {
          found20 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found19, target, ::boost::detail::has_one_T<long double> >::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found20, target, ::boost::detail::has_one_T<void *> >::type t20;
        enum mcc_enum_anon_108
        {
          found21 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found20, target, ::boost::detail::has_one_T<void *> >::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found21, target, ::boost::detail::has_one_T<void (*)()> >::type t21;
        enum mcc_enum_anon_109
        {
          found22 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found21, target, ::boost::detail::has_one_T<void (*)()> >::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found22, target, ::boost::detail::has_one_T<int (::boost::detail::alignment_dummy::*)> >::type t22;
        enum mcc_enum_anon_110
        {
          found23 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found22, target, ::boost::detail::has_one_T<int (::boost::detail::alignment_dummy::*)> >::value
        };
        typename ::boost::detail::lower_alignment_helper< ::boost::detail::lower_alignment<target>::found23, target, ::boost::detail::has_one_T<int (::boost::detail::alignment_dummy::*)()> >::type t23;
        enum mcc_enum_anon_111
        {
          found24 = lower_alignment_helper< ::boost::detail::lower_alignment<target>::found23, target, ::boost::detail::has_one_T<int (::boost::detail::alignment_dummy::*)()> >::value
        };
    };
 /* Instantiation of class template '::boost::detail::has_one_T<char>' */ 
 /* Instantiation of class template '::boost::detail::has_one_T<short int>' */ 
 /* Instantiation of class template '::boost::detail::has_one_T<int>' */ 
 /* Instantiation of class template '::boost::detail::has_one_T<long int>' */ 
 /* Instantiation of class template '::boost::detail::has_one_T<long long int>' */ 
 /* Instantiation of class template '::boost::detail::has_one_T<float>' */ 
 /* Instantiation of class template '::boost::detail::has_one_T<double>' */ 
 /* Instantiation of class template '::boost::detail::has_one_T<long double>' */ 
 /* Instantiation of class template '::boost::detail::has_one_T<void *>' */ 
 /* Instantiation of class template '::boost::detail::has_one_T<void (*)()>' */ 
 /* Instantiation of class template '::boost::detail::has_one_T<int (::boost::detail::alignment_dummy::*)>' */ 
 /* Instantiation of class template '::boost::detail::has_one_T<int (::boost::detail::alignment_dummy::*)()>' */ 
    union  max_align
    {
        char t0;
        short int t1;
        int t2;
        long int t3;
        ::boost::long_long_type t4;
        float t5;
        double t6;
        long double t7;
        void *t8;
        ::boost::detail::function_ptr t9;
        ::boost::detail::member_ptr t10;
        ::boost::detail::member_function_ptr t11;
        ::boost::detail::has_one_T<char> t12;
        ::boost::detail::has_one_T<short int> t13;
        ::boost::detail::has_one_T<int> t14;
        ::boost::detail::has_one_T<long int> t15;
        ::boost::detail::has_one_T<long long int> t16;
        ::boost::detail::has_one_T<float> t17;
        ::boost::detail::has_one_T<double> t18;
        ::boost::detail::has_one_T<long double> t19;
        ::boost::detail::has_one_T<void *> t20;
        ::boost::detail::has_one_T<void (*)()> t21;
        ::boost::detail::has_one_T<int (::boost::detail::alignment_dummy::*)> t22;
        ::boost::detail::has_one_T<int (::boost::detail::alignment_dummy::*)()> t23;
    };
    template < ::std::size_t TAlign, ::std::size_t Align >
    struct  is_aligned
    {
        static const bool value = (TAlign >= Align) & (TAlign % Align == 0);
    };
  }
  template < ::std::size_t Align >
  struct  is_pod< ::boost::detail::lower_alignment<Align> >
  {
      static const ::std::size_t value = true;
  };
  namespace detail {
    template < ::std::size_t Align >
    class  type_with_alignment_imp
    {
        typedef ::boost::detail::lower_alignment<Align> t1;
        typedef typename ::boost::mpl::if_c< ::boost::detail::is_aligned< ::boost::alignment_of<typename ::boost::detail::type_with_alignment_imp<Align>::t1>::value, Align>::value, typename ::boost::detail::type_with_alignment_imp<Align>::t1, ::boost::detail::max_align>::type align_t;
        static const ::std::size_t found = alignment_of<typename ::boost::detail::type_with_alignment_imp<Align>::align_t>::value;
        static_assert(::boost::detail::type_with_alignment_imp<Align>::found >= Align, "found >= Align");
        static_assert(::boost::detail::type_with_alignment_imp<Align>::found % Align == 0, "found % Align == 0");
      public:
        typedef typename ::boost::detail::type_with_alignment_imp<Align>::align_t type;
    };
  }
  template < ::std::size_t Align >
  class  type_with_alignment : public ::boost::detail::type_with_alignment_imp<Align>
  {
  };
  namespace align {
    struct __attribute__((aligned(2)))  a2
    {
    };
    struct __attribute__((aligned(4)))  a4
    {
    };
    struct __attribute__((aligned(8)))  a8
    {
    };
    struct __attribute__((aligned(16)))  a16
    {
    };
    struct __attribute__((aligned(32)))  a32
    {
    };
    struct __attribute__((aligned(64)))  a64
    {
    };
    struct __attribute__((aligned(128)))  a128
    {
    };
  }
  template <>
  class  type_with_alignment<1LU>
  {
    public:
      typedef char type;
  };
  template <>
  class  type_with_alignment<2LU>
  {
    public:
      typedef ::boost::align::a2 type;
  };
  template <>
  class  type_with_alignment<4LU>
  {
    public:
      typedef ::boost::align::a4 type;
  };
  template <>
  class  type_with_alignment<8LU>
  {
    public:
      typedef ::boost::align::a8 type;
  };
  template <>
  class  type_with_alignment<16LU>
  {
    public:
      typedef ::boost::align::a16 type;
  };
  template <>
  class  type_with_alignment<32LU>
  {
    public:
      typedef ::boost::align::a32 type;
  };
  template <>
  class  type_with_alignment<64LU>
  {
    public:
      typedef ::boost::align::a64 type;
  };
  template <>
  class  type_with_alignment<128LU>
  {
    public:
      typedef ::boost::align::a128 type;
  };
  namespace detail {
    template <>
    struct  is_pod_impl< ::boost::align::a2>
    {
        static const bool value = true;
    };
    template <>
    struct  is_pod_impl< ::boost::align::a4>
    {
        static const bool value = true;
    };
    template <>
    struct  is_pod_impl< ::boost::align::a8>
    {
        static const bool value = true;
    };
    template <>
    struct  is_pod_impl< ::boost::align::a16>
    {
        static const bool value = true;
    };
    template <>
    struct  is_pod_impl< ::boost::align::a32>
    {
        static const bool value = true;
    };
    template <>
    struct  is_pod_impl< ::boost::align::a64>
    {
        static const bool value = true;
    };
    template <>
    struct  is_pod_impl< ::boost::align::a128>
    {
        static const bool value = true;
    };
 /* Instantiation of class template '::boost::detail::alignment_of_impl< ::boost::detail::max_align>' */ 
 /* Instantiation of class template '::mpl_::integral_c<unsigned long int, ::boost::detail::alignment_of_impl< ::boost::detail::max_align>::value>' */ 
 /* Instantiation of class template '::boost::integral_constant<unsigned long int, ::boost::detail::alignment_of_impl< ::boost::detail::max_align>::value>' */ 
 /* Instantiation of class template '::boost::alignment_of< ::boost::detail::max_align>' */ 
    namespace aligned_storage {
      static const ::std::size_t alignment_of_max_align(::mpl_::integral_c<unsigned long int, ::boost::detail::alignment_of_impl< ::boost::detail::max_align>::value>::value);
      template < ::std::size_t size_, ::std::size_t alignment_ >
      struct  aligned_storage_imp
      {
          union  data_t
          {
              char buf[size_];
              typename ::boost::mpl::eval_if_c<alignment_ == (::std::size_t) -1, ::boost::mpl::identity< ::boost::detail::max_align>, ::boost::type_with_alignment<alignment_> >::type align_;
          };
          typename ::boost::detail::aligned_storage::aligned_storage_imp<size_, alignment_>::data_t data_;
          inline void *address() const 
          {
            return const_cast< ::boost::detail::aligned_storage::aligned_storage_imp<size_, alignment_> *>(this);
          }
      };
      template < ::std::size_t alignment_ >
      struct  aligned_storage_imp<0LU, alignment_>
      {
          inline void *address() const 
          {
            return 0;
          }
      };
    }
  }
  template < ::std::size_t size_, ::std::size_t alignment_ = (::std::size_t) -1 >
  class  aligned_storage : ::boost::detail::aligned_storage::aligned_storage_imp<size_, alignment_>
  {
    public:
      typedef ::boost::detail::aligned_storage::aligned_storage_imp<size_, alignment_> type;
      static const ::std::size_t size = size_;
      static const ::std::size_t alignment = alignment_ == (::std::size_t) -1 ? ::boost::detail::aligned_storage::alignment_of_max_align : alignment_;
    private:
      aligned_storage(const ::boost::aligned_storage<size_, alignment_> &);
      ::boost::aligned_storage<size_, alignment_> &operator =(const ::boost::aligned_storage<size_, alignment_> &);
    public:
      inline aligned_storage()
      {
      }
      inline ~aligned_storage()
      {
      }
      inline void *address()
      {
        return static_cast<typename ::boost::aligned_storage<size_, alignment_>::type *>(this)->address();
      }
      inline const void *address() const 
      {
        return static_cast<const typename ::boost::aligned_storage<size_, alignment_>::type *>(this)->address();
      }
  };
  template < ::std::size_t size_, ::std::size_t alignment_ >
  struct  is_pod< ::boost::detail::aligned_storage::aligned_storage_imp<size_, alignment_> > : ::boost::integral_constant<bool, true>
  {
  };
  namespace serialization {
    namespace detail {
      template < typename T >
      struct  stack_allocate
      {
          inline T *address()
          {
            return static_cast<T *>(::boost::serialization::detail::stack_allocate<T>::storage_.address());
          }
          inline T &reference()
          {
            return *(*this).address();
          }
        private:
          typedef ::boost::aligned_storage<sizeof(T), boost::alignment_of<T>::value> type;
          typename ::boost::serialization::detail::stack_allocate<T>::type storage_;
      };
      template < typename Archive, typename T >
      struct  stack_construct : ::boost::serialization::detail::stack_allocate<T>
      {
          inline stack_construct(Archive &ar, const unsigned int version)
          {
            boost::serialization::load_construct_data_adl(ar, this->address(), version);
          }
          inline ~stack_construct()
          {
            this->address()->~T();
          }
      };
    }
    namespace stl {
      template < typename Archive, typename Container >
      struct  archive_input_seq
      {
          inline typename Container::iterator operator ()(Archive &ar, Container &s, const unsigned int v, typename Container::iterator hint)
          {
            typedef typename Container::value_type type;
            ::boost::serialization::detail::stack_construct<Archive, type> t(ar, v);
            ar >> boost::serialization::make_nvp("item", t.reference());
            s.push_back(t.reference());
            ar.reset_object_address(&s.back(), &t.reference());
            return hint;
          }
      };
      template < typename Archive, typename Container >
      struct  archive_input_map
      {
          inline typename Container::iterator operator ()(Archive &ar, Container &s, const unsigned int v, typename Container::iterator hint)
          {
            typedef typename Container::value_type type;
            ::boost::serialization::detail::stack_construct<Archive, type> t(ar, v);
            ar >> boost::serialization::make_nvp("item", t.reference());
            typename Container::iterator result = s.insert(hint, t.reference());
            ar.reset_object_address(&result->second, &t.reference().second);
            return result;
          }
      };
      template < typename Archive, typename Container >
      struct  archive_input_set
      {
          inline typename Container::iterator operator ()(Archive &ar, Container &s, const unsigned int v, typename Container::iterator hint)
          {
            typedef typename Container::value_type type;
            ::boost::serialization::detail::stack_construct<Archive, type> t(ar, v);
            ar >> boost::serialization::make_nvp("item", t.reference());
            typename Container::iterator result = s.insert(hint, t.reference());
            ar.reset_object_address(&*result, &t.reference());
            return result;
          }
      };
      template < typename Container >
      class  reserve_imp
      {
        public:
          inline void operator ()(Container &s, ::std::size_t count) const 
          {
            s.reserve(count);
          }
      };
      template < typename Container >
      class  no_reserve_imp
      {
        public:
          inline void operator ()(Container &, ::std::size_t) const 
          {
          }
      };
 /* Instantiation of class template '::std::pair<const char *, ::boost::serialization::item_version_type *>' */ 
 /* Instantiation of class template '::boost::serialization::traits<const ::boost::serialization::nvp< ::boost::serialization::item_version_type>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp< ::boost::serialization::item_version_type> >, ::mpl_::bool_<true> >' */ 
 /* Instantiation of class template '::boost::serialization::wrapper_traits<const ::boost::serialization::nvp< ::boost::serialization::item_version_type>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp< ::boost::serialization::item_version_type> > >' */ 
 /* Instantiation of class template '::boost::serialization::nvp< ::boost::serialization::item_version_type>' */ 
      template < typename Archive, typename Container, typename InputFunction, typename R >
      inline void load_collection(Archive &ar, Container &s);
      template < typename Archive, typename Container, typename InputFunction, typename R >
      inline void load_collection(Archive &ar, Container &s)
      {
        s.clear();
        ::boost::serialization::collection_size_type count /* () */ ;
        const ::boost::archive::library_version_type library_version(ar.get_library_version());
        ::boost::serialization::item_version_type item_version((0));
        ar >> boost::serialization::make_nvp("count", count);
        if (::boost::archive::library_version_type(3) < library_version)
          {
            ar >> boost::serialization::make_nvp("item_version", item_version);
          }
        R rx;
        rx(s, count);
        InputFunction ifunc;
        typename Container::iterator hint;
        hint = s.begin();
        while (count-- > 0)
          {
            hint = ifunc(ar, s, item_version, hint);
          }
      }
    }
  }
}
namespace std __attribute__((__visibility__("default"))) {
   template < typename _Clos, typename _Tp >
  class _Expr;
  template < typename _Tp1, typename _Tp2 >
  class _ValArray;
  template < typename _Oper,   template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ > class _Meta, typename _Dom >
  struct _UnClos;
  template < typename _Oper,   template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ > class _Meta1,   template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ > class _Meta2, typename _Dom1, typename _Dom2 >
  class _BinClos;
  template <   template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ > class _Meta, typename _Dom >
  class _SClos;
  template <   template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ > class _Meta, typename _Dom >
  class _GClos;
  template <   template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ > class _Meta, typename _Dom >
  class _IClos;
  template <   template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ > class _Meta, typename _Dom >
  class _ValFunClos;
  template <   template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ > class _Meta, typename _Dom >
  class _RefFunClos;
  template < typename _Tp >
  class valarray;
  class slice;
  template < typename _Tp >
  class slice_array;
  class gslice;
  template < typename _Tp >
  class gslice_array;
  template < typename _Tp >
  class mask_array;
  template < typename _Tp >
  class indirect_array;
  inline void *__valarray_get_memory(::std::size_t __n)
  {
    return ::operator new(__n);
  }
  template < typename _Tp >
  inline _Tp *__restrict __valarray_get_storage(::std::size_t __n);
  template < typename _Tp >
  inline _Tp *__restrict __valarray_get_storage(::std::size_t __n)
  {
    return static_cast<_Tp *__restrict >(std::__valarray_get_memory(__n * sizeof(_Tp)));
  }
  inline void __valarray_release_memory(void *__p)
  {
    ::operator delete(__p);
  }
  template < typename _Tp, bool __nontype_tpl_param_1_1__ >
  struct  _Array_default_ctor
  {
      static inline void _S_do_it(_Tp *__b, _Tp *__e)
      {
        while (__b != __e)
          {
            new (__b++)_Tp();
          }
      }
  };
  template < typename _Tp >
  struct  _Array_default_ctor<_Tp, true>
  {
      static inline void _S_do_it(_Tp *__b, _Tp *__e)
      {
        __builtin_memset(__b, 0, (__e - __b) * sizeof(_Tp));
      }
  };
  template < typename _Tp >
  inline void __valarray_default_construct(_Tp *__b, _Tp *__e);
  template < typename _Tp >
  inline void __valarray_default_construct(_Tp *__b, _Tp *__e)
  {
    _Array_default_ctor<_Tp, __is_scalar<_Tp>::__value>::_S_do_it(__b, __e);
  }
  template < typename _Tp, bool __nontype_tpl_param_1_1__ >
  struct  _Array_init_ctor
  {
      static inline void _S_do_it(_Tp *__b, _Tp *__e, const _Tp __t)
      {
        while (__b != __e)
          {
            new (__b++)_Tp(__t);
          }
      }
  };
  template < typename _Tp >
  struct  _Array_init_ctor<_Tp, true>
  {
      static inline void _S_do_it(_Tp *__b, _Tp *__e, const _Tp __t)
      {
        while (__b != __e)
          {
            *__b++ = __t;
          }
      }
  };
  template < typename _Tp >
  inline void __valarray_fill_construct(_Tp *__b, _Tp *__e, const _Tp __t);
  template < typename _Tp >
  inline void __valarray_fill_construct(_Tp *__b, _Tp *__e, const _Tp __t)
  {
    _Array_init_ctor<_Tp, __is_trivial(_Tp)>::_S_do_it(__b, __e, __t);
  }
  template < typename _Tp, bool __nontype_tpl_param_1_1__ >
  struct  _Array_copy_ctor
  {
      static inline void _S_do_it(const _Tp *__b, const _Tp *__e, _Tp *__restrict __o)
      {
        while (__b != __e)
          {
            new (__o++)_Tp(*__b++);
          }
      }
  };
  template < typename _Tp >
  struct  _Array_copy_ctor<_Tp, true>
  {
      static inline void _S_do_it(const _Tp *__b, const _Tp *__e, _Tp *__restrict __o)
      {
        __builtin_memcpy(__o, __b, (__e - __b) * sizeof(_Tp));
      }
  };
  template < typename _Tp >
  inline void __valarray_copy_construct(const _Tp *__b, const _Tp *__e, _Tp *__restrict __o);
  template < typename _Tp >
  inline void __valarray_copy_construct(const _Tp *__b, const _Tp *__e, _Tp *__restrict __o)
  {
    _Array_copy_ctor<_Tp, __is_trivial(_Tp)>::_S_do_it(__b, __e, __o);
  }
  template < typename _Tp >
  inline void __valarray_copy_construct(const _Tp *__restrict __a, ::std::size_t __n, ::std::size_t __s, _Tp *__restrict __o);
  template < typename _Tp >
  inline void __valarray_copy_construct(const _Tp *__restrict __a, ::std::size_t __n, ::std::size_t __s, _Tp *__restrict __o)
  {
    if (__is_trivial(_Tp))
      {
        while (__n--)
          {
            *__o++ = *__a;
            __a += __s;
          }
      }
    else
      {
        while (__n--)
          {
            new (__o++)_Tp(*__a);
            __a += __s;
          }
      }
  }
  template < typename _Tp >
  inline void __valarray_copy_construct(const _Tp *__restrict __a, const ::std::size_t *__restrict __i, _Tp *__restrict __o, ::std::size_t __n);
  template < typename _Tp >
  inline void __valarray_copy_construct(const _Tp *__restrict __a, const ::std::size_t *__restrict __i, _Tp *__restrict __o, ::std::size_t __n)
  {
    if (__is_trivial(_Tp))
      {
        while (__n--)
          {
            *__o++ = __a[*__i++];
          }
      }
    else
      {
        while (__n--)
          {
            new (__o++)_Tp(__a[*__i++]);
          }
      }
  }
  template < typename _Tp >
  inline void __valarray_destroy_elements(_Tp *__b, _Tp *__e);
  template < typename _Tp >
  inline void __valarray_destroy_elements(_Tp *__b, _Tp *__e)
  {
    if (!(__is_trivial(_Tp)))
      {
        while (__b != __e)
          {
            __b->~_Tp();
             ++__b;
          }
      }
  }
  template < typename _Tp >
  inline void __valarray_fill(_Tp *__restrict __a, ::std::size_t __n, const _Tp &__t);
  template < typename _Tp >
  inline void __valarray_fill(_Tp *__restrict __a, ::std::size_t __n, const _Tp &__t)
  {
    while (__n--)
      {
        *__a++ = __t;
      }
  }
  template < typename _Tp >
  inline void __valarray_fill(_Tp *__restrict __a, ::std::size_t __n, ::std::size_t __s, const _Tp &__t);
  template < typename _Tp >
  inline void __valarray_fill(_Tp *__restrict __a, ::std::size_t __n, ::std::size_t __s, const _Tp &__t)
  {
    for (::std::size_t __i(0); __i < __n; ( ++__i, __a += __s))
      {
        *__a = __t;
      }
  }
  template < typename _Tp >
  inline void __valarray_fill(_Tp *__restrict __a, const ::std::size_t *__restrict __i, ::std::size_t __n, const _Tp &__t);
  template < typename _Tp >
  inline void __valarray_fill(_Tp *__restrict __a, const ::std::size_t *__restrict __i, ::std::size_t __n, const _Tp &__t)
  {
    for (::std::size_t __j(0); __j < __n; ( ++__j,  ++__i))
      {
        __a[*__i] = __t;
      }
  }
  template < typename _Tp, bool __nontype_tpl_param_1_1__ >
  struct  _Array_copier
  {
      static inline void _S_do_it(const _Tp *__restrict __a, ::std::size_t __n, _Tp *__restrict __b)
      {
        while (__n--)
          {
            *__b++ = *__a++;
          }
      }
  };
  template < typename _Tp >
  struct  _Array_copier<_Tp, true>
  {
      static inline void _S_do_it(const _Tp *__restrict __a, ::std::size_t __n, _Tp *__restrict __b)
      {
        __builtin_memcpy(__b, __a, __n * sizeof(_Tp));
      }
  };
  template < typename _Tp >
  inline void __valarray_copy(const _Tp *__restrict __a, ::std::size_t __n, _Tp *__restrict __b);
  template < typename _Tp >
  inline void __valarray_copy(const _Tp *__restrict __a, ::std::size_t __n, _Tp *__restrict __b)
  {
    _Array_copier<_Tp, __is_trivial(_Tp)>::_S_do_it(__a, __n, __b);
  }
  template < typename _Tp >
  inline void __valarray_copy(const _Tp *__restrict __a, ::std::size_t __n, ::std::size_t __s, _Tp *__restrict __b);
  template < typename _Tp >
  inline void __valarray_copy(const _Tp *__restrict __a, ::std::size_t __n, ::std::size_t __s, _Tp *__restrict __b)
  {
    for (::std::size_t __i(0); __i < __n; ((( ++__i,  ++__b)), __a += __s))
      {
        *__b = *__a;
      }
  }
  template < typename _Tp >
  inline void __valarray_copy(const _Tp *__restrict __a, _Tp *__restrict __b, ::std::size_t __n, ::std::size_t __s);
  template < typename _Tp >
  inline void __valarray_copy(const _Tp *__restrict __a, _Tp *__restrict __b, ::std::size_t __n, ::std::size_t __s)
  {
    for (::std::size_t __i(0); __i < __n; ((( ++__i,  ++__a)), __b += __s))
      {
        *__b = *__a;
      }
  }
  template < typename _Tp >
  inline void __valarray_copy(const _Tp *__restrict __src, ::std::size_t __n, ::std::size_t __s1, _Tp *__restrict __dst, ::std::size_t __s2);
  template < typename _Tp >
  inline void __valarray_copy(const _Tp *__restrict __src, ::std::size_t __n, ::std::size_t __s1, _Tp *__restrict __dst, ::std::size_t __s2)
  {
    for (::std::size_t __i(0); __i < __n;  ++__i)
      {
        __dst[__i * __s2] = __src[__i * __s1];
      }
  }
  template < typename _Tp >
  inline void __valarray_copy(const _Tp *__restrict __a, const ::std::size_t *__restrict __i, _Tp *__restrict __b, ::std::size_t __n);
  template < typename _Tp >
  inline void __valarray_copy(const _Tp *__restrict __a, const ::std::size_t *__restrict __i, _Tp *__restrict __b, ::std::size_t __n)
  {
    for (::std::size_t __j(0); __j < __n; ((( ++__j,  ++__b)),  ++__i))
      {
        *__b = __a[*__i];
      }
  }
  template < typename _Tp >
  inline void __valarray_copy(const _Tp *__restrict __a, ::std::size_t __n, _Tp *__restrict __b, const ::std::size_t *__restrict __i);
  template < typename _Tp >
  inline void __valarray_copy(const _Tp *__restrict __a, ::std::size_t __n, _Tp *__restrict __b, const ::std::size_t *__restrict __i)
  {
    for (::std::size_t __j(0); __j < __n; ((( ++__j,  ++__a)),  ++__i))
      {
        __b[*__i] = *__a;
      }
  }
  template < typename _Tp >
  inline void __valarray_copy(const _Tp *__restrict __src, ::std::size_t __n, const ::std::size_t *__restrict __i, _Tp *__restrict __dst, const ::std::size_t *__restrict __j);
  template < typename _Tp >
  inline void __valarray_copy(const _Tp *__restrict __src, ::std::size_t __n, const ::std::size_t *__restrict __i, _Tp *__restrict __dst, const ::std::size_t *__restrict __j)
  {
    for (::std::size_t __k(0); __k < __n;  ++__k)
      {
        __dst[*__j++] = __src[*__i++];
      }
  }
  template < typename _Tp >
  inline _Tp __valarray_sum(const _Tp *__f, const _Tp *__l);
  template < typename _Tp >
  inline _Tp __valarray_sum(const _Tp *__f, const _Tp *__l)
  {
    _Tp __r = _Tp();
    while (__f != __l)
      {
        __r += *__f++;
      }
    return __r;
  }
  template < typename _Tp >
  inline _Tp __valarray_product(const _Tp *__f, const _Tp *__l);
  template < typename _Tp >
  inline _Tp __valarray_product(const _Tp *__f, const _Tp *__l)
  {
    _Tp __r = _Tp(1);
    while (__f != __l)
      {
        __r = __r * *__f++;
      }
    return __r;
  }
  template < typename _Ta >
  inline typename _Ta::value_type __valarray_min(const _Ta &__a);
  template < typename _Ta >
  inline typename _Ta::value_type __valarray_min(const _Ta &__a)
  {
    ::std::size_t __s = __a.size();
    typedef typename _Ta::value_type _Value_type;
    _Value_type __r = __s == 0 ? _Value_type() : __a[0];
    for (::std::size_t __i(1); __i < __s;  ++__i)
      {
        _Value_type __t = __a[__i];
        if (__t < __r)
          {
            __r = __t;
          }
      }
    return __r;
  }
  template < typename _Ta >
  inline typename _Ta::value_type __valarray_max(const _Ta &__a);
  template < typename _Ta >
  inline typename _Ta::value_type __valarray_max(const _Ta &__a)
  {
    ::std::size_t __s = __a.size();
    typedef typename _Ta::value_type _Value_type;
    _Value_type __r = __s == 0 ? _Value_type() : __a[0];
    for (::std::size_t __i(1); __i < __s;  ++__i)
      {
        _Value_type __t = __a[__i];
        if (__t > __r)
          {
            __r = __t;
          }
      }
    return __r;
  }
  template < typename _Tp >
  struct  _Array
  {
      inline explicit _Array(::std::size_t __n);
      inline explicit _Array(_Tp *const __restrict __p);
      inline explicit _Array(const ::std::valarray<_Tp> &__v);
      inline _Array(const _Tp *__restrict __b, ::std::size_t __s);
      inline _Tp *begin() const ;
      _Tp *const __restrict _M_data;
  };
 /* Instantiation of class template '::std::_Array<unsigned long int>' */ 
  template < typename _Tp >
  inline void __valarray_copy_construct(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  inline void __valarray_copy_construct(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    std::__valarray_copy_construct(__a._M_data, __i._M_data, __b._M_data, __n);
  }
  template < typename _Tp >
  inline void __valarray_copy_construct(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void __valarray_copy_construct(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b)
  {
    std::__valarray_copy_construct(__a._M_data, __n, __s, __b._M_data);
  }
  template < typename _Tp >
  inline void __valarray_fill(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t);
  template < typename _Tp >
  inline void __valarray_fill(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t)
  {
    std::__valarray_fill(__a._M_data, __n, __t);
  }
  template < typename _Tp >
  inline void __valarray_fill(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, const _Tp &__t);
  template < typename _Tp >
  inline void __valarray_fill(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, const _Tp &__t)
  {
    std::__valarray_fill(__a._M_data, __n, __s, __t);
  }
  template < typename _Tp >
  inline void __valarray_fill(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::size_t __n, const _Tp &__t);
  template < typename _Tp >
  inline void __valarray_fill(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::size_t __n, const _Tp &__t)
  {
    std::__valarray_fill(__a._M_data, __i._M_data, __n, __t);
  }
  template < typename _Tp >
  inline void __valarray_copy(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void __valarray_copy(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b)
  {
    std::__valarray_copy(__a._M_data, __n, __b._M_data);
  }
  template < typename _Tp >
  inline void __valarray_copy(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void __valarray_copy(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b)
  {
    std::__valarray_copy(__a._M_data, __n, __s, __b._M_data);
  }
  template < typename _Tp >
  inline void __valarray_copy(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s);
  template < typename _Tp >
  inline void __valarray_copy(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s)
  {
    __valarray_copy(__a._M_data, __b._M_data, __n, __s);
  }
  template < typename _Tp >
  inline void __valarray_copy(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s1, ::std::_Array<_Tp> __b, ::std::size_t __s2);
  template < typename _Tp >
  inline void __valarray_copy(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s1, ::std::_Array<_Tp> __b, ::std::size_t __s2)
  {
    std::__valarray_copy(__a._M_data, __n, __s1, __b._M_data, __s2);
  }
  template < typename _Tp >
  inline void __valarray_copy(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  inline void __valarray_copy(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    std::__valarray_copy(__a._M_data, __i._M_data, __b._M_data, __n);
  }
  template < typename _Tp >
  inline void __valarray_copy(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i);
  template < typename _Tp >
  inline void __valarray_copy(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i)
  {
    std::__valarray_copy(__a._M_data, __n, __b._M_data, __i._M_data);
  }
  template < typename _Tp >
  inline void __valarray_copy(::std::_Array<_Tp> __src, ::std::size_t __n, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __dst, ::std::_Array<unsigned long int> __j);
  template < typename _Tp >
  inline void __valarray_copy(::std::_Array<_Tp> __src, ::std::size_t __n, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __dst, ::std::_Array<unsigned long int> __j)
  {
    std::__valarray_copy(__src._M_data, __n, __i._M_data, __dst._M_data, __j._M_data);
  }
  template < typename _Tp >
  inline _Array<_Tp>::_Array(::std::size_t __n)
    : _M_data(__valarray_get_storage<_Tp>(__n))
  {
    std::__valarray_default_construct(::std::_Array<_Tp>::_M_data, ::std::_Array<_Tp>::_M_data + __n);
  }
  template < typename _Tp >
  inline _Array<_Tp>::_Array(_Tp *const __restrict __p)
    : _M_data(__p)
  {
  }
  template < typename _Tp >
  inline _Array<_Tp>::_Array(const ::std::valarray<_Tp> &__v)
    : _M_data(__v._M_data)
  {
  }
  template < typename _Tp >
  inline _Array<_Tp>::_Array(const _Tp *__restrict __b, ::std::size_t __s)
    : _M_data(__valarray_get_storage<_Tp>(__s))
  {
    std::__valarray_copy_construct(__b, __s, ::std::_Array<_Tp>::_M_data);
  }
  template < typename _Tp >
  inline _Tp *_Array<_Tp>::begin() const 
  {
    return ::std::_Array<_Tp>::_M_data;
  }
  template < typename _Tp >
  inline void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t);
  template < typename _Tp >
  inline void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t)
  {
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n;  ++__p)
      {
        *__p += __t;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b)
  {
    _Tp *__p = __a._M_data;
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ( ++__p,  ++__q))
      {
        *__p += *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___plus(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___plus(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i,  ++__p))
      {
        *__p += __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __s * __n; (__p += __s,  ++__q))
      {
        *__p += *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s);
  template < typename _Tp >
  inline void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ( ++__p, __q += __s))
      {
        *__p += *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i, __p += __s))
      {
        *__p += __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  inline void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    _Tp *__q(__b._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__q))
      {
        __a._M_data[*__j] += *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i);
  template < typename _Tp >
  inline void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__p))
      {
        *__p += __b._M_data[*__j];
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    ::std::size_t *__j(__i._M_data);
    for (::std::size_t __k(0); __k < __n; ( ++__k,  ++__j))
      {
        __a._M_data[*__j] += __e[__k];
      }
  }
 /* Instantiation of class template '::std::_Array<bool>' */ 
  template < typename _Tp >
  void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ((( ++__q,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p += *__q;
      }
  }
  template < typename _Tp >
  void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m);
  template < typename _Tp >
  void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m)
  {
    bool *__ok(__m._M_data);
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ((( ++__p,  ++__ok)),  ++__q))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__q;
          }
        *__p += *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___plus(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ((( ++__i,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p += __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t);
  template < typename _Tp >
  inline void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t)
  {
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n;  ++__p)
      {
        *__p -= __t;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b)
  {
    _Tp *__p = __a._M_data;
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ( ++__p,  ++__q))
      {
        *__p -= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___minus(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___minus(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i,  ++__p))
      {
        *__p -= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __s * __n; (__p += __s,  ++__q))
      {
        *__p -= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s);
  template < typename _Tp >
  inline void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ( ++__p, __q += __s))
      {
        *__p -= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i, __p += __s))
      {
        *__p -= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  inline void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    _Tp *__q(__b._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__q))
      {
        __a._M_data[*__j] -= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i);
  template < typename _Tp >
  inline void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__p))
      {
        *__p -= __b._M_data[*__j];
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    ::std::size_t *__j(__i._M_data);
    for (::std::size_t __k(0); __k < __n; ( ++__k,  ++__j))
      {
        __a._M_data[*__j] -= __e[__k];
      }
  }
  template < typename _Tp >
  void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ((( ++__q,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p -= *__q;
      }
  }
  template < typename _Tp >
  void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m);
  template < typename _Tp >
  void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m)
  {
    bool *__ok(__m._M_data);
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ((( ++__p,  ++__ok)),  ++__q))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__q;
          }
        *__p -= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___minus(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ((( ++__i,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p -= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t);
  template < typename _Tp >
  inline void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t)
  {
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n;  ++__p)
      {
        *__p *= __t;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b)
  {
    _Tp *__p = __a._M_data;
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ( ++__p,  ++__q))
      {
        *__p *= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___multiplies(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___multiplies(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i,  ++__p))
      {
        *__p *= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __s * __n; (__p += __s,  ++__q))
      {
        *__p *= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s);
  template < typename _Tp >
  inline void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ( ++__p, __q += __s))
      {
        *__p *= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i, __p += __s))
      {
        *__p *= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  inline void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    _Tp *__q(__b._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__q))
      {
        __a._M_data[*__j] *= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i);
  template < typename _Tp >
  inline void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__p))
      {
        *__p *= __b._M_data[*__j];
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    ::std::size_t *__j(__i._M_data);
    for (::std::size_t __k(0); __k < __n; ( ++__k,  ++__j))
      {
        __a._M_data[*__j] *= __e[__k];
      }
  }
  template < typename _Tp >
  void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ((( ++__q,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p *= *__q;
      }
  }
  template < typename _Tp >
  void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m);
  template < typename _Tp >
  void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m)
  {
    bool *__ok(__m._M_data);
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ((( ++__p,  ++__ok)),  ++__q))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__q;
          }
        *__p *= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___multiplies(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ((( ++__i,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p *= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t);
  template < typename _Tp >
  inline void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t)
  {
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n;  ++__p)
      {
        *__p /= __t;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b)
  {
    _Tp *__p = __a._M_data;
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ( ++__p,  ++__q))
      {
        *__p /= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___divides(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___divides(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i,  ++__p))
      {
        *__p /= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __s * __n; (__p += __s,  ++__q))
      {
        *__p /= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s);
  template < typename _Tp >
  inline void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ( ++__p, __q += __s))
      {
        *__p /= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i, __p += __s))
      {
        *__p /= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  inline void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    _Tp *__q(__b._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__q))
      {
        __a._M_data[*__j] /= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i);
  template < typename _Tp >
  inline void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__p))
      {
        *__p /= __b._M_data[*__j];
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    ::std::size_t *__j(__i._M_data);
    for (::std::size_t __k(0); __k < __n; ( ++__k,  ++__j))
      {
        __a._M_data[*__j] /= __e[__k];
      }
  }
  template < typename _Tp >
  void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ((( ++__q,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p /= *__q;
      }
  }
  template < typename _Tp >
  void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m);
  template < typename _Tp >
  void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m)
  {
    bool *__ok(__m._M_data);
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ((( ++__p,  ++__ok)),  ++__q))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__q;
          }
        *__p /= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___divides(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ((( ++__i,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p /= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t);
  template < typename _Tp >
  inline void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t)
  {
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n;  ++__p)
      {
        *__p %= __t;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b)
  {
    _Tp *__p = __a._M_data;
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ( ++__p,  ++__q))
      {
        *__p %= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___modulus(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___modulus(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i,  ++__p))
      {
        *__p %= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __s * __n; (__p += __s,  ++__q))
      {
        *__p %= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s);
  template < typename _Tp >
  inline void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ( ++__p, __q += __s))
      {
        *__p %= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i, __p += __s))
      {
        *__p %= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  inline void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    _Tp *__q(__b._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__q))
      {
        __a._M_data[*__j] %= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i);
  template < typename _Tp >
  inline void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__p))
      {
        *__p %= __b._M_data[*__j];
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    ::std::size_t *__j(__i._M_data);
    for (::std::size_t __k(0); __k < __n; ( ++__k,  ++__j))
      {
        __a._M_data[*__j] %= __e[__k];
      }
  }
  template < typename _Tp >
  void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ((( ++__q,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p %= *__q;
      }
  }
  template < typename _Tp >
  void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m);
  template < typename _Tp >
  void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m)
  {
    bool *__ok(__m._M_data);
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ((( ++__p,  ++__ok)),  ++__q))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__q;
          }
        *__p %= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___modulus(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ((( ++__i,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p %= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t)
  {
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n;  ++__p)
      {
        *__p ^= __t;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b)
  {
    _Tp *__p = __a._M_data;
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ( ++__p,  ++__q))
      {
        *__p ^= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i,  ++__p))
      {
        *__p ^= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __s * __n; (__p += __s,  ++__q))
      {
        *__p ^= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ( ++__p, __q += __s))
      {
        *__p ^= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i, __p += __s))
      {
        *__p ^= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    _Tp *__q(__b._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__q))
      {
        __a._M_data[*__j] ^= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__p))
      {
        *__p ^= __b._M_data[*__j];
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    ::std::size_t *__j(__i._M_data);
    for (::std::size_t __k(0); __k < __n; ( ++__k,  ++__j))
      {
        __a._M_data[*__j] ^= __e[__k];
      }
  }
  template < typename _Tp >
  void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ((( ++__q,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p ^= *__q;
      }
  }
  template < typename _Tp >
  void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m);
  template < typename _Tp >
  void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m)
  {
    bool *__ok(__m._M_data);
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ((( ++__p,  ++__ok)),  ++__q))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__q;
          }
        *__p ^= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_xor(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ((( ++__i,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p ^= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t)
  {
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n;  ++__p)
      {
        *__p |= __t;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b)
  {
    _Tp *__p = __a._M_data;
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ( ++__p,  ++__q))
      {
        *__p |= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i,  ++__p))
      {
        *__p |= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __s * __n; (__p += __s,  ++__q))
      {
        *__p |= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ( ++__p, __q += __s))
      {
        *__p |= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i, __p += __s))
      {
        *__p |= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    _Tp *__q(__b._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__q))
      {
        __a._M_data[*__j] |= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__p))
      {
        *__p |= __b._M_data[*__j];
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    ::std::size_t *__j(__i._M_data);
    for (::std::size_t __k(0); __k < __n; ( ++__k,  ++__j))
      {
        __a._M_data[*__j] |= __e[__k];
      }
  }
  template < typename _Tp >
  void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ((( ++__q,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p |= *__q;
      }
  }
  template < typename _Tp >
  void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m);
  template < typename _Tp >
  void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m)
  {
    bool *__ok(__m._M_data);
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ((( ++__p,  ++__ok)),  ++__q))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__q;
          }
        *__p |= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_or(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ((( ++__i,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p |= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t)
  {
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n;  ++__p)
      {
        *__p &= __t;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b)
  {
    _Tp *__p = __a._M_data;
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ( ++__p,  ++__q))
      {
        *__p &= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i,  ++__p))
      {
        *__p &= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __s * __n; (__p += __s,  ++__q))
      {
        *__p &= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ( ++__p, __q += __s))
      {
        *__p &= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i, __p += __s))
      {
        *__p &= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    _Tp *__q(__b._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__q))
      {
        __a._M_data[*__j] &= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i);
  template < typename _Tp >
  inline void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__p))
      {
        *__p &= __b._M_data[*__j];
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    ::std::size_t *__j(__i._M_data);
    for (::std::size_t __k(0); __k < __n; ( ++__k,  ++__j))
      {
        __a._M_data[*__j] &= __e[__k];
      }
  }
  template < typename _Tp >
  void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ((( ++__q,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p &= *__q;
      }
  }
  template < typename _Tp >
  void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m);
  template < typename _Tp >
  void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m)
  {
    bool *__ok(__m._M_data);
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ((( ++__p,  ++__ok)),  ++__q))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__q;
          }
        *__p &= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___bitwise_and(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ((( ++__i,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p &= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t);
  template < typename _Tp >
  inline void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t)
  {
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n;  ++__p)
      {
        *__p <<= __t;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b)
  {
    _Tp *__p = __a._M_data;
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ( ++__p,  ++__q))
      {
        *__p <<= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_left(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_left(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i,  ++__p))
      {
        *__p <<= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __s * __n; (__p += __s,  ++__q))
      {
        *__p <<= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s);
  template < typename _Tp >
  inline void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ( ++__p, __q += __s))
      {
        *__p <<= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i, __p += __s))
      {
        *__p <<= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  inline void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    _Tp *__q(__b._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__q))
      {
        __a._M_data[*__j] <<= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i);
  template < typename _Tp >
  inline void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__p))
      {
        *__p <<= __b._M_data[*__j];
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    ::std::size_t *__j(__i._M_data);
    for (::std::size_t __k(0); __k < __n; ( ++__k,  ++__j))
      {
        __a._M_data[*__j] <<= __e[__k];
      }
  }
  template < typename _Tp >
  void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ((( ++__q,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p <<= *__q;
      }
  }
  template < typename _Tp >
  void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m);
  template < typename _Tp >
  void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m)
  {
    bool *__ok(__m._M_data);
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ((( ++__p,  ++__ok)),  ++__q))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__q;
          }
        *__p <<= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_left(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ((( ++__i,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p <<= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t);
  template < typename _Tp >
  inline void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::size_t __n, const _Tp &__t)
  {
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n;  ++__p)
      {
        *__p >>= __t;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b)
  {
    _Tp *__p = __a._M_data;
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ( ++__p,  ++__q))
      {
        *__p >>= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_right(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_right(::std::_Array<_Tp> __a, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i,  ++__p))
      {
        *__p >>= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b);
  template < typename _Tp >
  inline void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::size_t __s, ::std::_Array<_Tp> __b)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __s * __n; (__p += __s,  ++__q))
      {
        *__p >>= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s);
  template < typename _Tp >
  inline void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::_Array<_Tp> __b, ::std::size_t __n, ::std::size_t __s)
  {
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ( ++__p, __q += __s))
      {
        *__p >>= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::size_t __s, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i, __p += __s))
      {
        *__p >>= __e[__i];
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  inline void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    _Tp *__q(__b._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__q))
      {
        __a._M_data[*__j] >>= *__q;
      }
  }
  template < typename _Tp >
  inline void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i);
  template < typename _Tp >
  inline void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<unsigned long int> __i)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t *__j(__i._M_data); __j < __i._M_data + __n; ( ++__j,  ++__p))
      {
        *__p >>= __b._M_data[*__j];
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    ::std::size_t *__j(__i._M_data);
    for (::std::size_t __k(0); __k < __n; ( ++__k,  ++__j))
      {
        __a._M_data[*__j] >>= __e[__k];
      }
  }
  template < typename _Tp >
  void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ((( ++__q,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p >>= *__q;
      }
  }
  template < typename _Tp >
  void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m);
  template < typename _Tp >
  void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m)
  {
    bool *__ok(__m._M_data);
    _Tp *__q(__b._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ((( ++__p,  ++__ok)),  ++__q))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__q;
          }
        *__p >>= *__q;
      }
  }
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n);
  template < typename _Tp, typename _Dom >
  void _Array_augmented___shift_right(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ((( ++__i,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p >>= __e[__i];
      }
  }
  template < typename _Tp >
  void __valarray_fill(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<bool> __m, const _Tp &__t);
  template < typename _Tp >
  void __valarray_fill(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<bool> __m, const _Tp &__t)
  {
    _Tp *__p = __a._M_data;
    bool *__ok(__m._M_data);
    for (::std::size_t __i(0); __i < __n; ((( ++__i,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p = __t;
      }
  }
  template < typename _Tp >
  void __valarray_copy(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  void __valarray_copy(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    bool *__ok(__m._M_data);
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ((( ++__q,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__q = *__p;
      }
  }
  template < typename _Tp >
  void __valarray_copy(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m);
  template < typename _Tp >
  void __valarray_copy(::std::_Array<_Tp> __a, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __m)
  {
    _Tp *__q(__b._M_data);
    bool *__ok(__m._M_data);
    for (_Tp *__p = __a._M_data; __p < __a._M_data + __n; ((( ++__p,  ++__ok)),  ++__q))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__q;
          }
        *__q = *__p;
      }
  }
  template < typename _Tp >
  void __valarray_copy(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __k);
  template < typename _Tp >
  void __valarray_copy(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::size_t __n, ::std::_Array<_Tp> __b, ::std::_Array<bool> __k)
  {
    _Tp *__p(__a._M_data);
    _Tp *__q(__b._M_data);
    bool *__srcok(__m._M_data);
    bool *__dstok(__k._M_data);
    for (::std::size_t __i(0); __i < __n; ((((((( ++__srcok,  ++__p)),  ++__dstok)),  ++__q)),  ++__i))
      {
        while (!*__srcok)
          {
             ++__srcok;
             ++__p;
          }
        while (!*__dstok)
          {
             ++__dstok;
             ++__q;
          }
        *__q = *__p;
      }
  }
  template < typename _Tp, typename _Dom >
  void __valarray_copy(const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n, ::std::_Array<_Tp> __a);
  template < typename _Tp, typename _Dom >
  void __valarray_copy(const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n, ::std::_Array<_Tp> __a)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i,  ++__p))
      {
        *__p = __e[__i];
      }
  }
  template < typename _Tp, typename _Dom >
  void __valarray_copy(const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n, ::std::_Array<_Tp> __a, ::std::size_t __s);
  template < typename _Tp, typename _Dom >
  void __valarray_copy(const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n, ::std::_Array<_Tp> __a, ::std::size_t __s)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i, __p += __s))
      {
        *__p = __e[__i];
      }
  }
  template < typename _Tp, typename _Dom >
  void __valarray_copy(const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n, ::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i);
  template < typename _Tp, typename _Dom >
  void __valarray_copy(const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n, ::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i)
  {
    ::std::size_t *__j(__i._M_data);
    for (::std::size_t __k(0); __k < __n; ( ++__k,  ++__j))
      {
        __a._M_data[*__j] = __e[__k];
      }
  }
  template < typename _Tp >
  void __valarray_copy(::std::_Array<_Tp> __e, ::std::_Array<unsigned long int> __f, ::std::size_t __n, ::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i);
  template < typename _Tp >
  void __valarray_copy(::std::_Array<_Tp> __e, ::std::_Array<unsigned long int> __f, ::std::size_t __n, ::std::_Array<_Tp> __a, ::std::_Array<unsigned long int> __i)
  {
    ::std::size_t *__g(__f._M_data);
    ::std::size_t *__j(__i._M_data);
    for (::std::size_t __k(0); __k < __n; ((( ++__k,  ++__j)),  ++__g))
      {
        __a._M_data[*__j] = __e._M_data[*__g];
      }
  }
  template < typename _Tp, typename _Dom >
  void __valarray_copy(const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n, ::std::_Array<_Tp> __a, ::std::_Array<bool> __m);
  template < typename _Tp, typename _Dom >
  void __valarray_copy(const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n, ::std::_Array<_Tp> __a, ::std::_Array<bool> __m)
  {
    bool *__ok(__m._M_data);
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ((( ++__i,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        *__p = __e[__i];
      }
  }
  template < typename _Tp, typename _Dom >
  void __valarray_copy_construct(const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n, ::std::_Array<_Tp> __a);
  template < typename _Tp, typename _Dom >
  void __valarray_copy_construct(const ::std::_Expr<_Dom, _Tp> &__e, ::std::size_t __n, ::std::_Array<_Tp> __a)
  {
    _Tp *__p(__a._M_data);
    for (::std::size_t __i(0); __i < __n; ( ++__i,  ++__p))
      {
        new (__p)_Tp(__e[__i]);
      }
  }
  template < typename _Tp >
  void __valarray_copy_construct(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n);
  template < typename _Tp >
  void __valarray_copy_construct(::std::_Array<_Tp> __a, ::std::_Array<bool> __m, ::std::_Array<_Tp> __b, ::std::size_t __n)
  {
    _Tp *__p(__a._M_data);
    bool *__ok(__m._M_data);
    for (_Tp *__q = __b._M_data; __q < __b._M_data + __n; ((( ++__q,  ++__ok)),  ++__p))
      {
        while (!*__ok)
          {
             ++__ok;
             ++__p;
          }
        new (__q)_Tp(*__p);
      }
  }
  class  slice
  {
    public:
      inline slice();
      inline slice(::std::size_t __o, ::std::size_t __d, ::std::size_t __s);
      inline ::std::size_t start() const ;
      inline ::std::size_t size() const ;
      inline ::std::size_t stride() const ;
    private:
      ::std::size_t _M_off;
      ::std::size_t _M_sz;
      ::std::size_t _M_st;
    public:
  };
  inline slice::slice()
    : _M_off(0), _M_sz(0), _M_st(0)
  {
  }
  inline slice::slice(::std::size_t __o, ::std::size_t __d, ::std::size_t __s)
    : _M_off(__o), _M_sz(__d), _M_st(__s)
  {
  }
  inline ::std::size_t slice::start() const 
  {
    return (*this)._M_off;
  }
  inline ::std::size_t slice::size() const 
  {
    return (*this)._M_sz;
  }
  inline ::std::size_t slice::stride() const 
  {
    return (*this)._M_st;
  }
  template < typename _Tp >
  class  slice_array
  {
    public:
      typedef _Tp value_type;
      inline slice_array(const ::std::slice_array<_Tp> &a);
      inline ::std::slice_array<_Tp> &operator =(const ::std::slice_array<_Tp> &__a);
      inline void operator =(const ::std::valarray<_Tp> &__v) const ;
      inline void operator *=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator /=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator %=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator +=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator -=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator ^=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator &=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator |=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator <<=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator >>=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator =(const _Tp &__t) const ;
      template < typename _Dom >
      inline void operator =(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator *=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator /=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator %=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator +=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator -=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator ^=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator &=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator |=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator <<=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator >>=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
    private:
      inline slice_array(::std::_Array<_Tp> __a, const ::std::slice &__s);
      const ::std::size_t _M_sz;
      const ::std::size_t _M_stride;
      const ::std::_Array<_Tp> _M_array;
      slice_array();
    friend class ::std::valarray<_Tp>;
  };
  template < typename _Tp >
  inline slice_array<_Tp>::slice_array(::std::_Array<_Tp> __a, const ::std::slice &__s)
    : _M_sz(__s.::std::slice::size()), _M_stride(__s.::std::slice::stride()), _M_array(__a.begin() + __s.::std::slice::start())
  {
  }
  template < typename _Tp >
  inline slice_array<_Tp>::slice_array(const ::std::slice_array<_Tp> &a)
    : _M_sz(a._M_sz), _M_stride(a._M_stride), _M_array(a._M_array)
  {
  }
  template < typename _Tp >
  inline ::std::slice_array<_Tp> &slice_array<_Tp>::operator =(const ::std::slice_array<_Tp> &__a)
  {
    std::__valarray_copy(__a._M_array, __a._M_sz, __a._M_stride, ::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_stride);
    return *this;
  }
  template < typename _Tp >
  inline void slice_array<_Tp>::operator =(const _Tp &__t) const 
  {
    std::__valarray_fill(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_sz, ::std::slice_array<_Tp>::_M_stride, __t);
  }
  template < typename _Tp >
  inline void slice_array<_Tp>::operator =(const ::std::valarray<_Tp> &__v) const 
  {
    std::__valarray_copy(::std::_Array<_Tp>(__v), ::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_sz, ::std::slice_array<_Tp>::_M_stride);
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void slice_array<_Tp>::operator =(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    std::__valarray_copy(__e, ::std::slice_array<_Tp>::_M_sz, ::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_stride);
  }
  template < typename _Tp >
  inline void slice_array<_Tp>::operator *=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___multiplies(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_sz, ::std::slice_array<_Tp>::_M_stride, ::std::_Array<_Tp>(__v));
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void slice_array<_Tp>::operator *=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___multiplies(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_stride, __e, ::std::slice_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void slice_array<_Tp>::operator /=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___divides(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_sz, ::std::slice_array<_Tp>::_M_stride, ::std::_Array<_Tp>(__v));
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void slice_array<_Tp>::operator /=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___divides(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_stride, __e, ::std::slice_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void slice_array<_Tp>::operator %=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___modulus(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_sz, ::std::slice_array<_Tp>::_M_stride, ::std::_Array<_Tp>(__v));
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void slice_array<_Tp>::operator %=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___modulus(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_stride, __e, ::std::slice_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void slice_array<_Tp>::operator +=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___plus(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_sz, ::std::slice_array<_Tp>::_M_stride, ::std::_Array<_Tp>(__v));
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void slice_array<_Tp>::operator +=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___plus(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_stride, __e, ::std::slice_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void slice_array<_Tp>::operator -=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___minus(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_sz, ::std::slice_array<_Tp>::_M_stride, ::std::_Array<_Tp>(__v));
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void slice_array<_Tp>::operator -=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___minus(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_stride, __e, ::std::slice_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void slice_array<_Tp>::operator ^=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___bitwise_xor(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_sz, ::std::slice_array<_Tp>::_M_stride, ::std::_Array<_Tp>(__v));
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void slice_array<_Tp>::operator ^=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___bitwise_xor(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_stride, __e, ::std::slice_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void slice_array<_Tp>::operator &=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___bitwise_and(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_sz, ::std::slice_array<_Tp>::_M_stride, ::std::_Array<_Tp>(__v));
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void slice_array<_Tp>::operator &=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___bitwise_and(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_stride, __e, ::std::slice_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void slice_array<_Tp>::operator |=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___bitwise_or(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_sz, ::std::slice_array<_Tp>::_M_stride, ::std::_Array<_Tp>(__v));
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void slice_array<_Tp>::operator |=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___bitwise_or(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_stride, __e, ::std::slice_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void slice_array<_Tp>::operator <<=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___shift_left(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_sz, ::std::slice_array<_Tp>::_M_stride, ::std::_Array<_Tp>(__v));
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void slice_array<_Tp>::operator <<=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___shift_left(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_stride, __e, ::std::slice_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void slice_array<_Tp>::operator >>=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___shift_right(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_sz, ::std::slice_array<_Tp>::_M_stride, ::std::_Array<_Tp>(__v));
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void slice_array<_Tp>::operator >>=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___shift_right(::std::slice_array<_Tp>::_M_array, ::std::slice_array<_Tp>::_M_stride, __e, ::std::slice_array<_Tp>::_M_sz);
  }
  template < typename _Tp1, typename _Tp2 >
  class _Constant;
  struct  _Abs
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return abs(__t);
      }
  };
  struct  _Cos
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return cos(__t);
      }
  };
  struct  _Acos
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return acos(__t);
      }
  };
  struct  _Cosh
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return cosh(__t);
      }
  };
  struct  _Sin
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return sin(__t);
      }
  };
  struct  _Asin
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return asin(__t);
      }
  };
  struct  _Sinh
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return sinh(__t);
      }
  };
  struct  _Tan
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return tan(__t);
      }
  };
  struct  _Atan
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return atan(__t);
      }
  };
  struct  _Tanh
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return tanh(__t);
      }
  };
  struct  _Exp
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return exp(__t);
      }
  };
  struct  _Log
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return log(__t);
      }
  };
  struct  _Log10
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return log10(__t);
      }
  };
  struct  _Sqrt
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return sqrt(__t);
      }
  };
  struct  __unary_plus
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return  +__t;
      }
  };
  struct  __negate
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return  -__t;
      }
  };
  struct  __bitwise_not
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__t) const 
      {
        return ~__t;
      }
  };
  struct  __plus
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x + __y;
      }
  };
  struct  __minus
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x - __y;
      }
  };
  struct  __multiplies
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x * __y;
      }
  };
  struct  __divides
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x / __y;
      }
  };
  struct  __modulus
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x % __y;
      }
  };
  struct  __bitwise_xor
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x ^ __y;
      }
  };
  struct  __bitwise_and
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x & __y;
      }
  };
  struct  __bitwise_or
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x | __y;
      }
  };
  struct  __shift_left
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x << __y;
      }
  };
  struct  __shift_right
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x >> __y;
      }
  };
  struct  __logical_and
  {
      template < typename _Tp >
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x && __y;
      }
  };
  struct  __logical_or
  {
      template < typename _Tp >
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x || __y;
      }
  };
  struct  __logical_not
  {
      template < typename _Tp >
      inline bool operator ()(const _Tp &__x) const 
      {
        return !__x;
      }
  };
  struct  __equal_to
  {
      template < typename _Tp >
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x == __y;
      }
  };
  struct  __not_equal_to
  {
      template < typename _Tp >
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x != __y;
      }
  };
  struct  __less
  {
      template < typename _Tp >
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x < __y;
      }
  };
  struct  __greater
  {
      template < typename _Tp >
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x > __y;
      }
  };
  struct  __less_equal
  {
      template < typename _Tp >
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x <= __y;
      }
  };
  struct  __greater_equal
  {
      template < typename _Tp >
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x >= __y;
      }
  };
  struct  _Atan2
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return atan2(__x, __y);
      }
  };
  struct  _Pow
  {
      template < typename _Tp >
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return pow(__x, __y);
      }
  };
  template < typename __type_tpl__param_1_0__, typename _Tp >
  struct  __fun
  {
      typedef _Tp result_type;
  };
  template < typename _Tp >
  struct  __fun< ::std::__logical_not, _Tp>
  {
      typedef bool result_type;
  };
  template < typename _Tp >
  struct  __fun< ::std::__logical_and, _Tp>
  {
      typedef bool result_type;
  };
  template < typename _Tp >
  struct  __fun< ::std::__logical_or, _Tp>
  {
      typedef bool result_type;
  };
  template < typename _Tp >
  struct  __fun< ::std::__less, _Tp>
  {
      typedef bool result_type;
  };
  template < typename _Tp >
  struct  __fun< ::std::__greater, _Tp>
  {
      typedef bool result_type;
  };
  template < typename _Tp >
  struct  __fun< ::std::__less_equal, _Tp>
  {
      typedef bool result_type;
  };
  template < typename _Tp >
  struct  __fun< ::std::__greater_equal, _Tp>
  {
      typedef bool result_type;
  };
  template < typename _Tp >
  struct  __fun< ::std::__equal_to, _Tp>
  {
      typedef bool result_type;
  };
  template < typename _Tp >
  struct  __fun< ::std::__not_equal_to, _Tp>
  {
      typedef bool result_type;
  };
  template < typename _Dom, typename _Arg >
  class  _FunBase
  {
    public:
      typedef typename _Dom::value_type value_type;
      inline _FunBase(const _Dom &__e, typename ::std::_FunBase<_Dom, _Arg>::value_type (*__f)(_Arg))
        : _M_expr(__e), _M_func(__f)
      {
      }
      inline typename ::std::_FunBase<_Dom, _Arg>::value_type operator [](::std::size_t __i) const 
      {
        return ::std::_FunBase<_Dom, _Arg>::_M_func(::std::_FunBase<_Dom, _Arg>::_M_expr[__i]);
      }
      inline ::std::size_t size() const 
      {
        return ::std::_FunBase<_Dom, _Arg>::_M_expr.size();
      }
    private:
      const _Dom &_M_expr;
      typename ::std::_FunBase<_Dom, _Arg>::value_type (*_M_func)(_Arg);
  };
  template < typename _Dom >
  struct  _ValFunClos< ::std::_Expr, _Dom> : ::std::_FunBase<_Dom, typename _Dom::value_type>
  {
      typedef ::std::_FunBase<_Dom, typename _Dom::value_type> _Base;
      typedef typename ::std::_FunBase<_Dom, typename _Dom::value_type>::value_type value_type;
      typedef typename ::std::_ValFunClos< ::std::_Expr, _Dom>::value_type _Tp;
      inline _ValFunClos(const _Dom &__e, typename ::std::_ValFunClos< ::std::_Expr, _Dom>::_Tp (*__f)(typename ::std::_ValFunClos< ::std::_Expr, _Dom>::_Tp))
        : _Base(__e, __f)
      {
      }
  };
  template < typename _Tp >
  struct  _ValFunClos< ::std::_ValArray, _Tp> : ::std::_FunBase< ::std::valarray<_Tp>, _Tp>
  {
      typedef ::std::_FunBase< ::std::valarray<_Tp>, _Tp> _Base;
      typedef _Tp value_type;
      inline _ValFunClos(const ::std::valarray<_Tp> &__v, _Tp (*__f)(_Tp))
        : _Base(__v, __f)
      {
      }
  };
  template < typename _Dom >
  struct  _RefFunClos< ::std::_Expr, _Dom> : ::std::_FunBase<_Dom, const typename _Dom::value_type &>
  {
      typedef ::std::_FunBase<_Dom, const typename _Dom::value_type &> _Base;
      typedef typename ::std::_FunBase<_Dom, const typename _Dom::value_type &>::value_type value_type;
      typedef typename ::std::_RefFunClos< ::std::_Expr, _Dom>::value_type _Tp;
      inline _RefFunClos(const _Dom &__e, typename ::std::_RefFunClos< ::std::_Expr, _Dom>::_Tp (*__f)(const typename ::std::_RefFunClos< ::std::_Expr, _Dom>::_Tp &))
        : _Base(__e, __f)
      {
      }
  };
  template < typename _Tp >
  struct  _RefFunClos< ::std::_ValArray, _Tp> : ::std::_FunBase< ::std::valarray<_Tp>, const _Tp &>
  {
      typedef ::std::_FunBase< ::std::valarray<_Tp>, const _Tp &> _Base;
      typedef _Tp value_type;
      inline _RefFunClos(const ::std::valarray<_Tp> &__v, _Tp (*__f)(const _Tp &))
        : _Base(__v, __f)
      {
      }
  };
  template < typename _Oper, typename _Arg >
  class  _UnBase
  {
    public:
      typedef typename _Arg::value_type _Vt;
      typedef typename ::std::__fun<_Oper, typename ::std::_UnBase<_Oper, _Arg>::_Vt>::result_type value_type;
      inline _UnBase(const _Arg &__e)
        : _M_expr(__e)
      {
      }
      inline typename ::std::_UnBase<_Oper, _Arg>::value_type operator [](::std::size_t __i) const 
      {
        return _Oper()(::std::_UnBase<_Oper, _Arg>::_M_expr[__i]);
      }
      inline ::std::size_t size() const 
      {
        return ::std::_UnBase<_Oper, _Arg>::_M_expr.size();
      }
    private:
      const _Arg &_M_expr;
  };
  template < typename _Oper, typename _Dom >
  struct  _UnClos<_Oper, ::std::_Expr, _Dom> : ::std::_UnBase<_Oper, _Dom>
  {
      typedef _Dom _Arg;
      typedef ::std::_UnBase<_Oper, _Dom> _Base;
      typedef typename ::std::_UnBase<_Oper, _Dom>::value_type value_type;
      inline _UnClos(const typename ::std::_UnClos<_Oper, ::std::_Expr, _Dom>::_Arg &__e)
        : _Base(__e)
      {
      }
  };
  template < typename _Oper, typename _Tp >
  struct  _UnClos<_Oper, ::std::_ValArray, _Tp> : ::std::_UnBase<_Oper, ::std::valarray<_Tp> >
  {
      typedef ::std::valarray<_Tp> _Arg;
      typedef ::std::_UnBase<_Oper, ::std::valarray<_Tp> > _Base;
      typedef typename ::std::_UnBase<_Oper, ::std::valarray<_Tp> >::value_type value_type;
      inline _UnClos(const typename ::std::_UnClos<_Oper, ::std::_ValArray, _Tp>::_Arg &__e)
        : _Base(__e)
      {
      }
  };
  template < typename _Oper, typename _FirstArg, typename _SecondArg >
  class  _BinBase
  {
    public:
      typedef typename _FirstArg::value_type _Vt;
      typedef typename ::std::__fun<_Oper, typename ::std::_BinBase<_Oper, _FirstArg, _SecondArg>::_Vt>::result_type value_type;
      inline _BinBase(const _FirstArg &__e1, const _SecondArg &__e2)
        : _M_expr1(__e1), _M_expr2(__e2)
      {
      }
      inline typename ::std::_BinBase<_Oper, _FirstArg, _SecondArg>::value_type operator [](::std::size_t __i) const 
      {
        return _Oper()(::std::_BinBase<_Oper, _FirstArg, _SecondArg>::_M_expr1[__i], ::std::_BinBase<_Oper, _FirstArg, _SecondArg>::_M_expr2[__i]);
      }
      inline ::std::size_t size() const 
      {
        return ::std::_BinBase<_Oper, _FirstArg, _SecondArg>::_M_expr1.size();
      }
    private:
      const _FirstArg &_M_expr1;
      const _SecondArg &_M_expr2;
  };
  template < typename _Oper, typename _Clos >
  class  _BinBase2
  {
    public:
      typedef typename _Clos::value_type _Vt;
      typedef typename ::std::__fun<_Oper, typename ::std::_BinBase2<_Oper, _Clos>::_Vt>::result_type value_type;
      inline _BinBase2(const _Clos &__e, const typename ::std::_BinBase2<_Oper, _Clos>::_Vt &__t)
        : _M_expr1(__e), _M_expr2(__t)
      {
      }
      inline typename ::std::_BinBase2<_Oper, _Clos>::value_type operator [](::std::size_t __i) const 
      {
        return _Oper()(::std::_BinBase2<_Oper, _Clos>::_M_expr1[__i], ::std::_BinBase2<_Oper, _Clos>::_M_expr2);
      }
      inline ::std::size_t size() const 
      {
        return ::std::_BinBase2<_Oper, _Clos>::_M_expr1.size();
      }
    private:
      const _Clos &_M_expr1;
      const typename ::std::_BinBase2<_Oper, _Clos>::_Vt &_M_expr2;
  };
  template < typename _Oper, typename _Clos >
  class  _BinBase1
  {
    public:
      typedef typename _Clos::value_type _Vt;
      typedef typename ::std::__fun<_Oper, typename ::std::_BinBase1<_Oper, _Clos>::_Vt>::result_type value_type;
      inline _BinBase1(const typename ::std::_BinBase1<_Oper, _Clos>::_Vt &__t, const _Clos &__e)
        : _M_expr1(__t), _M_expr2(__e)
      {
      }
      inline typename ::std::_BinBase1<_Oper, _Clos>::value_type operator [](::std::size_t __i) const 
      {
        return _Oper()(::std::_BinBase1<_Oper, _Clos>::_M_expr1, ::std::_BinBase1<_Oper, _Clos>::_M_expr2[__i]);
      }
      inline ::std::size_t size() const 
      {
        return ::std::_BinBase1<_Oper, _Clos>::_M_expr2.size();
      }
    private:
      const typename ::std::_BinBase1<_Oper, _Clos>::_Vt &_M_expr1;
      const _Clos &_M_expr2;
  };
  template < typename _Oper, typename _Dom1, typename _Dom2 >
  struct  _BinClos<_Oper, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> : ::std::_BinBase<_Oper, _Dom1, _Dom2>
  {
      typedef ::std::_BinBase<_Oper, _Dom1, _Dom2> _Base;
      typedef typename ::std::_BinBase<_Oper, _Dom1, _Dom2>::value_type value_type;
      inline _BinClos(const _Dom1 &__e1, const _Dom2 &__e2)
        : _Base(__e1, __e2)
      {
      }
  };
  template < typename _Oper, typename _Tp >
  struct  _BinClos<_Oper, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> : ::std::_BinBase<_Oper, ::std::valarray<_Tp>, ::std::valarray<_Tp> >
  {
      typedef ::std::_BinBase<_Oper, ::std::valarray<_Tp>, ::std::valarray<_Tp> > _Base;
      typedef typename ::std::_BinBase<_Oper, ::std::valarray<_Tp>, ::std::valarray<_Tp> >::value_type value_type;
      inline _BinClos(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
        : _Base(__v, __w)
      {
      }
  };
  template < typename _Oper, typename _Dom >
  struct  _BinClos<_Oper, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type> : ::std::_BinBase<_Oper, _Dom, ::std::valarray<typename _Dom::value_type> >
  {
      typedef typename _Dom::value_type _Tp;
      typedef ::std::_BinBase<_Oper, _Dom, ::std::valarray<typename ::std::_BinClos<_Oper, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>::_Tp> > _Base;
      typedef typename ::std::_BinBase<_Oper, _Dom, ::std::valarray<typename ::std::_BinClos<_Oper, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>::_Tp> >::value_type value_type;
      inline _BinClos(const _Dom &__e1, const ::std::valarray<typename ::std::_BinClos<_Oper, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>::_Tp> &__e2)
        : _Base(__e1, __e2)
      {
      }
  };
  template < typename _Oper, typename _Dom >
  struct  _BinClos<_Oper, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom> : ::std::_BinBase<_Oper, ::std::valarray<typename _Dom::value_type>, _Dom>
  {
      typedef typename _Dom::value_type _Tp;
      typedef ::std::_BinBase<_Oper, ::std::valarray<typename ::std::_BinClos<_Oper, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>::_Tp>, _Dom> _Base;
      typedef typename ::std::_BinBase<_Oper, ::std::valarray<typename ::std::_BinClos<_Oper, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>::_Tp>, _Dom>::value_type value_type;
      inline _BinClos(const ::std::valarray<typename ::std::_BinClos<_Oper, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>::_Tp> &__e1, const _Dom &__e2)
        : _Base(__e1, __e2)
      {
      }
  };
  template < typename _Oper, typename _Dom >
  struct  _BinClos<_Oper, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type> : ::std::_BinBase2<_Oper, _Dom>
  {
      typedef typename _Dom::value_type _Tp;
      typedef ::std::_BinBase2<_Oper, _Dom> _Base;
      typedef typename ::std::_BinBase2<_Oper, _Dom>::value_type value_type;
      inline _BinClos(const _Dom &__e1, const typename ::std::_BinClos<_Oper, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>::_Tp &__e2)
        : _Base(__e1, __e2)
      {
      }
  };
  template < typename _Oper, typename _Dom >
  struct  _BinClos<_Oper, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom> : ::std::_BinBase1<_Oper, _Dom>
  {
      typedef typename _Dom::value_type _Tp;
      typedef ::std::_BinBase1<_Oper, _Dom> _Base;
      typedef typename ::std::_BinBase1<_Oper, _Dom>::value_type value_type;
      inline _BinClos(const typename ::std::_BinClos<_Oper, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>::_Tp &__e1, const _Dom &__e2)
        : _Base(__e1, __e2)
      {
      }
  };
  template < typename _Oper, typename _Tp >
  struct  _BinClos<_Oper, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> : ::std::_BinBase2<_Oper, ::std::valarray<_Tp> >
  {
      typedef ::std::_BinBase2<_Oper, ::std::valarray<_Tp> > _Base;
      typedef typename ::std::_BinBase2<_Oper, ::std::valarray<_Tp> >::value_type value_type;
      inline _BinClos(const ::std::valarray<_Tp> &__v, const _Tp &__t)
        : _Base(__v, __t)
      {
      }
  };
  template < typename _Oper, typename _Tp >
  struct  _BinClos<_Oper, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> : ::std::_BinBase1<_Oper, ::std::valarray<_Tp> >
  {
      typedef ::std::_BinBase1<_Oper, ::std::valarray<_Tp> > _Base;
      typedef typename ::std::_BinBase1<_Oper, ::std::valarray<_Tp> >::value_type value_type;
      inline _BinClos(const _Tp &__t, const ::std::valarray<_Tp> &__v)
        : _Base(__t, __v)
      {
      }
  };
  template < typename _Dom >
  class  _SBase
  {
    public:
      typedef typename _Dom::value_type value_type;
      inline _SBase(const _Dom &__e, const ::std::slice &__s)
        : _M_expr(__e), _M_slice(__s)
      {
      }
      inline typename ::std::_SBase<_Dom>::value_type operator [](::std::size_t __i) const 
      {
        return ::std::_SBase<_Dom>::_M_expr[::std::_SBase<_Dom>::_M_slice.start() + __i * ::std::_SBase<_Dom>::_M_slice.stride()];
      }
      inline ::std::size_t size() const 
      {
        return ::std::_SBase<_Dom>::_M_slice.size();
      }
    private:
      const _Dom &_M_expr;
      const ::std::slice &_M_slice;
  };
  template < typename _Tp >
  class  _SBase< ::std::_Array<_Tp> >
  {
    public:
      typedef _Tp value_type;
      inline _SBase(::std::_Array<_Tp> __a, const ::std::slice &__s)
        : _M_array(__a._M_data + __s.::std::slice::start()), _M_size(__s.::std::slice::size()), _M_stride(__s.::std::slice::stride())
      {
      }
      inline typename ::std::_SBase< ::std::_Array<_Tp> >::value_type operator [](::std::size_t __i) const 
      {
        return ::std::_SBase< ::std::_Array<_Tp> >::_M_array._M_data[__i * ::std::_SBase< ::std::_Array<_Tp> >::_M_stride];
      }
      inline ::std::size_t size() const 
      {
        return ::std::_SBase< ::std::_Array<_Tp> >::_M_size;
      }
    private:
      const ::std::_Array<_Tp> _M_array;
      const ::std::size_t _M_size;
      const ::std::size_t _M_stride;
  };
  template < typename _Dom >
  struct  _SClos< ::std::_Expr, _Dom> : ::std::_SBase<_Dom>
  {
      typedef ::std::_SBase<_Dom> _Base;
      typedef typename ::std::_SBase<_Dom>::value_type value_type;
      inline _SClos(const _Dom &__e, const ::std::slice &__s)
        : _Base(__e, __s)
      {
      }
  };
  template < typename _Tp >
  struct  _SClos< ::std::_ValArray, _Tp> : ::std::_SBase< ::std::_Array<_Tp> >
  {
      typedef ::std::_SBase< ::std::_Array<_Tp> > _Base;
      typedef _Tp value_type;
      inline _SClos(::std::_Array<_Tp> __a, const ::std::slice &__s)
        : _Base(__a, __s)
      {
      }
  };
  template < typename _Tp >
  class  valarray
  {
      template < typename _Op >
      struct  _UnaryOp
      {
          typedef typename ::std::__fun<_Op, _Tp>::result_type __rt;
          typedef ::std::_Expr< ::std::_UnClos<_Op, ::std::_ValArray, _Tp>, typename ::std::valarray<_Tp>::template _UnaryOp<_Op>::__rt> _Rt;
      };
    public:
      typedef _Tp value_type;
      inline valarray();
      inline explicit valarray(::std::size_t __n);
      inline valarray(const _Tp &__t, ::std::size_t __n);
      inline valarray(const _Tp *__restrict __p, ::std::size_t __n);
      inline valarray(const ::std::valarray<_Tp> &__v);
      inline valarray(::std::valarray<_Tp> &&__v) noexcept(true);
      inline valarray(const ::std::slice_array<_Tp> &__sa);
      inline valarray(const ::std::gslice_array<_Tp> &__ga);
      inline valarray(const ::std::mask_array<_Tp> &__ma);
      inline valarray(const ::std::indirect_array<_Tp> &__ia);
      inline valarray(::std::initializer_list<_Tp> __l);
      template < typename _Dom >
      inline valarray(const ::std::_Expr<_Dom, _Tp> &__e);
      inline ~valarray() noexcept(true);
      inline ::std::valarray<_Tp> &operator =(const ::std::valarray<_Tp> &__v);
      inline ::std::valarray<_Tp> &operator =(::std::valarray<_Tp> &&__v) noexcept(true);
      inline ::std::valarray<_Tp> &operator =(const _Tp &__t);
      inline ::std::valarray<_Tp> &operator =(const ::std::slice_array<_Tp> &__sa);
      inline ::std::valarray<_Tp> &operator =(const ::std::gslice_array<_Tp> &__ga);
      inline ::std::valarray<_Tp> &operator =(const ::std::mask_array<_Tp> &__ma);
      inline ::std::valarray<_Tp> &operator =(const ::std::indirect_array<_Tp> &__ia);
      inline ::std::valarray<_Tp> &operator =(::std::initializer_list<_Tp> __l);
      template < typename _Dom >
      inline ::std::valarray<_Tp> &operator =(const ::std::_Expr<_Dom, _Tp> &__e);
      inline _Tp &operator [](::std::size_t __i);
      inline const _Tp &operator [](::std::size_t __i) const ;
      inline ::std::_Expr< ::std::_SClos< ::std::_ValArray, _Tp>, _Tp> operator [](::std::slice __s) const ;
      inline ::std::slice_array<_Tp> operator [](::std::slice __s);
      inline ::std::_Expr< ::std::_GClos< ::std::_ValArray, _Tp>, _Tp> operator [](const ::std::gslice &__gs) const ;
      inline ::std::gslice_array<_Tp> operator [](const ::std::gslice &__gs);
      inline ::std::valarray<_Tp> operator [](const ::std::valarray<bool> &__m) const ;
      inline ::std::mask_array<_Tp> operator [](const ::std::valarray<bool> &__m);
      inline ::std::_Expr< ::std::_IClos< ::std::_ValArray, _Tp>, _Tp> operator [](const ::std::valarray<unsigned long int> &__i) const ;
      inline ::std::indirect_array<_Tp> operator [](const ::std::valarray<unsigned long int> &__i);
      inline typename ::std::valarray<_Tp>::template _UnaryOp< ::std::__unary_plus>::_Rt operator +() const ;
      inline typename ::std::valarray<_Tp>::template _UnaryOp< ::std::__negate>::_Rt operator -() const ;
      inline typename ::std::valarray<_Tp>::template _UnaryOp< ::std::__bitwise_not>::_Rt operator ~() const ;
      inline typename ::std::valarray<_Tp>::template _UnaryOp< ::std::__logical_not>::_Rt operator !() const ;
      inline ::std::valarray<_Tp> &operator *=(const _Tp &__t);
      inline ::std::valarray<_Tp> &operator /=(const _Tp &__t);
      inline ::std::valarray<_Tp> &operator %=(const _Tp &__t);
      inline ::std::valarray<_Tp> &operator +=(const _Tp &__t);
      inline ::std::valarray<_Tp> &operator -=(const _Tp &__t);
      inline ::std::valarray<_Tp> &operator ^=(const _Tp &__t);
      inline ::std::valarray<_Tp> &operator &=(const _Tp &__t);
      inline ::std::valarray<_Tp> &operator |=(const _Tp &__t);
      inline ::std::valarray<_Tp> &operator <<=(const _Tp &__t);
      inline ::std::valarray<_Tp> &operator >>=(const _Tp &__t);
      inline ::std::valarray<_Tp> &operator *=(const ::std::valarray<_Tp> &__v);
      inline ::std::valarray<_Tp> &operator /=(const ::std::valarray<_Tp> &__v);
      inline ::std::valarray<_Tp> &operator %=(const ::std::valarray<_Tp> &__v);
      inline ::std::valarray<_Tp> &operator +=(const ::std::valarray<_Tp> &__v);
      inline ::std::valarray<_Tp> &operator -=(const ::std::valarray<_Tp> &__v);
      inline ::std::valarray<_Tp> &operator ^=(const ::std::valarray<_Tp> &__v);
      inline ::std::valarray<_Tp> &operator |=(const ::std::valarray<_Tp> &__v);
      inline ::std::valarray<_Tp> &operator &=(const ::std::valarray<_Tp> &__v);
      inline ::std::valarray<_Tp> &operator <<=(const ::std::valarray<_Tp> &__v);
      inline ::std::valarray<_Tp> &operator >>=(const ::std::valarray<_Tp> &__v);
      template < typename _Dom >
      inline ::std::valarray<_Tp> &operator *=(const ::std::_Expr<_Dom, _Tp> &__e);
      template < typename _Dom >
      inline ::std::valarray<_Tp> &operator /=(const ::std::_Expr<_Dom, _Tp> &__e);
      template < typename _Dom >
      inline ::std::valarray<_Tp> &operator %=(const ::std::_Expr<_Dom, _Tp> &__e);
      template < typename _Dom >
      inline ::std::valarray<_Tp> &operator +=(const ::std::_Expr<_Dom, _Tp> &__e);
      template < typename _Dom >
      inline ::std::valarray<_Tp> &operator -=(const ::std::_Expr<_Dom, _Tp> &__e);
      template < typename _Dom >
      inline ::std::valarray<_Tp> &operator ^=(const ::std::_Expr<_Dom, _Tp> &__e);
      template < typename _Dom >
      inline ::std::valarray<_Tp> &operator |=(const ::std::_Expr<_Dom, _Tp> &__e);
      template < typename _Dom >
      inline ::std::valarray<_Tp> &operator &=(const ::std::_Expr<_Dom, _Tp> &__e);
      template < typename _Dom >
      inline ::std::valarray<_Tp> &operator <<=(const ::std::_Expr<_Dom, _Tp> &__e);
      template < typename _Dom >
      inline ::std::valarray<_Tp> &operator >>=(const ::std::_Expr<_Dom, _Tp> &__e);
      inline void swap(::std::valarray<_Tp> &__v) noexcept(true);
      inline ::std::size_t size() const ;
      inline _Tp sum() const ;
      inline _Tp min() const ;
      inline _Tp max() const ;
      inline ::std::valarray<_Tp> shift(int __n) const ;
      inline ::std::valarray<_Tp> cshift(int __n) const ;
      inline ::std::_Expr< ::std::_ValFunClos< ::std::_ValArray, _Tp>, _Tp> apply(_Tp func(_Tp)) const ;
      inline ::std::_Expr< ::std::_RefFunClos< ::std::_ValArray, _Tp>, _Tp> apply(_Tp func(const _Tp &)) const ;
      inline void resize(::std::size_t __n, _Tp __c  = (_Tp()));
    private:
      ::std::size_t _M_size;
      _Tp *__restrict _M_data;
    friend struct ::std::_Array<_Tp>;
  };
  template < typename _Tp >
  inline const _Tp &valarray<_Tp>::operator [](::std::size_t __i) const 
  {
    ;
    return ::std::valarray<_Tp>::_M_data[__i];
  }
  template < typename _Tp >
  inline _Tp &valarray<_Tp>::operator [](::std::size_t __i)
  {
    ;
    return ::std::valarray<_Tp>::_M_data[__i];
  }
  template < typename _Dom >
  class  _GBase
  {
    public:
      typedef typename _Dom::value_type value_type;
      inline _GBase(const _Dom &__e, const ::std::valarray<unsigned long int> &__i)
        : _M_expr(__e), _M_index(__i)
      {
      }
      inline typename ::std::_GBase<_Dom>::value_type operator [](::std::size_t __i) const 
      {
        return ::std::_GBase<_Dom>::_M_expr[::std::_GBase<_Dom>::_M_index[__i]];
      }
      inline ::std::size_t size() const 
      {
        return ::std::_GBase<_Dom>::_M_index.size();
      }
    private:
      const _Dom &_M_expr;
      const ::std::valarray<unsigned long int> &_M_index;
  };
  template < typename _Tp >
  class  _GBase< ::std::_Array<_Tp> >
  {
    public:
      typedef _Tp value_type;
      inline _GBase(::std::_Array<_Tp> __a, const ::std::valarray<unsigned long int> &__i)
        : _M_array(__a), _M_index(__i)
      {
      }
      inline typename ::std::_GBase< ::std::_Array<_Tp> >::value_type operator [](::std::size_t __i) const 
      {
        return ::std::_GBase< ::std::_Array<_Tp> >::_M_array._M_data[::std::_GBase< ::std::_Array<_Tp> >::_M_index[__i]];
      }
      inline ::std::size_t size() const 
      {
        return ::std::_GBase< ::std::_Array<_Tp> >::_M_index.size();
      }
    private:
      const ::std::_Array<_Tp> _M_array;
      const ::std::valarray<unsigned long int> &_M_index;
  };
  template < typename _Dom >
  struct  _GClos< ::std::_Expr, _Dom> : ::std::_GBase<_Dom>
  {
      typedef ::std::_GBase<_Dom> _Base;
      typedef typename ::std::_GBase<_Dom>::value_type value_type;
      inline _GClos(const _Dom &__e, const ::std::valarray<unsigned long int> &__i)
        : _Base(__e, __i)
      {
      }
  };
  template < typename _Tp >
  struct  _GClos< ::std::_ValArray, _Tp> : ::std::_GBase< ::std::_Array<_Tp> >
  {
      typedef ::std::_GBase< ::std::_Array<_Tp> > _Base;
      typedef typename ::std::_GBase< ::std::_Array<_Tp> >::value_type value_type;
      inline _GClos(::std::_Array<_Tp> __a, const ::std::valarray<unsigned long int> &__i)
        : _Base(__a, __i)
      {
      }
  };
  template < typename _Dom >
  class  _IBase
  {
    public:
      typedef typename _Dom::value_type value_type;
      inline _IBase(const _Dom &__e, const ::std::valarray<unsigned long int> &__i)
        : _M_expr(__e), _M_index(__i)
      {
      }
      inline typename ::std::_IBase<_Dom>::value_type operator [](::std::size_t __i) const 
      {
        return ::std::_IBase<_Dom>::_M_expr[::std::_IBase<_Dom>::_M_index[__i]];
      }
      inline ::std::size_t size() const 
      {
        return ::std::_IBase<_Dom>::_M_index.size();
      }
    private:
      const _Dom &_M_expr;
      const ::std::valarray<unsigned long int> &_M_index;
  };
  template < typename _Dom >
  struct  _IClos< ::std::_Expr, _Dom> : ::std::_IBase<_Dom>
  {
      typedef ::std::_IBase<_Dom> _Base;
      typedef typename ::std::_IBase<_Dom>::value_type value_type;
      inline _IClos(const _Dom &__e, const ::std::valarray<unsigned long int> &__i)
        : _Base(__e, __i)
      {
      }
  };
  template < typename _Tp >
  struct  _IClos< ::std::_ValArray, _Tp> : ::std::_IBase< ::std::valarray<_Tp> >
  {
      typedef ::std::_IBase< ::std::valarray<_Tp> > _Base;
      typedef _Tp value_type;
      inline _IClos(const ::std::valarray<_Tp> &__a, const ::std::valarray<unsigned long int> &__i)
        : _Base(__a, __i)
      {
      }
  };
  template < typename _Clos, typename _Tp >
  class  _Expr
  {
    public:
      typedef _Tp value_type;
      inline _Expr(const _Clos &__c);
      inline const _Clos &operator ()() const ;
      inline typename ::std::_Expr<_Clos, _Tp>::value_type operator [](::std::size_t __i) const ;
      inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> operator [](::std::slice __s) const ;
      inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> operator [](const ::std::gslice &__gs) const ;
      inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> operator [](const ::std::valarray<bool> &__m) const ;
      inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> operator [](const ::std::valarray<unsigned long int> &__i) const ;
      inline ::std::_Expr< ::std::_UnClos< ::std::__unary_plus, ::std::_Expr, _Clos>, typename ::std::_Expr<_Clos, _Tp>::value_type> operator +() const ;
      inline ::std::_Expr< ::std::_UnClos< ::std::__negate, ::std::_Expr, _Clos>, typename ::std::_Expr<_Clos, _Tp>::value_type> operator -() const ;
      inline ::std::_Expr< ::std::_UnClos< ::std::__bitwise_not, ::std::_Expr, _Clos>, typename ::std::_Expr<_Clos, _Tp>::value_type> operator ~() const ;
      inline ::std::_Expr< ::std::_UnClos< ::std::__logical_not, ::std::_Expr, _Clos>, bool> operator !() const ;
      inline ::std::size_t size() const ;
      inline typename ::std::_Expr<_Clos, _Tp>::value_type sum() const ;
      inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> shift(int __n) const ;
      inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> cshift(int __n) const ;
      inline typename ::std::_Expr<_Clos, _Tp>::value_type min() const ;
      inline typename ::std::_Expr<_Clos, _Tp>::value_type max() const ;
      inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> apply(typename ::std::_Expr<_Clos, _Tp>::value_type (*__f)(const typename ::std::_Expr<_Clos, _Tp>::value_type &)) const ;
      inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> apply(typename ::std::_Expr<_Clos, _Tp>::value_type (*__f)(typename ::std::_Expr<_Clos, _Tp>::value_type)) const ;
    private:
      const _Clos _M_closure;
  };
  template < typename _Clos, typename _Tp >
  inline _Expr<_Clos, _Tp>::_Expr(const _Clos &__c)
    : _M_closure(__c)
  {
  }
  template < typename _Clos, typename _Tp >
  inline const _Clos &_Expr<_Clos, _Tp>::operator ()() const 
  {
    return ::std::_Expr<_Clos, _Tp>::_M_closure;
  }
  template < typename _Clos, typename _Tp >
  inline typename ::std::_Expr<_Clos, _Tp>::value_type _Expr<_Clos, _Tp>::operator [](::std::size_t __i) const 
  {
    return ::std::_Expr<_Clos, _Tp>::_M_closure[__i];
  }
  template < typename _Clos, typename _Tp >
  inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> _Expr<_Clos, _Tp>::operator [](::std::slice __s) const 
  {
    ::std::valarray<_Tp> __v = ::std::valarray<_Tp>(*this)[__s];
    return __v;
  }
  template < typename _Clos, typename _Tp >
  inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> _Expr<_Clos, _Tp>::operator [](const ::std::gslice &__gs) const 
  {
    ::std::valarray<_Tp> __v = ::std::valarray<_Tp>(*this)[__gs];
    return __v;
  }
  template < typename _Clos, typename _Tp >
  inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> _Expr<_Clos, _Tp>::operator [](const ::std::valarray<bool> &__m) const 
  {
    ::std::valarray<_Tp> __v = ::std::valarray<_Tp>(*this)[__m];
    return __v;
  }
  template < typename _Clos, typename _Tp >
  inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> _Expr<_Clos, _Tp>::operator [](const ::std::valarray<unsigned long int> &__i) const 
  {
    ::std::valarray<_Tp> __v = ::std::valarray<_Tp>(*this)[__i];
    return __v;
  }
  template < typename _Clos, typename _Tp >
  inline ::std::size_t _Expr<_Clos, _Tp>::size() const 
  {
    return ::std::_Expr<_Clos, _Tp>::_M_closure.size();
  }
  template < typename _Clos, typename _Tp >
  inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> _Expr<_Clos, _Tp>::shift(int __n) const 
  {
    ::std::valarray<_Tp> __v = ::std::valarray<_Tp>(*this).shift(__n);
    return __v;
  }
  template < typename _Clos, typename _Tp >
  inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> _Expr<_Clos, _Tp>::cshift(int __n) const 
  {
    ::std::valarray<_Tp> __v = ::std::valarray<_Tp>(*this).cshift(__n);
    return __v;
  }
  template < typename _Clos, typename _Tp >
  inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> _Expr<_Clos, _Tp>::apply(_Tp (*__f)(const _Tp &)) const 
  {
    ::std::valarray<_Tp> __v = ::std::valarray<_Tp>(*this).apply(__f);
    return __v;
  }
  template < typename _Clos, typename _Tp >
  inline ::std::valarray<typename ::std::_Expr<_Clos, _Tp>::value_type> _Expr<_Clos, _Tp>::apply(_Tp (*__f)(_Tp)) const 
  {
    ::std::valarray<_Tp> __v = ::std::valarray<_Tp>(*this).apply(__f);
    return __v;
  }
  template < typename _Clos, typename _Tp >
  inline typename ::std::_Expr<_Clos, _Tp>::value_type _Expr<_Clos, _Tp>::sum() const 
  {
    ::std::size_t __n = ::std::_Expr<_Clos, _Tp>::_M_closure.size();
    if (__n == 0)
      {
        return _Tp();
      }
    else
      {
        _Tp __s = ::std::_Expr<_Clos, _Tp>::_M_closure[ --__n];
        while (__n != 0)
          {
            __s += ::std::_Expr<_Clos, _Tp>::_M_closure[ --__n];
          }
        return __s;
      }
  }
  template < typename _Clos, typename _Tp >
  inline typename ::std::_Expr<_Clos, _Tp>::value_type _Expr<_Clos, _Tp>::min() const 
  {
    return __valarray_min(::std::_Expr<_Clos, _Tp>::_M_closure);
  }
  template < typename _Clos, typename _Tp >
  inline typename ::std::_Expr<_Clos, _Tp>::value_type _Expr<_Clos, _Tp>::max() const 
  {
    return __valarray_max(::std::_Expr<_Clos, _Tp>::_M_closure);
  }
  template < typename _Dom, typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::__logical_not, ::std::_Expr, _Dom>, bool> _Expr<_Dom, _Tp>::operator !() const 
  {
    typedef ::std::_UnClos< ::std::__logical_not, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, bool>(_Closure(this->_M_closure));
  }
  template < typename _Dom, typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::__unary_plus, ::std::_Expr, _Dom>, typename ::std::_Expr<_Dom, _Tp>::value_type> _Expr<_Dom, _Tp>::operator +() const 
  {
    typedef ::std::_UnClos< ::std::__unary_plus, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(this->_M_closure));
  }
  template < typename _Dom, typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::__negate, ::std::_Expr, _Dom>, typename ::std::_Expr<_Dom, _Tp>::value_type> _Expr<_Dom, _Tp>::operator -() const 
  {
    typedef ::std::_UnClos< ::std::__negate, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(this->_M_closure));
  }
  template < typename _Dom, typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::__bitwise_not, ::std::_Expr, _Dom>, typename ::std::_Expr<_Dom, _Tp>::value_type> _Expr<_Dom, _Tp>::operator ~() const 
  {
    typedef ::std::_UnClos< ::std::__bitwise_not, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(this->_M_closure));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__plus, typename _Dom1::value_type>::result_type> operator +(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__plus, typename _Dom1::value_type>::result_type> operator +(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__plus, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__plus, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__plus, typename _Dom::value_type>::result_type> operator +(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__plus, typename _Dom::value_type>::result_type> operator +(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__plus, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__plus, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__plus, typename _Dom::value_type>::result_type> operator +(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__plus, typename _Dom::value_type>::result_type> operator +(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__plus, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__plus, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__plus, typename _Dom::value_type>::result_type> operator +(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__plus, typename _Dom::value_type>::result_type> operator +(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__plus, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__plus, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__plus, typename _Dom::value_type>::result_type> operator +(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__plus, typename _Dom::value_type>::result_type> operator +(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__plus, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__plus, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__minus, typename _Dom1::value_type>::result_type> operator -(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__minus, typename _Dom1::value_type>::result_type> operator -(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__minus, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__minus, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__minus, typename _Dom::value_type>::result_type> operator -(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__minus, typename _Dom::value_type>::result_type> operator -(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__minus, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__minus, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__minus, typename _Dom::value_type>::result_type> operator -(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__minus, typename _Dom::value_type>::result_type> operator -(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__minus, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__minus, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__minus, typename _Dom::value_type>::result_type> operator -(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__minus, typename _Dom::value_type>::result_type> operator -(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__minus, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__minus, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__minus, typename _Dom::value_type>::result_type> operator -(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__minus, typename _Dom::value_type>::result_type> operator -(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__minus, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__minus, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__multiplies, typename _Dom1::value_type>::result_type> operator *(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__multiplies, typename _Dom1::value_type>::result_type> operator *(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__multiplies, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__multiplies, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__multiplies, typename _Dom::value_type>::result_type> operator *(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__multiplies, typename _Dom::value_type>::result_type> operator *(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__multiplies, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__multiplies, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__multiplies, typename _Dom::value_type>::result_type> operator *(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__multiplies, typename _Dom::value_type>::result_type> operator *(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__multiplies, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__multiplies, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__multiplies, typename _Dom::value_type>::result_type> operator *(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__multiplies, typename _Dom::value_type>::result_type> operator *(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__multiplies, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__multiplies, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__multiplies, typename _Dom::value_type>::result_type> operator *(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__multiplies, typename _Dom::value_type>::result_type> operator *(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__multiplies, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__multiplies, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__divides, typename _Dom1::value_type>::result_type> operator /(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__divides, typename _Dom1::value_type>::result_type> operator /(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__divides, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__divides, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__divides, typename _Dom::value_type>::result_type> operator /(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__divides, typename _Dom::value_type>::result_type> operator /(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__divides, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__divides, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__divides, typename _Dom::value_type>::result_type> operator /(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__divides, typename _Dom::value_type>::result_type> operator /(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__divides, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__divides, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__divides, typename _Dom::value_type>::result_type> operator /(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__divides, typename _Dom::value_type>::result_type> operator /(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__divides, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__divides, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__divides, typename _Dom::value_type>::result_type> operator /(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__divides, typename _Dom::value_type>::result_type> operator /(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__divides, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__divides, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__modulus, typename _Dom1::value_type>::result_type> operator %(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__modulus, typename _Dom1::value_type>::result_type> operator %(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__modulus, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__modulus, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__modulus, typename _Dom::value_type>::result_type> operator %(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__modulus, typename _Dom::value_type>::result_type> operator %(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__modulus, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__modulus, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__modulus, typename _Dom::value_type>::result_type> operator %(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__modulus, typename _Dom::value_type>::result_type> operator %(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__modulus, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__modulus, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__modulus, typename _Dom::value_type>::result_type> operator %(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__modulus, typename _Dom::value_type>::result_type> operator %(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__modulus, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__modulus, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__modulus, typename _Dom::value_type>::result_type> operator %(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__modulus, typename _Dom::value_type>::result_type> operator %(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__modulus, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__modulus, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__bitwise_xor, typename _Dom1::value_type>::result_type> operator ^(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__bitwise_xor, typename _Dom1::value_type>::result_type> operator ^(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__bitwise_xor, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_xor, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__bitwise_xor, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_xor, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__bitwise_xor, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_xor, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__bitwise_xor, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_xor, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__bitwise_xor, typename _Dom::value_type>::result_type> operator ^(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__bitwise_xor, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_xor, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__bitwise_and, typename _Dom1::value_type>::result_type> operator &(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__bitwise_and, typename _Dom1::value_type>::result_type> operator &(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__bitwise_and, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_and, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__bitwise_and, typename _Dom::value_type>::result_type> operator &(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__bitwise_and, typename _Dom::value_type>::result_type> operator &(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__bitwise_and, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_and, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__bitwise_and, typename _Dom::value_type>::result_type> operator &(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__bitwise_and, typename _Dom::value_type>::result_type> operator &(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__bitwise_and, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_and, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__bitwise_and, typename _Dom::value_type>::result_type> operator &(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__bitwise_and, typename _Dom::value_type>::result_type> operator &(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__bitwise_and, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_and, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__bitwise_and, typename _Dom::value_type>::result_type> operator &(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__bitwise_and, typename _Dom::value_type>::result_type> operator &(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__bitwise_and, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_and, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__bitwise_or, typename _Dom1::value_type>::result_type> operator |(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__bitwise_or, typename _Dom1::value_type>::result_type> operator |(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__bitwise_or, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_or, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__bitwise_or, typename _Dom::value_type>::result_type> operator |(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__bitwise_or, typename _Dom::value_type>::result_type> operator |(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__bitwise_or, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_or, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__bitwise_or, typename _Dom::value_type>::result_type> operator |(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__bitwise_or, typename _Dom::value_type>::result_type> operator |(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__bitwise_or, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_or, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__bitwise_or, typename _Dom::value_type>::result_type> operator |(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__bitwise_or, typename _Dom::value_type>::result_type> operator |(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__bitwise_or, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_or, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__bitwise_or, typename _Dom::value_type>::result_type> operator |(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__bitwise_or, typename _Dom::value_type>::result_type> operator |(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__bitwise_or, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__bitwise_or, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__shift_left, typename _Dom1::value_type>::result_type> operator <<(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__shift_left, typename _Dom1::value_type>::result_type> operator <<(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__shift_left, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__shift_left, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__shift_left, typename _Dom::value_type>::result_type> operator <<(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__shift_left, typename _Dom::value_type>::result_type> operator <<(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__shift_left, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__shift_left, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__shift_left, typename _Dom::value_type>::result_type> operator <<(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__shift_left, typename _Dom::value_type>::result_type> operator <<(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__shift_left, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__shift_left, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__shift_left, typename _Dom::value_type>::result_type> operator <<(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__shift_left, typename _Dom::value_type>::result_type> operator <<(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__shift_left, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__shift_left, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__shift_left, typename _Dom::value_type>::result_type> operator <<(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__shift_left, typename _Dom::value_type>::result_type> operator <<(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__shift_left, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__shift_left, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__shift_right, typename _Dom1::value_type>::result_type> operator >>(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__shift_right, typename _Dom1::value_type>::result_type> operator >>(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__shift_right, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__shift_right, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__shift_right, typename _Dom::value_type>::result_type> operator >>(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__shift_right, typename _Dom::value_type>::result_type> operator >>(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__shift_right, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__shift_right, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__shift_right, typename _Dom::value_type>::result_type> operator >>(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__shift_right, typename _Dom::value_type>::result_type> operator >>(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__shift_right, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__shift_right, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__shift_right, typename _Dom::value_type>::result_type> operator >>(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__shift_right, typename _Dom::value_type>::result_type> operator >>(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__shift_right, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__shift_right, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__shift_right, typename _Dom::value_type>::result_type> operator >>(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__shift_right, typename _Dom::value_type>::result_type> operator >>(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__shift_right, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__shift_right, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__logical_and, typename _Dom1::value_type>::result_type> operator &&(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__logical_and, typename _Dom1::value_type>::result_type> operator &&(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__logical_and, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__logical_and, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__logical_and, typename _Dom::value_type>::result_type> operator &&(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__logical_and, typename _Dom::value_type>::result_type> operator &&(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__logical_and, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__logical_and, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__logical_and, typename _Dom::value_type>::result_type> operator &&(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__logical_and, typename _Dom::value_type>::result_type> operator &&(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__logical_and, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__logical_and, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__logical_and, typename _Dom::value_type>::result_type> operator &&(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__logical_and, typename _Dom::value_type>::result_type> operator &&(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__logical_and, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__logical_and, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__logical_and, typename _Dom::value_type>::result_type> operator &&(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__logical_and, typename _Dom::value_type>::result_type> operator &&(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__logical_and, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__logical_and, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__logical_or, typename _Dom1::value_type>::result_type> operator ||(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__logical_or, typename _Dom1::value_type>::result_type> operator ||(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__logical_or, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__logical_or, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__logical_or, typename _Dom::value_type>::result_type> operator ||(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__logical_or, typename _Dom::value_type>::result_type> operator ||(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__logical_or, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__logical_or, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__logical_or, typename _Dom::value_type>::result_type> operator ||(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__logical_or, typename _Dom::value_type>::result_type> operator ||(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__logical_or, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__logical_or, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__logical_or, typename _Dom::value_type>::result_type> operator ||(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__logical_or, typename _Dom::value_type>::result_type> operator ||(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__logical_or, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__logical_or, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__logical_or, typename _Dom::value_type>::result_type> operator ||(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__logical_or, typename _Dom::value_type>::result_type> operator ||(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__logical_or, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__logical_or, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__equal_to, typename _Dom1::value_type>::result_type> operator ==(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__equal_to, typename _Dom1::value_type>::result_type> operator ==(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__equal_to, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__equal_to, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__equal_to, typename _Dom::value_type>::result_type> operator ==(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__equal_to, typename _Dom::value_type>::result_type> operator ==(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__equal_to, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__equal_to, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__equal_to, typename _Dom::value_type>::result_type> operator ==(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__equal_to, typename _Dom::value_type>::result_type> operator ==(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__equal_to, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__equal_to, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__equal_to, typename _Dom::value_type>::result_type> operator ==(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__equal_to, typename _Dom::value_type>::result_type> operator ==(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__equal_to, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__equal_to, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__equal_to, typename _Dom::value_type>::result_type> operator ==(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__equal_to, typename _Dom::value_type>::result_type> operator ==(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__equal_to, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__equal_to, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__not_equal_to, typename _Dom1::value_type>::result_type> operator !=(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__not_equal_to, typename _Dom1::value_type>::result_type> operator !=(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__not_equal_to, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__not_equal_to, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__not_equal_to, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__not_equal_to, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__not_equal_to, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__not_equal_to, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__not_equal_to, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__not_equal_to, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__not_equal_to, typename _Dom::value_type>::result_type> operator !=(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__not_equal_to, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__not_equal_to, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__less, typename _Dom1::value_type>::result_type> operator <(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__less, typename _Dom1::value_type>::result_type> operator <(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__less, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__less, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__less, typename _Dom::value_type>::result_type> operator <(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__less, typename _Dom::value_type>::result_type> operator <(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__less, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__less, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__less, typename _Dom::value_type>::result_type> operator <(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__less, typename _Dom::value_type>::result_type> operator <(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__less, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__less, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__less, typename _Dom::value_type>::result_type> operator <(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__less, typename _Dom::value_type>::result_type> operator <(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__less, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__less, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__less, typename _Dom::value_type>::result_type> operator <(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__less, typename _Dom::value_type>::result_type> operator <(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__less, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__less, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__greater, typename _Dom1::value_type>::result_type> operator >(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__greater, typename _Dom1::value_type>::result_type> operator >(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__greater, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__greater, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__greater, typename _Dom::value_type>::result_type> operator >(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__greater, typename _Dom::value_type>::result_type> operator >(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__greater, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__greater, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__greater, typename _Dom::value_type>::result_type> operator >(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__greater, typename _Dom::value_type>::result_type> operator >(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__greater, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__greater, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__greater, typename _Dom::value_type>::result_type> operator >(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__greater, typename _Dom::value_type>::result_type> operator >(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__greater, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__greater, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__greater, typename _Dom::value_type>::result_type> operator >(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__greater, typename _Dom::value_type>::result_type> operator >(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__greater, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__greater, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__less_equal, typename _Dom1::value_type>::result_type> operator <=(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__less_equal, typename _Dom1::value_type>::result_type> operator <=(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__less_equal, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__less_equal, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__less_equal, typename _Dom::value_type>::result_type> operator <=(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__less_equal, typename _Dom::value_type>::result_type> operator <=(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__less_equal, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__less_equal, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__less_equal, typename _Dom::value_type>::result_type> operator <=(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__less_equal, typename _Dom::value_type>::result_type> operator <=(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__less_equal, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__less_equal, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__less_equal, typename _Dom::value_type>::result_type> operator <=(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__less_equal, typename _Dom::value_type>::result_type> operator <=(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__less_equal, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__less_equal, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__less_equal, typename _Dom::value_type>::result_type> operator <=(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__less_equal, typename _Dom::value_type>::result_type> operator <=(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__less_equal, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__less_equal, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__greater_equal, typename _Dom1::value_type>::result_type> operator >=(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename ::std::__fun< ::std::__greater_equal, typename _Dom1::value_type>::result_type> operator >=(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__v, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__w)
  {
    typedef typename _Dom1::value_type _Arg;
    typedef typename ::std::__fun< ::std::__greater_equal, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__greater_equal, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __w()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__greater_equal, typename _Dom::value_type>::result_type> operator >=(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__greater_equal, typename _Dom::value_type>::result_type> operator >=(const ::std::_Expr<_Dom, typename _Dom::value_type> &__v, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__greater_equal, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__greater_equal, ::std::_Expr, ::std::_Constant, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__greater_equal, typename _Dom::value_type>::result_type> operator >=(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__greater_equal, typename _Dom::value_type>::result_type> operator >=(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__greater_equal, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__greater_equal, ::std::_Constant, ::std::_Expr, _Arg, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__t, __v()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__greater_equal, typename _Dom::value_type>::result_type> operator >=(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename ::std::__fun< ::std::__greater_equal, typename _Dom::value_type>::result_type> operator >=(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Arg;
    typedef typename ::std::__fun< ::std::__greater_equal, _Arg>::result_type _Value;
    typedef ::std::_BinClos< ::std::__greater_equal, ::std::_Expr, ::std::_ValArray, _Dom, _Arg> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__greater_equal, typename _Dom::value_type>::result_type> operator >=(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename ::std::__fun< ::std::__greater_equal, typename _Dom::value_type>::result_type> operator >=(const ::std::valarray<typename _Dom::value_type> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef typename ::std::__fun< ::std::__greater_equal, _Tp>::result_type _Value;
    typedef ::std::_BinClos< ::std::__greater_equal, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Value>(_Closure(__v, __e()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Abs, ::std::_Expr, _Dom>, typename _Dom::value_type> abs(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Abs, ::std::_Expr, _Dom>, typename _Dom::value_type> abs(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_UnClos< ::std::_Abs, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Abs, ::std::_ValArray, _Tp>, _Tp> abs(const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Abs, ::std::_ValArray, _Tp>, _Tp> abs(const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_UnClos< ::std::_Abs, ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Cos, ::std::_Expr, _Dom>, typename _Dom::value_type> cos(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Cos, ::std::_Expr, _Dom>, typename _Dom::value_type> cos(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_UnClos< ::std::_Cos, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Cos, ::std::_ValArray, _Tp>, _Tp> cos(const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Cos, ::std::_ValArray, _Tp>, _Tp> cos(const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_UnClos< ::std::_Cos, ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Acos, ::std::_Expr, _Dom>, typename _Dom::value_type> acos(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Acos, ::std::_Expr, _Dom>, typename _Dom::value_type> acos(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_UnClos< ::std::_Acos, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Acos, ::std::_ValArray, _Tp>, _Tp> acos(const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Acos, ::std::_ValArray, _Tp>, _Tp> acos(const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_UnClos< ::std::_Acos, ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Cosh, ::std::_Expr, _Dom>, typename _Dom::value_type> cosh(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Cosh, ::std::_Expr, _Dom>, typename _Dom::value_type> cosh(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_UnClos< ::std::_Cosh, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Cosh, ::std::_ValArray, _Tp>, _Tp> cosh(const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Cosh, ::std::_ValArray, _Tp>, _Tp> cosh(const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_UnClos< ::std::_Cosh, ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Sin, ::std::_Expr, _Dom>, typename _Dom::value_type> sin(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Sin, ::std::_Expr, _Dom>, typename _Dom::value_type> sin(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_UnClos< ::std::_Sin, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Sin, ::std::_ValArray, _Tp>, _Tp> sin(const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Sin, ::std::_ValArray, _Tp>, _Tp> sin(const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_UnClos< ::std::_Sin, ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Asin, ::std::_Expr, _Dom>, typename _Dom::value_type> asin(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Asin, ::std::_Expr, _Dom>, typename _Dom::value_type> asin(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_UnClos< ::std::_Asin, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Asin, ::std::_ValArray, _Tp>, _Tp> asin(const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Asin, ::std::_ValArray, _Tp>, _Tp> asin(const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_UnClos< ::std::_Asin, ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Sinh, ::std::_Expr, _Dom>, typename _Dom::value_type> sinh(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Sinh, ::std::_Expr, _Dom>, typename _Dom::value_type> sinh(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_UnClos< ::std::_Sinh, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Sinh, ::std::_ValArray, _Tp>, _Tp> sinh(const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Sinh, ::std::_ValArray, _Tp>, _Tp> sinh(const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_UnClos< ::std::_Sinh, ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Tan, ::std::_Expr, _Dom>, typename _Dom::value_type> tan(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Tan, ::std::_Expr, _Dom>, typename _Dom::value_type> tan(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_UnClos< ::std::_Tan, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Tan, ::std::_ValArray, _Tp>, _Tp> tan(const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Tan, ::std::_ValArray, _Tp>, _Tp> tan(const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_UnClos< ::std::_Tan, ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Tanh, ::std::_Expr, _Dom>, typename _Dom::value_type> tanh(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Tanh, ::std::_Expr, _Dom>, typename _Dom::value_type> tanh(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_UnClos< ::std::_Tanh, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Tanh, ::std::_ValArray, _Tp>, _Tp> tanh(const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Tanh, ::std::_ValArray, _Tp>, _Tp> tanh(const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_UnClos< ::std::_Tanh, ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Atan, ::std::_Expr, _Dom>, typename _Dom::value_type> atan(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Atan, ::std::_Expr, _Dom>, typename _Dom::value_type> atan(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_UnClos< ::std::_Atan, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Atan, ::std::_ValArray, _Tp>, _Tp> atan(const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Atan, ::std::_ValArray, _Tp>, _Tp> atan(const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_UnClos< ::std::_Atan, ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Exp, ::std::_Expr, _Dom>, typename _Dom::value_type> exp(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Exp, ::std::_Expr, _Dom>, typename _Dom::value_type> exp(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_UnClos< ::std::_Exp, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Exp, ::std::_ValArray, _Tp>, _Tp> exp(const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Exp, ::std::_ValArray, _Tp>, _Tp> exp(const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_UnClos< ::std::_Exp, ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Log, ::std::_Expr, _Dom>, typename _Dom::value_type> log(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Log, ::std::_Expr, _Dom>, typename _Dom::value_type> log(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_UnClos< ::std::_Log, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Log, ::std::_ValArray, _Tp>, _Tp> log(const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Log, ::std::_ValArray, _Tp>, _Tp> log(const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_UnClos< ::std::_Log, ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Log10, ::std::_Expr, _Dom>, typename _Dom::value_type> log10(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Log10, ::std::_Expr, _Dom>, typename _Dom::value_type> log10(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_UnClos< ::std::_Log10, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Log10, ::std::_ValArray, _Tp>, _Tp> log10(const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Log10, ::std::_ValArray, _Tp>, _Tp> log10(const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_UnClos< ::std::_Log10, ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Sqrt, ::std::_Expr, _Dom>, typename _Dom::value_type> sqrt(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Sqrt, ::std::_Expr, _Dom>, typename _Dom::value_type> sqrt(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_UnClos< ::std::_Sqrt, ::std::_Expr, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Sqrt, ::std::_ValArray, _Tp>, _Tp> sqrt(const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_UnClos< ::std::_Sqrt, ::std::_ValArray, _Tp>, _Tp> sqrt(const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_UnClos< ::std::_Sqrt, ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename _Dom1::value_type> atan2(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__e1, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__e2);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename _Dom1::value_type> atan2(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__e1, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__e2)
  {
    typedef typename _Dom1::value_type _Tp;
    typedef ::std::_BinClos< ::std::_Atan2, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e1(), __e2()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename _Dom::value_type> atan2(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename _Dom::value_type> atan2(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_BinClos< ::std::_Atan2, ::std::_Expr, ::std::_ValArray, _Dom, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> atan2(const ::std::valarray<typename _Dom::valarray> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> atan2(const ::std::valarray<typename _Dom::valarray> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_BinClos< ::std::_Atan2, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v, __e()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename _Dom::value_type> atan2(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename _Dom::value_type> atan2(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_BinClos< ::std::_Atan2, ::std::_Expr, ::std::_Constant, _Dom, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> atan2(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> atan2(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_BinClos< ::std::_Atan2, ::std::_Constant, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__t, __e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, _Tp> atan2(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, _Tp> atan2(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    typedef ::std::_BinClos< ::std::_Atan2, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, _Tp> atan2(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, _Tp> atan2(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::_Atan2, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, _Tp> atan2(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Atan2, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, _Tp> atan2(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::_Atan2, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__t, __v));
  }
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename _Dom1::value_type> pow(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__e1, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__e2);
  template < typename _Dom1, typename _Dom2 >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2>, typename _Dom1::value_type> pow(const ::std::_Expr<_Dom1, typename _Dom1::value_type> &__e1, const ::std::_Expr<_Dom2, typename _Dom2::value_type> &__e2)
  {
    typedef typename _Dom1::value_type _Tp;
    typedef ::std::_BinClos< ::std::_Pow, ::std::_Expr, ::std::_Expr, _Dom1, _Dom2> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e1(), __e2()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename _Dom::value_type> pow(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_Expr, ::std::_ValArray, _Dom, typename _Dom::value_type>, typename _Dom::value_type> pow(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const ::std::valarray<typename _Dom::value_type> &__v)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_BinClos< ::std::_Pow, ::std::_Expr, ::std::_ValArray, _Dom, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e(), __v));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> pow(const ::std::valarray<typename _Dom::valarray> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_ValArray, ::std::_Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> pow(const ::std::valarray<typename _Dom::valarray> &__v, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_BinClos< ::std::_Pow, ::std::_ValArray, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v, __e()));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename _Dom::value_type> pow(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const typename _Dom::value_type &__t);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_Expr, ::std::_Constant, _Dom, typename _Dom::value_type>, typename _Dom::value_type> pow(const ::std::_Expr<_Dom, typename _Dom::value_type> &__e, const typename _Dom::value_type &__t)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_BinClos< ::std::_Pow, ::std::_Expr, ::std::_Constant, _Dom, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__e(), __t));
  }
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> pow(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e);
  template < typename _Dom >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_Constant, ::std::_Expr, typename _Dom::value_type, _Dom>, typename _Dom::value_type> pow(const typename _Dom::value_type &__t, const ::std::_Expr<_Dom, typename _Dom::value_type> &__e)
  {
    typedef typename _Dom::value_type _Tp;
    typedef ::std::_BinClos< ::std::_Pow, ::std::_Constant, ::std::_Expr, _Tp, _Dom> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__t, __e()));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, _Tp> pow(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, _Tp> pow(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    typedef ::std::_BinClos< ::std::_Pow, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, _Tp> pow(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, _Tp> pow(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::_Pow, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, _Tp> pow(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::_Pow, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, _Tp> pow(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::_Pow, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(__t, __v));
  }
 /* Instantiation of class template '::std::__fun< ::std::__unary_plus, unsigned long int>' */ 
 /* Instantiation of class template '::std::valarray<unsigned long int>::_UnaryOp< ::std::__unary_plus>' */ 
 /* Instantiation of class template '::std::__fun< ::std::__negate, unsigned long int>' */ 
 /* Instantiation of class template '::std::valarray<unsigned long int>::_UnaryOp< ::std::__negate>' */ 
 /* Instantiation of class template '::std::__fun< ::std::__bitwise_not, unsigned long int>' */ 
 /* Instantiation of class template '::std::valarray<unsigned long int>::_UnaryOp< ::std::__bitwise_not>' */ 
 /* Instantiation of class template '::std::__fun< ::std::__logical_not, unsigned long int>' */ 
 /* Instantiation of class template '::std::valarray<unsigned long int>::_UnaryOp< ::std::__logical_not>' */ 
 /* Instantiation of class template '::std::valarray<unsigned long int>' */ 
  class  gslice
  {
    public:
      inline gslice();
      inline gslice(::std::size_t __o, const ::std::valarray<unsigned long int> &__l, const ::std::valarray<unsigned long int> &__s);
      inline gslice(const ::std::gslice &__g);
      inline ~gslice();
      inline ::std::gslice &operator =(const ::std::gslice &__g);
      inline ::std::size_t start() const ;
      inline ::std::valarray<unsigned long int> size() const ;
      inline ::std::valarray<unsigned long int> stride() const ;
    private:
      struct  _Indexer
      {
          ::std::size_t _M_count;
          ::std::size_t _M_start;
          ::std::valarray<unsigned long int> _M_size;
          ::std::valarray<unsigned long int> _M_stride;
          ::std::valarray<unsigned long int> _M_index;
          inline _Indexer()
            : _M_count(1), _M_start(0), _M_size(), _M_stride(), _M_index()
          {
          }
          _Indexer(::std::size_t, const ::std::valarray<unsigned long int> &, const ::std::valarray<unsigned long int> &);
          inline void _M_increment_use()
          {
             ++(*this)._M_count;
          }
          inline ::std::size_t _M_decrement_use()
          {
            return  --(*this)._M_count;
          }
      };
      ::std::gslice::_Indexer *_M_index;
    template < typename _Tp >
    friend class ::std::valarray;
  };
  inline ::std::size_t gslice::start() const 
  {
    return (*this)._M_index ? (*(*this)._M_index)._M_start : 0;
  }
 /* Instantiation of class template '::std::slice_array<unsigned long int>' */ 
  inline ::std::valarray<unsigned long int> gslice::size() const 
  {
    return (*this)._M_index ? (*(*this)._M_index)._M_size : ::std::valarray<unsigned long int>();
  }
  inline ::std::valarray<unsigned long int> gslice::stride() const 
  {
    return (*this)._M_index ? (*(*this)._M_index)._M_stride : ::std::valarray<unsigned long int>();
  }
  inline gslice::gslice()
    : _M_index(new (::std::gslice::_Indexer)())
  {
  }
  inline gslice::gslice(::std::size_t __o, const ::std::valarray<unsigned long int> &__l, const ::std::valarray<unsigned long int> &__s)
    : _M_index(new (::std::gslice::_Indexer)((__o), (__l), (__s)))
  {
  }
  inline gslice::gslice(const ::std::gslice &__g)
    : _M_index(__g._M_index)
  {
    if ((*this)._M_index)
      {
        (*(*this)._M_index).::std::gslice::_Indexer::_M_increment_use();
      }
  }
  inline gslice::~gslice()
  {
    if ((*this)._M_index && (*(*this)._M_index).::std::gslice::_Indexer::_M_decrement_use() == 0)
      {
        delete (*this)._M_index;
      }
  }
  inline ::std::gslice &gslice::operator =(const ::std::gslice &__g)
  {
    if (__g._M_index)
      {
        (*__g._M_index).::std::gslice::_Indexer::_M_increment_use();
      }
    if ((*this)._M_index && (*(*this)._M_index).::std::gslice::_Indexer::_M_decrement_use() == 0)
      {
        delete (*this)._M_index;
      }
    (*this)._M_index = __g._M_index;
    return *this;
  }
  template < typename _Tp >
  class  gslice_array
  {
    public:
      typedef _Tp value_type;
      inline gslice_array(const ::std::gslice_array<_Tp> &__a);
      inline ::std::gslice_array<_Tp> &operator =(const ::std::gslice_array<_Tp> &__a);
      inline void operator =(const ::std::valarray<_Tp> &__v) const ;
      inline void operator *=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator /=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator %=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator +=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator -=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator ^=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator &=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator |=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator <<=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator >>=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator =(const _Tp &__t) const ;
      template < typename _Dom >
      inline void operator =(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator *=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator /=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator %=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator +=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator -=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator ^=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator &=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator |=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator <<=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator >>=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
    private:
      ::std::_Array<_Tp> _M_array;
      const ::std::valarray<unsigned long int> &_M_index;
      inline gslice_array(::std::_Array<_Tp> __a, const ::std::valarray<unsigned long int> &__i);
      gslice_array();
    friend class ::std::valarray<_Tp>;
  };
  template < typename _Tp >
  inline gslice_array<_Tp>::gslice_array(::std::_Array<_Tp> __a, const ::std::valarray<unsigned long int> &__i)
    : _M_array(__a), _M_index(__i)
  {
  }
  template < typename _Tp >
  inline gslice_array<_Tp>::gslice_array(const ::std::gslice_array<_Tp> &__a)
    : _M_array(__a._M_array), _M_index(__a._M_index)
  {
  }
  template < typename _Tp >
  inline ::std::gslice_array<_Tp> &gslice_array<_Tp>::operator =(const ::std::gslice_array<_Tp> &__a)
  {
    std::__valarray_copy(::std::_Array<_Tp>(__a._M_array), ::std::_Array<unsigned long int>(__a._M_index), ::std::gslice_array<_Tp>::_M_index.size(), ::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index));
    return *this;
  }
  template < typename _Tp >
  inline void gslice_array<_Tp>::operator =(const _Tp &__t) const 
  {
    std::__valarray_fill(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), ::std::gslice_array<_Tp>::_M_index.size(), __t);
  }
  template < typename _Tp >
  inline void gslice_array<_Tp>::operator =(const ::std::valarray<_Tp> &__v) const 
  {
    std::__valarray_copy(::std::_Array<_Tp>(__v), __v.size(), ::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index));
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void gslice_array<_Tp>::operator =(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    std::__valarray_copy(__e, ::std::gslice_array<_Tp>::_M_index.size(), ::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index));
  }
  template < typename _Tp >
  inline void gslice_array<_Tp>::operator *=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___multiplies(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void gslice_array<_Tp>::operator *=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___multiplies(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), __e, ::std::gslice_array<_Tp>::_M_index.size());
  }
  template < typename _Tp >
  inline void gslice_array<_Tp>::operator /=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___divides(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void gslice_array<_Tp>::operator /=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___divides(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), __e, ::std::gslice_array<_Tp>::_M_index.size());
  }
  template < typename _Tp >
  inline void gslice_array<_Tp>::operator %=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___modulus(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void gslice_array<_Tp>::operator %=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___modulus(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), __e, ::std::gslice_array<_Tp>::_M_index.size());
  }
  template < typename _Tp >
  inline void gslice_array<_Tp>::operator +=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___plus(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void gslice_array<_Tp>::operator +=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___plus(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), __e, ::std::gslice_array<_Tp>::_M_index.size());
  }
  template < typename _Tp >
  inline void gslice_array<_Tp>::operator -=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___minus(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void gslice_array<_Tp>::operator -=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___minus(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), __e, ::std::gslice_array<_Tp>::_M_index.size());
  }
  template < typename _Tp >
  inline void gslice_array<_Tp>::operator ^=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___bitwise_xor(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void gslice_array<_Tp>::operator ^=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___bitwise_xor(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), __e, ::std::gslice_array<_Tp>::_M_index.size());
  }
  template < typename _Tp >
  inline void gslice_array<_Tp>::operator &=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___bitwise_and(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void gslice_array<_Tp>::operator &=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___bitwise_and(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), __e, ::std::gslice_array<_Tp>::_M_index.size());
  }
  template < typename _Tp >
  inline void gslice_array<_Tp>::operator |=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___bitwise_or(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void gslice_array<_Tp>::operator |=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___bitwise_or(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), __e, ::std::gslice_array<_Tp>::_M_index.size());
  }
  template < typename _Tp >
  inline void gslice_array<_Tp>::operator <<=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___shift_left(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void gslice_array<_Tp>::operator <<=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___shift_left(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), __e, ::std::gslice_array<_Tp>::_M_index.size());
  }
  template < typename _Tp >
  inline void gslice_array<_Tp>::operator >>=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___shift_right(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void gslice_array<_Tp>::operator >>=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___shift_right(::std::gslice_array<_Tp>::_M_array, ::std::_Array<unsigned long int>(::std::gslice_array<_Tp>::_M_index), __e, ::std::gslice_array<_Tp>::_M_index.size());
  }
  template < typename _Tp >
  class  mask_array
  {
    public:
      typedef _Tp value_type;
      inline mask_array(const ::std::mask_array<_Tp> &a);
      inline ::std::mask_array<_Tp> &operator =(const ::std::mask_array<_Tp> &__a);
      inline void operator =(const ::std::valarray<_Tp> &__v) const ;
      inline void operator *=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator /=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator %=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator +=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator -=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator ^=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator &=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator |=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator <<=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator >>=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator =(const _Tp &__t) const ;
      template < typename _Dom >
      inline void operator =(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator *=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator /=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator %=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator +=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator -=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator ^=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator &=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator |=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator <<=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator >>=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
    private:
      inline mask_array(::std::_Array<_Tp> __a, ::std::size_t __s, ::std::_Array<bool> __m);
      const ::std::size_t _M_sz;
      const ::std::_Array<bool> _M_mask;
      const ::std::_Array<_Tp> _M_array;
      mask_array();
    friend class ::std::valarray<_Tp>;
  };
  template < typename _Tp >
  inline mask_array<_Tp>::mask_array(const ::std::mask_array<_Tp> &a)
    : _M_sz(a._M_sz), _M_mask(a._M_mask), _M_array(a._M_array)
  {
  }
  template < typename _Tp >
  inline mask_array<_Tp>::mask_array(::std::_Array<_Tp> __a, ::std::size_t __s, ::std::_Array<bool> __m)
    : _M_sz(__s), _M_mask(__m), _M_array(__a)
  {
  }
  template < typename _Tp >
  inline ::std::mask_array<_Tp> &mask_array<_Tp>::operator =(const ::std::mask_array<_Tp> &__a)
  {
    std::__valarray_copy(__a._M_array, __a._M_mask, ::std::mask_array<_Tp>::_M_sz, ::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask);
    return *this;
  }
  template < typename _Tp >
  inline void mask_array<_Tp>::operator =(const _Tp &__t) const 
  {
    std::__valarray_fill(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_sz, ::std::mask_array<_Tp>::_M_mask, __t);
  }
  template < typename _Tp >
  inline void mask_array<_Tp>::operator =(const ::std::valarray<_Tp> &__v) const 
  {
    std::__valarray_copy(::std::_Array<_Tp>(__v), __v.size(), ::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask);
  }
  template < typename _Tp >
  template < typename _Ex >
  inline void mask_array<_Tp>::operator =(const ::std::_Expr<_Ex, _Tp> &__e) const 
  {
    std::__valarray_copy(__e, __e.size(), ::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask);
  }
  template < typename _Tp >
  inline void mask_array<_Tp>::operator *=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___multiplies(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void mask_array<_Tp>::operator *=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___multiplies(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, __e, __e.size());
  }
  template < typename _Tp >
  inline void mask_array<_Tp>::operator /=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___divides(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void mask_array<_Tp>::operator /=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___divides(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, __e, __e.size());
  }
  template < typename _Tp >
  inline void mask_array<_Tp>::operator %=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___modulus(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void mask_array<_Tp>::operator %=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___modulus(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, __e, __e.size());
  }
  template < typename _Tp >
  inline void mask_array<_Tp>::operator +=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___plus(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void mask_array<_Tp>::operator +=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___plus(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, __e, __e.size());
  }
  template < typename _Tp >
  inline void mask_array<_Tp>::operator -=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___minus(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void mask_array<_Tp>::operator -=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___minus(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, __e, __e.size());
  }
  template < typename _Tp >
  inline void mask_array<_Tp>::operator ^=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___bitwise_xor(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void mask_array<_Tp>::operator ^=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___bitwise_xor(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, __e, __e.size());
  }
  template < typename _Tp >
  inline void mask_array<_Tp>::operator &=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___bitwise_and(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void mask_array<_Tp>::operator &=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___bitwise_and(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, __e, __e.size());
  }
  template < typename _Tp >
  inline void mask_array<_Tp>::operator |=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___bitwise_or(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void mask_array<_Tp>::operator |=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___bitwise_or(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, __e, __e.size());
  }
  template < typename _Tp >
  inline void mask_array<_Tp>::operator <<=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___shift_left(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void mask_array<_Tp>::operator <<=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___shift_left(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, __e, __e.size());
  }
  template < typename _Tp >
  inline void mask_array<_Tp>::operator >>=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___shift_right(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, ::std::_Array<_Tp>(__v), __v.size());
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void mask_array<_Tp>::operator >>=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___shift_right(::std::mask_array<_Tp>::_M_array, ::std::mask_array<_Tp>::_M_mask, __e, __e.size());
  }
  template < typename _Tp >
  class  indirect_array
  {
    public:
      typedef _Tp value_type;
      inline indirect_array(const ::std::indirect_array<_Tp> &__a);
      inline ::std::indirect_array<_Tp> &operator =(const ::std::indirect_array<_Tp> &__a);
      inline void operator =(const ::std::valarray<_Tp> &__v) const ;
      inline void operator *=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator /=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator %=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator +=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator -=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator ^=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator &=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator |=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator <<=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator >>=(const ::std::valarray<_Tp> &__v) const ;
      inline void operator =(const _Tp &__t) const ;
      template < typename _Dom >
      inline void operator =(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator *=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator /=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator %=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator +=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator -=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator ^=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator &=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator |=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator <<=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
      template < typename _Dom >
      inline void operator >>=(const ::std::_Expr<_Dom, _Tp> &__e) const ;
    private:
      inline indirect_array(::std::_Array<_Tp> __a, ::std::size_t __s, ::std::_Array<unsigned long int> __i);
      const ::std::size_t _M_sz;
      const ::std::_Array<unsigned long int> _M_index;
      const ::std::_Array<_Tp> _M_array;
      indirect_array();
    friend class ::std::valarray<_Tp>;
    friend class ::std::gslice_array<_Tp>;
  };
  template < typename _Tp >
  inline indirect_array<_Tp>::indirect_array(const ::std::indirect_array<_Tp> &__a)
    : _M_sz(__a._M_sz), _M_index(__a._M_index), _M_array(__a._M_array)
  {
  }
  template < typename _Tp >
  inline indirect_array<_Tp>::indirect_array(::std::_Array<_Tp> __a, ::std::size_t __s, ::std::_Array<unsigned long int> __i)
    : _M_sz(__s), _M_index(__i), _M_array(__a)
  {
  }
  template < typename _Tp >
  inline ::std::indirect_array<_Tp> &indirect_array<_Tp>::operator =(const ::std::indirect_array<_Tp> &__a)
  {
    std::__valarray_copy(__a._M_array, ::std::indirect_array<_Tp>::_M_sz, __a._M_index, ::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index);
    return *this;
  }
  template < typename _Tp >
  inline void indirect_array<_Tp>::operator =(const _Tp &__t) const 
  {
    std::__valarray_fill(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, ::std::indirect_array<_Tp>::_M_sz, __t);
  }
  template < typename _Tp >
  inline void indirect_array<_Tp>::operator =(const ::std::valarray<_Tp> &__v) const 
  {
    std::__valarray_copy(::std::_Array<_Tp>(__v), ::std::indirect_array<_Tp>::_M_sz, ::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index);
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void indirect_array<_Tp>::operator =(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    std::__valarray_copy(__e, ::std::indirect_array<_Tp>::_M_sz, ::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index);
  }
  template < typename _Tp >
  inline void indirect_array<_Tp>::operator *=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___multiplies(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, ::std::_Array<_Tp>(__v), ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void indirect_array<_Tp>::operator *=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___multiplies(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, __e, ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void indirect_array<_Tp>::operator /=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___divides(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, ::std::_Array<_Tp>(__v), ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void indirect_array<_Tp>::operator /=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___divides(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, __e, ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void indirect_array<_Tp>::operator %=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___modulus(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, ::std::_Array<_Tp>(__v), ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void indirect_array<_Tp>::operator %=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___modulus(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, __e, ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void indirect_array<_Tp>::operator +=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___plus(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, ::std::_Array<_Tp>(__v), ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void indirect_array<_Tp>::operator +=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___plus(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, __e, ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void indirect_array<_Tp>::operator -=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___minus(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, ::std::_Array<_Tp>(__v), ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void indirect_array<_Tp>::operator -=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___minus(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, __e, ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void indirect_array<_Tp>::operator ^=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___bitwise_xor(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, ::std::_Array<_Tp>(__v), ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void indirect_array<_Tp>::operator ^=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___bitwise_xor(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, __e, ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void indirect_array<_Tp>::operator &=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___bitwise_and(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, ::std::_Array<_Tp>(__v), ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void indirect_array<_Tp>::operator &=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___bitwise_and(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, __e, ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void indirect_array<_Tp>::operator |=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___bitwise_or(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, ::std::_Array<_Tp>(__v), ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void indirect_array<_Tp>::operator |=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___bitwise_or(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, __e, ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void indirect_array<_Tp>::operator <<=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___shift_left(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, ::std::_Array<_Tp>(__v), ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void indirect_array<_Tp>::operator <<=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___shift_left(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, __e, ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline void indirect_array<_Tp>::operator >>=(const ::std::valarray<_Tp> &__v) const 
  {
    _Array_augmented___shift_right(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, ::std::_Array<_Tp>(__v), ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  template < typename _Dom >
  inline void indirect_array<_Tp>::operator >>=(const ::std::_Expr<_Dom, _Tp> &__e) const 
  {
    _Array_augmented___shift_right(::std::indirect_array<_Tp>::_M_array, ::std::indirect_array<_Tp>::_M_index, __e, ::std::indirect_array<_Tp>::_M_sz);
  }
  template < typename _Tp >
  inline valarray<_Tp>::valarray()
    : _M_size(0), _M_data(0)
  {
  }
  template < typename _Tp >
  inline valarray<_Tp>::valarray(::std::size_t __n)
    : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))
  {
    std::__valarray_default_construct(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + __n);
  }
  template < typename _Tp >
  inline valarray<_Tp>::valarray(const _Tp &__t, ::std::size_t __n)
    : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))
  {
    std::__valarray_fill_construct(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + __n, __t);
  }
  template < typename _Tp >
  inline valarray<_Tp>::valarray(const _Tp *__restrict __p, ::std::size_t __n)
    : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))
  {
    ;
    std::__valarray_copy_construct(__p, __p + __n, ::std::valarray<_Tp>::_M_data);
  }
  template < typename _Tp >
  inline valarray<_Tp>::valarray(const ::std::valarray<_Tp> &__v)
    : _M_size(__v._M_size), _M_data(__valarray_get_storage<_Tp>(__v._M_size))
  {
    std::__valarray_copy_construct(__v._M_data, __v._M_data + ::std::valarray<_Tp>::_M_size, ::std::valarray<_Tp>::_M_data);
  }
  template < typename _Tp >
  inline valarray<_Tp>::valarray(::std::valarray<_Tp> &&__v) noexcept(true)
    : _M_size(__v._M_size), _M_data(__v._M_data)
  {
    __v._M_size = 0;
    __v._M_data = 0;
  }
  template < typename _Tp >
  inline valarray<_Tp>::valarray(const ::std::slice_array<_Tp> &__sa)
    : _M_size(__sa._M_sz), _M_data(__valarray_get_storage<_Tp>(__sa._M_sz))
  {
    std::__valarray_copy_construct(__sa._M_array, __sa._M_sz, __sa._M_stride, ::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data));
  }
  template < typename _Tp >
  inline valarray<_Tp>::valarray(const ::std::gslice_array<_Tp> &__ga)
    : _M_size(__ga._M_index.size()), _M_data(__valarray_get_storage<_Tp>(::std::valarray<_Tp>::_M_size))
  {
    std::__valarray_copy_construct(__ga._M_array, ::std::_Array<unsigned long int>(__ga._M_index), ::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size);
  }
  template < typename _Tp >
  inline valarray<_Tp>::valarray(const ::std::mask_array<_Tp> &__ma)
    : _M_size(__ma._M_sz), _M_data(__valarray_get_storage<_Tp>(__ma._M_sz))
  {
    std::__valarray_copy_construct(__ma._M_array, __ma._M_mask, ::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size);
  }
  template < typename _Tp >
  inline valarray<_Tp>::valarray(const ::std::indirect_array<_Tp> &__ia)
    : _M_size(__ia._M_sz), _M_data(__valarray_get_storage<_Tp>(__ia._M_sz))
  {
    std::__valarray_copy_construct(__ia._M_array, __ia._M_index, ::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size);
  }
  template < typename _Tp >
  inline valarray<_Tp>::valarray(::std::initializer_list<_Tp> __l)
    : _M_size(__l.size()), _M_data(__valarray_get_storage<_Tp>(__l.size()))
  {
    std::__valarray_copy_construct(__l.begin(), __l.end(), ::std::valarray<_Tp>::_M_data);
  }
  template < typename _Tp >
  template < typename _Dom >
  inline valarray<_Tp>::valarray(const ::std::_Expr<_Dom, _Tp> &__e)
    : _M_size(__e.size()), _M_data(__valarray_get_storage<_Tp>(::std::valarray<_Tp>::_M_size))
  {
    std::__valarray_copy_construct(__e, ::std::valarray<_Tp>::_M_size, ::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data));
  }
  template < typename _Tp >
  inline valarray<_Tp>::~valarray() noexcept(true)
  {
    std::__valarray_destroy_elements(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size);
    std::__valarray_release_memory(::std::valarray<_Tp>::_M_data);
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator =(const ::std::valarray<_Tp> &__v)
  {
    if (::std::valarray<_Tp>::_M_size == __v._M_size)
      {
        std::__valarray_copy(__v._M_data, ::std::valarray<_Tp>::_M_size, ::std::valarray<_Tp>::_M_data);
      }
    else
      {
        if (::std::valarray<_Tp>::_M_data)
          {
            std::__valarray_destroy_elements(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size);
            std::__valarray_release_memory(::std::valarray<_Tp>::_M_data);
          }
        ::std::valarray<_Tp>::_M_size = __v._M_size;
        ::std::valarray<_Tp>::_M_data = __valarray_get_storage<_Tp>(::std::valarray<_Tp>::_M_size);
        std::__valarray_copy_construct(__v._M_data, __v._M_data + ::std::valarray<_Tp>::_M_size, ::std::valarray<_Tp>::_M_data);
      }
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator =(::std::valarray<_Tp> &&__v) noexcept(true)
  {
    if (::std::valarray<_Tp>::_M_data)
      {
        std::__valarray_destroy_elements(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size);
        std::__valarray_release_memory(::std::valarray<_Tp>::_M_data);
      }
    ::std::valarray<_Tp>::_M_size = __v._M_size;
    ::std::valarray<_Tp>::_M_data = __v._M_data;
    __v._M_size = 0;
    __v._M_data = 0;
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator =(::std::initializer_list<_Tp> __l)
  {
    if (::std::valarray<_Tp>::_M_size == __l.size())
      {
        std::__valarray_copy(__l.begin(), __l.size(), ::std::valarray<_Tp>::_M_data);
      }
    else
      {
        if (::std::valarray<_Tp>::_M_data)
          {
            std::__valarray_destroy_elements(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size);
            std::__valarray_release_memory(::std::valarray<_Tp>::_M_data);
          }
        ::std::valarray<_Tp>::_M_size = __l.size();
        ::std::valarray<_Tp>::_M_data = __valarray_get_storage<_Tp>(::std::valarray<_Tp>::_M_size);
        std::__valarray_copy_construct(__l.begin(), __l.begin() + ::std::valarray<_Tp>::_M_size, ::std::valarray<_Tp>::_M_data);
      }
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator =(const _Tp &__t)
  {
    std::__valarray_fill(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_size, __t);
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator =(const ::std::slice_array<_Tp> &__sa)
  {
    ;
    std::__valarray_copy(__sa._M_array, __sa._M_sz, __sa._M_stride, ::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data));
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator =(const ::std::gslice_array<_Tp> &__ga)
  {
    ;
    std::__valarray_copy(__ga._M_array, ::std::_Array<unsigned long int>(__ga._M_index), ::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size);
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator =(const ::std::mask_array<_Tp> &__ma)
  {
    ;
    std::__valarray_copy(__ma._M_array, __ma._M_mask, ::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size);
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator =(const ::std::indirect_array<_Tp> &__ia)
  {
    ;
    std::__valarray_copy(__ia._M_array, __ia._M_index, ::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size);
    return *this;
  }
  template < typename _Tp >
  template < typename _Dom >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator =(const ::std::_Expr<_Dom, _Tp> &__e)
  {
    if (::std::valarray<_Tp>::_M_size == __e.size())
      {
        std::__valarray_copy(__e, ::std::valarray<_Tp>::_M_size, ::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data));
      }
    else
      {
        if (::std::valarray<_Tp>::_M_data)
          {
            std::__valarray_destroy_elements(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size);
            std::__valarray_release_memory(::std::valarray<_Tp>::_M_data);
          }
        ::std::valarray<_Tp>::_M_size = __e.size();
        ::std::valarray<_Tp>::_M_data = __valarray_get_storage<_Tp>(::std::valarray<_Tp>::_M_size);
        std::__valarray_copy_construct(__e, ::std::valarray<_Tp>::_M_size, ::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data));
      }
    return *this;
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_SClos< ::std::_ValArray, _Tp>, _Tp> valarray<_Tp>::operator [](::std::slice __s) const 
  {
    typedef ::std::_SClos< ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __s));
  }
  template < typename _Tp >
  inline ::std::slice_array<_Tp> valarray<_Tp>::operator [](::std::slice __s)
  {
    return ::std::slice_array<_Tp>(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __s);
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_GClos< ::std::_ValArray, _Tp>, _Tp> valarray<_Tp>::operator [](const ::std::gslice &__gs) const 
  {
    typedef ::std::_GClos< ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), (*__gs._M_index)._M_index));
  }
  template < typename _Tp >
  inline ::std::gslice_array<_Tp> valarray<_Tp>::operator [](const ::std::gslice &__gs)
  {
    return ::std::gslice_array<_Tp>(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), (*__gs._M_index)._M_index);
  }
 /* Instantiation of class template '::std::__fun< ::std::__unary_plus, bool>' */ 
 /* Instantiation of class template '::std::valarray<bool>::_UnaryOp< ::std::__unary_plus>' */ 
 /* Instantiation of class template '::std::__fun< ::std::__negate, bool>' */ 
 /* Instantiation of class template '::std::valarray<bool>::_UnaryOp< ::std::__negate>' */ 
 /* Instantiation of class template '::std::__fun< ::std::__bitwise_not, bool>' */ 
 /* Instantiation of class template '::std::valarray<bool>::_UnaryOp< ::std::__bitwise_not>' */ 
 /* Instantiation of class template '::std::__fun< ::std::__logical_not, bool>' */ 
 /* Instantiation of class template '::std::valarray<bool>::_UnaryOp< ::std::__logical_not>' */ 
 /* Instantiation of class template '::std::valarray<bool>' */ 
  template < typename _Tp >
  inline ::std::valarray<_Tp> valarray<_Tp>::operator [](const ::std::valarray<bool> &__m) const 
  {
    ::std::size_t __s(0);
    ::std::size_t __e(__m.::std::valarray<bool>::size());
    for (::std::size_t __i(0); __i < __e;  ++__i)
      {
        if (__m.::std::valarray<bool>::operator [](__i))
          {
             ++__s;
          }
      }
    return ::std::valarray<_Tp>(::std::mask_array<_Tp>(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __s, ::std::_Array<bool>(__m)));
  }
  template < typename _Tp >
  inline ::std::mask_array<_Tp> valarray<_Tp>::operator [](const ::std::valarray<bool> &__m)
  {
    ::std::size_t __s(0);
    ::std::size_t __e(__m.::std::valarray<bool>::size());
    for (::std::size_t __i(0); __i < __e;  ++__i)
      {
        if (__m.::std::valarray<bool>::operator [](__i))
          {
             ++__s;
          }
      }
    return ::std::mask_array<_Tp>(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __s, ::std::_Array<bool>(__m));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_IClos< ::std::_ValArray, _Tp>, _Tp> valarray<_Tp>::operator [](const ::std::valarray<unsigned long int> &__i) const 
  {
    typedef ::std::_IClos< ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(*this, __i));
  }
  template < typename _Tp >
  inline ::std::indirect_array<_Tp> valarray<_Tp>::operator [](const ::std::valarray<unsigned long int> &__i)
  {
    return ::std::indirect_array<_Tp>(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __i.::std::valarray<unsigned long int>::size(), ::std::_Array<unsigned long int>(__i));
  }
  template < typename _Tp >
  inline void valarray<_Tp>::swap(::std::valarray<_Tp> &__v) noexcept(true)
  {
    std::swap(::std::valarray<_Tp>::_M_size, __v._M_size);
    std::swap(::std::valarray<_Tp>::_M_data, __v._M_data);
  }
  template < typename _Tp >
  inline ::std::size_t valarray<_Tp>::size() const 
  {
    return ::std::valarray<_Tp>::_M_size;
  }
  template < typename _Tp >
  inline _Tp valarray<_Tp>::sum() const 
  {
    ;
    return std::__valarray_sum(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size);
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> valarray<_Tp>::shift(int __n) const 
  {
    ::std::valarray<_Tp> __ret;
    if (::std::valarray<_Tp>::_M_size == 0)
      {
        return __ret;
      }
    _Tp *__restrict __tmp_M_data = std::__valarray_get_storage<_Tp>(::std::valarray<_Tp>::_M_size);
    if (__n == 0)
      {
        std::__valarray_copy_construct(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size, __tmp_M_data);
      }
    else
      {
        if (__n > 0)
          {
            if ((::std::size_t)__n > ::std::valarray<_Tp>::_M_size)
              {
                __n = int(::std::valarray<_Tp>::_M_size);
              }
            std::__valarray_copy_construct(::std::valarray<_Tp>::_M_data + __n, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size, __tmp_M_data);
            std::__valarray_default_construct(__tmp_M_data + ::std::valarray<_Tp>::_M_size - __n, __tmp_M_data + ::std::valarray<_Tp>::_M_size);
          }
        else
          {
            if ( -((::std::size_t)__n) > ::std::valarray<_Tp>::_M_size)
              {
                __n =  -int(::std::valarray<_Tp>::_M_size);
              }
            std::__valarray_copy_construct(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size + __n, __tmp_M_data - __n);
            std::__valarray_default_construct(__tmp_M_data, __tmp_M_data - __n);
          }
      }
    __ret._M_size = ::std::valarray<_Tp>::_M_size;
    __ret._M_data = __tmp_M_data;
    return __ret;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> valarray<_Tp>::cshift(int __n) const 
  {
    ::std::valarray<_Tp> __ret;
    if (::std::valarray<_Tp>::_M_size == 0)
      {
        return __ret;
      }
    _Tp *__restrict __tmp_M_data = std::__valarray_get_storage<_Tp>(::std::valarray<_Tp>::_M_size);
    if (__n == 0)
      {
        std::__valarray_copy_construct(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size, __tmp_M_data);
      }
    else
      {
        if (__n > 0)
          {
            if ((::std::size_t)__n > ::std::valarray<_Tp>::_M_size)
              {
                __n = int(__n % ::std::valarray<_Tp>::_M_size);
              }
            std::__valarray_copy_construct(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + __n, __tmp_M_data + ::std::valarray<_Tp>::_M_size - __n);
            std::__valarray_copy_construct(::std::valarray<_Tp>::_M_data + __n, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size, __tmp_M_data);
          }
        else
          {
            if ( -((::std::size_t)__n) > ::std::valarray<_Tp>::_M_size)
              {
                __n =  -int( -((::std::size_t)__n) % ::std::valarray<_Tp>::_M_size);
              }
            std::__valarray_copy_construct(::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size + __n, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size, __tmp_M_data);
            std::__valarray_copy_construct(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size + __n, __tmp_M_data - __n);
          }
      }
    __ret._M_size = ::std::valarray<_Tp>::_M_size;
    __ret._M_data = __tmp_M_data;
    return __ret;
  }
  template < typename _Tp >
  inline void valarray<_Tp>::resize(::std::size_t __n, _Tp __c)
  {
    std::__valarray_destroy_elements(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size);
    if (::std::valarray<_Tp>::_M_size != __n)
      {
        std::__valarray_release_memory(::std::valarray<_Tp>::_M_data);
        ::std::valarray<_Tp>::_M_size = __n;
        ::std::valarray<_Tp>::_M_data = __valarray_get_storage<_Tp>(__n);
      }
    std::__valarray_fill_construct(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + __n, __c);
  }
  template < typename _Tp >
  inline _Tp valarray<_Tp>::min() const 
  {
    ;
    return *std::min_element(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size);
  }
  template < typename _Tp >
  inline _Tp valarray<_Tp>::max() const 
  {
    ;
    return *std::max_element(::std::valarray<_Tp>::_M_data, ::std::valarray<_Tp>::_M_data + ::std::valarray<_Tp>::_M_size);
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_ValFunClos< ::std::_ValArray, _Tp>, _Tp> valarray<_Tp>::apply(_Tp (*func)(_Tp)) const 
  {
    typedef ::std::_ValFunClos< ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(*this, func));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_RefFunClos< ::std::_ValArray, _Tp>, _Tp> valarray<_Tp>::apply(_Tp (*func)(const _Tp &)) const 
  {
    typedef ::std::_RefFunClos< ::std::_ValArray, _Tp> _Closure;
    return ::std::_Expr<_Closure, _Tp>(_Closure(*this, func));
  }
  template < typename _Tp >
  inline typename ::std::valarray<_Tp>::template _UnaryOp< ::std::__unary_plus>::_Rt valarray<_Tp>::operator +() const 
  {
    typedef ::std::_UnClos< ::std::__unary_plus, ::std::_ValArray, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__unary_plus, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(*this));
  }
  template < typename _Tp >
  inline typename ::std::valarray<_Tp>::template _UnaryOp< ::std::__negate>::_Rt valarray<_Tp>::operator -() const 
  {
    typedef ::std::_UnClos< ::std::__negate, ::std::_ValArray, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__negate, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(*this));
  }
  template < typename _Tp >
  inline typename ::std::valarray<_Tp>::template _UnaryOp< ::std::__bitwise_not>::_Rt valarray<_Tp>::operator ~() const 
  {
    typedef ::std::_UnClos< ::std::__bitwise_not, ::std::_ValArray, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__bitwise_not, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(*this));
  }
  template < typename _Tp >
  inline typename ::std::valarray<_Tp>::template _UnaryOp< ::std::__logical_not>::_Rt valarray<_Tp>::operator !() const 
  {
    typedef ::std::_UnClos< ::std::__logical_not, ::std::_ValArray, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__logical_not, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(*this));
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator +=(const _Tp &__t)
  {
    _Array_augmented___plus(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, __t);
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator +=(const ::std::valarray<_Tp> &__v)
  {
    ;
    _Array_augmented___plus(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, ::std::_Array<_Tp>(__v._M_data));
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator -=(const _Tp &__t)
  {
    _Array_augmented___minus(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, __t);
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator -=(const ::std::valarray<_Tp> &__v)
  {
    ;
    _Array_augmented___minus(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, ::std::_Array<_Tp>(__v._M_data));
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator *=(const _Tp &__t)
  {
    _Array_augmented___multiplies(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, __t);
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator *=(const ::std::valarray<_Tp> &__v)
  {
    ;
    _Array_augmented___multiplies(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, ::std::_Array<_Tp>(__v._M_data));
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator /=(const _Tp &__t)
  {
    _Array_augmented___divides(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, __t);
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator /=(const ::std::valarray<_Tp> &__v)
  {
    ;
    _Array_augmented___divides(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, ::std::_Array<_Tp>(__v._M_data));
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator %=(const _Tp &__t)
  {
    _Array_augmented___modulus(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, __t);
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator %=(const ::std::valarray<_Tp> &__v)
  {
    ;
    _Array_augmented___modulus(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, ::std::_Array<_Tp>(__v._M_data));
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator ^=(const _Tp &__t)
  {
    _Array_augmented___bitwise_xor(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, __t);
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator ^=(const ::std::valarray<_Tp> &__v)
  {
    ;
    _Array_augmented___bitwise_xor(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, ::std::_Array<_Tp>(__v._M_data));
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator &=(const _Tp &__t)
  {
    _Array_augmented___bitwise_and(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, __t);
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator &=(const ::std::valarray<_Tp> &__v)
  {
    ;
    _Array_augmented___bitwise_and(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, ::std::_Array<_Tp>(__v._M_data));
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator |=(const _Tp &__t)
  {
    _Array_augmented___bitwise_or(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, __t);
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator |=(const ::std::valarray<_Tp> &__v)
  {
    ;
    _Array_augmented___bitwise_or(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, ::std::_Array<_Tp>(__v._M_data));
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator <<=(const _Tp &__t)
  {
    _Array_augmented___shift_left(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, __t);
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator <<=(const ::std::valarray<_Tp> &__v)
  {
    ;
    _Array_augmented___shift_left(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, ::std::_Array<_Tp>(__v._M_data));
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator >>=(const _Tp &__t)
  {
    _Array_augmented___shift_right(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, __t);
    return *this;
  }
  template < typename _Tp >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator >>=(const ::std::valarray<_Tp> &__v)
  {
    ;
    _Array_augmented___shift_right(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), ::std::valarray<_Tp>::_M_size, ::std::_Array<_Tp>(__v._M_data));
    return *this;
  }
  template < typename _Tp >
  template < typename _Dom >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator +=(const ::std::_Expr<_Dom, _Tp> &__e)
  {
    _Array_augmented___plus(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __e, ::std::valarray<_Tp>::_M_size);
    return *this;
  }
  template < typename _Tp >
  template < typename _Dom >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator -=(const ::std::_Expr<_Dom, _Tp> &__e)
  {
    _Array_augmented___minus(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __e, ::std::valarray<_Tp>::_M_size);
    return *this;
  }
  template < typename _Tp >
  template < typename _Dom >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator *=(const ::std::_Expr<_Dom, _Tp> &__e)
  {
    _Array_augmented___multiplies(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __e, ::std::valarray<_Tp>::_M_size);
    return *this;
  }
  template < typename _Tp >
  template < typename _Dom >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator /=(const ::std::_Expr<_Dom, _Tp> &__e)
  {
    _Array_augmented___divides(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __e, ::std::valarray<_Tp>::_M_size);
    return *this;
  }
  template < typename _Tp >
  template < typename _Dom >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator %=(const ::std::_Expr<_Dom, _Tp> &__e)
  {
    _Array_augmented___modulus(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __e, ::std::valarray<_Tp>::_M_size);
    return *this;
  }
  template < typename _Tp >
  template < typename _Dom >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator ^=(const ::std::_Expr<_Dom, _Tp> &__e)
  {
    _Array_augmented___bitwise_xor(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __e, ::std::valarray<_Tp>::_M_size);
    return *this;
  }
  template < typename _Tp >
  template < typename _Dom >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator &=(const ::std::_Expr<_Dom, _Tp> &__e)
  {
    _Array_augmented___bitwise_and(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __e, ::std::valarray<_Tp>::_M_size);
    return *this;
  }
  template < typename _Tp >
  template < typename _Dom >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator |=(const ::std::_Expr<_Dom, _Tp> &__e)
  {
    _Array_augmented___bitwise_or(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __e, ::std::valarray<_Tp>::_M_size);
    return *this;
  }
  template < typename _Tp >
  template < typename _Dom >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator <<=(const ::std::_Expr<_Dom, _Tp> &__e)
  {
    _Array_augmented___shift_left(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __e, ::std::valarray<_Tp>::_M_size);
    return *this;
  }
  template < typename _Tp >
  template < typename _Dom >
  inline ::std::valarray<_Tp> &valarray<_Tp>::operator >>=(const ::std::_Expr<_Dom, _Tp> &__e)
  {
    _Array_augmented___shift_right(::std::_Array<_Tp>(::std::valarray<_Tp>::_M_data), __e, ::std::valarray<_Tp>::_M_size);
    return *this;
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__plus, _Tp>::result_type> operator +(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__plus, _Tp>::result_type> operator +(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__plus, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__plus, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__plus, _Tp>::result_type> operator +(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__plus, _Tp>::result_type> operator +(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__plus, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__plus, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__plus, _Tp>::result_type> operator +(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__plus, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__plus, _Tp>::result_type> operator +(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__plus, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__plus, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__minus, _Tp>::result_type> operator -(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__minus, _Tp>::result_type> operator -(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__minus, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__minus, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__minus, _Tp>::result_type> operator -(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__minus, _Tp>::result_type> operator -(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__minus, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__minus, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__minus, _Tp>::result_type> operator -(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__minus, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__minus, _Tp>::result_type> operator -(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__minus, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__minus, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__multiplies, _Tp>::result_type> operator *(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__multiplies, _Tp>::result_type> operator *(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__multiplies, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__multiplies, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__multiplies, _Tp>::result_type> operator *(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__multiplies, _Tp>::result_type> operator *(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__multiplies, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__multiplies, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__multiplies, _Tp>::result_type> operator *(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__multiplies, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__multiplies, _Tp>::result_type> operator *(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__multiplies, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__multiplies, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__divides, _Tp>::result_type> operator /(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__divides, _Tp>::result_type> operator /(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__divides, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__divides, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__divides, _Tp>::result_type> operator /(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__divides, _Tp>::result_type> operator /(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__divides, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__divides, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__divides, _Tp>::result_type> operator /(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__divides, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__divides, _Tp>::result_type> operator /(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__divides, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__divides, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__modulus, _Tp>::result_type> operator %(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__modulus, _Tp>::result_type> operator %(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__modulus, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__modulus, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__modulus, _Tp>::result_type> operator %(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__modulus, _Tp>::result_type> operator %(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__modulus, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__modulus, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__modulus, _Tp>::result_type> operator %(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__modulus, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__modulus, _Tp>::result_type> operator %(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__modulus, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__modulus, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_xor, _Tp>::result_type> operator ^(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_xor, _Tp>::result_type> operator ^(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__bitwise_xor, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__bitwise_xor, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_xor, _Tp>::result_type> operator ^(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_xor, _Tp>::result_type> operator ^(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__bitwise_xor, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__bitwise_xor, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_xor, _Tp>::result_type> operator ^(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_xor, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_xor, _Tp>::result_type> operator ^(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__bitwise_xor, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__bitwise_xor, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_and, _Tp>::result_type> operator &(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_and, _Tp>::result_type> operator &(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__bitwise_and, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__bitwise_and, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_and, _Tp>::result_type> operator &(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_and, _Tp>::result_type> operator &(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__bitwise_and, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__bitwise_and, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_and, _Tp>::result_type> operator &(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_and, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_and, _Tp>::result_type> operator &(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__bitwise_and, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__bitwise_and, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_or, _Tp>::result_type> operator |(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_or, _Tp>::result_type> operator |(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__bitwise_or, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__bitwise_or, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_or, _Tp>::result_type> operator |(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_or, _Tp>::result_type> operator |(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__bitwise_or, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__bitwise_or, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_or, _Tp>::result_type> operator |(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__bitwise_or, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__bitwise_or, _Tp>::result_type> operator |(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__bitwise_or, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__bitwise_or, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__shift_left, _Tp>::result_type> operator <<(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__shift_left, _Tp>::result_type> operator <<(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__shift_left, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__shift_left, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__shift_left, _Tp>::result_type> operator <<(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__shift_left, _Tp>::result_type> operator <<(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__shift_left, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__shift_left, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__shift_left, _Tp>::result_type> operator <<(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_left, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__shift_left, _Tp>::result_type> operator <<(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__shift_left, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__shift_left, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__shift_right, _Tp>::result_type> operator >>(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__shift_right, _Tp>::result_type> operator >>(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__shift_right, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__shift_right, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__shift_right, _Tp>::result_type> operator >>(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__shift_right, _Tp>::result_type> operator >>(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__shift_right, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__shift_right, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__shift_right, _Tp>::result_type> operator >>(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__shift_right, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__shift_right, _Tp>::result_type> operator >>(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__shift_right, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__shift_right, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__logical_and, _Tp>::result_type> operator &&(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__logical_and, _Tp>::result_type> operator &&(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__logical_and, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__logical_and, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__logical_and, _Tp>::result_type> operator &&(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__logical_and, _Tp>::result_type> operator &&(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__logical_and, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__logical_and, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__logical_and, _Tp>::result_type> operator &&(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_and, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__logical_and, _Tp>::result_type> operator &&(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__logical_and, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__logical_and, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__logical_or, _Tp>::result_type> operator ||(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__logical_or, _Tp>::result_type> operator ||(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__logical_or, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__logical_or, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__logical_or, _Tp>::result_type> operator ||(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__logical_or, _Tp>::result_type> operator ||(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__logical_or, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__logical_or, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__logical_or, _Tp>::result_type> operator ||(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__logical_or, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__logical_or, _Tp>::result_type> operator ||(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__logical_or, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__logical_or, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__equal_to, _Tp>::result_type> operator ==(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__equal_to, _Tp>::result_type> operator ==(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__equal_to, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__equal_to, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__equal_to, _Tp>::result_type> operator ==(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__equal_to, _Tp>::result_type> operator ==(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__equal_to, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__equal_to, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__equal_to, _Tp>::result_type> operator ==(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__equal_to, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__equal_to, _Tp>::result_type> operator ==(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__equal_to, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__equal_to, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__not_equal_to, _Tp>::result_type> operator !=(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__not_equal_to, _Tp>::result_type> operator !=(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__not_equal_to, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__not_equal_to, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__not_equal_to, _Tp>::result_type> operator !=(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__not_equal_to, _Tp>::result_type> operator !=(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__not_equal_to, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__not_equal_to, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__not_equal_to, _Tp>::result_type> operator !=(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__not_equal_to, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__not_equal_to, _Tp>::result_type> operator !=(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__not_equal_to, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__not_equal_to, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__less, _Tp>::result_type> operator <(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__less, _Tp>::result_type> operator <(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__less, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__less, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__less, _Tp>::result_type> operator <(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__less, _Tp>::result_type> operator <(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__less, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__less, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__less, _Tp>::result_type> operator <(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__less, _Tp>::result_type> operator <(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__less, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__less, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__greater, _Tp>::result_type> operator >(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__greater, _Tp>::result_type> operator >(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__greater, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__greater, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__greater, _Tp>::result_type> operator >(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__greater, _Tp>::result_type> operator >(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__greater, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__greater, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__greater, _Tp>::result_type> operator >(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__greater, _Tp>::result_type> operator >(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__greater, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__greater, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__less_equal, _Tp>::result_type> operator <=(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__less_equal, _Tp>::result_type> operator <=(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__less_equal, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__less_equal, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__less_equal, _Tp>::result_type> operator <=(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__less_equal, _Tp>::result_type> operator <=(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__less_equal, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__less_equal, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__less_equal, _Tp>::result_type> operator <=(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__less_equal, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__less_equal, _Tp>::result_type> operator <=(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__less_equal, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__less_equal, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__greater_equal, _Tp>::result_type> operator >=(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__greater_equal, _Tp>::result_type> operator >=(const ::std::valarray<_Tp> &__v, const ::std::valarray<_Tp> &__w)
  {
    ;
    typedef ::std::_BinClos< ::std::__greater_equal, ::std::_ValArray, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__greater_equal, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __w));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__greater_equal, _Tp>::result_type> operator >=(const ::std::valarray<_Tp> &__v, const _Tp &__t);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_ValArray, ::std::_Constant, _Tp, _Tp>, typename ::std::__fun< ::std::__greater_equal, _Tp>::result_type> operator >=(const ::std::valarray<_Tp> &__v, const _Tp &__t)
  {
    typedef ::std::_BinClos< ::std::__greater_equal, ::std::_ValArray, ::std::_Constant, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__greater_equal, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__v, __t));
  }
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__greater_equal, _Tp>::result_type> operator >=(const _Tp &__t, const ::std::valarray<_Tp> &__v);
  template < typename _Tp >
  inline ::std::_Expr< ::std::_BinClos< ::std::__greater_equal, ::std::_Constant, ::std::_ValArray, _Tp, _Tp>, typename ::std::__fun< ::std::__greater_equal, _Tp>::result_type> operator >=(const _Tp &__t, const ::std::valarray<_Tp> &__v)
  {
    typedef ::std::_BinClos< ::std::__greater_equal, ::std::_Constant, ::std::_ValArray, _Tp, _Tp> _Closure;
    typedef typename ::std::__fun< ::std::__greater_equal, _Tp>::result_type _Rt;
    return ::std::_Expr<_Closure, _Rt>(_Closure(__t, __v));
  }
  template < typename _Tp >
  inline _Tp *begin(::std::valarray<_Tp> &__va);
  template < typename _Tp >
  inline _Tp *begin(::std::valarray<_Tp> &__va)
  {
    return std::__addressof(__va[0]);
  }
  template < typename _Tp >
  inline const _Tp *begin(const ::std::valarray<_Tp> &__va);
  template < typename _Tp >
  inline const _Tp *begin(const ::std::valarray<_Tp> &__va)
  {
    return std::__addressof(__va[0]);
  }
  template < typename _Tp >
  inline _Tp *end(::std::valarray<_Tp> &__va);
  template < typename _Tp >
  inline _Tp *end(::std::valarray<_Tp> &__va)
  {
    return std::__addressof(__va[0]) + __va.size();
  }
  template < typename _Tp >
  inline const _Tp *end(const ::std::valarray<_Tp> &__va);
  template < typename _Tp >
  inline const _Tp *end(const ::std::valarray<_Tp> &__va)
  {
    return std::__addressof(__va[0]) + __va.size();
  }
}
namespace boost {
  namespace serialization {
    namespace detail {
      template < typename T, typename Allocator >
      T *get_data(::std::vector<T, Allocator> &v);
      template < typename T, typename Allocator >
      T *get_data(::std::vector<T, Allocator> &v)
      {
        return v.empty() ? 0 : &v[0];
      }
      template < typename T, typename Allocator >
      T *get_data(const ::std::vector<T, Allocator> &v);
      template < typename T, typename Allocator >
      T *get_data(const ::std::vector<T, Allocator> &v)
      {
        return get_data(const_cast< ::std::vector<T, Allocator> &>(v));
      }
      template < typename T >
      T *get_data(::std::valarray<T> &v);
      template < typename T >
      T *get_data(::std::valarray<T> &v)
      {
        return v.size() == 0 ? 0 : &v[0];
      }
      template < typename T >
      const T *get_data(const ::std::valarray<T> &v);
      template < typename T >
      const T *get_data(const ::std::valarray<T> &v)
      {
        return get_data(const_cast< ::std::valarray<T> &>(v));
      }
    }
    template < typename Archive, typename U, typename Allocator >
    inline void save(Archive &ar, const ::std::vector<U, Allocator> &t, const unsigned int, ::mpl_::false_);
    template < typename Archive, typename U, typename Allocator >
    inline void save(Archive &ar, const ::std::vector<U, Allocator> &t, const unsigned int, ::mpl_::false_)
    {
      boost::serialization::stl::save_collection<Archive, ::std::vector<U, Allocator> >(ar, t);
    }
    template < typename Archive, typename U, typename Allocator >
    inline void load(Archive &ar, ::std::vector<U, Allocator> &t, const unsigned int, ::mpl_::false_);
    template < typename Archive, typename U, typename Allocator >
    inline void load(Archive &ar, ::std::vector<U, Allocator> &t, const unsigned int, ::mpl_::false_)
    {
      boost::serialization::stl::load_collection<Archive, ::std::vector<U, Allocator>, ::boost::serialization::stl::archive_input_seq<Archive, ::std::vector<U, Allocator> >, ::boost::serialization::stl::reserve_imp< ::std::vector<U, Allocator> > >(ar, t);
    }
 /* Instantiation of class template '::std::pair<const char *, const ::boost::serialization::collection_size_type *>' */ 
 /* Instantiation of class template '::boost::serialization::traits<const ::boost::serialization::nvp<const ::boost::serialization::collection_size_type>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp<const ::boost::serialization::collection_size_type> >, ::mpl_::bool_<true> >' */ 
 /* Instantiation of class template '::boost::serialization::wrapper_traits<const ::boost::serialization::nvp<const ::boost::serialization::collection_size_type>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp<const ::boost::serialization::collection_size_type> > >' */ 
 /* Instantiation of class template '::boost::serialization::nvp<const ::boost::serialization::collection_size_type>' */ 
    template < typename Archive, typename U, typename Allocator >
    inline void save(Archive &ar, const ::std::vector<U, Allocator> &t, const unsigned int, ::mpl_::true_);
    template < typename Archive, typename U, typename Allocator >
    inline void save(Archive &ar, const ::std::vector<U, Allocator> &t, const unsigned int, ::mpl_::true_)
    {
      const ::boost::serialization::collection_size_type count(t.size());
      ar << boost::serialization::make_nvp("count", count);
      if (!t.empty())
        {
          ar << make_array(detail::get_data(t), t.size());
        }
    }
 /* Instantiation of class template '::std::pair<const char *, unsigned int *>' */ 
 /* Instantiation of class template '::boost::serialization::traits<const ::boost::serialization::nvp<unsigned int>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp<unsigned int> >, ::mpl_::bool_<true> >' */ 
 /* Instantiation of class template '::boost::serialization::wrapper_traits<const ::boost::serialization::nvp<unsigned int>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp<unsigned int> > >' */ 
 /* Instantiation of class template '::boost::serialization::nvp<unsigned int>' */ 
    template < typename Archive, typename U, typename Allocator >
    inline void load(Archive &ar, ::std::vector<U, Allocator> &t, const unsigned int, ::mpl_::true_);
    template < typename Archive, typename U, typename Allocator >
    inline void load(Archive &ar, ::std::vector<U, Allocator> &t, const unsigned int, ::mpl_::true_)
    {
      ::boost::serialization::collection_size_type count(t.size());
      ar >> boost::serialization::make_nvp("count", count);
      t.resize(count);
      unsigned int item_version(0);
      if (ar.get_library_version() == 4 || ar.get_library_version() == 5)
        {
          ar >> boost::serialization::make_nvp("item_version", item_version);
        }
      if (!t.empty())
        {
          ar >> make_array(detail::get_data(t), t.size());
        }
    }
    template < typename Archive, typename U, typename Allocator >
    inline void save(Archive &ar, const ::std::vector<U, Allocator> &t, const unsigned int file_version);
    template < typename Archive, typename U, typename Allocator >
    inline void save(Archive &ar, const ::std::vector<U, Allocator> &t, const unsigned int file_version)
    {
      typedef typename ::boost::serialization::use_array_optimization<Archive>::template apply< typename ::boost::remove_const<U>::type>::type use_optimized;
      save(ar, t, file_version, use_optimized());
    }
    template < typename Archive, typename U, typename Allocator >
    inline void load(Archive &ar, ::std::vector<U, Allocator> &t, const unsigned int file_version);
    template < typename Archive, typename U, typename Allocator >
    inline void load(Archive &ar, ::std::vector<U, Allocator> &t, const unsigned int file_version)
    {
      typedef typename ::boost::serialization::use_array_optimization<Archive>::template apply< typename ::boost::remove_const<U>::type>::type use_optimized;
      load(ar, t, file_version, use_optimized());
    }
    template < typename Archive, typename U, typename Allocator >
    inline void serialize(Archive &ar, ::std::vector<U, Allocator> &t, const unsigned int file_version);
    template < typename Archive, typename U, typename Allocator >
    inline void serialize(Archive &ar, ::std::vector<U, Allocator> &t, const unsigned int file_version)
    {
      boost::serialization::split_free(ar, t, file_version);
    }
 /* Instantiation of class template '::__gnu_cxx::new_allocator<bool>' */ 
 /* Instantiation of class template '::std::allocator<bool>' */ 
 /* Instantiation of class template '::std::allocator<bool>::rebind<unsigned long int>' */ 
 /* Instantiation of class template '::__gnu_cxx::new_allocator<unsigned long int>' */ 
 /* Instantiation of class template '::std::allocator<unsigned long int>' */ 
 /* Instantiation of class template '::std::_Bvector_base< ::std::allocator<bool> >::_Bvector_impl' */ 
 /* Instantiation of class template '::std::_Bvector_base< ::std::allocator<bool> >' */ 
 /* Instantiation of class template '::std::vector<bool>' */ 
 /* Instantiation of class template '::std::__fun< ::std::__multiplies, ::std::_Bit_const_iterator>' */ 
 /* Instantiation of class template '::std::pair<const char *, bool *>' */ 
 /* Instantiation of class template '::boost::serialization::traits<const ::boost::serialization::nvp<bool>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp<bool> >, ::mpl_::bool_<true> >' */ 
 /* Instantiation of class template '::boost::serialization::wrapper_traits<const ::boost::serialization::nvp<bool>, 2, 0, 0U, ::boost::serialization::extended_type_info_impl<const ::boost::serialization::nvp<bool> > >' */ 
 /* Instantiation of class template '::boost::serialization::nvp<bool>' */ 
    template < typename Archive, typename Allocator >
    inline void save(Archive &ar, const ::std::vector<bool, Allocator> &t, const unsigned int);
    template < typename Archive, typename Allocator >
    inline void save(Archive &ar, const ::std::vector<bool, Allocator> &t, const unsigned int)
    {
      ::boost::serialization::collection_size_type count(t.size());
      ar << boost::serialization::make_nvp("count", count);
      ::std::vector<bool>::const_iterator it = t.begin();
      while (count-- > 0)
        {
          bool tb =  *it++;
          ar << boost::serialization::make_nvp("item", tb);
        }
    }
    template < typename Archive, typename Allocator >
    inline void load(Archive &ar, ::std::vector<bool, Allocator> &t, const unsigned int);
    template < typename Archive, typename Allocator >
    inline void load(Archive &ar, ::std::vector<bool, Allocator> &t, const unsigned int)
    {
      ::boost::serialization::collection_size_type count /* () */ ;
      ar >> boost::serialization::make_nvp("count", count);
      t.clear();
      while (count-- > 0)
        {
          bool i;
          ar >> boost::serialization::make_nvp("item", i);
          t.push_back(i);
        }
    }
    template < typename Archive, typename Allocator >
    inline void serialize(Archive &ar, ::std::vector<bool, Allocator> &t, const unsigned int file_version);
    template < typename Archive, typename Allocator >
    inline void serialize(Archive &ar, ::std::vector<bool, Allocator> &t, const unsigned int file_version)
    {
      boost::serialization::split_free(ar, t, file_version);
    }
    template <>
    struct  implementation_level< ::std::vector<bool> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
    template <>
    struct  implementation_level< ::std::vector<char> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
    template <>
    struct  implementation_level< ::std::vector<signed char> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
    template <>
    struct  implementation_level< ::std::vector<unsigned char> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
    template <>
    struct  implementation_level< ::std::vector<int> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
    template <>
    struct  implementation_level< ::std::vector<unsigned int> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
    template <>
    struct  implementation_level< ::std::vector<long int> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
    template <>
    struct  implementation_level< ::std::vector<unsigned long int> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
    template <>
    struct  implementation_level< ::std::vector<float> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
    template <>
    struct  implementation_level< ::std::vector<double> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
    template <>
    struct  implementation_level< ::std::vector<unsigned short int> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
    template <>
    struct  implementation_level< ::std::vector<short int> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
    template <>
    struct  implementation_level< ::std::vector<long long int> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
    template <>
    struct  implementation_level< ::std::vector<unsigned long long int> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
    template <>
    struct  implementation_level< ::std::vector<wchar_t> >
    {
        typedef ::mpl_::integral_c_tag tag;
        typedef ::mpl_::int_<2> type;
        static const int value = ::boost::serialization::object_serializable;
    };
  }
}
extern "C"
{
  void Muld(double *A, double *B, int wA, int wB, double *C, int NB);
}
using namespace ::std;
using namespace ::boost;
using namespace ::boost::serialization;
 /* Instantiation of class template '::__gnu_cxx::new_allocator< ::std::vector<double> >' */ 
 /* Instantiation of class template '::std::allocator< ::std::vector<double> >' */ 
 /* Instantiation of class template '::std::remove_volatile< ::std::vector<double> >' */ 
 /* Instantiation of class template '::std::remove_const< ::std::vector<double> >' */ 
 /* Instantiation of class template '::std::remove_cv< ::std::vector<double> >' */ 
 /* Instantiation of class template '::std::__ptrtr_not_void< ::std::vector<double>, ::std::vector<double> >' */ 
 /* Instantiation of class template '::std::pointer_traits< ::std::vector<double> *>' */ 
 /* Instantiation of class template '::std::allocator_traits< ::std::allocator< ::std::vector<double> > >' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator< ::std::vector<double> > >' */ 
 /* Instantiation of class template '::std::allocator< ::std::vector<double> >::rebind< ::std::vector<double> >' */ 
 /* Instantiation of template function 'bool ::std::__alloctr_rebind_helper< ::std::allocator< ::std::vector<double> >, ::std::vector<double> >::_S_chk< ::std::allocator< ::std::vector<double> >, ::std::vector<double> >(::std::allocator< ::std::vector<double> >::rebind< ::std::vector<double> >::other *)' */ 
 /* Instantiation of class template '::std::__alloctr_rebind_helper< ::std::allocator< ::std::vector<double> >, ::std::vector<double> >' */ 
 /* Instantiation of class template '::std::__alloctr_rebind< ::std::allocator< ::std::vector<double> >, ::std::vector<double>, true>' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator< ::std::vector<double> > >::rebind< ::std::vector<double> >' */ 
 /* Instantiation of class template '::std::_Vector_base< ::std::vector<double>, ::std::allocator< ::std::vector<double> > >::_Vector_impl' */ 
 /* Instantiation of class template '::std::_Vector_base< ::std::vector<double>, ::std::allocator< ::std::vector<double> > >' */ 
 /* Instantiation of class template '::std::vector< ::std::vector<double> >' */ 
 /* Instantiation of template function '::std::vector< ::std::vector<double> >::vector()' */ 
class  Block
{
  public:
    ::std::vector< ::std::vector<double> > data;
    inline Block()
    {
    }
    Block(int bSize);
    static ::Block *init(int bSize, double initVal);
    void multiplyCPU(::Block block1, ::Block block2);
    void multiplyGPU(::Block block1, ::Block block2);
    void print();
  private:
    int M;
    template < typename Archive >
    inline void serialize(Archive &ar, const unsigned int version)
    {
      ar & (*this).M;
      ar & (*this).data;
    }
  public:
  friend class ::boost::serialization::access;
};
using namespace ::std;
using namespace ::boost;
using namespace ::boost::serialization;
 /* Instantiation of class template '::__gnu_cxx::new_allocator< ::std::vector< ::Block *> >' */ 
 /* Instantiation of class template '::std::allocator< ::std::vector< ::Block *> >' */ 
 /* Instantiation of class template '::std::remove_volatile< ::std::vector< ::Block *> >' */ 
 /* Instantiation of class template '::std::remove_const< ::std::vector< ::Block *> >' */ 
 /* Instantiation of class template '::std::remove_cv< ::std::vector< ::Block *> >' */ 
 /* Instantiation of class template '::std::__ptrtr_not_void< ::std::vector< ::Block *>, ::std::vector< ::Block *> >' */ 
 /* Instantiation of class template '::std::pointer_traits< ::std::vector< ::Block *> *>' */ 
 /* Instantiation of class template '::std::allocator_traits< ::std::allocator< ::std::vector< ::Block *> > >' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator< ::std::vector< ::Block *> > >' */ 
 /* Instantiation of class template '::std::allocator< ::std::vector< ::Block *> >::rebind< ::std::vector< ::Block *> >' */ 
 /* Instantiation of template function 'bool ::std::__alloctr_rebind_helper< ::std::allocator< ::std::vector< ::Block *> >, ::std::vector< ::Block *> >::_S_chk< ::std::allocator< ::std::vector< ::Block *> >, ::std::vector< ::Block *> >(::std::allocator< ::std::vector< ::Block *> >::rebind< ::std::vector< ::Block *> >::other *)' */ 
 /* Instantiation of class template '::std::__alloctr_rebind_helper< ::std::allocator< ::std::vector< ::Block *> >, ::std::vector< ::Block *> >' */ 
 /* Instantiation of class template '::std::__alloctr_rebind< ::std::allocator< ::std::vector< ::Block *> >, ::std::vector< ::Block *>, true>' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator< ::std::vector< ::Block *> > >::rebind< ::std::vector< ::Block *> >' */ 
 /* Instantiation of class template '::std::_Vector_base< ::std::vector< ::Block *>, ::std::allocator< ::std::vector< ::Block *> > >::_Vector_impl' */ 
 /* Instantiation of class template '::std::_Vector_base< ::std::vector< ::Block *>, ::std::allocator< ::std::vector< ::Block *> > >' */ 
 /* Instantiation of class template '::std::vector< ::std::vector< ::Block *> >' */ 
 /* Instantiation of template function '::std::vector< ::std::vector< ::Block *> >::vector()' */ 
class  Matrix
{
  public:
    ::std::vector< ::std::vector< ::Block *> > data;
    inline Matrix()
    {
    }
    Matrix(int mSize, int bSize, char mat_name);
    void init(int mSize, int bSize, double val, char mat_name);
    void multiply(::Matrix matrix1, ::Matrix matrix2);
    void print();
    static ::Block *get_block(char *file, int M);
    static void write_block(::Block *b, char *file, int M);
  private:
    int N;
    int M;
    int matName;
    template < typename Archive >
    inline void serialize(Archive &ar, const unsigned int version)
    {
      ar & (*this).N;
      ar & (*this).data;
    }
  public:
  friend class ::boost::serialization::access;
};
 /* Instantiation of template function '::std::vector< ::std::vector< ::Block *> >::vector()' */ 
 /* Instantiation of template function 'void ::std::vector< ::std::vector< ::Block *> >::resize(unsigned long int)' */ 
 /* Instantiation of template function '::__gnu_cxx::__alloc_traits< ::std::allocator< ::std::vector< ::Block *> > >::reference ::std::vector< ::std::vector< ::Block *> >::operator [](unsigned long int)' */ 
 /* Instantiation of class template '::__gnu_cxx::new_allocator< ::Block *>' */ 
 /* Instantiation of class template '::std::allocator< ::Block *>' */ 
 /* Instantiation of class template '::std::remove_volatile< ::Block *>' */ 
 /* Instantiation of class template '::std::remove_const< ::Block *>' */ 
 /* Instantiation of class template '::std::remove_cv< ::Block *>' */ 
 /* Instantiation of class template '::std::__ptrtr_not_void< ::Block *, ::Block *>' */ 
 /* Instantiation of class template '::std::pointer_traits< ::Block **>' */ 
 /* Instantiation of class template '::std::allocator_traits< ::std::allocator< ::Block *> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator< ::Block *> >' */ 
 /* Instantiation of class template '::std::allocator< ::Block *>::rebind< ::Block *>' */ 
 /* Instantiation of template function 'bool ::std::__alloctr_rebind_helper< ::std::allocator< ::Block *>, ::Block *>::_S_chk< ::std::allocator< ::Block *>, ::Block *>(::std::allocator< ::Block *>::rebind< ::Block *>::other *)' */ 
 /* Instantiation of class template '::std::__alloctr_rebind_helper< ::std::allocator< ::Block *>, ::Block *>' */ 
 /* Instantiation of class template '::std::__alloctr_rebind< ::std::allocator< ::Block *>, ::Block *, true>' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator< ::Block *> >::rebind< ::Block *>' */ 
 /* Instantiation of class template '::std::_Vector_base< ::Block *, ::std::allocator< ::Block *> >::_Vector_impl' */ 
 /* Instantiation of class template '::std::_Vector_base< ::Block *, ::std::allocator< ::Block *> >' */ 
 /* Instantiation of class template '::std::vector< ::Block *>' */ 
 /* Instantiation of template function 'void ::std::vector< ::Block *>::resize(unsigned long int)' */ 
Matrix::Matrix(int mSize, int bSize, char mat_name)
{
  (*this).N = mSize;
  (*this).M = bSize;
  (*this).matName = mat_name;
  (*this).data.::std::vector< ::std::vector< ::Block *> >::resize((*this).N);
  for (int i(0); i < (*this).N; i++)
    {
      (*this).data.::std::vector< ::std::vector< ::Block *> >::operator [](i).::std::vector< ::Block *>::resize((*this).N);
    }
}
 /* Instantiation of template function '::__gnu_cxx::__alloc_traits< ::std::allocator< ::std::vector<double> > >::reference ::std::vector< ::std::vector<double> >::operator [](unsigned long int)' */ 
 /* Instantiation of template function '::__gnu_cxx::__alloc_traits< ::std::allocator<double> >::reference ::std::vector<double>::operator [](unsigned long int)' */ 
static ::Block *get_block(char *file, int M)
{
  ::Block *result;
  ::FILE *fp;
  result = Block::init(M, 0.00000000000000000000000000000000000000000000000000000e+00);
  fp = ::fopen(file, "r");
  for (int i(0); i < M; i++)
    {
      for (int j(0); j < M; j++)
        {
          ::fscanf(fp, "%lf ", &(*result).data.::std::vector< ::std::vector<double> >::operator [](i).::std::vector<double>::operator [](j));
        }
      ::fscanf(fp, " \n");
    }
  ::fclose(fp);
  return result;
}
 /* Instantiation of template function '::__gnu_cxx::__alloc_traits< ::std::allocator< ::std::vector<double> > >::reference ::std::vector< ::std::vector<double> >::operator [](unsigned long int)' */ 
 /* Instantiation of template function '::__gnu_cxx::__alloc_traits< ::std::allocator<double> >::reference ::std::vector<double>::operator [](unsigned long int)' */ 
static void write_block(::Block *b, char *file, int M)
{
  ::FILE *fp;
  fp = ::fopen(file, "w");
  for (int i(0); i < M; i++)
    {
      for (int j(0); j < M; j++)
        {
          ::fprintf(fp, "%lf ", (*b).data.::std::vector< ::std::vector<double> >::operator [](i).::std::vector<double>::operator [](j));
        }
      ::fprintf(fp, " \n");
    }
  ::fclose(fp);
}
 /* Instantiation of template function '::__gnu_cxx::__alloc_traits< ::std::allocator< ::std::vector< ::Block *> > >::reference ::std::vector< ::std::vector< ::Block *> >::operator [](unsigned long int)' */ 
 /* Instantiation of template function '::__gnu_cxx::__alloc_traits< ::std::allocator< ::Block *> >::reference ::std::vector< ::Block *>::operator [](unsigned long int)' */ 
 /* Instantiation of template function '::std::basic_ostream<char> &::std::operator <<< ::std::char_traits<char> >(::std::basic_ostream<char> &, const char *)' */ 
void Matrix::print()
{
  for (int i(0); i < (*this).N; i++)
    {
      for (int j(0); j < (*this).N; j++)
        {
          (*(*this).data.::std::vector< ::std::vector< ::Block *> >::operator [](i).::std::vector< ::Block *>::operator [](j)).::Block::print();
          ::std::cout << "\r\n";
        }
      ::std::cout << "\r\n";
    }
}
 /* Instantiation of template function '::std::basic_ostream<char> &::std::operator <<< ::std::char_traits<char> >(::std::basic_ostream<char> &, const char *)' */ 
 /* Instantiation of template function '::std::basic_ostream<char> &::std::basic_ostream<char>::operator <<(::std::basic_ostream<char> &(*)(::std::basic_ostream<char> &))' */ 
 /* Instantiation of class template '::std::remove_volatile< ::std::vector< ::std::vector<double> > >' */ 
 /* Instantiation of class template '::std::remove_const< ::std::vector< ::std::vector<double> > >' */ 
 /* Instantiation of class template '::std::remove_cv< ::std::vector< ::std::vector<double> > >' */ 
 /* Instantiation of class template '::std::__has_iterator_category_helper< ::std::vector< ::std::vector<double> > >' */ 
 /* Instantiation of class template '::std::__has_iterator_category< ::std::vector< ::std::vector<double> > >' */ 
 /* Instantiation of class template '::std::__iterator_traits< ::std::vector< ::std::vector<double> >, false>' */ 
 /* Instantiation of class template '::std::iterator_traits< ::std::vector< ::std::vector<double> > >' */ 
 /* Instantiation of class template '::std::initializer_list< ::std::vector<double> >' */ 
void multiplyBlocks(char *f1, char *f2, char *f3, int M)
{
  ::std::cout << "multiply GPU" << ::std::endl<char, ::std::char_traits<char> >;
  ::Block *block1;
  ::Block *block2;
  ::Block *block3;
  block1 = ::get_block(f1, M);
  block2 = ::get_block(f2, M);
  block3 = ::get_block(f3, M);
  (*block1).::Block::multiplyGPU(*block2, *block3);
  ::write_block(block1, f1, M);
}
 /* Instantiation of template function '::std::basic_ostream<char> &::std::operator <<< ::std::char_traits<char> >(::std::basic_ostream<char> &, const char *)' */ 
 /* Instantiation of template function '::std::basic_ostream<char> &::std::basic_ostream<char>::operator <<(::std::basic_ostream<char> &(*)(::std::basic_ostream<char> &))' */ 
void multiplyBlocks_CPU(char *f1, char *f2, char *f3, int M)
{
  ::std::cout << "multiply CPU" << ::std::endl<char, ::std::char_traits<char> >;
  ::Block *block1;
  ::Block *block2;
  ::Block *block3;
  block1 = ::get_block(f1, M);
  block2 = ::get_block(f2, M);
  block3 = ::get_block(f3, M);
  (*block1).::Block::multiplyCPU(*block2, *block3);
  ::write_block(block1, f1, M);
}
 /* Instantiation of template function '::std::basic_ostream<char> &::std::operator <<< ::std::char_traits<char> >(::std::basic_ostream<char> &, const char *)' */ 
 /* Instantiation of template function '::std::basic_ostream<char> &::std::basic_ostream<char>::operator <<(::std::basic_ostream<char> &(*)(::std::basic_ostream<char> &))' */ 
void init_block(char *file, int bSize, double val)
{
  ::std::cout << "init block " << file << ::std::endl<char, ::std::char_traits<char> >;
  ::FILE *fp(::fopen(file, "w"));
  for (int i(0); i < bSize; i++)
    {
      for (int j(0); j < bSize; j++)
        {
          ::fprintf(fp, "%lf ", val);
        }
      ::fprintf(fp, " \n");
    }
  ::fclose(fp);
}
